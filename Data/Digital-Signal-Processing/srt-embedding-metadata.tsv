filename	timestamp	sentence
48.srt	00:00:01.219 --> 00:00:25.870	Welcome back to real time digital signal processing course.
48.srt	00:00:26.300 --> 00:00:30.519	So today we will discuss about discrete cosine transform.
48.srt	00:00:30.910 --> 00:00:37.750	So, how we can implement using both MATLAB and then the DSP processor what we will be looking at it.
48.srt	00:00:37.750 --> 00:00:43.020	So, before giving the demo, so we will have little on the theory part of it.
48.srt	00:00:43.020 --> 00:00:51.380	So, as a recap in the last class we did little bit on speech coding and then its applications.
48.srt	00:00:51.490 --> 00:01:01.230	One of the application was LPC coding what we did both in MATLAB and then.
48.srt	00:01:01.940 --> 00:01:10.689	So, the other applications you can look in and then see that how you can use the speech coding in different applications.
48.srt	00:01:10.719 --> 00:01:16.939	So, today we will see little on image compression basically.
48.srt	00:01:17.460 --> 00:01:24.189	So, mostly we will be concentrating on the JPEG part of it.
48.srt	00:01:24.810 --> 00:01:26.890	So, why do we need compression?
48.srt	00:01:26.890 --> 00:01:34.659	Most of you will be taking lot of images using your mobile phones, cameras and so many other devices basically.
48.srt	00:01:37.890 --> 00:01:44.980	So, then how you are going to represent it most of the time will be telling that our memory is full.
48.srt	00:01:45.439 --> 00:01:59.230	So, we have to move our all images to some storage place what we have to take it can be a cloud or somewhere hard disk and then how you are going to retrieve and other problems challenges what you will be facing it.
48.srt	00:01:59.230 --> 00:02:08.500	So, to say that how the number of bits is going to increase we will see for a bit.
48.srt	00:02:08.620 --> 00:02:10.550	black and white image ok.
48.srt	00:02:11.080 --> 00:02:23.860	So, we say that it has a resolution of or the size of it is 1000 by 1000 is the image what you have taken a thing and each pixel we represent it with 8 bits.
48.srt	00:02:24.460 --> 00:02:27.939	We know that black and white is 0 to 255 is enough for us to represent it.
48.srt	00:02:27.939 --> 00:02:35.400	So, we say that 8 bits are sufficient to represent the intensity of these pixels.
48.srt	00:02:35.680 --> 00:02:38.099	So, now we will see that.
48.srt	00:02:40.740 --> 00:02:48.210	total number of bits what is required is we know that if we multiply 1000 into 1000 into 8 bits.
48.srt	00:02:48.639 --> 00:02:55.289	So, it comes to about as you can see that 80 lakhs bits per image what we needed.
48.srt	00:02:56.280 --> 00:03:14.520	And we say when we are talking about the video this is only the still image what you are talking about and then if we are considering a video for a black and white you know that it is 30 frames per second what we assume the video rate which is at which it is coming.
48.srt	00:03:15.000 --> 00:03:22.689	So, this type what happens we will be seeing that if it is taken for just 3 seconds ok.
48.srt	00:03:23.069 --> 00:03:25.099	So, what will be the value of it.
48.srt	00:03:25.099 --> 00:03:26.550	So, it is 3 into 0.
48.srt	00:03:27.189 --> 00:03:38.159	30 frames per second, 30 frames what I have to store it into whatever we have this value what we will be taking it 80000.
48.srt	00:03:38.549 --> 00:03:47.870	So, you will be seeing that how many bits is required to store our image in any of the storage units.
48.srt	00:03:48.459 --> 00:03:56.399	Then the further still images JPEG compression the compression is one of the popular one.
48.srt	00:03:58.409 --> 00:04:04.229	So, that is joint program extend group actually what it is.
48.srt	00:04:04.559 --> 00:04:08.739	So, here what are the steps involved in it.
48.srt	00:04:09.079 --> 00:04:15.579	So, we know that we need discrete cosine transform usually it is being used for compression.
48.srt	00:04:16.139 --> 00:04:30.069	Then the bits whatever received is going to be quantized and then it is going to be zig zag scanned and then the whatever you use the run length.
48.srt	00:04:30.209 --> 00:04:36.509	the encoding and then DPCM whatever differential pulse code modulation what you can use it.
48.srt	00:04:37.049 --> 00:04:43.829	Then later on use the entropy coding these are the coding techniques what you can use it and then you will be transmitting it.
48.srt	00:04:44.299 --> 00:04:47.669	So, what are the modes available for the JPEG?
48.srt	00:04:48.089 --> 00:05:04.839	It can be sequential what you can have mode or you want to have a lossless compression you can incorporate it or it can be a progressive mode what you can select it or it can be even the hierarchical mode what you can select.
48.srt	00:05:05.219 --> 00:05:09.279	Those these are the options in the modes what you have it for the JPEG.
48.srt	00:05:09.779 --> 00:05:16.699	So, the website what you can visit for more information is given here for you ok.
48.srt	00:05:16.819 --> 00:05:21.889	So, now why we have to select JPEG.
48.srt	00:05:22.649 --> 00:05:35.689	So, the compression ratio of lossless method is that is example is we can use the Huffman coding or arithmetic coding or LZW coding.
48.srt	00:05:36.599 --> 00:05:40.429	So, these are the once what it is used for coding.
48.srt	00:05:40.819 --> 00:05:45.579	So, it is not high enough for image and video compression.
48.srt	00:05:46.069 --> 00:05:54.289	So, although we use these things still the size of the image what we have to store is very high.
48.srt	00:05:54.849 --> 00:05:59.389	So, what happens in the JPEG it uses a transform coding basically.
48.srt	00:05:59.769 --> 00:06:02.719	So, largely based on the following observations.
48.srt	00:06:03.179 --> 00:06:06.009	So, you will be seeing that why do we need the transform.
48.srt	00:06:06.059 --> 00:06:09.779	So, we have looked at Fourier transform in our.
48.srt	00:06:10.009 --> 00:06:11.449	course already.
48.srt	00:06:11.949 --> 00:06:18.159	So, how fast you can make discrete Fourier transform to run using fast Fourier transform.
48.srt	00:06:18.679 --> 00:06:25.789	So, why do we have to represent an signal in the transform domain also what we have looked in.
48.srt	00:06:26.169 --> 00:06:30.139	Now, we will see why we need the transform for our images.
48.srt	00:06:30.589 --> 00:06:38.279	What it says is a large majority of useful image contents change relatively slowly across images.
48.srt	00:06:38.739 --> 00:06:43.509	So, it is unusual for intensity values to alter up.
48.srt	00:06:43.969 --> 00:06:47.049	and down several times in a small area.
48.srt	00:06:47.439 --> 00:06:53.409	So, that is usually we assume the small areas 8 by 8 image block.
48.srt	00:06:53.879 --> 00:07:10.279	So, even you would be seeing when you want to create your video from a small image what you do is I think the famous one you will be seeing that bird in a cage ok.
48.srt	00:07:10.279 --> 00:07:13.879	So, they are two different and if you rotate them varies.
48.srt	00:07:16.289 --> 00:07:27.869	high rotation if you are giving the thing or high speed you rotate it you will be observing the bird in the cage basically that is what the illusion what you will be getting it.
48.srt	00:07:28.209 --> 00:07:37.119	So, it is enough for us to look in the small image block and see the intensity values and whether we can remove some of the things.
48.srt	00:07:37.279 --> 00:07:44.579	So that we need not have to keep those values which are below some threshold what we will be putting it.
48.srt	00:07:48.849 --> 00:08:03.739	So, the translation of this fact into your spatial frequency domain implies generally that is lower spatial frequency components contain more information than the high frequency components.
48.srt	00:08:04.149 --> 00:08:10.999	So, we say that which often correspond to less useful details and then we call them as noises.
48.srt	00:08:10.999 --> 00:08:16.359	So, just like our speech the contents of it is in the lower frequency part of it.
48.srt	00:08:16.409 --> 00:08:24.899	Here also in the images we say at the lower frequency we have more.
48.srt	00:08:26.309 --> 00:08:32.129	coverage of the thing and then at a high frequencies the not much information and then it may be noises.
48.srt	00:08:32.159 --> 00:08:42.669	So, the that is what it says that experiment suggests that humans are more immune to loss of highest spatial frequency components than loss of lower frequency components.
48.srt	00:08:43.169 --> 00:08:50.349	So, if we lose the higher frequency components because of our visual what we call it as seeing capability.
48.srt	00:08:57.629 --> 00:09:07.229	So, it gets the low frequency components much registered than the one in the higher frequency region.
48.srt	00:09:08.119 --> 00:09:12.379	So, how we are going to incorporate this JPEG coding?
48.srt	00:09:12.869 --> 00:09:14.639	So, these are the steps involved.
48.srt	00:09:15.049 --> 00:09:20.559	First we do the discrete cosine transform of each 8 by 8 pixel array.
48.srt	00:09:21.009 --> 00:09:24.659	So, if you know f of x comma y is an image.
48.srt	00:09:25.009 --> 00:09:29.539	So, in the DCT what we will take it.
48.srt	00:09:29.599 --> 00:09:32.329	So, the image what you will be getting it is f.
48.srt	00:09:32.759 --> 00:09:40.249	So, you will be seeing that here it is represented in YCbCr basically.
48.srt	00:09:40.419 --> 00:09:47.439	So, this is the luminance and these are the chromium what you will have it in the image data.
48.srt	00:09:47.719 --> 00:09:52.969	So, you will be if you are considering the colour image.
48.srt	00:09:53.329 --> 00:10:00.909	So, instead of RGB so, we can represent it in this YCbCr format.
48.srt	00:10:01.249 --> 00:10:03.009	So, you will be seeing.
48.srt	00:10:03.419 --> 00:10:10.329	even in storage you have a JPEG image, BMP image, TIFF image.
48.srt	00:10:10.329 --> 00:10:16.359	So, you can compare which one consumes less storage for your storages.
48.srt	00:10:16.579 --> 00:10:27.009	So, we will consider 8 by 8 of the thing as you can see each one is divided into blocks of 8 by 8.
48.srt	00:10:27.269 --> 00:10:31.889	So, we will be using that and then we will do the DCT of it.
48.srt	00:10:32.429 --> 00:10:36.189	Then what we have is F, U, Y is the.
48.srt	00:10:36.439 --> 00:10:40.279	output what we have it and do the quantization.
48.srt	00:10:40.659 --> 00:11:01.729	So, we will call that quantized as FQ of u, v and that output what you will be feeding it for the sending through the channel what you can send it and then this is the receiving channel side of it what you will be looking at it.
48.srt	00:11:02.109 --> 00:11:07.739	So, you will be doing the you can have the either the run link.
48.srt	00:11:08.839 --> 00:11:31.669	coding you can do and then you will be using the differential PCM coding to generate our entropy coding part of it and then it can be stored as data if you want to store it with header and then tables what you will be getting it from your quantization tables of what type of quantization if you have used it for this image.
48.srt	00:11:31.669 --> 00:11:39.419	So, this is how the data is going to be stored and then you will be having the coding.
48.srt	00:11:39.609 --> 00:11:55.229	tables also whether you have used the zigzag scan and then what type of coding tables you will be putting it and then you will be using in storing the images and which you can retrieve it back.
48.srt	00:11:55.729 --> 00:12:08.969	So, what it says is quantization using a table or using a constant what you can do it and then the scanning is going to be zigzag scan to exploit redundancy we will see in a while with an example.
48.srt	00:12:09.499 --> 00:12:15.769	Then you will be using the differential pulse code modulation DPCPN and the DC component.
48.srt	00:12:16.109 --> 00:12:21.129	And, run length coding what you can incorporate on the AC components.
48.srt	00:12:21.129 --> 00:12:30.339	So, then you will be doing the entropy coding that is usually Hoffman code what popularly in the JPEG what you can have it of the final output.
48.srt	00:12:30.889 --> 00:12:31.919	So, what happens?
48.srt	00:12:31.919 --> 00:12:38.519	The first step what we have is the discrete cosine transform.
48.srt	00:12:39.209 --> 00:12:46.289	So, this converts the information contained in our block of 8 by 8 of pixels from.
48.srt	00:12:46.569 --> 00:12:49.569	spatial domain to the frequency domain.
48.srt	00:12:50.179 --> 00:12:56.939	So, in the case of FFT from time domain to frequency domain we transform.
48.srt	00:12:57.399 --> 00:13:01.369	Here it is from the spatial domain will be going into the frequency domain.
48.srt	00:13:01.899 --> 00:13:13.159	So, a simple analogy what it uses is that is uncertain list of 12 numbers between only 0 and 3 value what you are considering.
48.srt	00:13:20.169 --> 00:13:21.349	So, this is the thing what you have it 2312201101 0 and 0.
48.srt	00:13:21.979 --> 00:13:45.279	So, how we are going to do the transformation of this list involving two steps ok. First is sort the list that is we know that what is the this thing either it is upwards sorting you can do or downwards sorting what you can do the thing then sort it.
48.srt	00:13:58.139 --> 00:14:06.199	The second step is what you are going to use is 10100 that is consider with transformation of the list involving this thing 2 steps and then sorry count the frequency of occurrence of each of the numbers.
48.srt	00:14:06.199 --> 00:14:14.599	So, we because we have only 0 to 3 means it is only 4 numbers what we can represent here.
48.srt	00:14:14.929 --> 00:14:18.419	So, how many times these got repeated.
48.srt	00:14:18.769 --> 00:14:32.749	So, you will be seeing that 2 has got repeated 4 times and then you will be seeing that 3 is repeated 4 times this is the repetition rate what you will be putting it and through this transformation.
48.srt	00:14:33.229 --> 00:14:40.429	So, we lost the what we say is spatial information, but captured the frequency information part of it.
48.srt	00:14:40.769 --> 00:14:44.469	So, what is the frequency of numbers occurrence what we have collected.
48.srt	00:14:45.069 --> 00:14:55.929	So, there are other transformations which retain the spatial information like example Fourier transform, DCT etcetera.
48.srt	00:14:56.319 --> 00:15:02.119	So, therefore, allowing us to move back and forth between spatial and then frequency domains.
48.srt	00:15:03.609 --> 00:15:09.549	So, as an So, running the MATLAB that is we consider the discrete cosine transform.
48.srt	00:15:10.189 --> 00:15:21.069	So, this is the original signal what it has been considered and when you take the DCT, this is the DCT values what you will be getting it.
48.srt	00:15:21.069 --> 00:15:33.909	So, as you can see only in the small frequency that is lower frequency you have some values both positive and negative and after that you will be seeing that it is almost 0.
48.srt	00:15:34.429 --> 00:15:46.389	Then what I can do is this can be represented as 0 and then if I reconstruct that is I take the 1D inverse transform then I will be getting back my signal.
48.srt	00:15:46.909 --> 00:15:55.319	to show that how it is going to be the difference between the original and then are this thing reconstructed is shown here.
48.srt	00:15:55.869 --> 00:16:02.169	So, that is blue shows the original one and then the orange one is showing the reconstructed one.
48.srt	00:16:02.169 --> 00:16:07.319	So, you will be seeing that with little difference almost it is following the original one.
48.srt	00:16:07.789 --> 00:16:18.879	So, you will be seeing as an this thing in the case of image how it is going to look like this is original lena image when I take a DCT of this.
48.srt	00:16:20.389 --> 00:16:24.029	that is 2D DCT basically this is how the coefficients what will look like.
48.srt	00:16:24.029 --> 00:16:39.929	And then what we do is we put a threshold and then we eliminate the coefficients and make them zeros then we reconstruct the lossy information then what we after reconstruction we take a inverse DCT.
48.srt	00:16:40.029 --> 00:16:45.989	So, this is the reconstruction part of it.
48.srt	00:16:45.989 --> 00:16:48.479	So, you will be seeing that.
48.srt	00:16:54.949 --> 00:17:02.779	Our human eye perception what you can see is visually what you see is not much difference between the two.
48.srt	00:17:03.039 --> 00:17:10.969	Sorry, I did not take the difference between the original image and then the reconstructed image and then we can plot that also.
48.srt	00:17:11.369 --> 00:17:19.029	So, then we will get the complete information how much information is lot, but still our perception of eye has unable to make out.
48.srt	00:17:19.109 --> 00:17:23.739	So, only if you closely observe what you will be looking with the difference.
48.srt	00:17:23.869 --> 00:17:24.819	So, that is it had a 64000 pixels.
48.srt	00:17:25.179 --> 00:17:37.289	So, from 3200 to 64000 it was made zeros and then only use only 0 to 3200 images to reconstruct.
48.srt	00:17:41.219 --> 00:17:42.869	by using IDCT.
48.srt	00:17:43.469 --> 00:17:48.169	So, we will see in the lab these examples how we will be doing it.
48.srt	00:17:48.749 --> 00:17:59.489	So, now one more comparison we said that even the discrete Fourier transform is going to work in the frequency domain for our images and discrete cosine transform.
48.srt	00:17:59.799 --> 00:18:08.939	So, we will see that with an example you have 8 this thing n is 1D comparison what we are doing it.
48.srt	00:18:09.259 --> 00:18:14.919	So, you have 8 samples with different values what you will be seeing it.
48.srt	00:18:15.259 --> 00:18:19.089	So, it will be in terms of as you can see that.
48.srt	00:18:19.599 --> 00:18:37.369	8, 16, 24 that is what the values what you have at different play distinct samples that is what we say n is 0 to 7 what it is been chosen and these values are passed through FFT and then DCT.
48.srt	00:18:37.699 --> 00:18:40.569	So, this is what the table shows 8 values.
48.srt	00:18:40.569 --> 00:18:49.979	So, you will be getting after doing FFT 36, 10, 10, 6, 6 and then all these are 4s.
48.srt	00:18:50.809 --> 00:19:03.119	When you pass it through the DCT basically, so you will be seeing that this one the first value what we call it as DC coefficient and rest of them we call it as AC coefficients.
48.srt	00:19:03.440 --> 00:19:18.659	So, you will be seeing that maximum value is present in our DC coefficient and then you will be seeing some almost it is we see after the first coefficient rest of them are almost negligible.
48.srt	00:19:19.039 --> 00:19:26.500	So, for reconstruction we will do that 50 percent of the values we strike it off and make them 0s ok.
48.srt	00:19:26.980 --> 00:19:28.990	So, same thing what we will do with.
48.srt	00:19:29.349 --> 00:19:31.419	respect our FFT also.
48.srt	00:19:31.819 --> 00:19:39.339	So, we are striking of these 4 values and then we will take the inverse DCT here and then inverse FFT here.
48.srt	00:19:39.889 --> 00:19:46.369	So, that is IDCT and IFFT what we will be doing it and these are the values what we have got it.
48.srt	00:19:46.740 --> 00:20:00.309	Whereas, in the case of DCT you will be seeing that few of them are exactly represented 824 and then 32, 40, 48 almost same values.
48.srt	00:20:03.950 --> 00:20:17.119	And, then the other one instead of 16 what we have is 15 and then instead of 56 it is 57 instead of 64 it is 63 ok.
48.srt	00:20:17.549 --> 00:20:29.049	But the you can see the graph when we plot it almost it resembles the original plot with little what we call it as loss of information.
48.srt	00:20:29.509 --> 00:20:35.700	When we reconstruct our this thing from FFT that is IFFT we do the thing.
48.srt	00:20:36.049 --> 00:20:39.000	So, you will be seeing lot of difference with.
48.srt	00:20:39.829 --> 00:20:41.879	some places values of it.
48.srt	00:20:42.119 --> 00:20:51.740	So, you will be seeing that here it is gone bad and then here it is little smooth again at the higher end it has gone instead of 64 it is 48.
48.srt	00:20:52.179 --> 00:20:56.899	This is somewhat nearby in these values and then after that it goes down.
48.srt	00:20:57.279 --> 00:21:05.109	So, you will be seeing the advantage of using DCT for compression because we can eliminate these 0s.
48.srt	00:21:05.429 --> 00:21:10.959	That is what it says is we truncate and use inverse transform to compute our F dash.
48.srt	00:21:11.700 --> 00:21:13.000	n in both the cases.
48.srt	00:21:13.700 --> 00:21:16.299	So, coming to 2D DCT.
48.srt	00:21:16.299 --> 00:21:26.109	So, how we are going to incorporate this that is 2 dimensional how do you perform 2D DCT usually what we prefer is 1D transform.
48.srt	00:21:26.670 --> 00:21:40.220	So, how it is going to result in 2D is demonstrated here f of i comma j is your 2D image pixel values what it has been represented here it has been taken as 8 by 8 in this case.
48.srt	00:21:40.559 --> 00:21:44.500	So, first we will do 1D DCT.
48.srt	00:21:44.660 --> 00:21:47.690	that is row wise what you will be doing it.
48.srt	00:21:47.690 --> 00:21:50.700	So, it is shown as row wise DCT what we will do.
48.srt	00:21:51.420 --> 00:21:58.289	And then in the next stage for this input we can do only column wise DCT what we will be taking it.
48.srt	00:21:58.289 --> 00:22:03.799	Since we call it as this is a separable transform DCT.
48.srt	00:22:15.119 --> 00:22:29.750	So, we can use row decomposition and then column decomposition together to get our final output f of u comma v. So, we say that f of 0 0 is called DC component and rest of f of i comma j are going to be called as AC components.
48.srt	00:22:30.650 --> 00:22:38.700	So, how just it is an intuitive example in this picture what you will be seeing it.
48.srt	00:22:39.140 --> 00:22:41.480	So, to show the 2D transform ok.
48.srt	00:22:41.769 --> 00:22:52.970	So, the first one you will be representing all of them are once in thus f of i comma j and then this has a 8 by 8 matrix what you will be seeing it.
48.srt	00:22:53.309 --> 00:22:55.960	So, first we will do the 1D row wise ok.
48.srt	00:22:58.819 --> 00:23:17.860	So, you will be seeing that you will be So, what the function what we are doing is that is f m of w that is mimicking our d c t. So, which will be omega will this is going to vary n will be varying from omega to 8 f of n that is summation what we are doing it.
48.srt	00:23:18.240 --> 00:23:33.970	As you can see first I will be doing it row wise when we add it up this is 8 then omega becomes 0 to either it is 1 then 1 to 8 or it has to be 0 to 7 as you know 8 values what we have to take.
48.srt	00:23:34.160 --> 00:23:39.650	So, omega becomes 2 then we will be doing this summation.
48.srt	00:23:40.009 --> 00:23:41.430	So, which gives you 7.
48.srt	00:23:41.430 --> 00:23:46.829	So, on what you will be doing it and this is how our row wise transformation what it is shown.
48.srt	00:23:46.930 --> 00:23:56.779	Just it is the addition what we have done this is not the one what we will be using it for DCT as it is mentioned here ok.
48.srt	00:23:56.779 --> 00:24:04.339	It is a hypothetical transform and then we will see what is our DCT equation later.
48.srt	00:24:05.630 --> 00:24:09.599	After doing this then we will do column wise ok.
48.srt	00:24:10.059 --> 00:24:12.589	So, how we are going to do column wise?
48.srt	00:24:12.589 --> 00:24:22.250	So, you will be seeing that 8 into 8 64 and 8 into 7 becomes 56 and then you can go on doing that way.
48.srt	00:24:22.599 --> 00:24:25.230	Last one is 8 into 1 ok.
48.srt	00:24:25.490 --> 00:24:27.720	So, which is going to be 1 into 8.
48.srt	00:24:27.779 --> 00:24:29.690	So, you will be getting it 8 here.
48.srt	00:24:30.089 --> 00:24:31.460	The same with the next one.
48.srt	00:24:31.460 --> 00:24:34.970	So, it will be starting if I look from right to left.
48.srt	00:24:35.200 --> 00:24:37.009	So, it will be going from 7 to.
48.srt	00:24:37.480 --> 00:24:41.419	56 same what you have to apply this equation ok.
48.srt	00:24:41.419 --> 00:24:46.159	So, when you add it up column wise you will be doing it.
48.srt	00:24:46.159 --> 00:24:52.799	So, you know that 8 into 8 and here 7 into 8 and 6 into 8.
48.srt	00:24:52.869 --> 00:25:03.190	So, that is how these values have been filled and later on also what you will be doing from here to here what you will be doing ok column wise.
48.srt	00:25:08.180 --> 00:25:15.579	So, this is a intuitive thing to show that how the DCT is going to work in the regular sense the equation is going to be different.
48.srt	00:25:15.890 --> 00:25:29.759	So, this is how you will be getting f m u comma v. Coming with the quantization the next step is in our JPEG compression basically it is quantization.
48.srt	00:25:30.119 --> 00:25:31.410	Why do we need the quantization?
48.srt	00:25:31.410 --> 00:25:35.480	That is to reduce the number of bits per sample.
48.srt	00:25:36.009 --> 00:25:43.799	So, I need not have to as we know that f 7 has to be represented we need 3 bits 1 1 1.
48.srt	00:25:44.089 --> 00:25:46.430	If I have to represent 0 I.
48.srt	00:25:46.759 --> 00:25:52.799	it is enough to show that 1 bit is sufficient for me to represent 0th bit.
48.srt	00:25:53.049 --> 00:26:13.829	So, that is how we can do the reduction that is what it is shown here as an example 101101 which is the value is 45, we need 6 bits to represent and we will truncate it to 4 bits then it becomes 1011 that is what we will be selecting it.
48.srt	00:26:14.170 --> 00:26:17.339	So, I need this also further.
48.srt	00:26:18.419 --> 00:26:20.450	we can represent it as 1 1.
48.srt	00:26:20.819 --> 00:26:26.460	So, compare that is 11 into 4 is 44 against 45.
48.srt	00:26:26.869 --> 00:26:33.609	So, instead of 45 we will represent it as 11 and then because we have represented it 4 bits.
48.srt	00:26:34.029 --> 00:26:39.430	So, I can multiply and then I will be almost nearer 45 ok.
48.srt	00:26:39.720 --> 00:26:44.849	Same way truncate to 3 bits that is 101 what you will be doing it.
48.srt	00:26:45.240 --> 00:26:50.049	So, then what happens the result value what I will get is 5.
48.srt	00:26:50.519 --> 00:27:05.289	So, then what happens it is 8 into 5 what I have to multiply which is 40 again as 45 whether this loss I can take into account that is what will be looking at it.
48.srt	00:27:05.289 --> 00:27:07.299	So, how much quantization it can tolerate.
48.srt	00:27:07.299 --> 00:27:14.350	So, that the more bits we truncate the more precision we lose basically.
48.srt	00:27:14.660 --> 00:27:17.650	So, it depends on how much precision you want to have it.
48.srt	00:27:18.019 --> 00:27:24.190	So, the quantization it is the error is the main source of our lossy compression.
48.srt	00:27:24.769 --> 00:27:38.299	So, I can do uniform quantization that is Q of u comma v is a constant value I can take it and then do the quantization or I can do different ways of quantizations.
48.srt	00:27:38.649 --> 00:27:42.119	So, that is the other one is non uniform quantization.
48.srt	00:27:42.509 --> 00:27:48.339	So, you will be using the quantization tables that is the reason why you have tables in JPEG compression.
48.srt	00:27:48.339 --> 00:28:02.930	So, that is what we say I is most sensitive to low frequencies upper left corner in frequency matrix what it says and then less sensitive to high frequency that is lower right corner.
48.srt	00:28:04.029 --> 00:28:14.840	So, the custom quantization tables can be put in an image as scan header and say what kind of quantization was incorporated.
48.srt	00:28:15.360 --> 00:28:24.740	So, the JPEG standard defines two default quantization tables, one each for luminance and chrominance fine.
48.srt	00:28:25.230 --> 00:28:34.590	So, as an example how the code length we can decrease that is encoding average code length is shown with this way.
48.srt	00:28:36.890 --> 00:29:00.090	A 1 has this thing 18 symbols what will be representing it 18 and then the probability of its occurrence is 0.6 times and binary code to represent 18 is given here and then if we represent with the Huffman coding we represent it as 0 then the length of Huffman code is 1 bit in this case.
48.srt	00:29:00.090 --> 00:29:05.950	So, the same way for A 2 is equal to 25 what it is shown here.
48.srt	00:29:07.519 --> 00:29:09.009	which is occurrence is 0.3.
48.srt	00:29:09.090 --> 00:29:14.590	So, these are the Huffman code length what it is represent 1, 2, 3, 4 and then 5.
48.srt	00:29:14.590 --> 00:29:23.280	Now, if we see how many bits per bits are required to represent our intensity level is shown here.
48.srt	00:29:23.280 --> 00:29:32.380	So, because the occurrence is 0.6 and then I need 1 bit here and then the other ones you multiply this is 0.3 the probability into number of bits.
48.srt	00:29:32.380 --> 00:29:38.400	So, you will be seeing that approximately we need 1.56 bits per intensity level.
48.srt	00:29:38.400 --> 00:29:43.000	So, you will be seeing that does the number of bits required represent our.
48.srt	00:29:44.950 --> 00:29:57.430	pixel intensities drastically is going to be reduced from 8 earlier we had 8 bits which has come down to 1.56 bits per intensity level with our coding.
48.srt	00:29:57.430 --> 00:30:02.170	So, after coding we have to do the scanning.
48.srt	00:30:02.170 --> 00:30:05.070	So, why to do the scanning?
48.srt	00:30:05.070 --> 00:30:12.990	Because in this 8 by 8 different values what we have represented and then we have done the quantization.
48.srt	00:30:17.160 --> 00:30:24.410	So, low frequency coefficients in top of vector basically what we will call it and high frequency coefficients at the bottom what we will look at it.
48.srt	00:30:25.420 --> 00:30:30.430	So, this maps 8 by 8 matrix into 1 into 64 vector.
48.srt	00:30:30.780 --> 00:30:37.230	So, you will be seeing that this is how we will be representing it as 1 into 64.
48.srt	00:30:37.580 --> 00:30:46.920	As you have seen earlier also higher values were for the DC coefficient that is on top and then after that it decreases.
48.srt	00:30:46.920 --> 00:30:48.550	So, this is how will be.
48.srt	00:30:49.009 --> 00:30:54.700	putting it in our zigzag scan what we will do it and then put the values of the bits here.
48.srt	00:30:55.670 --> 00:31:02.590	So, the next one what we say that we will do differential pulse code modulation on the DC components.
48.srt	00:31:03.040 --> 00:31:10.009	So, the DC component value of in each 8 by 8 block is large as we know in the thing.
48.srt	00:31:10.450 --> 00:31:12.910	So, continuously what we can represent it.
48.srt	00:31:12.950 --> 00:31:16.470	So, the first one will be the maximum value what will be having it.
48.srt	00:31:17.180 --> 00:31:23.810	And then use the this thing DPC to represent this that is 1 into 64.
48.srt	00:31:24.259 --> 00:31:25.769	So, this is how.
48.srt	00:31:26.260 --> 00:31:40.340	you will be converting it into lesser this thing value in the initial because the otherwise we need more number of bits to represent this value ok.
48.srt	00:31:40.630 --> 00:31:51.480	So, the next is we can have a run length encoder on AC component that is the 1 into 64 vectors have a lot of 0s in them.
48.srt	00:31:51.950 --> 00:31:54.490	So, more so towards the end of the vector.
48.srt	00:32:01.850 --> 00:32:05.010	So, higher up entries in the vector capture higher frequency that is DCT components which to be capture less of the content.
48.srt	00:32:05.520 --> 00:32:15.810	So, could have been as result of using a quantization table ok. Encode a series of 0s as skip comma value.
48.srt	00:32:16.490 --> 00:32:26.040	So, the this is the pair what you will be sending it ok, where skip is the number of 0s and value is the next non-zero component what you will send.
48.srt	00:32:26.040 --> 00:32:34.230	So, that is sent 0 comma 0s end of block that is sentinel value basically what you will be.
48.srt	00:32:34.660 --> 00:32:44.300	So, you will be seeing that how this is represented and then the run length coding if they are repeating it so many 0s.
48.srt	00:32:44.300 --> 00:32:49.960	So, you will be putting the value skip and then value in this way ok.
48.srt	00:32:50.200 --> 00:33:01.120	So, the next one is what we have to do is entropy coding that is basically for the DC components if you use the thing you will be having size and value what you will be providing it.
48.srt	00:33:01.460 --> 00:33:13.760	So, the code for a value is derived from the following table this is the size what we have it size and value table these are the values and then how you will be generating the code is shown in this.
48.srt	00:33:14.340 --> 00:33:20.880	So, this is how the entropy coding for DC components happens.
48.srt	00:33:21.250 --> 00:33:37.210	So, you will be seeing that as an example if a DC component is 40 and the previous DC component is 48, then what we will do because we are doing the differential pulse code modulation the difference is minus 8.
48.srt	00:33:37.710 --> 00:33:41.140	So, therefore, it is coded as this value.
48.srt	00:33:41.750 --> 00:33:46.450	So, that is 011 the value for representing minus 8.
48.srt	00:33:47.059 --> 00:33:52.410	So, that is these are the values what will be representing it this is the code length.
48.srt	00:33:52.799 --> 00:34:01.329	So, 101 is the size from the same table what you will be taking it and then it reads as 4.
48.srt	00:34:01.789 --> 00:34:09.000	So, you will be seeing that 101 is 5 it reads it as 4 what you will be representing it ok.
48.srt	00:34:09.300 --> 00:34:16.860	The corresponding code from the table at left is 101 here what you are showing it ok. Ok.
48.srt	00:34:17.559 --> 00:34:41.959	So, the code length is 3 bits for 101 this thing size is 4 what you have taken the thing that is length of it is you have chosen as for 8, 4 bits are required and this is how you will be Huffman table for DC component size field what it is shown fine.
48.srt	00:34:42.359 --> 00:34:47.609	Next is what you can have is a entropy coding for your AC components.
48.srt	00:34:48.329 --> 00:34:55.149	So, the range between minus 1023 and etcetera to negative to positive value 1023.
48.srt	00:34:55.729 --> 00:35:06.119	So, you will be coding it as S1 comma S2 pairs basically and then S1 is run length slash size you will have it.
48.srt	00:35:06.629 --> 00:35:09.019	So, how do you are going to take the run length?
48.srt	00:35:09.399 --> 00:35:15.719	The length of the consecutive 0 values that is 0 to 15 what you will take it.
48.srt	00:35:15.719 --> 00:35:21.649	So, you will be seeing that here lot of them have 0s how you will take the run length.
48.srt	00:35:22.289 --> 00:35:24.429	length and then code it basically.
48.srt	00:35:24.710 --> 00:35:31.239	So, the last value will be 0 comma 0 is the end of block for the 8 by 8 block.
48.srt	00:35:31.579 --> 00:35:33.399	So, this one Huffman coded.
48.srt	00:35:33.829 --> 00:35:49.759	So, you have to see this AC code table for what is the run size and what is the code length and then what is the code which is going to be represented and then this will be the run size for these values.
48.srt	00:35:50.069 --> 00:35:53.579	Otherwise, if you are transmitting this length of bits.
48.srt	00:35:55.249 --> 00:35:57.409	So, you know that how many bits are required to transmit.
48.srt	00:35:57.669 --> 00:36:05.469	So, you will be this thing sending it as this way so that you will be reducing your code length.
48.srt	00:36:06.169 --> 00:36:10.459	So, in this case S2 what you will be having S1 comma S2.
48.srt	00:36:10.739 --> 00:36:12.339	So, S2 will be the value.
48.srt	00:36:12.339 --> 00:36:19.429	So, this is the run length or size what you will be sending it and then the value what you will exactly put in here.
48.srt	00:36:19.879 --> 00:36:25.269	Value of the AC component size and then value table this is size.
48.srt	00:36:27.369 --> 00:36:30.669	And, then you have the code length and then code here.
48.srt	00:36:31.069 --> 00:36:33.649	So, the value will be from here ok.
48.srt	00:36:34.239 --> 00:36:40.819	So, this is how you would be doing the entropy coding example what it is shown in this.
48.srt	00:36:41.259 --> 00:36:48.209	So, it is in the as you see only these few coefficients what you have the values rest of them are 0s.
48.srt	00:36:48.549 --> 00:36:55.419	So, you will be seeing that zigzag order it is 12, 10, 1, minus 7, 2 and then 0s ok.
48.srt	00:36:55.859 --> 00:36:57.439	So, minus 4.
48.srt	00:36:57.909 --> 00:37:01.899	after that you are sending it as 56 0s ok.
48.srt	00:37:02.459 --> 00:37:07.229	So, it is 12 read as 0 0s.
48.srt	00:37:07.579 --> 00:37:15.369	So, you will be representing as 0 slash 4 that is 12 is 1011 1100.
48.srt	00:37:15.369 --> 00:37:34.689	So, you will be reading it as these 4 bits basically that is 12 what you will be sending it 1011 the code for what is your thing is 0 slash 4 from AC code table and 1100 the code for 12 from the size and then value table.
48.srt	00:37:35.239 --> 00:37:37.459	So, that is what you will be sending it.
48.srt	00:37:37.739 --> 00:37:48.859	So, minus 7 is sent as this and then next one what you have is two 0s in between minus 7 and then minus 4.
48.srt	00:37:49.309 --> 00:38:04.069	So, you will be sending it in this fashion and the 10 bit code for 2 comma 3 what it is represented and the last one is minus 4 what you will be representing it size and value table.
48.srt	00:38:04.339 --> 00:38:09.999	So, you will be having what is it last one 56 0s have been represented.
48.srt	00:38:10.439 --> 00:38:12.059	So, which is 0 comma 0.
48.srt	00:38:12.519 --> 00:38:15.929	1 0 1 0 rest of the components are 0s.
48.srt	00:38:15.929 --> 00:38:25.689	Therefore, we simply put the end of block to signify the to show that this is the end of the block ok.
48.srt	00:38:26.179 --> 00:38:31.749	So, this is what how the coding has been implemented in JPEG.
48.srt	00:38:32.219 --> 00:38:42.019	So, the rest of the components what we will see it in the next class DCT we will continue and then we will see how quantization is going to be done ok.
48.srt	00:38:42.399 --> 00:38:42.919	Thank you.
48.srt	00:38:43.419 --> 00:38:47.249	Happy learning and then have a nice day.
49.srt	00:00:01.219 --> 00:00:24.649	Welcome back to real time digital signal processing course.
49.srt	00:00:24.649 --> 00:00:28.539	So we are discussing about discrete cosine transform in image processing.
49.srt	00:00:28.629 --> 00:00:33.649	So we will continue in today's class also.
49.srt	00:00:35.679 --> 00:00:46.670	So, in the last class we discussed about discrete cosine transform where it is being used we know that it is in JPEG compression.
49.srt	00:00:47.329 --> 00:00:53.620	So, today we will continue with some of the properties what we are discussing about JPEG.
49.srt	00:00:54.120 --> 00:00:56.340	So, here we will see the JPEG modes.
49.srt	00:00:56.769 --> 00:01:06.200	So, that is the first one is we can have sequential mode that is each image is encoded in a single left to right.
49.srt	00:01:06.730 --> 00:01:08.609	top to bottom scan.
49.srt	00:01:09.239 --> 00:01:18.479	So, this technique we have been discussing so far in is an example of such a mode also referred to as the baseline sequential mode.
49.srt	00:01:19.140 --> 00:01:27.789	And it supports only 8 bit images as opposed to 12 bit images as we have discussed it earlier.
49.srt	00:01:29.090 --> 00:01:37.599	Coming to the second mode, so we will see that it is lossless mode that is truly lossless what we call it.
49.srt	00:01:37.979 --> 00:01:39.279	What do you mean by that?
49.srt	00:01:39.679 --> 00:01:50.969	So, we will be doing the predictive coding mechanism opposed to the baseline mechanism which is based on DCT and quantization that is source of the loss.
49.srt	00:01:51.489 --> 00:01:56.819	So, here the simple block diagram of the technique is what it is shown in this.
49.srt	00:01:57.279 --> 00:02:03.299	So, what we have is this is the image what we have it.
49.srt	00:02:03.669 --> 00:02:06.199	So, we will find the predictive difference.
49.srt	00:02:06.519 --> 00:02:09.399	So, which is shown in this diagram.
49.srt	00:02:09.479 --> 00:02:11.279	Then we will do the.
49.srt	00:02:11.549 --> 00:02:16.979	Huffman encoder, then we will be calling this as the last list coding.
49.srt	00:02:17.389 --> 00:02:26.909	So, as you can see in this figure, there are 7 predictive coding techniques which is going to be used.
49.srt	00:02:27.259 --> 00:02:38.339	Here, it is going to be unknown parameter in the P1 and the surrounding images pixels what we call it which are 0 0 and 1.
49.srt	00:02:38.749 --> 00:02:42.579	In this case, in the P2 mode, it is going to be 1 0 0.
49.srt	00:02:43.159 --> 00:02:45.250	and so on what we will be using it.
49.srt	00:02:45.569 --> 00:02:55.039	As you will be seeing in the p 5 we have 1 minus half and then half same way with p 7 we have half 0 and then half.
49.srt	00:02:55.359 --> 00:02:58.189	So, we will see predictive coding how it is going to be used.
49.srt	00:02:59.529 --> 00:03:03.299	Only we are going to consider the difference in this case.
49.srt	00:03:03.639 --> 00:03:12.939	So, that is for each pixel a predictor that is what we shown one of the 7 which is listed in the table here is possible.
49.srt	00:03:13.399 --> 00:03:24.399	So, that is used best predicts the value contained in the pixel as a combination of up to 3 neighbouring pixels as you are seeing it this is the pixel.
49.srt	00:03:24.399 --> 00:03:27.399	So, it can be a, c, b, r these 3.
49.srt	00:03:27.709 --> 00:03:43.919	So, the predictor with respect to that if it is in the p 1 only a what you will be selecting it p 2 b and p 3 c and then the other combinations what you can see the thing up to p 4 to p 7 with respect to a b and then c.
49.srt	00:03:44.949 --> 00:03:56.120	What we say is the difference between the predicted value and the actual value that is x containing the pixel is used as the predictive difference to represent the pixel.
49.srt	00:03:56.580 --> 00:04:11.289	Instead of directly sending the value of that pixel, so we will be computing predict the difference and then what it belongs to, so that number of bits are going to be less to represent them.
49.srt	00:04:11.879 --> 00:04:17.290	The predictor along with the predictive difference are encoded as the pixels content.
49.srt	00:04:17.849 --> 00:04:26.079	So, the series of pixel values are encoded using as in the previous slide it depicted using the Huffman coding.
49.srt	00:04:26.689 --> 00:04:29.939	So, one has to take care of it that is what is this nodes.
49.srt	00:04:30.349 --> 00:04:47.969	The very first pixel in location 0 comma 0 will always use itself and pixels at the first row always use p 1 that is pixel in row they will use p 1 and pixel at the first column always.
49.srt	00:04:48.610 --> 00:05:02.279	In this use P2 technique ok and then the best that that is what of the 7 predictions is always chosen for any of the pixel in this portion.
49.srt	00:05:02.959 --> 00:05:12.019	So, here it is selected as 5 by 5 pixel what it is shown, but usually we will take 8 by 8 pixel as the sample.
49.srt	00:05:13.670 --> 00:05:17.660	So, then how we are going to continue with the progressive mode.
49.srt	00:05:18.209 --> 00:05:19.279	So, from the.
49.srt	00:05:19.899 --> 00:05:21.149	previous one predictive.
49.srt	00:05:21.149 --> 00:05:23.379	So, we will see progressive how it is going to go.
49.srt	00:05:23.959 --> 00:05:34.349	So, it allows a coarse conversion of an image to be transmitted at a low rate which is then progressively improved over subsequent transmissions.
49.srt	00:05:34.829 --> 00:05:47.899	So, as you will be seeing spectral selection, send DC component and first few AC coefficients first and then gradually some more AC coefficients what you will be selecting it.
49.srt	00:05:48.209 --> 00:05:49.139	So, what is it?
49.srt	00:05:49.139 --> 00:05:51.569	So, you will be seeing that in the 8 by 8.
49.srt	00:05:51.870 --> 00:05:55.669	So, these are your red depicts your DC coefficients.
49.srt	00:05:56.089 --> 00:05:59.599	So, first scan you will be sending all the dc coefficients.
49.srt	00:06:00.139 --> 00:06:03.000	In the second scan what you will be seeing it.
49.srt	00:06:03.310 --> 00:06:20.719	So, you will send some few ac coefficients like that you can send some more ac coefficients which are dominant as you can see the thing the last one is yellow that is nth scan you will be sending these coefficients.
49.srt	00:06:21.209 --> 00:06:26.449	This is how in the progressive mode you will be sending the coefficients.
49.srt	00:06:27.929 --> 00:06:36.839	So, as you can see that in the progressive mode successive approximation all the DCT components are sent few bits at a time.
49.srt	00:06:37.389 --> 00:06:41.439	For example, send n 1 what it says is 4.
49.srt	00:06:42.089 --> 00:06:47.009	So, you are seeing that these are the 4 pixels which are sent ok.
49.srt	00:06:47.959 --> 00:06:53.019	Bit starting with MSB of all pixels in the first scan.
49.srt	00:06:53.639 --> 00:06:57.839	The next n to say in this case only one bit.
49.srt	00:06:58.329 --> 00:07:02.209	what it will be sent here that is the complete length of it.
49.srt	00:07:02.539 --> 00:07:22.529	So, you will be seeing that this 4 bits that whatever the length of it is going to be our first scan and then the second scan what you are seeing it here and then bits of all pixels in the second scan and then so on what you will be doing it.
49.srt	00:07:22.529 --> 00:07:26.409	So, you are seeing that till the end that is LSB bit.
49.srt	00:07:29.369 --> 00:07:32.859	So, that is 1 pixel what for the rest of the thing what you will be sending it.
49.srt	00:07:33.279 --> 00:07:39.819	Last one is that is in this case it becomes fifth scan which you will be transmitting yellow.
49.srt	00:07:40.129 --> 00:07:51.879	And then this is what you have ordered the pixels in the zigzag wise basically on this axis.
49.srt	00:07:53.799 --> 00:07:58.699	So, the other mode is the hierarchical mode what you have to incorporate.
49.srt	00:07:59.859 --> 00:08:13.399	So, this is used primarily to support multiple resolutions of the same image which can be chosen from depending on the targets capabilities.
49.srt	00:08:13.849 --> 00:08:22.619	So, the figure shows here description of how we are three level hierarchical encoder or decoder is going to work.
49.srt	00:08:23.039 --> 00:08:24.269	So, what is it?
49.srt	00:08:24.479 --> 00:08:28.239	So, you have I as the image input here.
49.srt	00:08:28.719 --> 00:08:30.699	So, you have a 4 by 4.
49.srt	00:08:31.129 --> 00:08:53.589	you call it as I 4, then do the encoding of it and then you will call it as L 4 basically and then you will be at the decoder end that is you will be doing the decode and do the conversion to 4 by 4 and then output will be I dash 4 what you will be getting it.
49.srt	00:08:53.750 --> 00:09:04.209	So, the same thing encoded at the encoding side also you can decode and then convert it into 2 by 2.
49.srt	00:09:04.870 --> 00:09:17.459	So, you will be seeing that the next 2 by 2 whatever image thing what you have taken you call it as I 2, then find the difference between these two.
49.srt	00:09:19.509 --> 00:09:27.620	And then you will be encoding this value and then calling it as L 2 and you will be transmitting it.
49.srt	00:09:28.279 --> 00:09:34.079	So, the same thing the next level is you are passing this encoder to decode.
49.srt	00:09:35.589 --> 00:09:49.629	And, then you will be doing the addition of the thing from whatever 2 by 2 what you have it and then you will call it as the 2 by 2 and this will be passed on to the third level.
49.srt	00:09:49.990 --> 00:09:57.969	So, which will be subtracted with respect to the original i and then do this encode and call it as L alone.
49.srt	00:09:58.009 --> 00:10:05.000	And again at the decoding place you are doing the.
49.srt	00:10:05.239 --> 00:10:11.539	decode of these 3 level whatever encoded message.
49.srt	00:10:12.609 --> 00:10:14.689	So, we got I 4 dash.
49.srt	00:10:15.019 --> 00:10:26.319	Now, the same thing what you will be taking it and then doing it as 2 by 2, then you will be adding with whatever you are getting from L 2 and that you call it as I 2 dash.
49.srt	00:10:26.829 --> 00:10:35.069	The same thing will proceed to the next stage that is 2 by 2 and then whatever it decoded at this.
49.srt	00:11:09.499 --> 00:11:23.119	last stage is going to be added and then you will be calling it as I dash ok so where this JPEG common applications lie so one of the application is the JPEG format what we have it and in MPEG one that is this is the joint distinct group what you have it this is MPEG is a moving average what you have one and then two And, then MP3 is the audio player and even in the advanced audio coding and then in WMA most of them use are DCT method for compression.
49.srt	00:11:23.579 --> 00:11:31.909	So, that is what is common in all these applications what you have the DCT coming into the thing.
49.srt	00:11:31.989 --> 00:11:37.929	So, now, we will see a little bit on wide dimensional DCT.
49.srt	00:11:37.929 --> 00:11:39.089	How does it look like?
49.srt	00:11:39.649 --> 00:11:55.499	So, we say n be a positive integer, the one dimensional DCT of order n is defined by an n by n matrix C will be using A and C interchangeably.
49.srt	00:11:55.499 --> 00:12:02.789	So, wherever C matrix in some of the applications we may call it as A matrix.
49.srt	00:12:03.289 --> 00:12:09.309	So, whose entries are given by that is C i comma j is given by.
49.srt	00:12:09.919 --> 00:12:21.209	A i into cos i of 2 j plus 1 into pi divided by 2 n. What is the advantage of orthogonality we will see the thing?
49.srt	00:12:21.679 --> 00:12:28.600	If c is orthogonal then we say that c transpose c is going to be identity matrix i.
49.srt	00:12:29.409 --> 00:12:37.090	That implies that when you take a inverse of c which is equivalent to c transpose itself.
49.srt	00:12:37.490 --> 00:12:40.039	So, this makes us solving the matrix.
49.srt	00:12:40.210 --> 00:12:57.570	equation easy that is shown here that is y is c into x into c transpose for x then what happens to c transpose y when I take c transpose of y and then c transpose on the right hand side also.
49.srt	00:13:15.629 --> 00:13:18.470	Then it becomes c transpose c into x into c transpose here which is nothing, but x into c transpose if you multiply with c c transpose y into c is nothing, but X into C transpose C which becomes X.
49.srt	00:13:18.769 --> 00:13:29.779	So, now, you will be seeing that how Y and X can be computed interchangeably basically that if our matrix is orthogonal.
49.srt	00:13:30.180 --> 00:13:38.389	So, X will be what is it C transpose Y into C whereas, original Y is nothing, but C X into C transpose.
49.srt	00:13:38.830 --> 00:13:46.500	So, it does helps in computation that is both synthesis and analysis equation.
49.srt	00:13:47.759 --> 00:13:50.129	becomes easy for us to do the computation.
49.srt	00:13:50.549 --> 00:13:59.110	Now, we will see for the discrete cosine transform that is we have taken here n length basically.
49.srt	00:13:59.870 --> 00:14:05.759	So, one basic characteristic is it is real orthogonal matrix.
49.srt	00:14:06.199 --> 00:14:15.209	So, what is it which is given by c is equal to root 2 by n into the all the first columns are 1 by root 2.
49.srt	00:14:15.480 --> 00:14:18.419	So, the next one is cos pi by 2n.
49.srt	00:14:19.340 --> 00:14:22.519	n and then cos 3 pi by 2 n and so on.
49.srt	00:14:22.970 --> 00:14:35.360	So, the last one entry will be cos 2 n minus 1 into pi divided by 2 n. And in the last row what we have cos n minus 1 into pi by 2 pi and so on.
49.srt	00:14:35.809 --> 00:14:52.769	And the last entry will be n by n entry is cos n minus 1 into 2 n minus 1 into pi divided by 2 n. Now, we will see either C inverse or C transpose how does it look like.
49.srt	00:14:53.139 --> 00:15:21.039	that is root 2 by n and we know that row becomes column in this case and you will be seeing cos 2 pi by n and then this row is becoming this column and you will be seeing this last column entries cos of n minus 1 into pi by 2 n and so on and then this is the last n by nth entry is the same as the original.
49.srt	00:15:23.580 --> 00:15:27.590	So, how we are going to do the classification of our DCT algorithm?
49.srt	00:15:28.060 --> 00:15:32.620	So, either we can do direct 2D method fine.
49.srt	00:15:32.840 --> 00:15:47.580	This 2D transforms what we call it as both DCT and IDCT to be applied directly on the n by n input data items or we can go with row column method.
49.srt	00:15:48.620 --> 00:15:55.170	That is the 2D transform can be carried out with two passes of 1D transforms.
49.srt	00:15:55.770 --> 00:16:09.120	So, we will be applying the separability property of 2D DCT and IDCT allows us to transform apply in this 1D fashion that is one dimension row then on the other column.
49.srt	00:16:09.970 --> 00:16:16.920	So, this requires what we say 2N instances of endpoint 1D DCT.
49.srt	00:16:17.690 --> 00:16:28.310	So, to implement an N by N 2D DCT that is one of the advantage of using it and then what we call it is this computation is.
49.srt	00:16:28.510 --> 00:16:31.840	So, what do I mean by in place is?
49.srt	00:16:31.840 --> 00:16:38.910	So, whatever the original your matrix what it has it.
49.srt	00:16:38.910 --> 00:16:41.840	So, same thing can be replaced with the new data.
49.srt	00:16:41.840 --> 00:16:50.260	So, that I need not have more storage for this computation and it is much faster also we will see in a while.
49.srt	00:16:50.260 --> 00:16:54.980	So, now how we are going to do the row column decomposition.
49.srt	00:16:59.080 --> 00:17:01.610	So, we said that separable row column decomposition what will be using it.
49.srt	00:17:01.610 --> 00:17:29.690	So, in the matrix form what it is given as z is equal to x into a transpose what we have it and then a k of n is nothing, but root 2 by n into c of k, n is the order what will be taking it and then these are the cos 2 pi into 2 n plus 1 into k divided by 4 n. So, these are the coefficients what we have it.
49.srt	00:17:30.100 --> 00:17:33.769	k and n will be varying between 0 to n minus 1.
49.srt	00:17:34.550 --> 00:17:53.870	And we know the first coefficient c of 0 is root 1 by 2 and then the other coefficients k is equal to 1 to n minus 1 that is what it says for k is not equal to 0, c of k coefficient is going to be 1.
49.srt	00:17:54.300 --> 00:18:00.580	As you can see in the previous this thing, you will be seeing that this is root 2 by.
49.srt	00:18:01.420 --> 00:18:02.809	n what we have taken the thing.
49.srt	00:18:02.809 --> 00:18:04.319	So, this is 1 by root 2.
49.srt	00:18:04.789 --> 00:18:11.880	So, you will be seeing that the first c 0 is 1 by root 2 basically.
49.srt	00:18:11.880 --> 00:18:19.279	So, which we can take it as 1 by root 2 and then rest of them we can assume it as 1.
49.srt	00:18:21.190 --> 00:18:23.960	Then what happens to our equation?
49.srt	00:18:24.480 --> 00:18:28.019	So, x is the input or 1 d dct unit.
49.srt	00:18:28.289 --> 00:18:31.200	So, what we are going to compute here y is equal to.
49.srt	00:18:32.099 --> 00:18:41.519	The first stage of the thing A into x, then we will be doing the transpose the memory of Y.
49.srt	00:18:42.909 --> 00:18:45.539	So, Y we have to do the transpose.
49.srt	00:18:45.539 --> 00:18:56.099	So, you will be seeing that this is my transpose of Y here it is C what it has been done here A into x what will be transposing.
49.srt	00:18:56.359 --> 00:19:02.119	Then I will do the 1D DCT same unit I can apply 1D DCT unit.
49.srt	00:19:02.539 --> 00:19:06.289	then I will be getting y into A transpose.
49.srt	00:19:07.400 --> 00:19:10.769	So, that is my z what it is shown here.
49.srt	00:19:11.450 --> 00:19:16.150	So, this is how we do the row column decomposition and then computation.
49.srt	00:19:17.039 --> 00:19:18.990	Now, why we have to use this?
49.srt	00:19:19.049 --> 00:19:26.580	So, carry out the computation as a full matrix vector multiplications.
49.srt	00:19:36.430 --> 00:19:44.029	We know that 1D transform requires n into n multiplications which is nothing, but 1D order of n squared multiplications and then n into n minus 1 additions what we needed.
49.srt	00:19:44.380 --> 00:20:06.940	So, this also order of n squared whereas, our 2D transform requires as we know that all is length n which is going to be order of n to the power of 4 and then multiplications and this one order of n to the power of 4 that is n into n into.
49.srt	00:20:07.470 --> 00:20:13.299	n minus 1 additions what we needed if we are using direct 2D transform.
49.srt	00:20:14.119 --> 00:20:35.690	So, although requiring most number of operations this method is very regular and most suitable for vector processors are deeply pipelined architecture what we have discussed for high processor execute our processor engine basically utilization.
49.srt	00:20:36.569 --> 00:20:37.869	So, what is it?
49.srt	00:20:38.130 --> 00:20:58.460	So, we can have 1D fast algorithms, we can just like our FFT we can configure our DCT also for the fast algorithm, which brings down to order of n log n instead of order of n squared what we can have computation.
49.srt	00:20:59.059 --> 00:21:10.619	Whereas, a 2D fast algorithm we can incorporate it in order of n into n log n a ways that is order of n squared log n.
49.srt	00:21:11.240 --> 00:21:14.980	what we will be getting directly if we are doing the 2D algorithm.
49.srt	00:21:15.400 --> 00:21:21.350	So, one of the applications I will be showing that how this can be incorporated later.
49.srt	00:21:22.480 --> 00:21:30.069	So, now, we will see why we need the compression we have been discussed in the last class also.
49.srt	00:21:30.470 --> 00:21:33.110	So, there are different ways of doing the compression.
49.srt	00:21:33.110 --> 00:21:40.490	So, we know that is a method that reduces amount of a memory takes to store in image.
49.srt	00:21:40.809 --> 00:21:44.690	So, we discussed in the last class so with 3 milliseconds.
49.srt	00:21:45.529 --> 00:21:50.230	data, how much video we have to store it.
49.srt	00:21:50.599 --> 00:21:52.599	So, how we can reduce it.
49.srt	00:21:53.159 --> 00:21:59.299	So, that DCT matrix is based on our visual system for the purpose of image compression.
49.srt	00:22:00.190 --> 00:22:06.559	And this means we can delete the least significant values without our eyes noticing the difference.
49.srt	00:22:07.069 --> 00:22:09.659	There are different ways of doing the compression.
49.srt	00:22:09.659 --> 00:22:14.730	So, the first one we have discussed we will just go for one more.
49.srt	00:22:15.769 --> 00:22:16.799	time to see the thing.
49.srt	00:22:17.390 --> 00:22:18.299	So, what is it?
49.srt	00:22:18.359 --> 00:22:23.549	We have found this matrix that is y is c transpose whole transpose what we wanted.
49.srt	00:22:23.549 --> 00:22:38.609	And we say in this case this is the most important part in our image what it is required and these are semi important and these are the least important values what we are interested in.
49.srt	00:22:38.980 --> 00:22:47.170	So, using the DCT the entries in y will be organized based on the human visual system.
49.srt	00:22:47.950 --> 00:22:53.660	The most important values to arise will be placed in the upper left corner of the matrix.
49.srt	00:22:54.309 --> 00:23:00.610	And the least important values will be mostly in the lower right corner of the matrix as you are seeing it here.
49.srt	00:23:01.569 --> 00:23:06.930	So, the next one to show that what are the DCT coefficients how it is ordered ok.
49.srt	00:23:07.330 --> 00:23:21.750	So, you will be seeing that the first corner you will have the DC in terms of frequencies as DC component is here and rest of the frequencies that is low frequencies which are present in the.
49.srt	00:23:22.129 --> 00:23:31.200	this domain same as our previous one we have the medium frequencies and these are the high frequencies.
49.srt	00:23:31.200 --> 00:23:38.159	Most of us know that high frequencies is a noise so, that we can eliminate that.
49.srt	00:23:38.789 --> 00:23:49.480	And then when we are looking at some of the edges what we are going to want to put it in the frequency domain that is in the DCT coefficients.
49.srt	00:23:49.779 --> 00:23:54.859	So, we will have the DCT and the vertical edges are represented.
49.srt	00:23:55.330 --> 00:23:57.330	in the horizontal coefficients.
49.srt	00:23:57.830 --> 00:24:07.569	Whereas, the horizontal edges values are represented as are column wise in this and all these are high frequencies what we will be representing it.
49.srt	00:24:07.569 --> 00:24:10.029	So, coming to the image compression.
49.srt	00:24:11.360 --> 00:24:13.940	So, you will be seeing that it is 8 by 8 pixels.
49.srt	00:24:14.289 --> 00:24:23.539	So, this is the grayscale what we have taken the thing that is some of them are white, some of them are black and then some of them are gray.
49.srt	00:24:29.779 --> 00:24:43.799	So, this is how the pixels can be taken or one of the best way of doing it is take a checker board which has both white and black components only and then see how the compression is going to look like.
49.srt	00:24:44.240 --> 00:24:50.759	And then we have taken an image here all of you know that this is an input image lena.
49.srt	00:24:51.180 --> 00:25:00.019	So, which is there in the matlab you can choose this or from anywhere you can download different images and then you can represent.
49.srt	00:25:00.319 --> 00:25:03.769	So, we will see the compression how it is going to have it.
49.srt	00:25:05.180 --> 00:25:09.600	The first one is we can do a greyscale example what it is taken.
49.srt	00:25:09.930 --> 00:25:14.780	So, the value what will be representing is 0 to 255.
49.srt	00:25:15.300 --> 00:25:26.260	So, 0 represents black and 255 represent white and in between values will be different levels of grey what will have it.
49.srt	00:25:26.620 --> 00:25:35.280	So, as an x what you will be seeing is these are the values what you will have it in the matrix.
49.srt	00:25:35.789 --> 00:25:43.930	So, you will be seeing some of them are 214, 208, 198 and other things the first one is 63.
49.srt	00:25:44.420 --> 00:25:46.789	So, now, we will have we will do the.
49.srt	00:25:47.140 --> 00:25:51.610	So, 2D DCT of matrix what we are going to do it.
49.srt	00:25:51.610 --> 00:26:05.410	So, numbers are coefficients of a polynomial what we will take it and this is after doing the 2D DCT for this x value we will be getting y.
49.srt	00:26:06.039 --> 00:26:08.819	So, these are the values what it is represented.
49.srt	00:26:09.099 --> 00:26:28.609	So, we can see that this is dc minus 304 which is what we call it as 255 white and then you will be seeing that they will be having different values approximately this is minus 327 and 260 what you will be seeing somewhere here ok.
49.srt	00:26:37.490 --> 00:26:45.680	So, some of them are that is represented as black and then you will be seeing rest of the thing and then you are seeing that some of them have very less values.
49.srt	00:26:46.059 --> 00:26:47.129	So, what is it?
49.srt	00:26:47.480 --> 00:26:49.389	I can put a threshold.
49.srt	00:26:49.940 --> 00:27:02.609	So, that is above that I will be making them 0s or below them I will be making 0s and above threshold I will be making them whatever they have it.
49.srt	00:27:02.609 --> 00:27:08.149	So, what is the threshold you can put the thing here?
49.srt	00:27:08.519 --> 00:27:23.250	As you can see that the values less than arbitrarily you here it is chosen ok. As you can see here I have a 12 here 30 ok.
49.srt	00:27:23.720 --> 00:27:26.339	So, some of them are getting eliminated.
49.srt	00:27:26.500 --> 00:27:36.089	One way of doing the thing is I can put a threshold saying that above any value 10 or below that what I am going to make them 0s.
49.srt	00:27:36.389 --> 00:27:38.210	I can do that way or.
49.srt	00:27:38.559 --> 00:27:43.199	one corner of it what I can do it because these are going to be 0s.
49.srt	00:27:43.499 --> 00:27:51.649	So, what you have selected is from here you have made them 0s basically all of the lower side of the matrix ok.
49.srt	00:27:52.209 --> 00:28:10.929	So, this is one way of selecting rest of the what we say we are going to keep the coefficient as it is that is cut the least significant components that is what it is done that is we save a little over half the original memory by doing it.
49.srt	00:28:12.539 --> 00:28:16.079	So, this is one way of doing our compression.
49.srt	00:28:16.569 --> 00:28:24.549	So, in the next class we will see other ways that is we will use the quantization matrix.
49.srt	00:28:24.599 --> 00:28:35.889	So, to say that we will be dividing by that quantization matrix and then we will discuss that how it is done and then we will take the demo of the DCT also.
49.srt	00:28:36.369 --> 00:28:38.859	So, thank you and then happy listening.
49.srt	00:28:39.919 --> 00:28:41.449	We will meet in the next class.
8.srt	00:00:00.330 --> 00:00:26.160	So, welcome back to real time digital signal processing course.
8.srt	00:00:26.550 --> 00:00:32.369	Today we will discuss about some of the real time constraints what we are going to have it and then how to.
8.srt	00:00:32.689 --> 00:00:43.109	solve and then look for the built in DSP processor or how to design our own DSP processor in FPGA.
8.srt	00:00:43.890 --> 00:00:47.079	So, we will do the recap first.
8.srt	00:00:47.609 --> 00:00:52.329	In the previous class, we discussed about DSP architecture in detail.
8.srt	00:00:53.000 --> 00:00:57.700	So, hope you are comfortable with the architecture whatever we have used.
8.srt	00:00:58.129 --> 00:01:02.409	In this class as I mentioned, we will be seeing some of the real time constraints.
8.srt	00:01:02.869 --> 00:01:06.969	how to design the DSP for such applications.
8.srt	00:01:07.650 --> 00:01:09.019	What are the real-time constraints?
8.srt	00:01:09.019 --> 00:01:16.460	The major limitation of DSP systems for real-time applications is the bandwidth of the system.
8.srt	00:01:16.460 --> 00:01:24.960	So, the processing speed determines the maximum rate at which the analog signal can be sampled.
8.srt	00:01:24.960 --> 00:01:30.039	As an example with sample by sample processing.
8.srt	00:01:35.540 --> 00:01:41.340	So, if we use the interrupt driven service, one output sample is generated before the news input sample is presented to the system.
8.srt	00:01:42.130 --> 00:02:01.130	Then either we have to forego what we say is lose that sample if we are unable to compute our algorithm within that time or use buffer to store it that is if we do not want to lose any of the sample.
8.srt	00:02:01.640 --> 00:02:05.590	So, we have to have a buffer to store that.
8.srt	00:02:06.330 --> 00:02:10.150	whatever sample which is coming much faster than our computation time.
8.srt	00:02:10.810 --> 00:02:20.580	So, what it says therefore, the time delay between input and output for our sample by sample processing must be less than one sampling interval.
8.srt	00:02:21.050 --> 00:02:28.530	So, we have discussed that 80 seconds is my sampling time what I have it in seconds.
8.srt	00:02:28.870 --> 00:02:37.629	So, our processing time tp plus our overhead I o overhead together should be less than our sampling.
8.srt	00:02:38.370 --> 00:02:54.580	So, as it is defined TO is our overhead I O operations which takes that is the data which comes from input and then till the output is going to the system or wherever you are storing that we call it as TO will be the overhead.
8.srt	00:02:55.060 --> 00:03:04.410	And then TP will be our signal processing time the algorithm which you are going to incorporate in your computation basically.
8.srt	00:03:04.410 --> 00:03:09.270	So, the other constraint what we are going to see.
8.srt	00:03:09.590 --> 00:03:24.070	So, one we say that it is hard real time constraint, which is going to limit our highest frequency of signal that can be processed by our DSP systems using sample by sample processing approach.
8.srt	00:03:24.920 --> 00:03:35.720	That means, to say that I am unable to hard real time system constraint is one such that where I cannot afford to lose even a single clock cycle.
8.srt	00:03:36.140 --> 00:03:41.160	I have to process and then my result should be ready before the next sample comes.
8.srt	00:03:41.510 --> 00:03:44.230	In that case what happens to our bandwidth?
8.srt	00:03:44.830 --> 00:03:49.240	We say f m is the maximum frequency I can allow in my input sample.
8.srt	00:03:49.689 --> 00:04:09.160	So, that should be less than or equal to half the sampling rate which is driven by our sampling theorem constraint which should be less than or equal to 1 by 2 into our T p plus T o that is my processing time as well as my overhead for I O operations.
8.srt	00:04:09.680 --> 00:04:15.030	So, it says that the no long the longer the processing time.
8.srt	00:04:15.230 --> 00:04:28.460	T p that is my processing time is much greater then what happens lower will be the signal bandwidth that can be handled by the system as we can see from this equation.
8.srt	00:04:29.080 --> 00:04:37.120	So, coming to how to do the system design that is our digital signal processor system design how we are going to take it.
8.srt	00:04:37.560 --> 00:04:45.550	So, the first one is we will be seeing that DSP system is going to be characterized by the embedded algorithm.
8.srt	00:04:46.080 --> 00:04:49.450	which specifies the arithmetic operations to be performed.
8.srt	00:04:49.850 --> 00:05:04.640	So, the next step is the algorithm for a given application is initially described using difference equations and or signal flow block diagram with symbolic names for the inputs and outputs.
8.srt	00:05:05.210 --> 00:05:15.270	The next stage of the development process is to provide more details on the sequence of operations that must be performed in order to derive the output.
8.srt	00:05:16.920 --> 00:05:21.970	two methods which characterize the sequence of operations in a program.
8.srt	00:05:22.490 --> 00:05:29.310	One is using the flowcharts or structured descriptions one can give it.
8.srt	00:05:29.650 --> 00:05:47.010	So, in this case you will be giving the structured description it derived from your application for whichever application you are designing your processor you will be specifying that and then you have to consider all the system specifications in this case.
8.srt	00:05:47.520 --> 00:05:54.129	Then, you will be going for the algorithm development and then initially we will be doing the simulation.
8.srt	00:05:54.430 --> 00:06:07.629	So, that all our algorithm is working correctly, then we will be seeing that which DSP processor I have to select or which DSP processor I have to design if I am using the FPGA.
8.srt	00:06:08.390 --> 00:06:17.450	Then we will be coming for the software architecture, how to steer this hardware or I can generate my hardware schematic.
8.srt	00:06:19.290 --> 00:06:22.490	And, then I can generate the hardware prototype here.
8.srt	00:06:23.150 --> 00:06:28.500	Then in the software side we will be seeing that I have to do the coding and then debugging.
8.srt	00:06:29.000 --> 00:06:39.710	So, that the complete system is working as nowadays we will be seeing that hardware and then software code design is the popular one in the present scenario.
8.srt	00:06:40.300 --> 00:06:45.250	So, both of them will be going hand in hand if it is possible.
8.srt	00:06:45.740 --> 00:06:50.569	Otherwise, we have to do them separately and then merge here.
8.srt	00:06:50.789 --> 00:06:52.800	in the integration system here.
8.srt	00:06:53.269 --> 00:07:05.649	So, we have to integrate both software and hardware and then the do the debugging see that my software and then hardware are going correctly according to my application.
8.srt	00:07:06.009 --> 00:07:11.029	Then we will be doing the system testing and then we will be releasing my hardware.
8.srt	00:07:11.490 --> 00:07:28.120	So, even the system testing involves lot of test to be conducted it depends on how you will be for all cases you may do the testing and some of them may be left out because exhaustive testing is going to take a lot of time.
8.srt	00:07:29.189 --> 00:07:43.250	So, mostly some of the testing will be critical ones will be done and then we will be releasing our product or for whichever application we are doing our hardware which is going to be released.
8.srt	00:07:43.250 --> 00:07:47.959	Coming to the software side ok.
8.srt	00:07:48.439 --> 00:07:54.300	So, how general purpose processor is advantageous we will see it here.
8.srt	00:07:54.529 --> 00:07:59.500	One is we know that we use the high level languages.
8.srt	00:07:59.820 --> 00:08:12.020	such as we can use the MATLAB or C plus C or C plus plus or other DSP software packages on computers can significantly save algorithm development time.
8.srt	00:08:12.670 --> 00:08:23.480	So, even nowadays the python is the one of the popular one, one can use it and then test your prototype basically.
8.srt	00:08:23.860 --> 00:08:29.570	In addition the prototype C programs used for algorithm.
8.srt	00:08:29.970 --> 00:08:34.490	evaluation can be ported to different DSP hardware platforms.
8.srt	00:08:35.009 --> 00:08:45.110	So, one of the advantage of using the higher level language is it is independent of the platforms and with little bit of fine tuning.
8.srt	00:08:45.379 --> 00:08:52.570	So, we can port from one DSP hardware platform to the other DSP hardware platforms.
8.srt	00:08:52.830 --> 00:09:04.950	And then the other one is it is easier to debug and modify high level language programs to computers using integrated software development tools.
8.srt	00:09:05.269 --> 00:09:14.320	As an example you are seeing the DSP algorithm which is there I can specify either in MATLAB or using C plus C or C plus plus.
8.srt	00:09:15.490 --> 00:09:33.779	And, then the this is the DSP software what will be using it and data inputs for this software which will be coming from the external ADC or any other computers what you can take it as an input and you will be storing it in the data file.
8.srt	00:09:34.700 --> 00:09:43.659	And then you perform your software operations and see if you are meeting all your requirements for that particular algorithm.
8.srt	00:09:44.080 --> 00:09:45.500	So, if.
8.srt	00:09:45.779 --> 00:09:56.549	If everything is done, so you can specify some of the signal generators back, you can store it in the data file and then it can be reused.
8.srt	00:09:57.100 --> 00:10:16.399	So, if the complete algorithm is satisfactorily working, then what you will be doing is you will be generating the data files, you can send it for either for analysis or if you want to have the analog output, you will be converting this digital data into analog and sending it.
8.srt	00:10:18.000 --> 00:10:28.440	out to other hardware or you can save them as digital data in other computers also for later use if you want to have it.
8.srt	00:10:28.440 --> 00:10:37.210	Continuing with development of software basically on the general purpose computer what happens to our I O operations.
8.srt	00:10:37.790 --> 00:10:46.070	So, it will be based on disk files, so it is easy to implement and behaviors of the system are easy to analyze all these operations.
8.srt	00:10:52.659 --> 00:11:04.500	And, we know that we have a floating point data formats and arithmetic can be used for computer simulations thus ease of development.
8.srt	00:11:04.980 --> 00:11:12.180	So, as we can see even the fixed point file system is available in MATLAB.
8.srt	00:11:12.629 --> 00:11:23.730	So, if I want to test my floating point data if it is working and then I want to convert it into fixed point and then see that my code is running perfectly.
8.srt	00:11:24.080 --> 00:11:32.460	almost equivalent to my floating point operations, I can check it and then use them in my hardware development.
8.srt	00:11:32.650 --> 00:11:48.640	So, we will see that we call that as the bit true simulations of the developed algorithms which can be performed using MATLAB or CRC++ for fixed point DSP implementation.
8.srt	00:11:54.120 --> 00:11:59.420	So, our algorithms will be running depending on what software I will be using it on the general purpose computer.
8.srt	00:12:00.490 --> 00:12:05.340	So, the next one is how we are going to decide on the selection of DSP hardware.
8.srt	00:12:06.340 --> 00:12:14.500	So, we know that the hardware cost and product manufacture integration are important factors for our high volume applications.
8.srt	00:12:14.940 --> 00:12:17.590	So, one is concentrating on high volume.
8.srt	00:12:17.590 --> 00:12:23.670	So, we have to see the cost and then the manufacture integration how it is going to happen.
8.srt	00:12:24.290 --> 00:12:26.120	So, we know that for portable.
8.srt	00:12:26.560 --> 00:12:31.550	that is battery powered products, power consumption is more critical.
8.srt	00:12:32.090 --> 00:12:41.000	All of us use our mobiles, they have DSP processor built in them, all of us are power hungry as you know about it.
8.srt	00:12:41.250 --> 00:12:51.570	I want to save my power and I should not be charging my mobile and then I want all the features in them to be working for full day.
8.srt	00:12:51.570 --> 00:12:57.810	So, that I need not have to use the power banks in these cases.
8.srt	00:12:58.590 --> 00:13:04.450	So, this becomes the critical component of our portable devices.
8.srt	00:13:04.490 --> 00:13:16.629	And then for low to medium volume applications, there will be trade off among development time cost of development tools and the cost of the hardware itself.
8.srt	00:13:16.860 --> 00:13:30.160	So, in this case I do not want to have high volume products to be coming out, but mine is going to be low and medium, but at the same time I have to look at it my cost should not be going up.
8.srt	00:13:31.580 --> 00:13:39.080	At the same time I should provide whatever features that are required at the low cost.
8.srt	00:13:39.179 --> 00:13:48.529	So, the likelihood of having higher performance process with upwards compatible software is also an important factor.
8.srt	00:13:48.529 --> 00:13:58.460	So, one has to look at it that the they have to be programmable using higher level software basically that is like.
8.srt	00:14:04.059 --> 00:14:13.299	Either I can interface with MATLAB or I can use CRC plus plus programming so that one is at ease in programming.
8.srt	00:14:14.019 --> 00:14:30.360	So, for the high performance a low volume application such as communication infrastructures and wireless based stations the performance ease of development and multiprocessor configurations are the paramount in this case.
8.srt	00:14:30.750 --> 00:14:33.799	So, in the communication field you will be seeing that.
8.srt	00:14:34.330 --> 00:14:38.149	All of us will be hungry with our network.
8.srt	00:14:38.500 --> 00:14:47.149	So, I want immediate connectivity as we connect to other person or any other devices or whatever may be the thing.
8.srt	00:14:47.500 --> 00:14:50.159	I do not want to lose my time in that.
8.srt	00:14:50.440 --> 00:14:55.580	So, that way we say that this becomes the performance becomes the paramount in that.
8.srt	00:14:56.049 --> 00:15:01.480	And even the development of that and how we will be using the multiprocessor in those cases.
8.srt	00:15:01.830 --> 00:15:05.070	I have to increase my hardware and then the cost.
8.srt	00:15:05.740 --> 00:15:13.320	may little go up, but try to see that we try to keep the cost also at a low whatever possible.
8.srt	00:15:14.610 --> 00:15:16.889	Continuing with the hardware selection.
8.srt	00:15:17.340 --> 00:15:25.000	So, some of the ways one processor execution speed is compared is as follows.
8.srt	00:15:36.970 --> 00:15:37.509	So, usually we say it is MIPS that is million of instructions per second, how much the processor is doing it or we say MOPS it is millions of per second.
8.srt	00:15:37.590 --> 00:16:03.409	Otherwise it is going to be millions of floating point operations per second we call it as mega flops basically or the clock rate should be in the megahertz range what we have we wanted or in terms of my multiply and accumulate I should be able to do millions of them that is mm max what we will define.
8.srt	00:16:03.800 --> 00:16:07.830	So, these are the earlier comparisons one used to make it.
8.srt	00:16:08.159 --> 00:16:17.669	But, nowadays any of the DSP processor if you go to Buckley site actually you will be seeing how the processor are going to be tested.
8.srt	00:16:18.039 --> 00:16:40.629	It is based on the application previous to application it was on the algorithms whether you want to run the filter algorithm or discrete Fourier transform what you want to run it or any other adaptive filter applications wise basically that is algorithm wise the testing used to be done.
8.srt	00:16:41.600 --> 00:16:51.009	So, each one will not have the same hardware built in, but how well they react to these algorithms was getting tested.
8.srt	00:16:51.509 --> 00:17:04.430	So, but later on they found that even the algorithm level is not sufficient, it is in the application level one is going to test that how fast these applications in can run in their hardware.
8.srt	00:17:04.430 --> 00:17:11.980	So, you will you can go to the Berkeley website and then see that how the processors are.
8.srt	00:17:13.019 --> 00:17:15.279	tested for their operations.
8.srt	00:17:15.860 --> 00:17:24.720	In addition to these low level actually we need other matrix to be considered that is we call it as milli watts.
8.srt	00:17:25.509 --> 00:17:43.870	So, you will be seeing that power consumption always have to be in milli watt for measuring what are the things power consumption that is a mips per milli watt what we will call it instead of instructions per second I want to consume.
8.srt	00:17:44.150 --> 00:17:48.600	based on my power or MIPS per dollar also.
8.srt	00:17:48.630 --> 00:17:53.640	So, you will be seeing the cost is also coming into picture.
8.srt	00:17:54.230 --> 00:18:03.140	So, these numbers provide a simple indication of performance, power and price for the given applications.
8.srt	00:18:03.530 --> 00:18:07.960	So, depending on it you will be deciding on your hardware.
8.srt	00:18:08.590 --> 00:18:13.400	So, how we will do the selection of the DSP hardware we will continue with the thing.
8.srt	00:18:13.900 --> 00:18:16.950	So, we have number of DSP applications.
8.srt	00:18:17.390 --> 00:18:24.640	along with the relative importance for performance, price and then power consumption as we have already said.
8.srt	00:18:25.019 --> 00:18:27.640	So, which is given in the this table.
8.srt	00:18:28.309 --> 00:18:34.210	So, for handheld devices that the primary concern is power efficiency.
8.srt	00:18:34.490 --> 00:18:39.769	However, the main criterion for the communication infrastructure is performance.
8.srt	00:18:39.980 --> 00:18:44.619	So, these are the one low end to the high end what you will be traversing here.
8.srt	00:18:45.119 --> 00:18:49.700	So, the first application we will be considering was the audio receiver.
8.srt	00:18:50.490 --> 00:18:59.050	So, the performance what we want is 1 and price should be medium and power consumption should be low.
8.srt	00:18:59.460 --> 00:19:07.780	So, you will be seeing the rating is 1 to 3, 1 being the most important one and the 3 is the lowest one.
8.srt	00:19:08.340 --> 00:19:11.300	So, we want to have a low power consumption in this.
8.srt	00:19:11.780 --> 00:19:16.110	So, we know that hearing aid have DSP processor.
8.srt	00:19:16.950 --> 00:19:19.940	So, what is the constraint in this?
8.srt	00:19:20.319 --> 00:19:31.309	The performance is what we are claiming is medium and then my price has to be very low and power consumption can be little more what we say.
8.srt	00:19:31.740 --> 00:19:41.589	But still most of the cases that is power consumption has to be very low in this case because one person will be wearing it.
8.srt	00:19:41.859 --> 00:19:47.230	So, if it is a middle class or low class family who is using the hearing aid.
8.srt	00:19:47.630 --> 00:19:50.019	So, you can see that the.
8.srt	00:19:50.369 --> 00:19:56.419	that they have to replace in a day or in a week or in a month what you will be calculating it.
8.srt	00:19:56.459 --> 00:20:15.250	So, the next one now I think mp3 players are getting outdated, but they are more important earlier days for all our music and other things now because of the mobile all the players are available for us in the mobile system itself.
8.srt	00:20:15.480 --> 00:20:20.019	So, in this case what we say is the performances.
8.srt	00:20:23.500 --> 00:20:38.159	not such criteria and then price has to be as minimum as possible it is very important then then power consumption is in between because it is not being used continuously.
8.srt	00:20:38.409 --> 00:20:43.029	So, we can take it that it can have a power consumption of medium rate.
8.srt	00:20:43.679 --> 00:20:48.779	Coming with the portable video recorder one uses the thing.
8.srt	00:20:48.879 --> 00:20:53.169	So, which has to have the middle performance what we.
8.srt	00:20:53.549 --> 00:21:01.569	call it and then the price has to be minimum and then our power consumption has to be little more or whatever.
8.srt	00:21:01.889 --> 00:21:17.029	So, desktop computer we know that performance is the critical part of it and then price is a middle what we compare and then power consumption because it is connected to the mains basically.
8.srt	00:21:17.029 --> 00:21:20.559	So, not much botheration in this case.
8.srt	00:21:20.759 --> 00:21:25.839	So, you will be seeing like that notebook or cell phone handset.
8.srt	00:21:26.369 --> 00:21:32.999	And, then last one is cellular base station which is power hungry for your computation.
8.srt	00:21:33.299 --> 00:21:42.239	So, we say the performance rating is 1 and then price is 2 and then your power consumption is going to be 3.
8.srt	00:21:42.729 --> 00:21:51.389	So, that is how we have the list says that how the DSP applications with relative importance rating in this table.
8.srt	00:21:52.239 --> 00:21:57.709	Coming to the processor selection, so when processing speed is a premium.
8.srt	00:21:58.289 --> 00:22:04.579	The only valid comparison between processor is on an execution time must be compared.
8.srt	00:22:05.089 --> 00:22:10.859	How fast because I need the algorithm my or application running at most speed.
8.srt	00:22:10.899 --> 00:22:20.680	So, then I have to see that how execution of my algorithm is going to have it done being done in my processor.
8.srt	00:22:20.680 --> 00:22:27.180	Other important factors are memory usage and on chip peripheral devices.
8.srt	00:22:30.950 --> 00:22:35.250	such as on chip converters and I O interfaces.
8.srt	00:22:35.840 --> 00:22:59.759	So, some of the cases as we say that memory usage is very much you will be seeing that our portable device like I will be giving example of our mobile always what we want is the memory usage we want to have there is no end for asking for more memory every time.
8.srt	00:22:59.759 --> 00:23:02.490	So, whatever memory you want to add on with.
8.srt	00:23:03.160 --> 00:23:13.670	other devices or try to save it in some place or in your cloud or whatever you will be doing the thing if it is overflowing.
8.srt	00:23:14.660 --> 00:23:18.720	And then whether can I have on chip peripheral devices.
8.srt	00:23:19.100 --> 00:23:27.780	So, in the mobile itself what are the things I needed I have to answer my call, I want to see my movie, I want to listen to my music.
8.srt	00:23:28.600 --> 00:23:33.860	And then what else lot of applications what I needed.
8.srt	00:23:33.860 --> 00:23:38.420	So, you will be seeing lot of WhatsApp messages what so many.
8.srt	00:23:38.819 --> 00:23:43.970	peripherals which are connected to this device what you can have it.
8.srt	00:23:44.759 --> 00:23:57.990	And then I need on chip converters also because you will be seeing that we have different network providers how will I be switching from one vendor to the other one.
8.srt	00:23:58.230 --> 00:24:03.930	If I have a BSNL SIM or no what I will call it as Airtel SIM.
8.srt	00:24:04.160 --> 00:24:09.900	So, both are incorporated in the same mobile I should be able to.
8.srt	00:24:10.380 --> 00:24:18.009	or I must be able to have converters for me to change from one vendor to the other one.
8.srt	00:24:18.559 --> 00:24:21.279	So, these are the important ones.
8.srt	00:24:21.359 --> 00:24:31.039	Next one in addition to this we need full set of development tools and support listed as follows are important for digital signal processor.
8.srt	00:24:31.509 --> 00:24:33.130	Why do we need the tools?
8.srt	00:24:33.130 --> 00:24:36.009	Because we are in the development stage.
8.srt	00:24:36.339 --> 00:24:39.890	So, we have to see that our algorithm is going to run.
8.srt	00:24:40.609 --> 00:24:45.779	And, then our application is met and then all the testing is done.
8.srt	00:24:46.079 --> 00:24:49.569	So, these are the capabilities that development tools should have.
8.srt	00:24:50.029 --> 00:24:58.779	The first one we will say is the software development tools such as C compilers, assemblers, linkers, debuggers and simulators.
8.srt	00:24:58.779 --> 00:25:06.750	This is C compilers we know that it is the higher the software what I needed.
8.srt	00:25:06.750 --> 00:25:11.230	So, that I can have the.
8.srt	00:25:11.680 --> 00:25:17.220	I need not have to worry about the hardware which on which I am going to run.
8.srt	00:25:17.220 --> 00:25:29.159	The next one is assemblers because all DSP processors we say that assembler is equivalent almost our machine coding.
8.srt	00:25:29.579 --> 00:25:40.359	So, they usually we do C 2 assembly conversion or one can do the programming written in assembly language itself.
8.srt	00:25:40.720 --> 00:25:48.009	So, disadvantage of assembly languages it is particular to one of the hardware and this is not portable.
8.srt	00:25:49.809 --> 00:25:58.480	person who is writing the code or software should be knowing the in and out of the hardware or the architecture.
8.srt	00:25:58.480 --> 00:26:01.759	So, that he is going to use them in a better way.
8.srt	00:26:02.329 --> 00:26:13.730	The other one is linkers because I will be using some of the libraries which are present because or if I develop my own library I must be able to save them or combine them.
8.srt	00:26:13.839 --> 00:26:16.430	So, that I will be working on it.
8.srt	00:26:16.700 --> 00:26:22.119	So, it will be linking all the files and then next is debuggers.
8.srt	00:26:22.670 --> 00:26:39.700	So, this is one of the important thing because if I have done a mystic or if it is not running based on my intuition then how I am going to do the debugging and see where it is getting stuck or it is taking more time.
8.srt	00:26:39.970 --> 00:26:53.470	So, that that part of the code whether I can optimize on it and why do we need the simulators because I would not be able to go and buy all the DSP process for my applications.
8.srt	00:26:53.900 --> 00:26:58.119	So, I have to see that whether it is going to run on this platform.
8.srt	00:26:58.460 --> 00:27:13.970	So, if I have a simulator I can simulate and then check if it is doing the performance in this particular DSP processor, then I can go and then buy and then install the thing or this chip is suitable for me that is what I can say.
8.srt	00:27:14.269 --> 00:27:24.710	If it is not possible then I have to try other vendors or I have to design my own algorithm once I have tested it that it is working.
8.srt	00:27:25.109 --> 00:27:28.660	Then I can go for my own design in FPGA or VLSI.
8.srt	00:27:29.680 --> 00:27:40.859	The commercially available DSP boards for software development and testing before the target DSP hardware is available that is one of the criteria what we are looking at.
8.srt	00:27:41.519 --> 00:27:55.009	The other one is hardware testing tools such as in circuit emulators and logic analyzer should be able to pinpoint where the error is coming from.
8.srt	00:27:55.549 --> 00:28:12.899	The other one is development assistance such as application notes and DSP function libraries and application libraries, data books, low cost prototyping and so on are the criteria for the processor selection.
8.srt	00:28:13.629 --> 00:28:21.099	Coming to the software development, we have there are four common measures for of a good DSP software.
8.srt	00:28:21.449 --> 00:28:22.349	What are they?
8.srt	00:28:22.769 --> 00:28:26.769	The first one is what we call it as real reliability.
8.srt	00:28:27.379 --> 00:28:33.869	The reliable program is one that seldom or we say never fails.
8.srt	00:28:34.440 --> 00:28:36.649	So, that is what one of the thing.
8.srt	00:28:36.909 --> 00:28:47.649	So, you will be seeing that Google never goes down or whatever may be the thing or you can say that it has gone down in once in 20 years or what you call it.
8.srt	00:28:58.009 --> 00:29:05.339	I think you will be seeing even the banking system, you will be seeing that whenever they are doing the updation or something like that it goes down for one or two hours that is you will be getting the message, but we do not want this basically happen or seldom what we call it.
8.srt	00:29:05.730 --> 00:29:07.889	The next one is the maintainability.
8.srt	00:29:08.440 --> 00:29:24.909	Since most programs will occasionally fail, we know that although it has been considered you can think of 2000 case nobody had considered that our computers will sustain so many years.
8.srt	00:29:25.169 --> 00:29:30.950	So, all of them Y2K problem so, you know that how everybody has to.
8.srt	00:29:31.359 --> 00:29:40.500	go and then redo their checking and then redesigning all their software and other things to take care of beyond 2000 and beyond.
8.srt	00:29:40.919 --> 00:29:46.529	A maintainable program is one that is easy to correct.
8.srt	00:29:46.529 --> 00:29:49.500	So, that is what the thing what one needs it.
8.srt	00:29:49.839 --> 00:29:52.019	So, that I can modify it.
8.srt	00:29:52.019 --> 00:30:00.469	So, that I can maintain whenever I want to change some of the things which I found out that it has got.
8.srt	00:30:04.389 --> 00:30:05.189	error in it.
8.srt	00:30:05.839 --> 00:30:18.089	The other one is extensibility, what when do we say that program is extensible that is from one platform to the other platform I can extend it.
8.srt	00:30:18.539 --> 00:30:23.869	So, whenever the requirement changes also I can easily modify that.
8.srt	00:30:23.869 --> 00:30:28.559	So, that the extension of the program is easy in that case.
8.srt	00:30:35.609 --> 00:30:49.089	The other one is efficiency that is a good DSP program often contains many small functions with only one purpose which can be easily reduced by other programs for different purposes that is what we call it as efficiency.
8.srt	00:30:49.469 --> 00:31:03.379	Coming further with the software development we know that hardware and software design can be conducted at the same time for a given DSP application that is what I discussed when we are doing the DSP system design.
8.srt	00:31:10.929 --> 00:31:21.009	So, we said since there are many independent factors between hardware and software which restricts them actually what we call it as may not be a true system engineer should be capable of understanding issues with both hardware and then software.
8.srt	00:31:21.449 --> 00:31:33.659	So, most of the people you will be seeing that IT software industry most of us or something we say that we are capable of solving the software, but not in the hardware.
8.srt	00:31:33.929 --> 00:31:42.349	So, one person as you can see that he can understand both the hardware and software he can do a real justice to the.
8.srt	00:31:42.599 --> 00:31:44.029	hardware which has come out.
8.srt	00:31:44.239 --> 00:31:45.409	So, which is going to be rare.
8.srt	00:31:45.409 --> 00:31:49.989	So, that is why we will be having a little bit of difference between the two.
8.srt	00:31:50.419 --> 00:31:54.059	So, as we know VLSI has come a long way.
8.srt	00:31:54.379 --> 00:32:08.519	So, our hardware has the cost of it has gone down dramatically as you will be seeing it whatever buying of your laptop or system or your mobile or any product for that matter.
8.srt	00:32:08.519 --> 00:32:11.529	So, you will be seeing that your cost is going down.
8.srt	00:32:15.589 --> 00:32:21.779	But major cost of our DSP solutions it resides in the software development.
8.srt	00:32:22.219 --> 00:32:40.489	So, as I can point out we used to have software cost was much higher than in 1000 dollars earlier for our emulators that is JTAG interfaces compared our own system which was in 400 dollars or something like that.
8.srt	00:32:41.079 --> 00:32:45.809	The software lifecycle involves completion of the software project.
8.srt	00:32:46.239 --> 00:32:59.169	So, namely that is project definition, detailed specifications one has to have it, how you are going to do coding and then you will be having the coding also you can do modularly.
8.srt	00:32:59.169 --> 00:33:01.779	So, that testing becomes easy.
8.srt	00:33:02.209 --> 00:33:16.849	The next is system integration all of them have to be your hardware and then software has to be integrated and finally, how you are going to test it and later on you will be seeing that your product software.
8.srt	00:33:17.109 --> 00:33:22.489	maintenance is one of the important criteria in your software development.
8.srt	00:33:23.159 --> 00:33:30.199	So, continuing with this maintenance is a significant part of the cost for DSP systems.
8.srt	00:33:30.559 --> 00:33:31.959	How we are going to do that?
8.srt	00:33:32.309 --> 00:33:35.219	What are the things that are there in maintenance basically?
8.srt	00:33:35.219 --> 00:33:46.029	One is enhancing the software functions, fixing errors identified as the software is used.
8.srt	00:33:46.529 --> 00:33:49.749	As you will be seeing even in your mobile you will be getting.
8.srt	00:33:50.309 --> 00:33:51.959	updates for your software.
8.srt	00:33:52.309 --> 00:34:00.149	So, from one stage to the other one within one year you may be having multiple software updation which is going to come.
8.srt	00:34:00.149 --> 00:34:15.179	So, you should be able to have more functions incorporated and then if there are bugs in the earlier cases how you have rectified and then identification and then how you will be updating them in your next software.
8.srt	00:34:15.799 --> 00:34:20.949	And then modifying the software to work with new hardware and then software.
8.srt	00:34:21.499 --> 00:34:35.599	So, you will be seeing that iPhone has its own operating system whereas, Android has its own operating system, but the devices may be from different wonders vendors basically.
8.srt	00:34:35.929 --> 00:34:43.259	So, how the Androids the platforms will be having the same software which is running on different platform.
8.srt	00:34:43.819 --> 00:34:51.919	So, it is important to use meaningful variable names in source code and do document programs, thoroughly with the.
8.srt	00:34:52.479 --> 00:34:59.809	titles and comment statements because this greatly simplifies the task of software maintenance.
8.srt	00:35:00.079 --> 00:35:09.049	It is not just writing and then leaving it like or solving our own problem or a math problem, we have to document how it has been done.
8.srt	00:35:09.049 --> 00:35:16.599	So, it will be easy for someone else to take our and then continue from that so, that it need not have to be repeated.
8.srt	00:35:17.179 --> 00:35:23.509	So, the specifications for the software include the basic algorithm and task description.
8.srt	00:35:24.129 --> 00:35:40.209	and how much of memory I need it and constraints on the program size execution and time and then so on what you can keep on including it these are the major ones rest of it will be coming as and when you will be developing it.
8.srt	00:35:40.759 --> 00:36:00.169	So, the next one in the software development is we have to thoroughly review specifications to catch the mistakes even before the code has been written and prevent potential code changes at system integration stage this becomes a little cumbersome.
8.srt	00:36:00.479 --> 00:36:01.729	So, it is better to.
8.srt	00:36:02.469 --> 00:36:06.729	see that all the errors are fixed much earlier.
8.srt	00:36:07.279 --> 00:36:13.919	And as always I mentioned to students nowadays people would not write their flow diagram.
8.srt	00:36:14.329 --> 00:36:25.549	They directly go and then implement their algorithm in the software or whatever and then it becomes little tough to see that where the error has occurred.
8.srt	00:36:25.929 --> 00:36:31.969	If a flow diagram is prepared ok, it will help in design tool to adapt.
8.srt	00:36:32.469 --> 00:36:33.789	at any stage.
8.srt	00:36:33.909 --> 00:36:40.279	So, which flow has gone bad whether I am flowing in the right direction or wrong direction I will be knowing about it.
8.srt	00:36:40.909 --> 00:36:48.039	And writing and testing DSP code is highly interactive process one has to discuss and then do the thing.
8.srt	00:36:48.519 --> 00:37:01.699	So, with the use of integrated software development tools we call it as IDE tool that include simulators or evaluation boards code may be tested regularly as it is written.
8.srt	00:37:02.079 --> 00:37:03.619	So, we will be seeing thus.
8.srt	00:37:03.789 --> 00:37:16.949	how we will be using the software exclusively in our DSK boards, how we will be testing how the input is coming, how the output is going, how our algorithm is running, we will be looking into that.
8.srt	00:37:17.409 --> 00:37:29.629	And writing code in modules as I have already mentioned or sections can help this process because debugging becomes easier, which part of the section or module is not working.
8.srt	00:37:29.989 --> 00:37:37.569	So, we can fix go back and then fix that and input and output those modules are coming correctly or not.
8.srt	00:37:38.169 --> 00:37:45.889	So, coming to the comparison we know that already we said we have different programming parts of it.
8.srt	00:37:45.889 --> 00:37:56.799	So, one of the DSP processor popular one in the earlier 80s and 90s was assembly programming.
8.srt	00:37:57.479 --> 00:38:04.519	So, it is as I have already mentioned it is equivalent to machine code actually used by the processor.
8.srt	00:38:04.929 --> 00:38:11.009	And this gives engineers full control of processor functions and resources thus.
8.srt	00:38:11.219 --> 00:38:16.479	resulting in the most efficient program for mapping the algorithm by hand.
8.srt	00:38:16.749 --> 00:38:38.419	This is the disadvantage what I have to say very time consuming because you should understand how one assembly programming runs and laborious task it is going to be especially for today's highly parallel processor architectures and then complicated DSP algorithms it becomes a hindrance.
8.srt	00:38:38.819 --> 00:38:44.009	So, it is better to go will come to the mixed C and X assembly in a while.
8.srt	00:38:44.269 --> 00:38:46.789	ok. What is the advantage of C programming?
8.srt	00:38:47.189 --> 00:38:56.479	We know that it is software development upgrading and then maintenance is easy and machine code is generated by the C compiler in this case.
8.srt	00:38:56.889 --> 00:39:13.599	Often what happens in this case it is inefficient in both processing speed as well as memory usage which will be much more we will see this in a lab in the lab I will demonstrate how you can compare between just one addition what is going to happen.
8.srt	00:39:14.169 --> 00:39:19.849	Whereas, I can use both C and then assembly and then where I am going to use we will see the thing.
8.srt	00:39:20.349 --> 00:39:30.809	Overall program is written using C actually, but the runtime critical inner loops and modules are replaced by your assembly code.
8.srt	00:39:31.469 --> 00:39:39.759	So, routine may be called as a function or intrinsics we call it or inline coded into the C program.
8.srt	00:39:39.789 --> 00:39:49.749	So, you will be having the library of hand optimized functions may be built up and then brought into your code when required.
8.srt	00:39:50.729 --> 00:40:01.589	So, coming to other distinct development tools, we know that either signal analysis or filtering what we will be doing in the DSP operations.
8.srt	00:40:02.059 --> 00:40:14.989	So, we know that signal analysis deals with measurement of signal properties and MATLAB is powerful tool basically all of us know for the analysis, visualization.
8.srt	00:40:15.319 --> 00:40:19.949	So, which are the critical components in understanding and developing DSP systems.
8.srt	00:40:20.229 --> 00:40:21.419	Even in my regular.
8.srt	00:40:21.679 --> 00:40:27.829	course I told my students to check using MATLAB and later on port it on to the DSP processor.
8.srt	00:40:28.079 --> 00:40:31.529	So, that you can compare with whether you are getting the same results.
8.srt	00:40:32.049 --> 00:40:39.189	Any design we do FPGA or any of the coding we do the thing we first test it in the MATLAB.
8.srt	00:40:39.189 --> 00:40:49.329	So, that our algorithm is running correctly then we will go to our hardware implementation and see that we are almost nearer to whatever MATLAB gives.
8.srt	00:40:51.849 --> 00:40:58.599	So, we say C is an efficient tool for performing signal processing and is portable for different platforms DSP platform what we have said.
8.srt	00:40:59.029 --> 00:41:03.769	Then what happens my input is going to be a C program which is a source code I will be giving it.
8.srt	00:41:04.129 --> 00:41:13.299	So, I have to do use the compiler here and then generate the object code which we call it as machine code or assembly code basically.
8.srt	00:41:13.619 --> 00:41:21.419	And we will be linking with the libraries and then we will loading the code on to the hardware.
8.srt	00:41:21.819 --> 00:41:26.069	Then the data whichever has to be input it is taken from the.
8.srt	00:41:26.829 --> 00:41:29.979	input and then we will be doing the execution here.
8.srt	00:41:30.289 --> 00:41:32.669	So, I will be getting the program output here.
8.srt	00:41:33.799 --> 00:41:37.639	Coming to the comparison of MATLAB versus C C++ we will see.
8.srt	00:41:37.639 --> 00:41:50.149	So, we know that it is an MATLAB is an interactive technical computing environment for scientific and engineering numerical analysis computation and visualization.
8.srt	00:41:50.149 --> 00:41:59.109	So, its strength lies in the fact that complex numerical problems can be solved easily in a fraction of the.
8.srt	00:41:59.679 --> 00:42:02.659	time which is required by our CRC++.
8.srt	00:42:03.489 --> 00:42:07.249	And then program written in these are usually portable.
8.srt	00:42:07.409 --> 00:42:13.579	So, they can be recompiled and run on many different computer platforms.
8.srt	00:42:13.619 --> 00:42:26.459	And it is a high level language, it can also be used for our low level device drivers you know that all your kernel and other things are written using C and C++.
8.srt	00:42:26.579 --> 00:42:28.479	Nowadays you will be seeing with python also.
8.srt	00:42:28.479 --> 00:42:35.629	The other advantage of MATLAB is by using its relatively simple programming.
8.srt	00:42:38.709 --> 00:42:49.639	capability, it can be easily extended to your create a new functions and is further enhanced by our numerous tool boxes.
8.srt	00:42:49.959 --> 00:42:58.559	This is you will be seeing every year there will be new tool boxes introduced or updated basically in the tool box itself.
8.srt	00:42:58.559 --> 00:43:06.679	So, that you have whatever is required at your tip of fingers that is what I will call it.
8.srt	00:43:06.879 --> 00:43:08.379	So, I have the GUI.
8.srt	00:43:08.979 --> 00:43:22.899	tools to support whatever design you are doing it and then for the signal processing toolbox we have the SP toolbox or FDA toolbox for the filter design analysis toolbox.
8.srt	00:43:22.899 --> 00:43:33.589	So, we will be using the FDA toolbox, but nowadays they are naming it in 2020 and above as a filter design toolbox basically.
8.srt	00:43:33.839 --> 00:43:35.519	So, still this is supported.
8.srt	00:43:35.519 --> 00:43:36.439	So, we will use them.
8.srt	00:43:36.909 --> 00:43:40.039	The other one we say that CC++.
8.srt	00:43:40.269 --> 00:44:07.789	is a high level language and usually used for many DSP software development engineers not only because it has powerful commands and data structures, but also because it can easily be ported as we have been telling from the one we have started considering the C. It includes even C or we know that C or C++ debugger which is useful in identifying errors in source programs.
8.srt	00:44:11.189 --> 00:44:20.569	So, it can display values stored in variables at different points in the program and step through the program line by line.
8.srt	00:44:20.569 --> 00:44:23.909	So, which will be taking it up in the lab and see.
8.srt	00:44:24.379 --> 00:44:32.579	So, this ends the constraints when we are designing the DSP processor for real time applications.
8.srt	00:44:32.939 --> 00:44:42.349	So, in the next class we will see that our module second will continue that how the algorithm or filters are going to be built around.
8.srt	00:44:42.639 --> 00:44:45.819	So, we will be considering both finite impulse response.
8.srt	00:44:46.279 --> 00:44:48.149	and infinite impulse response.
8.srt	00:44:48.149 --> 00:45:10.359	So, we have some input how I want to extract these components using different kinds of filters it can be a low pass filter, high pass, band pass or band stop or notch filter to eliminate one of the frequency and how you will be getting the output and their responses is shown.
8.srt	00:45:10.679 --> 00:45:14.479	So, more in detail we will cover it in the next class.
8.srt	00:45:14.679 --> 00:45:15.879	So, happy learning.
8.srt	00:45:16.629 --> 00:45:19.289	And, then thank you for listening to this lecture.
9.srt	00:00:01.219 --> 00:00:25.420	Welcome back to real time digital signal processing course.
9.srt	00:00:25.940 --> 00:00:30.890	Today we will be discussing about module 2 unit 7.
9.srt	00:00:31.250 --> 00:00:47.939	So, as a recap we saw in the module 1 which goes from unit 1 to 6 introduction design concepts and real time constraints what we have considered.
9.srt	00:00:48.420 --> 00:00:56.409	In this class in the module 2 first we will discuss about digital filters and later with FIR filters.
9.srt	00:00:56.640 --> 00:01:00.189	So, why do we need digital filters?
9.srt	00:01:01.060 --> 00:01:03.939	So, where we are going to use it in signal processing.
9.srt	00:01:04.389 --> 00:01:28.159	For separation of signals is one of the application we say as you can see in the example here your original signals has multiple frequencies components present in it and you can see that how they have been added and each one how we can separate it from the signal using different techniques.
9.srt	00:01:28.159 --> 00:01:35.039	So, we will be seeing in a while here it is low pass filter this gives the high pass filter and this is band.
9.srt	00:01:35.410 --> 00:01:43.500	pass and this we call it as notch filter or band stop filter if only one frequency has to be removed then we call it as notch filter.
9.srt	00:01:44.590 --> 00:01:47.430	The one application is restoration.
9.srt	00:01:47.570 --> 00:01:57.480	So, from these signals I want to reconstruct my signal then as you have seen the thing we will be adding all of them and I will be getting back the original signal.
9.srt	00:01:58.180 --> 00:02:01.230	So, if I want to restore back I will be using that.
9.srt	00:02:02.010 --> 00:02:07.290	Then coming to analog that is electronic filters can be used for these same task.
9.srt	00:02:08.520 --> 00:02:14.350	However, digital filters can achieve far superior results.
9.srt	00:02:14.850 --> 00:02:19.620	So, we will see in a short while how it is going to be done with digital filters.
9.srt	00:02:20.050 --> 00:02:36.490	And the application of digital filters is given here, one is in the signal processing what we are considering it, it can be in the communication systems or in control or in electrical systems or in biomedical systems, everywhere we need the filters.
9.srt	00:02:37.950 --> 00:02:40.540	What are the advantages of digital filters?
9.srt	00:02:41.220 --> 00:02:48.760	So, we know that many input signals can be filtered by one digital filter without replacing the hardware.
9.srt	00:02:50.010 --> 00:03:00.410	And then they have the characteristic like linear phase response, we will see it in a while and the performance does not vary with environmental parameters.
9.srt	00:03:00.760 --> 00:03:15.590	So, if you are in a cold place or is in a hot place as we know in the analog filters their components have to be highly meant for those conditions, if it is not the environment is going to play an havoc.
9.srt	00:03:16.050 --> 00:03:28.820	Hence, digital filters will not have this degradation for environments and that is what what it says and it is unlike analog filters these can be portable.
9.srt	00:03:28.820 --> 00:03:35.720	So, from place to place and from one application to the other application.
9.srt	00:03:35.720 --> 00:03:46.390	The other disadvantage of digital filter is basically the bandwidth of the digital filter is much lower than that of analog filter.
9.srt	00:03:47.390 --> 00:03:50.300	And, we are going to have quantization noise in this filters.
9.srt	00:03:50.590 --> 00:03:59.700	The accuracy of digital filter depends on the word length used to encode them in binary form.
9.srt	00:03:59.730 --> 00:04:01.520	So, we have seen the number system.
9.srt	00:04:01.980 --> 00:04:05.670	So, we have used fixed point and then floating point.
9.srt	00:04:05.990 --> 00:04:07.270	So, their pros and cons.
9.srt	00:04:07.270 --> 00:04:15.050	So, this will be constituting whatever we say that accuracy is going to be affected.
9.srt	00:04:16.160 --> 00:04:19.210	And it requires more design and development time.
9.srt	00:04:19.500 --> 00:04:21.079	compared to analog filters.
9.srt	00:04:21.170 --> 00:04:34.420	So, one has to see what should be the order of the filter, whatever you are designing and then you have to pass through input and then if it is available and then see and it is going to take more time.
9.srt	00:04:35.670 --> 00:04:39.189	The difference between analog digital filters is this.
9.srt	00:04:39.810 --> 00:04:52.350	The main difference we will consider here two methods is that digital circuit has to sample the analog signal first and convert it into a set of binary numbers.
9.srt	00:04:53.420 --> 00:05:03.640	And, in contrast analog filters need not have to do this conversion, they can be used directly wherever it is required.
9.srt	00:05:04.880 --> 00:05:13.050	So, coming to some of the recent in the social media what kind of filters is being used is shown here.
9.srt	00:05:13.520 --> 00:05:22.130	So, most of you may be using this augmented reality filters are computer generated effects all of you know about it.
9.srt	00:05:22.570 --> 00:05:31.520	So, they are layered over the real life images in your camera displays and in Instagram stories.
9.srt	00:05:31.880 --> 00:05:42.540	So, you will have most of this augmented the reality filters, they alter the image of your front or back camera displays.
9.srt	00:05:43.580 --> 00:05:52.690	You can think of Instagram's face filters, how they will be working and then you can imagine what is the.
9.srt	00:05:53.090 --> 00:05:55.160	role of filters in social media.
9.srt	00:05:56.189 --> 00:06:00.860	Coming to noise filter digital noise filters why we need it.
9.srt	00:06:01.430 --> 00:06:09.050	In basically in smart TV it is going to reduce the analog noise that is created during your signal transmission.
9.srt	00:06:10.689 --> 00:06:18.460	Helps in eliminate excess noise in a picture and reduce your flickers caused by them.
9.srt	00:06:19.960 --> 00:06:22.840	And how we can eliminate noise on an.
9.srt	00:06:23.220 --> 00:06:33.170	So, you will be knowing that frequency modulated receivers most of the time what we will be using it, how we can eliminate the noise in that.
9.srt	00:06:33.700 --> 00:06:42.510	Usually keep any cell phones or two way radios at least 20 feet from an FM receiver.
9.srt	00:06:43.890 --> 00:06:53.100	And then in cell phones even when not in use all of us know that send out pings that are picked up by your FM receivers.
9.srt	00:06:54.560 --> 00:07:01.770	You can choose a station and adjust the dial to the setting if you are using an analog radio.
9.srt	00:07:02.950 --> 00:07:11.250	Add a large external antler to the receiver that is how you will be eliminating your FM receiver noise.
9.srt	00:07:11.250 --> 00:07:22.210	So, in other way what we will see noise is in your microphone basically whatever microphone you are using for your applications they will have some what we call it as static noise.
9.srt	00:07:27.110 --> 00:07:30.050	So, how you can eliminate the static noise?
9.srt	00:07:30.460 --> 00:07:39.610	You can unplug and re-plug in your mic that way it will try to adapt to the noise which is present there and then it can eliminate it.
9.srt	00:07:39.660 --> 00:07:51.670	So, other way of doing it is try unplugging your headset or standalone microphone from the computer or device to which it is connected and then re-plugging it back.
9.srt	00:07:51.670 --> 00:07:59.370	So, if possible try using a different USB port, if it is USB connected you can try on a different USB so that.
9.srt	00:08:00.280 --> 00:08:02.190	your static noise is gone.
9.srt	00:08:02.730 --> 00:08:11.500	So, if there is a hissing noise in the audio all of you know the thing then use low pass filtering to avoid this hissing noise.
9.srt	00:08:12.210 --> 00:08:16.730	And then how we are going to stop my mic from picking up background noise.
9.srt	00:08:17.060 --> 00:08:22.870	Here it was the static noise here background noise because you will be at different places how you can do that.
9.srt	00:08:23.510 --> 00:08:32.370	So, what it says is click the recording tab in the sound window and select your microphone device and click properties.
9.srt	00:08:32.880 --> 00:08:34.220	Click the levels tab.
9.srt	00:08:34.760 --> 00:08:42.210	So, in that what you will be doing is background noise try lowering your microphone boost option.
9.srt	00:08:42.670 --> 00:08:48.070	Perhaps if you have kept it to 20 dB try to reduce it to plus 10 dB.
9.srt	00:08:48.840 --> 00:08:57.520	So, the other one is we know that most of the ECG signals carry line frequency in them.
9.srt	00:08:57.970 --> 00:09:01.060	How to avoid the line frequency?
9.srt	00:09:01.240 --> 00:09:03.430	In that case we use the notch filter.
9.srt	00:09:03.920 --> 00:09:06.170	to eliminate this line frequency.
9.srt	00:09:06.500 --> 00:09:17.870	So, usually in abroad it is 60 hertz or USA and in India we call it as 50 whatever our line frequency is 50 hertz signal.
9.srt	00:09:18.690 --> 00:09:21.700	So, we will see today FIR filter.
9.srt	00:09:22.130 --> 00:09:27.960	So, first we will see why we have to go for FIR filters their advantages and disadvantages.
9.srt	00:09:28.530 --> 00:09:31.690	So, the advantages as it is listed here.
9.srt	00:09:32.080 --> 00:09:33.470	So, we say it is stable.
9.srt	00:09:34.100 --> 00:09:55.930	simple and design complexity gets really linear in this case and then it has a linear phase response we will see in a while and it is easy to optimize on the order of the filter what we want to have it and this is a non causal system.
9.srt	00:09:55.930 --> 00:10:02.110	Hopefully you would have done your causal and non causal systems earlier in your signals and system.
9.srt	00:10:06.080 --> 00:10:11.280	So, how to make non causal system into causal all of you must be knowing it.
9.srt	00:10:12.770 --> 00:10:17.370	And it has a transient which is going to be finite duration.
9.srt	00:10:17.440 --> 00:10:22.510	So, what we call it is for finite input the output is going to be finite.
9.srt	00:10:22.560 --> 00:10:29.430	So, that is why there would not be any transient which is going to be finite in this case.
9.srt	00:10:30.210 --> 00:10:34.710	And we know that quantization noise is not much as a problem.
9.srt	00:10:35.450 --> 00:10:38.610	So, this is one of the advantage of our FIR filter.
9.srt	00:10:39.050 --> 00:10:40.640	What are the disadvantages?
9.srt	00:10:41.220 --> 00:10:48.190	So, we know that the order of the filter we usually call FIR filter is equivalent to an open loop systems.
9.srt	00:10:48.220 --> 00:10:49.530	It requires large storage basically.
9.srt	00:10:49.570 --> 00:10:57.810	So, it needs storage requirements what we say and then cannot simulate prototype analog filter.
9.srt	00:10:57.810 --> 00:11:03.930	So, a IR filter infinite impulse response filter will be taking it in further classes.
9.srt	00:11:04.780 --> 00:11:07.040	So, we know that.
9.srt	00:11:14.710 --> 00:11:21.100	We most of the design is done in the analog domain and then we convert it into digital domain.
9.srt	00:11:21.590 --> 00:11:34.410	Because, the earlier world more than 100 years analog filter have survived and then they are very well working with the system, but whereas, this FIA filter we would not be able to simulate using our analog filters.
9.srt	00:11:34.510 --> 00:11:42.850	So, for implementation complex computational we say is techniques are required.
9.srt	00:11:46.130 --> 00:11:53.850	And, then it is expensive to take a large order we have to pay in for the memory as well as the speed of it.
9.srt	00:11:54.640 --> 00:11:58.230	And then it is hard to implement than IR filter.
9.srt	00:11:58.890 --> 00:12:03.800	We will see how we will design it in the lab class.
9.srt	00:12:04.570 --> 00:12:09.900	And it is expensive as it is large order it is cost is going to be more.
9.srt	00:12:10.770 --> 00:12:16.430	Here more memory and time consuming process because we are talking about real time.
9.srt	00:12:16.770 --> 00:12:19.200	So, if the order of the filter is very high.
9.srt	00:12:19.780 --> 00:12:31.990	And, then we are unable to complete within the next sample comes if it is interrupt driven then we will be losing the sample that is why they are very time consuming in the case of FIR filters.
9.srt	00:12:32.230 --> 00:12:37.680	So, we will see there how they can be used they are represented in this figure.
9.srt	00:12:38.650 --> 00:12:42.990	So, we will consider FIR filter of length m order what we call it.
9.srt	00:12:42.990 --> 00:12:51.850	So, then what we say is order of n is equal to m minus 1.
9.srt	00:12:52.440 --> 00:13:03.200	So, you have to watch out it is that is order minus number of delays what will be considering as the length of the filter basically.
9.srt	00:13:03.540 --> 00:13:09.560	So, we are given the equation y of n is given by k is equal to 0 to m minus 1.
9.srt	00:13:10.060 --> 00:13:16.520	So, bk into x of n minus k, x is our input bk is our coefficients.
9.srt	00:13:16.940 --> 00:13:30.200	So, same thing we said that it is equivalent to convolution if it flashes to you h of k is the impulse response what we take it and x of n minus k is your.
9.srt	00:13:30.670 --> 00:13:43.820	So, we can represent it in this way, but since we use the filter coefficients usually we represent it as b k. And how in the flow diagram we are going to represent x of n is the input.
9.srt	00:13:44.240 --> 00:13:58.210	So, these are the square brackets are the unit delay basically and then x of n is multiplied by the b naught coefficient and this is the result what is available for our adder.
9.srt	00:13:58.820 --> 00:14:02.180	Same way here the after the delay which is going to come.
9.srt	00:14:02.180 --> 00:14:04.910	So, output is going to be x of n minus 1.
9.srt	00:14:05.450 --> 00:14:10.480	into if I am considered it as b1 then this is going to get added with the previous one.
9.srt	00:14:10.830 --> 00:14:15.210	So on because we are going to have m-1 delays basically.
9.srt	00:14:15.210 --> 00:14:33.660	So the last one is going to be bm into x of n-m will be the thing whatever the order of filter m which is going to be multiplied with your bm coefficients and added together you will be getting y of n as the output.
9.srt	00:14:36.640 --> 00:14:48.850	So, continuing with the thing so, if we represent our input as a impulse response if I want to take it then x of n is going to be delta n basically.
9.srt	00:14:49.180 --> 00:14:56.700	Then we will be getting the what will be the impulse response of the filter we will be getting it.
9.srt	00:14:57.010 --> 00:15:06.630	So, as h of n is equal to what we call it h of n is the impulse response which is equal to y of n which is given by k is equal to 0 to m minus 1.
9.srt	00:15:07.100 --> 00:15:20.980	So, you are replacing x of n minus k with the impulse response delta n minus k into b k. So, the output is going to be b n what you will be getting n will be varying to 0 to m minus 1.
9.srt	00:15:21.760 --> 00:15:38.160	So, the impulse response is a finite length m as required and then note that FIR filters have only 0s as you can see from the thing they do not have any poles that is the reason why we call this.
9.srt	00:15:38.370 --> 00:15:39.980	filter as a stable filter.
9.srt	00:15:40.800 --> 00:15:45.110	So, or this name is all zero filters also.
9.srt	00:15:46.200 --> 00:15:55.000	F air filters also known as feed forward or non recursive or traversal filters what we call it.
9.srt	00:15:55.000 --> 00:16:07.970	That is as you can see in the previous case the output will be only going in the forward direction that is why it is a feed forward filter also.
9.srt	00:16:10.140 --> 00:16:15.830	Coming with the design aspect of it, some of the parameters what we have to look in.
9.srt	00:16:16.430 --> 00:16:24.850	The characteristics as specified in the frequency domain in terms of desired magnitude and phase response of the filter.
9.srt	00:16:25.280 --> 00:16:30.010	We call it as H of omega in the frequency domain.
9.srt	00:16:40.450 --> 00:16:45.560	So, the filter design involves determining the coefficients of a or causal FIR or IR that closely approximate the desired frequency response specifications.
9.srt	00:16:46.090 --> 00:16:49.570	So, what are the design specification is given with this diagram.
9.srt	00:16:49.650 --> 00:17:10.330	So, what y axis represent is the magnitude of h of omega and then x axis will be represented with omega which varies between in this case 0 to pi what has been considered most of the time it will be minus pi to pi or 0 to pi.
9.srt	00:17:10.750 --> 00:17:22.210	2 pi, but we will be interested in only 0 to pi frequency components present in the thing as our sampling frequency is twice that of the highest frequency.
9.srt	00:17:22.460 --> 00:17:29.860	So, highest frequency is represented with 2 pi, hence we can consider the frequencies that are present only up to pi.
9.srt	00:17:30.580 --> 00:17:39.460	And then we say omega is the pass band frequency that is from 0 to if here it is the example taken as a low pass filter.
9.srt	00:17:39.830 --> 00:17:42.640	So, I want to allow all the frequencies which are.
9.srt	00:17:43.220 --> 00:17:51.289	in the pass band that is WP where I want to stop the collecting my frequency components.
9.srt	00:17:51.799 --> 00:18:01.640	Then what I have is I am going to say stop band, WS is going to say where I have to stop my collection of components.
9.srt	00:18:02.049 --> 00:18:09.779	So, that is WS between the difference between our WS and WP we call it as transition band.
9.srt	00:18:10.630 --> 00:18:12.940	For most of the cases we want.
9.srt	00:18:13.309 --> 00:18:16.960	direct dropping down which is not going to happen we will see in a while.
9.srt	00:18:17.630 --> 00:18:21.259	It is going to be a smooth transition what it should happen.
9.srt	00:18:21.720 --> 00:18:25.220	So, which will be constituting for our transition band.
9.srt	00:18:26.109 --> 00:18:33.349	And then we say that is W s is my pass band edge frequency and W s will be stop band edge frequency.
9.srt	00:18:33.789 --> 00:18:38.980	And what are this variation I am going to have it.
9.srt	00:18:39.440 --> 00:18:44.069	Most of the cases I want the magnitude to be 1 basically.
9.srt	00:18:44.529 --> 00:18:56.679	But, we know the constraints as and when more constraints are put our design is going to become very critical then we will be having order of the filter very high.
9.srt	00:18:56.679 --> 00:19:00.230	So, as we little bit relax on some of the components.
9.srt	00:19:00.230 --> 00:19:03.789	So, we can have the order low.
9.srt	00:19:04.369 --> 00:19:15.389	So, we say that delta r is the my ripple what I can allow actually in the pass band region between minus 1 minus delta r to 1 plus delta r.
9.srt	00:19:15.940 --> 00:19:25.730	So, then pass band will have little bit of ripples in the pass band and then I can little bit deviate from that.
9.srt	00:19:26.019 --> 00:19:28.230	And how I am going to represent the stop band?
9.srt	00:19:28.230 --> 00:19:33.909	Although most of the cases I want the flat response which may not be able to achieve it.
9.srt	00:19:34.139 --> 00:19:45.849	So, I have to specify what is the dB that is stop band attenuation what we call it as delta s how much I have to come down so that I will not have the frequencies beyond.
9.srt	00:19:46.389 --> 00:19:54.230	So, coming to comparison between FIR versus IAR.
9.srt	00:19:54.689 --> 00:19:58.519	So, we will take up IR filter more detailed one next few classes.
9.srt	00:19:58.519 --> 00:20:00.139	What is the comparison?
9.srt	00:20:00.969 --> 00:20:08.399	They we say that FIR filters are normally used when there is a requirement of a linear phase.
9.srt	00:20:08.399 --> 00:20:15.509	So, we will take it up little more in detail in a while and FIR filter with following symmetry what we call it as linear phase.
9.srt	00:20:15.539 --> 00:20:17.389	What is that symmetry?
9.srt	00:20:17.509 --> 00:20:21.480	My impulse response has to be.
9.srt	00:20:23.889 --> 00:20:33.789	H of n equal to plus or minus H of m minus 1 minus n for n is equal to 0 to m minus 1 order of the filter.
9.srt	00:20:34.419 --> 00:20:42.719	Whereas in IR filters they are normally used when linear phase is not required and cost effectiveness is going to be needed.
9.srt	00:20:44.079 --> 00:20:53.159	We say that they have compared to FIR filters they have lower side lobes and then stop band band than that of FIR filter.
9.srt	00:20:54.129 --> 00:21:07.000	And, for the same type of design we will see it later also how it is going to we will be meeting with IR filter with a less number of coefficients.
9.srt	00:21:07.079 --> 00:21:19.429	In some phase distortion is tolerable then better to use IR filter implementation with fewer parameters requiring less memory and then lower complexity.
9.srt	00:21:20.839 --> 00:21:23.969	Coming to how we are going to design FIR filters.
9.srt	00:21:24.559 --> 00:21:29.900	So, we say that we cannot derive it from analog filters.
9.srt	00:21:30.289 --> 00:21:34.259	So, we have to design in a different way.
9.srt	00:21:34.549 --> 00:21:35.940	So, why we have to bother?
9.srt	00:21:36.420 --> 00:21:54.000	Because we know the advantages of them which we have already discussed and then how they going to achieve linear phase stability and then how they will have the magnitude response which is what we can accommodate.
9.srt	00:21:54.450 --> 00:21:57.920	and then it is easy and then convenient to implement.
9.srt	00:21:58.420 --> 00:22:00.299	So, coming to the linear phase.
9.srt	00:22:00.710 --> 00:22:01.680	So, what is that?
9.srt	00:22:01.880 --> 00:22:08.700	The ability to have an exactly linear phase response is the one of the most important of FAR filters.
9.srt	00:22:08.759 --> 00:22:10.210	What is that?
9.srt	00:22:10.549 --> 00:22:21.850	h of omega it should be equal to magnitude of h of omega into e power j phi omega where phi of omega is nothing, but minus omega n naught.
9.srt	00:22:22.720 --> 00:22:30.180	So, when general FAR filter does not have a linear phase response, but this property is satisfied.
9.srt	00:22:30.780 --> 00:22:43.650	When your h of n is equal to plus or minus if I have taken h of m minus 1 minus n, n is varying between 0 to m minus 1 definitely we will have a linear phase filter.
9.srt	00:22:44.030 --> 00:22:56.450	So, different types of impulse response whether it is odd or even and then as you are seeing it there are 4 types how it can be designed.
9.srt	00:22:56.990 --> 00:23:05.150	So, you can go through them and then whichever is convenient you can select one of them to design your linear phase.
9.srt	00:23:05.490 --> 00:23:08.250	So, why do we say it is linear phase?
9.srt	00:23:08.250 --> 00:23:26.539	The phase is straight line in the pass band of the system as you are seeing it this minus pi to pi I say that that is my pass band it should be linear or we call it as all pass system basically.
9.srt	00:23:26.910 --> 00:23:33.289	In this case group delay is given by the negative of the slope of the line.
9.srt	00:23:33.720 --> 00:23:35.140	So, we will see it in a while.
9.srt	00:23:35.629 --> 00:23:37.740	hold on for little while.
9.srt	00:23:38.889 --> 00:23:52.399	So, coming to the other thing we said all pass system because we may have discontinuity in the filters or band pass filter at different frequencies what I want to design it.
9.srt	00:23:52.559 --> 00:23:55.970	Then what is the thing is going to happen?
9.srt	00:23:56.289 --> 00:24:00.470	We say phase wrapping may occur that is what you are seeing it.
9.srt	00:24:01.039 --> 00:24:04.299	So, but the phase is still considered to be linear.
9.srt	00:24:04.500 --> 00:24:04.839	Why?
9.srt	00:24:05.210 --> 00:24:07.950	This is the pass band region of one this thing.
9.srt	00:24:08.480 --> 00:24:24.189	the other region of the thing is from here to here still we have a what we call it as a line is linear in this case and then here this side also.
9.srt	00:24:25.969 --> 00:24:40.609	Coming to the other part of it that is if we are considering the high pass system we call it as high pass filter that is the low frequencies are going to be eliminated only the higher frequencies are going to be considered in that case.
9.srt	00:24:40.869 --> 00:25:05.909	the phase response looks like which is having a discontinuity that is from here to here I will be having that is my pi to magnitude 1 in this case to pi and then from here it is minus 1 to minus pi magnitude if I am considering the magnitude as minus 1 to 1.
9.srt	00:25:06.549 --> 00:25:14.859	So, then here it is going to be linear and then this side also it is going to be linear both on the negative side as well as the positive side of it.
9.srt	00:25:15.319 --> 00:25:20.709	So, the other one as you can see the thing when we say it is going to be linear phase.
9.srt	00:25:20.959 --> 00:25:36.039	So, this is my pass band region if it is going to be linear I say it is linear phase and I am not bothered about beyond my interest of region they are not linear they become non-linear in phase.
9.srt	00:25:36.039 --> 00:25:43.409	So, some of the terms we will see it which is going to help us for our linear derivation.
9.srt	00:25:46.779 --> 00:25:56.649	So, discrete time Fourier transform some of the theorems and properties which more we will be taking it up when I consider DFT and then FFT.
9.srt	00:25:57.149 --> 00:26:01.309	So, the property we consider is the notation what we are going to have it.
9.srt	00:26:01.309 --> 00:26:12.699	In time domain we say x of n, x1 and x2 and frequency domain all of us know it is capital x of omega, x1 of omega and x2 of omega.
9.srt	00:26:13.209 --> 00:26:16.739	So, when we say it is linearity.
9.srt	00:26:17.129 --> 00:26:20.919	when it meets the superposition theorem.
9.srt	00:26:21.269 --> 00:26:28.539	So, which is both commutative as well as can you guess the other one.
9.srt	00:26:28.969 --> 00:26:35.229	So, a 1 into x of x 1 of n plus a 2 into x 2 of n when I do the thing.
9.srt	00:26:35.649 --> 00:26:43.789	So, I should be able to get even in the frequency domain a 1 into x 1 of omega plus a 2 into x 2 of omega.
9.srt	00:26:44.449 --> 00:26:51.569	So, when we do the time shifting that is if I provide a shift of k n minus k then.
9.srt	00:26:51.759 --> 00:26:57.779	here the resultant is going to be e power minus j omega k into x of omega.
9.srt	00:26:58.659 --> 00:27:07.639	In the case of time reversal x of minus n will be giving me in the frequency domain is capital X of minus omega.
9.srt	00:27:08.399 --> 00:27:19.859	So, when we do the convolution of 2 signals x 1 and then x 2 I know it is convolution in the time domain whereas, in the frequency domain it is multiplication.
9.srt	00:27:22.389 --> 00:27:29.049	So, when we want to do the basically it can be autocorrelation as we will be seeing it later or x1 to x2.
9.srt	00:27:29.469 --> 00:27:47.259	So, if we consider the thing this is in the time domain it is convolution whereas, in the frequency domain it becomes a multiplication with respect to complex conjugate of the other sequence.
9.srt	00:27:47.639 --> 00:27:54.619	So, if we consider x2 of n as real it becomes a multiplication of x1 of omega into.
9.srt	00:27:55.419 --> 00:27:57.319	conjugate of x 2 of omega.
9.srt	00:27:57.879 --> 00:28:10.219	So, whereas, in the some of the Wiener filter we will be considering in the adaptive filter LMS algorithm.
9.srt	00:28:25.139 --> 00:28:29.039	So, that time you are autocorrelation with respect to the same signal what you are seeing it that convolution of this that is the time reverse signal what you are having it which becomes the square of the X of omega magnitude of it what you are seeing in the filter domain.
9.srt	00:28:29.409 --> 00:28:34.739	So, there are other more properties and then both in time domain and frequency domain.
9.srt	00:28:35.069 --> 00:28:41.889	So, you would have studied in your signal processing or signals and system classes you can look into them.
9.srt	00:28:42.709 --> 00:28:45.879	So, now we are telling that linear phase.
9.srt	00:28:46.319 --> 00:28:53.579	So, what we have said is something group delay which we have to consider.
9.srt	00:28:54.209 --> 00:28:56.339	So, Y of n is my.
9.srt	00:28:56.809 --> 00:29:02.059	output and then x of n is going to be delayed by n naught.
9.srt	00:29:02.309 --> 00:29:17.159	So, we call that as group delay then what happens to the frequency domain signal which is y of omega is the output which is going to be x of omega you are seeing e power minus j omega n naught it is going to be.
9.srt	00:29:17.609 --> 00:29:26.279	So, then what happens to the our magnitude and then phase responses basically.
9.srt	00:29:26.769 --> 00:29:47.269	So, h of omega will be y of omega by x of omega which is going to be given as e power minus j omega n naught and the phase of it we call it as phi of omega which is going to be minus omega n naught and because we know that n naught is the group delay which is minus omega into group delay.
9.srt	00:29:57.279 --> 00:29:59.829	So, in general even for non-linear phase systems we consider group delay as the differentiation with respect to our phase.
9.srt	00:29:59.989 --> 00:30:09.589	So, that is minus d by d omega of phi of omega negative part of it what will be taking up.
9.srt	00:30:10.349 --> 00:30:12.669	So, continuing with the group delay.
9.srt	00:30:12.979 --> 00:30:26.729	So, we know that linear phase filters maintain the relative positioning of the sinusoid in the filter pass band as you will be seeing it that is structure of the signal while removing unwanted frequency components.
9.srt	00:30:27.109 --> 00:30:28.439	So, if we see that.
9.srt	00:30:28.709 --> 00:30:39.869	So, some of the this is an input and as you can see this is a low pass filter which is represented both in the negative domain as well as in the positive domain.
9.srt	00:30:40.309 --> 00:30:44.099	So, the phase is going to be linear in this.
9.srt	00:30:44.439 --> 00:30:58.389	So, output after passing it through also you will be having little bit delay at the output, but they will maintain the same phase of the thing.
9.srt	00:31:00.399 --> 00:31:02.919	So, why do we need a linear phase?
9.srt	00:31:03.389 --> 00:31:19.829	So, as you know that in what happens to loss of phase information that is one of the thing whatever literature gives it most of us how do we identify the phases of people basically.
9.srt	00:31:20.319 --> 00:31:25.189	So, we say that the phase for one person to the other person is different.
9.srt	00:31:34.309 --> 00:31:59.639	So, if their linear that is a pass band frequency arranged linear phase or close to linear phase is required otherwise I may be reconstructing a different one as you will be seeing it some of the frequency domain component how it looks like and then what is the phase of it what you are looking at it and if they are distorted then you may not see the same phase you may be looking at different phase ok.
9.srt	00:32:06.779 --> 00:32:11.750	So, lean FIF filters as we said how we can the develop them that is we follow the symmetry property.
9.srt	00:32:12.019 --> 00:32:25.109	So, in this case we will be following only the simple one we will assume that h of n is equal to plus r minus h of m minus 1 minus n for n varying between 0 to m minus 1 what we will consider.
9.srt	00:32:25.569 --> 00:32:27.509	That means, what is the thing?
9.srt	00:32:27.539 --> 00:32:34.879	So, I am considering the positive side of this for these values as well as h of n for the negative of it what I am considering it.
9.srt	00:32:37.189 --> 00:32:49.429	So, we will see that what happens if I give delta n minus delta of n minus 1 as my impulse response to my system.
9.srt	00:32:50.019 --> 00:32:54.929	So, whether it is going to represent a linear phase or not we will see the thing.
9.srt	00:32:55.309 --> 00:32:59.319	So, for that we have to see the phase response as well as the group delay.
9.srt	00:32:59.889 --> 00:33:04.759	So, note in this case because m is equal to second order we have chosen the thing.
9.srt	00:33:05.219 --> 00:33:06.719	So, it will be going h of 1.
9.srt	00:33:07.190 --> 00:33:23.779	n will be equal to minus h of 1 minus n which is equal to h of minus h of m minus 1 minus n. So, these are the 2 things what will be substituting first n is equal to 0 comma 1 because m is equal to 2.
9.srt	00:33:24.089 --> 00:33:38.409	When n is equal to 0 h of 0 will be minus h of 1 minus 0 which is nothing but h of 1 and when n is equal to 1 h of 1 will be is equal to minus of h of 1 minus 1 which becomes minus.
9.srt	00:33:38.690 --> 00:33:45.470	1 basically which is h of 0, h of 0 is 1 so it becomes minus 1.
9.srt	00:33:45.549 --> 00:34:01.650	So, this is how you will be representing with respect to n is equal to 0 it is impulse response is 1 and then when is equal to 1 its impulse response is minus 1.
9.srt	00:34:02.900 --> 00:34:09.090	So, we will see an example how we are going to show that this has a linear phase.
9.srt	00:34:09.849 --> 00:34:23.829	So, what is that equivalent to convolution of your x of n into h of n by expanding the our function which is nothing but x of n into delta n plus delta of n minus 1.
9.srt	00:34:24.269 --> 00:34:27.769	In this case we have assumed minus delta of n minus 1.
9.srt	00:34:27.769 --> 00:34:33.869	So, this will be negative x of n into delta of n minus x of n into delta of n minus 1.
9.srt	00:34:34.259 --> 00:34:41.049	So, which is nothing but x of n minus x of n minus 1 this we call it as first difference system.
9.srt	00:34:41.650 --> 00:34:47.989	So, first difference system what we can go into the discrete sign time derivative.
9.srt	00:34:48.889 --> 00:34:56.920	So, we define this is a high pass filter we will seen it in a while how it can be a high pass filter.
9.srt	00:34:57.779 --> 00:35:14.500	So, we will be expanding this we have h of omega is nothing, but n is equal to minus infinity to infinity this is our DTFT equation h of n into e power minus j omega n. So, I am substituting h of 0 as 1.
9.srt	00:35:14.849 --> 00:35:25.119	And, we have e power minus j omega naught plus minus 1 into e power minus j omega 1 which is nothing but 1 minus e power minus j omega.
9.srt	00:35:25.549 --> 00:35:30.019	So, when I expand in terms of my exponential.
9.srt	00:35:30.349 --> 00:35:38.179	So, you will be seeing that simplifying it becomes e power minus j omega by 2 into 2 j into sin omega by 2.
9.srt	00:35:45.919 --> 00:35:46.979	So, this is what if I move 2 j into the first place and then put e power minus j omega by sin omega by 2.
9.srt	00:35:47.269 --> 00:35:52.159	So, for various value of omega between minus and pi if you plot the thing.
9.srt	00:35:52.469 --> 00:35:54.889	So, you will be seeing the curve like this.
9.srt	00:35:55.159 --> 00:36:09.639	So, that means, to say low frequencies whatever they are there that has going to be avoid going to be eliminated only higher frequencies almost when it becomes 1 you will be allowing those frequencies to be present in the system.
9.srt	00:36:10.309 --> 00:36:18.069	So, how we are going to consider the group delay we have to see phi of omega what we have got it as.
9.srt	00:36:18.479 --> 00:36:25.769	angle of 2, 2 j into e power minus j omega by 2 into sin omega by 2.
9.srt	00:36:26.029 --> 00:36:41.219	So, by putting them that is angle of 2 we know that it is 0, angle of j is equal to pi by 2 and angle of e power minus j omega by 2 will be minus omega by 2 and for sin omega by 2 it will be in this range.
9.srt	00:36:41.549 --> 00:36:48.789	It is going to be 0, 0 less than omega less than pi and it will be pi for minus pi to 0.
9.srt	00:36:49.299 --> 00:37:01.629	So, when we put it in terms of omega which will be pi by 2 minus omega by 2 and 3 pi by 2 minus omega by 2 minus 2 pi in this range.
9.srt	00:37:02.099 --> 00:37:16.599	So, when you put this simplified one you will be getting it as minus omega by 2 into the other one it is in the range 0 to pi minus pi to 0 will be minus pi minus omega by 2.
9.srt	00:37:17.039 --> 00:37:19.499	So, now, we will see that.
9.srt	00:37:19.939 --> 00:37:21.819	How is it going to be represented?
9.srt	00:37:21.819 --> 00:37:23.309	So, we have phi of omega.
9.srt	00:37:23.619 --> 00:37:27.869	So, we will be put omega 0 to pi.
9.srt	00:37:28.429 --> 00:37:40.629	Then you will be seeing this is shown as pi by 2 to pi here the magnitude is going to be half here which is going to go between that 2 that is pi here.
9.srt	00:37:41.119 --> 00:37:43.839	So, whereas, in the case of negative region.
9.srt	00:37:50.439 --> 00:37:56.199	So, you will be seeing that minus pi to minus pi by 2 because we are representing even my y axis is and phase of the thing.
9.srt	00:37:56.199 --> 00:38:02.249	So, which is going to be minus pi by 2 to pi by 2 fine.
9.srt	00:38:02.709 --> 00:38:08.209	So, how we are going to say that group delay is going to be constant in this case.
9.srt	00:38:08.559 --> 00:38:13.549	So, I am going to take the derivative negative derivative of my phase.
9.srt	00:38:13.589 --> 00:38:18.569	So, which is nothing, but half minus pi into delta omega.
9.srt	00:38:18.609 --> 00:38:21.349	So, which is going to give me.
9.srt	00:38:21.579 --> 00:38:29.219	half and then minus pi into delta omega which omega equal to 0 and wherever omega is not equal to 0 it is going to be half.
9.srt	00:38:29.539 --> 00:38:36.569	So, we consider in the pass band region because I am not bothered about when omega equal to 0.
9.srt	00:38:36.909 --> 00:38:41.319	So, we know that in the pass band region it is becoming constant.
9.srt	00:38:41.619 --> 00:38:54.989	So, we say that that delay is constant or we call it as a linear phase basically that is the reason why you will be seeing that it is pi by 2 to minus pi by 2 what you will be seeing a.
9.srt	00:38:55.579 --> 00:38:59.019	linear slope of the line here.
9.srt	00:39:00.339 --> 00:39:03.729	So, coming further with the example.
9.srt	00:39:04.079 --> 00:39:09.359	So, what we have is this is an assignment for you to work it out.
9.srt	00:39:09.359 --> 00:39:14.139	We showed that the FIR filter for a high pass filter is linear phase.
9.srt	00:39:14.179 --> 00:39:29.799	Now, it is your time to show that the low pass filter that is you have been given delta n plus delta of n minus 1 is my impulse response that this also is a linear phase.
9.srt	00:39:30.239 --> 00:39:46.079	So, you can consider here also you have m is equal to 2 and these are the values what you have it when n is equal to 0 it is going to be 1 and then when n is equal to 1 it is a plus h of 0 which is also 1.
9.srt	00:39:46.119 --> 00:39:51.799	So, you will be seeing that both of them are 1 you are supposed to show whether it is linear phase filter.
9.srt	00:39:52.379 --> 00:40:00.829	So, as you can see that when you are giving your delta n representation input.
9.srt	00:40:01.579 --> 00:40:08.049	Y of n is nothing, but because we have a impulse response delta n and delta n minus 1 equal to 1.
9.srt	00:40:08.429 --> 00:40:17.599	So, the output Y of n will be equal to x of n plus x of n minus 1, it is the scaled averaging system what we call it.
9.srt	00:40:17.919 --> 00:40:25.289	So, the averager is also represented as discrete time smoother and we call it as low pass filter.
9.srt	00:40:25.719 --> 00:40:32.069	So, some of the techniques to design our FIR filter which we will be taking it up more in our lab.
9.srt	00:40:32.529 --> 00:40:34.839	class just to give a flavor of it.
9.srt	00:40:35.129 --> 00:40:38.769	So, I can design a hamming using the window technique.
9.srt	00:40:39.099 --> 00:40:40.909	There are different ways of doing it.
9.srt	00:40:40.909 --> 00:40:50.859	So, most of the time we will be using MATLAB FDA toolbox with the older versions and latest version use the filter design toolbox.
9.srt	00:40:51.439 --> 00:40:59.989	So, here it is the hamming window what you are seeing m is equal to 16 what we have considered in this case plotting this figures from the MATLAB.
9.srt	00:41:00.489 --> 00:41:02.609	So, you will be seeing that this is a smooth.
9.srt	00:41:03.239 --> 00:41:05.589	as you will be seeing between 0 and the other thing.
9.srt	00:41:05.949 --> 00:41:13.539	So, whereas, the hamming window so, you will be seeing there is a little drift in the thing and then that is how what it will be represented.
9.srt	00:41:13.969 --> 00:41:33.959	Use a Blackman window as you will be seeing that it will be having the pass band is an arrow band whereas, it is going to drop down the number the dB whatever a frequency response what you can see that is if we have put this as a reference line.
9.srt	00:41:34.259 --> 00:41:35.479	So, which will be.
9.srt	00:41:35.919 --> 00:41:39.799	below this line that is minus 20 dB point.
9.srt	00:41:40.179 --> 00:41:54.239	Whereas, in the case of these are the side lobes what we call it whether I want a narrow this thing pass band lobe or more ripples in the side lobe what we have to take it into considerations.
9.srt	00:41:54.389 --> 00:42:09.309	So, for the hamming window you will be seeing that it goes little more than minus 20 dB whereas, in the hamming window also, but it is going to come down as you will be seeing when you are using the hamming window.
9.srt	00:42:09.629 --> 00:42:15.719	Most of the filter equations will be using the hamming window to design FIR filters.
9.srt	00:42:16.089 --> 00:42:19.969	So, that is it should this table shows that.
9.srt	00:42:20.279 --> 00:42:21.679	how they are represented?
9.srt	00:42:22.099 --> 00:42:35.349	The main lobe is going to be 4 pi by m which is equivalent to minus 13 dB what they will have it and if I consider the peak 20 log 10 delta side lobe.
9.srt	00:42:35.649 --> 00:42:43.929	So, it will be coming down to you will be seeing that minus 21 dB whereas, in the Hanning window it comes to minus 44 dB.
9.srt	00:42:43.929 --> 00:42:51.399	When I want to go with the increasing the order of the filter basically if I want to achieve it m has to be increased.
9.srt	00:42:51.839 --> 00:43:05.189	and then I can go up to minus 53 dB maximum in the hamming window and if you consider the Blackman window I can go up to 74 dB from 58 dB.
9.srt	00:43:05.819 --> 00:43:22.899	So, some of the design if you want to have a peak side lobe as that minus 13 and other things you can select any one of these windows and if you want a variable you would have heard of KSZ window which you can select it which one of the.
9.srt	00:43:23.329 --> 00:43:29.129	parameter what beta parameter what you can vary alpha and beta parameter there and select your own window.
9.srt	00:43:29.599 --> 00:43:32.269	So, this gives you a flavor of FIR filter.
9.srt	00:43:32.929 --> 00:43:42.069	So, in the next class we will be taking up pipelining and parallelism for low power how we can design this FIR filters.
9.srt	00:43:42.539 --> 00:43:46.889	Thank you for your listening and then happy learning in this course.
9.srt	00:43:47.689 --> 00:43:48.089	Thank you.
17.srt	00:00:01.219 --> 00:00:25.620	Welcome back to real time digital signal processing lab today.
17.srt	00:00:30.420 --> 00:00:36.759	So, we will be seeing some of the implementations whatever we have done using the MATLAB in the last class.
17.srt	00:00:37.100 --> 00:00:44.429	So, we saw some sign generation using the DDS in code composer studio.
17.srt	00:00:44.960 --> 00:00:57.179	Today we will see how we can use resonator for generating the sine wave and then we will see from lookup table how the real time signal is going to come out today.
17.srt	00:00:57.789 --> 00:01:00.310	So, you can see that.
17.srt	00:01:00.699 --> 00:01:15.179	Now, some of the things one has to remember is you can open the project and then some of the files has to be connected for this code basically.
17.srt	00:01:15.179 --> 00:01:24.250	In this case you will be seeing the CMD file which is going to define what are the memory which are going to be used in this.
17.srt	00:01:24.729 --> 00:01:32.049	So, the default what it takes and then you will be seeing.
17.srt	00:01:32.619 --> 00:01:41.519	that the what is the buffer length and then what is the audio which is going to be used.
17.srt	00:01:41.870 --> 00:01:50.689	So, in this case I am using LCDK 6748 board today for real time demo.
17.srt	00:01:50.789 --> 00:01:59.390	So, we have a sine waves that is it which is going to have 48 kilohertz what it is going to run.
17.srt	00:02:03.619 --> 00:02:06.480	So, we will be using the interrupt driven.
17.srt	00:02:06.859 --> 00:02:22.019	So, you will be knowing different methods of accessing the CPU, one is using the polling, the other one can be interrupt driven which we discussed in our theory class also, the other one is DMA based.
17.srt	00:02:22.379 --> 00:02:30.800	So, their CPU intervention is not going to be there directly from the memory you will be reading into your memory to work on it.
17.srt	00:02:30.870 --> 00:02:37.490	So, some of the cases you may have to have a frame length of whatever the length if you have given.
17.srt	00:02:37.829 --> 00:02:42.050	So, you can directly read from the memory and then put it into the local memory.
17.srt	00:02:42.439 --> 00:02:45.379	So, in this case what we have is.
17.srt	00:02:46.899 --> 00:03:02.060	So, the buffer length in this case is taken it as 128 samples and then the loop length is 48.
17.srt	00:03:02.620 --> 00:03:06.159	So, how we are going to generate the sine wave?
17.srt	00:03:06.560 --> 00:03:15.739	Basically we use MATLAB to generate the sine wave and then take this 48 samples here.
17.srt	00:03:16.199 --> 00:03:25.389	And, then use them as you can see it is in the fixed point that is signed Q15 format what we are using it here.
17.srt	00:03:25.449 --> 00:03:33.549	So, use this in your code, then all of it as you are seeing that it is in 16 length of the buffer as well as the computation.
17.srt	00:03:33.549 --> 00:03:38.219	So, here we are going to do interrupt driven.
17.srt	00:03:38.479 --> 00:03:40.559	In this case.
17.srt	00:03:46.649 --> 00:03:54.829	Interrupt 4 is going to be used and then you will be getting it is the stereo data what we are going to get it.
17.srt	00:03:54.869 --> 00:03:59.419	So, we will be as I have mentioned in the first lab session.
17.srt	00:03:59.469 --> 00:04:02.699	So, we can have mono input or stereo.
17.srt	00:04:02.879 --> 00:04:17.730	So, whenever speech is there either we can take it from the mono that is mic we can connect it or we can connect the audio input from our laptop.
17.srt	00:04:17.779 --> 00:04:20.810	Today we are connecting the audio input to the board.
17.srt	00:04:21.289 --> 00:04:28.819	So, we will be taking first left sample and then you will be doing the processing here.
17.srt	00:04:29.359 --> 00:04:51.549	So, what you have is take from the input buffer left sample pointer and then you are putting into the buffer length basically what you are comparing that is you are incrementing it and then you will be putting back left sample the value from the sign table whatever the pointer is pointing to.
17.srt	00:04:52.219 --> 00:05:04.839	And, then sine pointer is also going to be incremented here, then we will be seeing that both for the left and right channel the same left sample is going to be output.
17.srt	00:05:05.370 --> 00:05:09.949	So, then we are going to out the sample codec data out.
17.srt	00:05:10.539 --> 00:05:15.709	So, in this case as I have already mentioned we will be using AAC 3106.
17.srt	00:05:16.089 --> 00:05:23.379	So, now, what is the frequency at which it is going to operate that is what it shown it is L138.
17.srt	00:05:23.999 --> 00:05:26.379	initialize interrupt driven basically.
17.srt	00:05:26.819 --> 00:05:43.689	It has the sampling frequency of 48 kilohertz and then ADC gain what you have given is 0 dB and then DAC attenuation is also 0 dB what you have taken the thing and then you will be putting LCDK line input.
17.srt	00:05:44.029 --> 00:05:53.799	From here input what you are going to take it and then you will be outputting on the outside of your this thing.
17.srt	00:05:55.949 --> 00:06:14.669	processor basically both the codec input has in and then out one of the input is from the I will put it as our computer to input of the board and then output of the board is connected to the speaker here.
17.srt	00:06:15.109 --> 00:06:19.579	I think next time we will show the scenario where the board and other things are there.
17.srt	00:06:19.959 --> 00:06:22.569	So, we will see that how to run this code.
17.srt	00:06:26.749 --> 00:06:49.439	Some of the important thing what we have to do is when I am So, experimenting with this or generating the file one has to keep that in this case my as you are can see that it is LCDKC6748 what I am using it and then here using debug connector.
17.srt	00:06:49.949 --> 00:06:59.499	So, XDC110 USB debug connector what we are connecting it to the board and then the compiler version what it is being used is the 7.4.4 version.
17.srt	00:07:01.669 --> 00:07:09.009	And, we are generating the executable and then here output format has to be legacy cough file what will be generating.
17.srt	00:07:09.319 --> 00:07:11.429	It has a two options.
17.srt	00:07:11.779 --> 00:07:23.109	So, that is ELF format, but in our case it is legacy cough file what it we need it and device endian is little endian.
17.srt	00:07:23.609 --> 00:07:32.259	So, when I talk about little endian and big endian, in the little endian lower memory is going to be store first and then later on the higher part.
17.srt	00:07:32.899 --> 00:07:38.229	of your 32 bit data which is going to be stored later higher part later.
17.srt	00:07:38.379 --> 00:07:48.049	Whereas, in the big endian some applications need that higher memory has to be first and then lower memory bytes have to be later.
17.srt	00:07:48.429 --> 00:07:55.339	So, in that case we will be using the big endian for our cases all these TI board support little endian.
17.srt	00:07:56.139 --> 00:08:04.169	And then we will be command file what we needed is linkerdsp.cmd these can be downloaded from the TI.
17.srt	00:08:05.209 --> 00:08:27.229	site or we will be providing you whatever necessity to run your codes in the web page basically and we need is RTS 6740 dot library this is the common here 674 series any one of them can be using the library part of it.
17.srt	00:08:27.609 --> 00:08:31.179	The next one is what we see here is the compiler.
17.srt	00:08:31.679 --> 00:08:35.209	So, in this case we have to include certain files.
17.srt	00:08:35.539 --> 00:08:47.490	So, these are the support files one has to include where you have downloaded in my case it is in D colon DSP lab 6748 what I have taken where the support file is located.
17.srt	00:08:47.879 --> 00:08:56.899	And next one is we have to have the board support library under that there are some include files which are required for real time running.
17.srt	00:08:56.989 --> 00:09:03.759	So, then coming to the linker options we have to provide the search path.
17.srt	00:09:04.009 --> 00:09:17.829	So, one of the thing is as you have already taken RTS6740.library which reflects here and then the other one is what we have.
17.srt	00:09:18.289 --> 00:09:27.929	call this one although it is LCDKC6748, we can select EVM OMAP L138, BSL is for board support logic.
17.srt	00:09:27.929 --> 00:09:32.729	So, we need what is the board it is going to separate library what we have to provide.
17.srt	00:09:32.729 --> 00:09:43.639	And this is has been stored in this location that is how it is coming location of from where I am been including which has to be provided.
17.srt	00:09:43.639 --> 00:09:48.519	Then next again we have some libraries.
17.srt	00:09:48.859 --> 00:09:51.149	So, which are put in the board support library.
17.srt	00:09:51.189 --> 00:09:52.139	So, you can link.
17.srt	00:09:52.759 --> 00:09:53.009	them.
17.srt	00:09:53.359 --> 00:09:56.179	Once you have done the thing you can apply and then close.
17.srt	00:09:56.519 --> 00:09:59.319	So, these are the necessary things for running it.
17.srt	00:09:59.639 --> 00:10:11.779	The other files which we need it for running in real time is that is one is L138LCDK, AIC3106.init.c.h and then linkerdsp.cmd and then vectors interrupt.asm.
17.srt	00:10:12.319 --> 00:10:22.139	These four files have to be taken from the support files what we have it and then we have to include.
17.srt	00:10:22.139 --> 00:10:23.069	Once everything is done.
17.srt	00:10:27.679 --> 00:10:31.329	So, what you can do is whether your code is running correctly or not.
17.srt	00:10:31.709 --> 00:10:33.579	So, I can do a compilation.
17.srt	00:10:34.149 --> 00:10:41.959	So, if there is any error which it will be listed out here your syntax error then you have to go and then attend to that.
17.srt	00:10:41.959 --> 00:10:48.819	If nothing is there then what I can do is I can go and then build my system.
17.srt	00:10:49.509 --> 00:10:58.959	So, once I build this system you will be seeing that you will be seeing some green light it is coming here.
17.srt	00:10:59.329 --> 00:11:03.269	which is telling that it is going and then loading on to the board.
17.srt	00:11:03.819 --> 00:11:14.729	So, here you have seen that the complete code has been loaded on to the board, you will be seeing that C674X underscore 0 what it has taken the thing.
17.srt	00:11:15.279 --> 00:11:23.339	So, and then where it has started your entry point what it is showing that it has entered where the main is there.
17.srt	00:11:23.829 --> 00:11:29.519	So, what we will do is we will run this code and then you will be hearing a.
17.srt	00:11:30.959 --> 00:11:35.129	wave which is generated at 48 kilohertz.
17.srt	00:11:35.559 --> 00:11:42.019	So, I will run it and then you will be hearing the output from the speaker.
17.srt	00:11:42.789 --> 00:11:47.349	Hope you are hearing it.
17.srt	00:11:52.239 --> 00:11:59.349	So, this is how real time sine wave generation using lookup table has happened.
17.srt	00:11:59.999 --> 00:12:05.289	So, once I stop also you will be seeing that code has gone and then loaded onto the board.
17.srt	00:12:06.269 --> 00:12:11.679	And, then what is the thing the code is going to lie in the board.
17.srt	00:12:12.139 --> 00:12:17.429	So, unless I reset the board it will be running continuously this is what we call it real time.
17.srt	00:12:17.849 --> 00:12:29.179	Once I have taken the debugger I have downloaded all my code into the dumped into the board, then it will be continuously running for whatever input you are going to give it.
17.srt	00:12:29.499 --> 00:12:31.889	So, this is what we call it as real time.
17.srt	00:12:32.199 --> 00:12:35.399	So, here what is the thing happening is.
17.srt	00:12:35.859 --> 00:12:46.759	We are going to interrupt for every sample my CPU and collect the data into my buffer here and then I am taking it out and then playing it.
17.srt	00:12:46.759 --> 00:13:06.699	Here it is only in this case what we have done the thing is because we have generated the sign table, the samples are taken from the table and it is sent it out to the codec channel that is DAC output.
17.srt	00:13:06.939 --> 00:13:09.029	So, that is what you heard the thing.
17.srt	00:13:09.399 --> 00:13:13.269	So, the next one what we will take the example is.
17.srt	00:13:13.699 --> 00:13:24.089	So, this is the second sine generation, next one we will take it resonation using resonator how we can generate our sine wave.
17.srt	00:13:24.139 --> 00:13:32.949	So, we said that in IR filter we can push it to the resonator thing and then generate our sine wave.
17.srt	00:13:32.999 --> 00:13:35.089	So, here what is the thing here.
17.srt	00:13:39.809 --> 00:13:51.219	So, you will be seeing that we are calling it as a sign generator and then we will be redefining my y1 sample that is value is given here.
17.srt	00:13:51.649 --> 00:14:02.479	So, what is the value how we have calculated that we said that 3 samples what we have to give it after that the IR filter is going to resonate in on its own.
17.srt	00:14:03.029 --> 00:14:09.509	So, here it is sign f tone what you have taken the thing divided by f sample.
17.srt	00:14:10.019 --> 00:14:16.499	So, into 360 degrees what you are converting into.
17.srt	00:14:16.949 --> 00:14:25.359	So, in this case sine you want to generate 500 hertz divided by 48 kilohertz into 360.
17.srt	00:14:25.789 --> 00:14:27.149	So, what is it?
17.srt	00:14:27.389 --> 00:14:36.039	My f tone whatever the frequency I want to generate 500 hertz and sampling frequency I was have chosen as 48 kilohertz.
17.srt	00:14:36.409 --> 00:14:41.139	So, which will be equivalent to sine of 3.75 which is my.
17.srt	00:14:41.649 --> 00:14:43.799	y 1 value what it has been taken.
17.srt	00:14:44.249 --> 00:14:49.609	Then we define our equation A a as 1.9957178.
17.srt	00:14:49.749 --> 00:14:54.669	So, this we call it as 2 star cos 3.75.
17.srt	00:14:54.669 --> 00:15:04.789	You can go back in the literature where we have discussed about the IR filter application as a resonator.
17.srt	00:15:04.789 --> 00:15:11.799	So, you will get the filter structure and from there you will see that these are the coefficients what it has to be provided initially.
17.srt	00:15:13.919 --> 00:15:18.609	Then, this is the value what it has been taken for this.
17.srt	00:15:18.989 --> 00:15:35.549	Then you are calling y3 as you will be providing 0 first sample, then y1 is the other sample what you are providing it and then 0 and then our amplitude basically a is given as a a value.
17.srt	00:15:36.609 --> 00:15:43.739	Then you are going to run the code that is you will be making your.
17.srt	00:15:46.059 --> 00:15:56.059	Later on computation y 0 is my output, what is y 0 is equal to y 1 star a minus y 2.
17.srt	00:15:56.669 --> 00:16:04.199	This is our higher filter equation and then y 2 will be y 1 and y 1 becomes y 0.
17.srt	00:16:14.899 --> 00:16:16.299	And then y 0 what you will be continuously multiplying is you have given a scale of full 16 bit range what we are giving it.
17.srt	00:16:16.579 --> 00:16:20.009	So, multiplied with 32000 what we have taken.
17.srt	00:16:20.399 --> 00:16:33.769	So, that is what it says using a number slightly less than this such as 32000 maximum if y 0 becomes 1 I can go up to 32767.
17.srt	00:16:34.189 --> 00:16:37.639	So, if there is any overflow or underflow.
17.srt	00:16:37.639 --> 00:16:44.250	So, you are multiplying it by 3200 that is what it says prevent overflow.
17.srt	00:16:44.669 --> 00:16:46.429	Then you will be returning shard.
17.srt	00:16:46.779 --> 00:17:00.649	So, we recast the result to a short and then value upon returning it since your DTA converter is programmed basically to accept 16 bit signed values in this case.
17.srt	00:17:01.009 --> 00:17:11.279	But here you will be generating it in the on the board, but real time we will not be running it today in this class.
17.srt	00:17:11.509 --> 00:17:16.889	So, you will be what is it then signed data using sign generation.
17.srt	00:17:20.709 --> 00:17:24.490	a block sign value what I have to calculate continuously.
17.srt	00:17:24.929 --> 00:17:42.439	So, you will be putting it in the loop i is equal to 0 and for 0 to length whatever you have defined you will be calculating your i plus plus and then buffer of i is going to call the function sign generation basically.
17.srt	00:17:42.859 --> 00:17:44.309	So, then what happens?
17.srt	00:17:44.599 --> 00:17:51.159	You are calling your function block sign from the main and then you are calling the passing the parameters.
17.srt	00:17:51.529 --> 00:17:53.239	G buffer and buffer size.
17.srt	00:17:53.689 --> 00:17:58.969	So, that is what it says fill buffer with the sign data and then return.
17.srt	00:17:59.329 --> 00:18:14.689	So, your G buffer will be containing your output value we will see how it is going to show that whether we are getting IR filter in the oscillatory mode going to generate a sine wave for our application.
17.srt	00:18:14.689 --> 00:18:20.419	So, I am doing again debugging the code.
17.srt	00:18:23.949 --> 00:18:33.829	So, the code has gone and then loaded on to the board then we will run the thing because I am showing you in the waveform format.
17.srt	00:18:33.829 --> 00:18:36.480	So, I have given a break point in this case.
17.srt	00:18:36.599 --> 00:18:55.089	So, the code will be stopping there was a as you will see sometimes you will be getting the debugger is going to misbehave because my break point it has not.
17.srt	00:18:55.409 --> 00:19:04.419	taken the thing it has completely gone and then run and then it is unable to reach whatever you have given sometimes return 0.
17.srt	00:19:04.789 --> 00:19:06.399	So, it was unable to locate it.
17.srt	00:19:06.439 --> 00:19:08.669	So, hence it gave you an error.
17.srt	00:19:08.979 --> 00:19:16.589	So, to I will be reallocating my breakpoint here and then we will rerun it.
17.srt	00:19:17.779 --> 00:19:21.719	So, you have seen that it has come the breakpoint has come and then stopped here.
17.srt	00:19:22.199 --> 00:19:24.259	Now, I will be able to see the output.
17.srt	00:19:24.439 --> 00:19:28.429	Once I complete it, it comes out of it my memory gets erased.
17.srt	00:19:28.429 --> 00:19:29.599	So, I would not be able to.
17.srt	00:19:29.999 --> 00:19:31.899	see my what buffer has.
17.srt	00:19:31.939 --> 00:19:50.189	So, if you keep the thing also you will be seeing that what are the hex values your G buffer where it is located default it is going to show, hex value, decimal value and octal binary all the format whatever you want to view it you can see that.
17.srt	00:19:50.499 --> 00:19:54.299	Now, what we will do is we will see using a graph.
17.srt	00:19:54.599 --> 00:19:56.629	So, for that I will be going to tools.
17.srt	00:19:57.059 --> 00:20:00.539	So, if you are holding on in the.
17.srt	00:20:00.949 --> 00:20:09.239	with the break point then this tools option will be coming for you while running your code otherwise it goes off we will see it in a while.
17.srt	00:20:09.239 --> 00:20:10.549	So, I can do a single time.
17.srt	00:20:10.879 --> 00:20:15.049	So, I will got some 50 samples what I will be collecting it.
17.srt	00:20:15.049 --> 00:20:21.409	So, I can say that it is 16 bit signed integer what I am going to get the output.
17.srt	00:20:21.649 --> 00:20:27.689	So, then my start address is what we have is G buffer where the data is stored.
17.srt	00:20:33.429 --> 00:20:36.229	So, the if I give j buffer.
17.srt	00:20:36.629 --> 00:20:42.079	So, you will be seeing that the output is going to come here.
17.srt	00:20:42.369 --> 00:20:51.359	So, you can see that only half the sine wave what it has come because I have chosen number of samples small.
17.srt	00:20:51.599 --> 00:21:04.239	So, what I can do is hopefully I have control on the thing data what I can specify display properties will see it.
17.srt	00:21:05.359 --> 00:21:07.519	axis and other things what it is given.
17.srt	00:21:07.519 --> 00:21:15.349	So, otherwise what I can do is I can close it and once again go to the tools and then increase my data size here.
17.srt	00:21:16.179 --> 00:21:35.439	So, I will give it as something 250 let us see whether I have the thing and then this is 16 bit signed integer what I can select and again I have to do this G buffer and then I can give it.
17.srt	00:21:36.019 --> 00:21:38.639	So, what is the thing happening?
17.srt	00:21:39.139 --> 00:21:50.509	Since my it is generating only one single cycle basically after that you will be seeing whatever is in the memory is junk.
17.srt	00:21:51.079 --> 00:21:59.219	So, if you want to increase this so, you have to have more data what you will be generating it.
17.srt	00:22:07.579 --> 00:22:19.669	Number of samples what you will increase so, that for loop will be much more than the thing the what you can increase in this case length is chosen as where we have defined our length.
17.srt	00:22:20.009 --> 00:22:28.229	Buffer size is our length which is getting passed on there.
17.srt	00:22:28.229 --> 00:22:34.899	So, buffer size is what we have taken is 128 samples.
17.srt	00:22:35.229 --> 00:22:38.029	So, you will be seeing that at 128 samples.
17.srt	00:22:38.379 --> 00:22:40.149	I am going to get one cycle.
17.srt	00:22:40.219 --> 00:22:44.629	So, you can increase the buffer size and then collect more data.
17.srt	00:22:44.629 --> 00:22:50.009	So, you can get more samples in your waveform what you are looking at it.
17.srt	00:22:50.009 --> 00:22:54.729	So, this is how we make IR filter oscillate to generate sine wave.
17.srt	00:22:54.729 --> 00:23:01.829	Now, we will see one of the example what we have seen is sine wave generated only we have output.
17.srt	00:23:01.829 --> 00:23:05.229	Now, the other one is what we have is audio in and then out in the.
17.srt	00:23:11.219 --> 00:23:31.849	board that is it takes the input from any of your external devices and then whatever comes out of it is going to be sent out directly to check that whether your path from ADC to DAC it is through the board it is working or not.
17.srt	00:23:31.849 --> 00:23:33.669	How we are going to do that?
17.srt	00:23:34.059 --> 00:23:35.879	So, this is audio in and out.
17.srt	00:23:35.879 --> 00:23:40.349	Here you will be seeing that it uses the polling mechanism.
17.srt	00:23:42.169 --> 00:23:46.469	So, to differentiate between your polling and then interrupt driven.
17.srt	00:23:46.939 --> 00:23:52.109	So, the CPU has to go and then check if there is any data in the buffer.
17.srt	00:23:52.719 --> 00:23:56.069	So, once in a while it will go and then check and then collect it.
17.srt	00:23:56.399 --> 00:24:05.759	Whereas, in the interrupt driven so, as you know that whenever the person comes to your house they will be pressing the calling bell.
17.srt	00:24:06.230 --> 00:24:08.699	So, then you will go and then attend to that.
17.srt	00:24:08.959 --> 00:24:17.069	But if you are expecting the guest at that time and if he is a chief guest or whatever may be the thing once in a while you have to go.
17.srt	00:24:17.289 --> 00:24:26.789	and then check the person has come or not that we call it as a polling that is every 5 minutes or something you will be going and then checking.
17.srt	00:24:27.139 --> 00:24:40.809	So, if he has come then you will be bringing him that is how your polling is going to work whereas in interim driven as an example the person comes and then rings the bell then we know that somebody has come you will go and then attend.
17.srt	00:24:41.149 --> 00:24:46.569	So, that is the difference what I have given with an example.
17.srt	00:24:46.919 --> 00:24:52.519	Now we know that using the polling and then we are using the sampling frequency as 48 kilohertz.
17.srt	00:24:53.599 --> 00:25:00.700	So, we have taken both ADC gain and DAC gain as same way and then we will be using line input.
17.srt	00:25:01.200 --> 00:25:13.650	So, this is what the board will be using it then sample what I am going to get is input sample I will get it and I will be sending it out output sample sample.
17.srt	00:25:14.329 --> 00:25:17.019	So, what happens in this case?
17.srt	00:25:17.019 --> 00:25:25.109	So, you will be seeing that it is a 32 bit uninitialized int what you are calling it whatever data comes here.
17.srt	00:25:25.370 --> 00:25:26.529	you are sending it out.
17.srt	00:25:26.910 --> 00:25:31.440	So, we will see that how this is going to run in real time.
17.srt	00:25:31.470 --> 00:25:42.170	So, you will be see hearing some whatever speed signal if I give it, it will be coming out if it is tone it has to come out that is how it will be working.
17.srt	00:25:42.340 --> 00:25:47.610	So, we will do the debugging because I have checked for all the errors and other things.
17.srt	00:25:47.610 --> 00:25:56.840	So, directly I can run the debug if you are sure that there are no errors in your code directly I can go debug and then test them.
17.srt	00:25:57.210 --> 00:25:58.720	So, now we will run the thing.
17.srt	00:25:59.630 --> 00:26:02.550	So, there is nothing coming out of it.
17.srt	00:26:02.890 --> 00:26:11.650	So, just we will go and then see that some speech signal what I will be sending it out.
17.srt	00:26:12.430 --> 00:26:23.870	So, you have heard the speech coming out of it.
17.srt	00:26:23.870 --> 00:26:26.140	So, I can select.
17.srt	00:26:27.600 --> 00:26:31.830	If you want any audio you can select the audio also.
17.srt	00:26:32.259 --> 00:26:40.769	So, we will select here what I have is some tones different tones are there which has been generated.
17.srt	00:26:41.090 --> 00:26:43.590	So, you will be seeing that how they behave.
17.srt	00:26:43.590 --> 00:26:55.300	As you are seeing it is a 500 hertz sine wave what it is getting played.
17.srt	00:26:55.360 --> 00:27:00.050	So, we will see for the other tones anyway in the music.
17.srt	00:27:00.340 --> 00:27:02.840	the music you have heard of it.
17.srt	00:27:04.470 --> 00:27:06.460	So, how the pitch is going to change?
17.srt	00:27:06.910 --> 00:27:13.049	So, we will see 1 kilohertz how it is going to have a behavior ok.
17.srt	00:27:16.049 --> 00:27:18.960	So, different what you can generate the tone.
17.srt	00:27:19.110 --> 00:27:24.920	So, you will be seeing the shrill most of the thing will say it as a noise basically.
17.srt	00:27:25.269 --> 00:27:32.569	So, this is how your board takes audio in and then sends out it is not doing any processing.
17.srt	00:27:32.890 --> 00:27:39.170	So, most of the time what we do is if we want both audio in and out we will be taking here.
17.srt	00:27:39.539 --> 00:27:44.669	sample here input sample then we do the processing and send it out.
17.srt	00:27:45.059 --> 00:27:58.069	So, as an example we will see here there is a audio is getting what I will put it as attenuated.
17.srt	00:27:58.490 --> 00:28:06.609	So, but still you will be you may be able to hear a little bit of the thing otherwise you can try on yourself.
17.srt	00:28:07.079 --> 00:28:09.480	We have seen sine wave generation.
17.srt	00:28:10.379 --> 00:28:21.959	And, in the next class we will see how FIR filter can be put in between our audio in and out with noisy signal, how we can remove the noise.
17.srt	00:28:22.459 --> 00:28:29.679	We will look at it on the board we have seen already on using our lab MATLAB.
17.srt	00:28:30.059 --> 00:28:35.639	So, we will be designing the coefficient using MATLAB FDA toolbox.
17.srt	00:28:35.999 --> 00:28:42.429	So, I had shown you how to store that FDA coefficients in our file which we will be using.
17.srt	00:28:42.889 --> 00:28:46.799	in our FIR filter design in hardware.
17.srt	00:28:47.319 --> 00:28:47.859	Thank you.
17.srt	00:28:48.089 --> 00:28:48.879	Have a nice day.
16.srt	00:00:00.920 --> 00:00:25.280	In this lab class, we were doing the demo of musical notes.
16.srt	00:00:25.280 --> 00:00:33.600	So, I wanted to show that how the musical note is going to look like in the spectrum.
16.srt	00:00:34.759 --> 00:00:38.659	So, we will be doing the FFT of the musical notes.
16.srt	00:00:39.100 --> 00:00:41.579	So, I will get the complete spectrum.
16.srt	00:00:41.579 --> 00:00:45.579	So, have a patience to listen to this music again.
16.srt	00:00:46.039 --> 00:00:47.339	So, we will see the thing.
16.srt	00:00:51.259 --> 00:00:55.780	As you have seen the thing the note has got increased.
16.srt	00:00:56.079 --> 00:00:58.849	So, you will be seeing the spectrum of this.
16.srt	00:00:59.140 --> 00:01:06.069	So, you will be seeing from the basic frequency here it is approximately 200 hertz what it is kept.
16.srt	00:01:06.479 --> 00:01:24.530	And, then which goes up to 400 hits this will be my sir you will be seeing re ga ma pa the ni sir that is what you heard and you can find out from the spectrogram what are the frequencies present in your music not our audio functions.
16.srt	00:01:25.089 --> 00:01:31.709	So, today what we will do is as we are discussing about the filters in the theory.
16.srt	00:01:32.099 --> 00:01:37.899	So, we will have a look at how we can use the FDA toolbox.
16.srt	00:01:38.389 --> 00:01:46.019	to represent what all the design what we can have with respect to.
16.srt	00:01:49.379 --> 00:02:01.099	As I have been mentioning FDA toolbox is going to be removed from the recent editions of it, I can give filter design also what it will be taking it.
16.srt	00:02:01.469 --> 00:02:05.109	So, we will see that this is our FDA toolbox.
16.srt	00:02:05.369 --> 00:02:10.079	So, earlier all we have seen the thing that is I can have a.
16.srt	00:02:10.609 --> 00:02:18.809	response type, whether I want a low pass filter or high pass I can select the thing and then what kind of filter.
16.srt	00:02:18.809 --> 00:02:24.049	So, FIR filter either I can design the equi ripple filter.
16.srt	00:02:24.049 --> 00:02:29.799	So, if you click on this you will be getting the various modes of the filters.
16.srt	00:02:29.889 --> 00:02:40.989	If I want to use the window technique I can use it or any of direct implementation what you can see that you can select them.
16.srt	00:02:41.459 --> 00:02:47.659	For the time being we will select the window because we have comfortable with hamming and then hanning window in the theory.
16.srt	00:02:48.079 --> 00:02:51.779	So, even the KZ window what you can select it.
16.srt	00:02:52.119 --> 00:02:56.879	So, for the time being we will select first as the Blackman window.
16.srt	00:02:57.599 --> 00:02:58.699	Then what happens?
16.srt	00:02:58.699 --> 00:03:05.969	So, whether either I can specify my filter order or I will be going with the minimum order design.
16.srt	00:03:05.999 --> 00:03:13.359	So, I will click on the here what it is shown is the sampling frequencies.
16.srt	00:03:13.919 --> 00:03:26.349	So, we will bring it down to 8000 and this what we have seen in the last class is 1000 hertz what we will give it.
16.srt	00:03:26.810 --> 00:03:32.810	So, I can I it is not allowing me to design the minimum order.
16.srt	00:03:33.360 --> 00:03:35.719	So, only it is giving me specify the order.
16.srt	00:03:35.719 --> 00:03:44.530	So, I can specify as 30 is my order and then I can view the response of it.
16.srt	00:03:44.530 --> 00:03:47.000	So, we had seen in the last class that is.
16.srt	00:03:47.630 --> 00:03:58.760	So, this is my low pass filter what I am designing it and samples what I have seen this is my normalized frequency what it will be showing.
16.srt	00:03:58.760 --> 00:04:19.110	So, that is my 48000 kilohertz is 0 to 2 pi what you will 0 to pi on the right hand side you will be seeing it on the left hand side it will be 0 to minus pi the response will be.
16.srt	00:04:19.529 --> 00:04:26.620	So, here it is pointing to 0 to 30 is the thing order of the filter what it has taken this the impulse response.
16.srt	00:04:26.990 --> 00:04:31.089	In the time domain how it looks frequency domain in the theory we have seen it.
16.srt	00:04:31.089 --> 00:04:35.199	So, now, we are seeing how in the MATLAB what it is going to show it.
16.srt	00:04:35.199 --> 00:04:39.110	So, the next one is I can do the design of the filter.
16.srt	00:04:39.639 --> 00:04:41.180	So, we will design the filter.
16.srt	00:04:41.779 --> 00:04:44.269	So, you have to hold on for a while.
16.srt	00:04:44.719 --> 00:04:46.669	So, you will be seeing the response.
16.srt	00:04:47.139 --> 00:04:51.969	So, what is it I have given the cutoff frequency as 1000 Hertz.
16.srt	00:04:52.350 --> 00:04:53.889	So, you will be seeing that.
16.srt	00:04:54.259 --> 00:05:01.710	So, when I map this to frequencies this is going to go from 0 to 4000.
16.srt	00:05:02.090 --> 00:05:07.650	So, it normalized will be 4 what you will be seeing it in this case.
16.srt	00:05:07.699 --> 00:05:12.170	So, this is my approximately 1000 hertz.
16.srt	00:05:12.480 --> 00:05:17.490	So, which it should be giving me 3 dB cutoff what we say.
16.srt	00:05:17.819 --> 00:05:22.410	So, you will be seeing that approximately it comes down to this is my cutoff frequency .
16.srt	00:05:22.740 --> 00:05:28.960	comes down by minus 3 dB that is equivalent to 0.707 of the magnitude.
16.srt	00:05:28.960 --> 00:05:42.930	So, you have to be careful when you are designing your filter the output may be what I say is amplitude may be modified basically.
16.srt	00:05:42.930 --> 00:05:47.100	So, scaled version what you will be getting it.
16.srt	00:05:47.100 --> 00:05:55.030	So, if you want if it is 0 dB the frequencies what I can pass as you can see the thing is only up to 500 Hertz.
16.srt	00:05:55.030 --> 00:05:57.890	So, if you are doing anything beyond it.
16.srt	00:05:57.890 --> 00:06:00.730	So, you will be having the attenuation in the magnitude.
16.srt	00:06:00.730 --> 00:06:02.290	So, you may have to.
16.srt	00:06:02.940 --> 00:06:12.940	Now, we will see that how the band stop frequencies are going to look like.
16.srt	00:06:13.270 --> 00:06:21.510	So, here it has come down to approximately minus 80 dB what we can say using the Blackman filter.
16.srt	00:06:22.020 --> 00:06:25.850	So, it depends on how much down you want to come down.
16.srt	00:06:26.030 --> 00:06:30.970	So, you can think of it and then use one of the filter.
16.srt	00:06:31.040 --> 00:06:33.790	The order if I increase it as you will be seeing it.
16.srt	00:06:34.140 --> 00:06:37.290	So, I will make it as 50 order filter in this case.
16.srt	00:06:37.930 --> 00:06:46.360	So, we will see the Blackman filter itself.
16.srt	00:06:46.360 --> 00:06:47.860	So, I can design the filter.
16.srt	00:06:48.170 --> 00:06:52.980	So, now, you will be seeing that as and when I am increasing the order of the filter.
16.srt	00:06:53.550 --> 00:07:08.180	So, you will be seeing that the flat response is much more wider here that is the pass band will be for more frequency and this is my transition band what we call it from the.
16.srt	00:07:08.579 --> 00:07:12.300	0 to whatever the delta is represented.
16.srt	00:07:12.300 --> 00:07:17.780	So, it will be narrowing down as and when the order of the filter is going to increase.
16.srt	00:07:18.060 --> 00:07:22.389	So, now, I want to see that what is the group delay of this.
16.srt	00:07:22.970 --> 00:07:24.310	So, I can click on it.
16.srt	00:07:24.740 --> 00:07:31.620	So, you will be seeing that hopefully there is a trigger in your mind which is happening.
16.srt	00:07:31.620 --> 00:07:34.800	So, direct form FIR filter is designed.
16.srt	00:07:38.819 --> 00:07:48.769	So, the order is going to be 49 and then whether it is stable filter or not what you will be seeing it, it says S and then it is a designed.
16.srt	00:07:49.079 --> 00:07:54.259	So, why I am getting the group delay, it is a constant in case of linear filter.
16.srt	00:07:54.730 --> 00:08:09.139	So, here the delay is going to be although I have 0 to 49 samples, I should have had a delay of 50 samples since I have used the linear phase.
16.srt	00:08:10.210 --> 00:08:14.090	So, that delay because I will be combining it if you remember your structure.
16.srt	00:08:14.090 --> 00:08:17.010	So, which comes down by half basically.
16.srt	00:08:17.290 --> 00:08:23.290	So, the constant delay of this filter is going to be 25 units.
16.srt	00:08:23.290 --> 00:08:31.670	So, after that you will be getting it continuously your output if you are running for your real time applications.
16.srt	00:08:31.750 --> 00:08:36.220	So, coming to if you want to represent the face of it.
16.srt	00:08:36.279 --> 00:08:47.620	So, you are seeing that my face has to be linear in the pass band that is 0 to 1 kilohertz what we have given the thing this is cutoff frequency.
16.srt	00:08:47.940 --> 00:08:49.590	So, which you are seeing that.
16.srt	00:08:49.930 --> 00:08:51.550	it is constant.
16.srt	00:08:51.990 --> 00:09:08.879	So, if you want to represent your response is this and then if you want to see the filter specification you can go and then see that this is how my cutoff frequency low pass filter what I have designed.
16.srt	00:09:09.270 --> 00:09:15.060	So, like this you can go design your high pass filter or band pass or band stop.
16.srt	00:09:15.320 --> 00:09:18.540	So, we will see one band pass filter specification.
16.srt	00:09:18.950 --> 00:09:25.110	So, you will be seeing that there will be two cutoff frequencies that is fc1 and then fc2.
16.srt	00:09:25.900 --> 00:09:28.380	So, these are the two things what you have to provide.
16.srt	00:09:28.680 --> 00:09:50.180	So, as usual we can say that 8 kilohertz what I will take as my sampling frequency instead of 48 and then I will say my low frequency I want up to 400 hertz which has to be eliminated and then here I can give it as 3200 hertz.
16.srt	00:09:50.290 --> 00:09:56.090	That means, I want to allow frequencies between 400 and 3200 hertz.
16.srt	00:09:56.610 --> 00:09:59.220	and then rest of them have to be eliminated.
16.srt	00:09:59.220 --> 00:10:03.320	So, I will design the filter here same Blackman window I am doing it.
16.srt	00:10:03.600 --> 00:10:06.330	So, this will be the response what you can see it.
16.srt	00:10:06.840 --> 00:10:08.150	So, what is it?
16.srt	00:10:08.700 --> 00:10:21.480	So, 400 hertz is going to be this thing somewhere here what you will be getting it and then this is 3000 approximately 200 what you will get the thing.
16.srt	00:10:22.090 --> 00:10:24.100	So, this is what the filter design.
16.srt	00:10:28.040 --> 00:10:33.590	So, if I change my filter to So, you will be seeing the response what is the thing is going to happen.
16.srt	00:10:34.890 --> 00:10:43.150	So, you are seeing that there are ripples what you will be seeing it and then your response is going to vary.
16.srt	00:10:43.330 --> 00:10:53.020	So, when you view this, this is what you will be seeing in the time domain how the Hanning window looks like and then this is the frequency domain.
16.srt	00:10:53.020 --> 00:10:57.280	So, you will be seeing that your magnitude your ripples will be.
16.srt	00:10:57.680 --> 00:11:04.960	somewhere here that is minus 20 dB or whatever you will be getting it.
16.srt	00:11:04.960 --> 00:11:14.670	So, that is what it says main lobe width is minus 3 dB in this case you will be seeing it ok.
16.srt	00:11:14.850 --> 00:11:26.560	So, these are the you will be analyzing these things maximum relative side lobe attenuation what it says this is minus 31.5 dB.
16.srt	00:11:26.630 --> 00:11:29.340	So, somewhere here what you will be.
16.srt	00:11:30.050 --> 00:11:31.180	getting it below that.
16.srt	00:11:31.770 --> 00:11:40.170	So, this is how you can play with your design thing and then you can use it in your filter design.
16.srt	00:11:40.500 --> 00:11:54.790	So, you can use FIR 1 or FIR 2 to do the design or these are the coefficients one of the thing what you have to do is if you are using it for code composer studio.
16.srt	00:11:54.790 --> 00:12:02.590	So, you will be seeing there is a IDE generation of coefficients any other platform if you want to use.
16.srt	00:12:03.250 --> 00:12:17.240	Xilinx platform or HDL code you want to generate it or C header file if you want to use the C code you can generate using that or I will put it as code composer studio what I want to generate my coefficients with.
16.srt	00:12:17.750 --> 00:12:34.400	So, I have to specify the header file C header file and then I will be getting here it is numerator and the length is defined with the BL and then export what is suggested.
16.srt	00:12:35.100 --> 00:12:40.930	What it says is signed 32 bit integer what you export it as that is what it is showing.
16.srt	00:12:41.330 --> 00:12:47.150	So, and then I can specify the DSP board also select the target for which I am generating it.
16.srt	00:12:47.530 --> 00:13:05.710	So, or I can specify what I want it to be exported as I can export it as signed 16 bit integer or I can specify any other format I want unsigned or unsigned 32 bit or signed 8 bit.
16.srt	00:13:05.960 --> 00:13:12.170	8 bit integer depends on hardware which one you are using it for us 60 sin 16 bit is enough.
16.srt	00:13:12.520 --> 00:13:16.630	So, I have chosen sin 16 bit integer in this case.
16.srt	00:13:17.210 --> 00:13:26.580	And then if I call it as a generate it you will be seeing that it is going to generate and then it gives the name as FDA coefficient.
16.srt	00:13:26.580 --> 00:13:28.520	So, we can save it.
16.srt	00:13:28.810 --> 00:13:34.290	So, I will be saving it in the documents because I have lot of things and downloads.
16.srt	00:13:34.630 --> 00:13:35.920	So, better to save it here.
16.srt	00:13:36.190 --> 00:13:40.410	So, you will be seeing that it is saved as dot star dot h file.
16.srt	00:13:40.870 --> 00:13:44.420	So, that is fda coefficients dot h what it will be storing it.
16.srt	00:13:44.740 --> 00:13:47.710	So, we will go and then look at the values of it.
16.srt	00:13:49.690 --> 00:13:53.000	So, in the documents file what I have stored it.
16.srt	00:13:53.360 --> 00:14:00.010	So, you will be seeing that fda coefficients is stored here dot h file.
16.srt	00:14:00.100 --> 00:14:03.250	So, if you see the format here.
16.srt	00:14:03.700 --> 00:14:04.610	So, what is it?
16.srt	00:14:04.970 --> 00:14:13.550	It is filter coefficients, see source file what it is generated and then from filter design and analysis toolbox and MATLAB.
16.srt	00:14:14.030 --> 00:14:23.790	whatever version signal processing toolbox what it has used is 8.5 MATLAB registered what it says and generated when date and everything.
16.srt	00:14:23.790 --> 00:14:35.370	So, you will be seeing that what is the filter you have generated it is FIR filter direct form FIR what it says and the filter length is 51 because we gave order as 50.
16.srt	00:14:35.370 --> 00:14:43.460	So, it will be generating the order 1 n plus 1 what it will be taking it 51 is the order and linear phase.
16.srt	00:14:44.160 --> 00:14:45.760	it is using type 1.
16.srt	00:14:46.290 --> 00:14:53.580	So, if you want to change and other things you can go and then look at the manual and then you can do that.
16.srt	00:14:53.900 --> 00:15:01.850	So, it says that filter coefficients were truncated to fit specified data type because we gave sign 16 bit.
16.srt	00:15:02.100 --> 00:15:09.600	So, you will be seeing that b l is my length of the coefficients and then you will be seeing the values of these coefficients here.
16.srt	00:15:10.020 --> 00:15:11.960	So, it is from 0 minus 3.
16.srt	00:15:15.310 --> 00:15:24.490	So, you have already seen that it has taken care of truncation of the values in this format in the fixed point format what I have given ok.
16.srt	00:15:24.740 --> 00:15:31.730	So, this you will be using it in your code composer studio to run your FIR filter applications.
16.srt	00:15:31.800 --> 00:15:35.610	So, this is one thing.
16.srt	00:15:35.610 --> 00:15:40.890	So, we will see how one can run in MATLAB itself.
16.srt	00:15:46.300 --> 00:15:47.860	So, we can close this.
16.srt	00:15:48.370 --> 00:15:56.540	And, then what I will do is from the FDA toolbox I will be coming out of it if anybody wants to see rest of the thing.
16.srt	00:15:57.070 --> 00:16:05.670	So, you will be seeing FIR filter band stop or high pass filter one can design depending on your application.
16.srt	00:16:06.000 --> 00:16:17.780	So, coming back to this thing I have.
16.srt	00:16:17.990 --> 00:16:26.890	So, you can one by one run and then check it in the MATLAB dot m file what you can generate and then do the thing.
16.srt	00:16:27.340 --> 00:16:38.560	So, here usually I ask my students to generate a GUI for it will be easy to show that what is the filter they are using it and then how I can modify.
16.srt	00:16:38.640 --> 00:16:45.130	So, in this case as a demo I am showing you this one one of it which is developed.
16.srt	00:16:45.130 --> 00:16:48.070	So, I will be going into this and then running it.
16.srt	00:16:48.070 --> 00:16:50.230	So, you will be seeing that GUI is getting generated.
16.srt	00:16:50.610 --> 00:16:54.140	So, now, I have to specify here filter type what I wanted.
16.srt	00:16:58.820 --> 00:17:12.050	So, we will see that I want FIR filter we were trying it we can do that and then what is the response type what I want whether I want a low pass response or a high pass, band pass or band stop.
16.srt	00:17:12.310 --> 00:17:21.090	So, since we have done the low pass and then band stop design we will take up here band stop.
16.srt	00:17:21.090 --> 00:17:29.780	So, now, what is the thing is usually why we use filter in this case we are going to eliminate the noise.
16.srt	00:17:29.780 --> 00:17:32.580	So, we will play the original wave file and see what.
16.srt	00:17:35.830 --> 00:17:37.650	I will be getting the output as.
16.srt	00:17:38.400 --> 00:17:43.980	Remember, the force will be with you always.
16.srt	00:17:43.980 --> 00:17:47.580	So, this is the original speech file what you heard it.
16.srt	00:17:47.580 --> 00:17:51.210	Now, we will say when the noise is added how does it look like.
16.srt	00:17:51.210 --> 00:17:54.060	Remember, the force will be with you always.
16.srt	00:17:59.730 --> 00:18:05.890	So, there is a single tone noise what has been added to the speech and then.
16.srt	00:18:06.839 --> 00:18:09.500	which is fed as input to your filter.
16.srt	00:18:09.980 --> 00:18:17.670	So, that is what it says which tone has been added is 2100 hertz as noise is loaded into this.
16.srt	00:18:18.059 --> 00:18:20.940	Now, we can play the filtered output.
16.srt	00:18:21.630 --> 00:18:23.369	So, you will be seeing it.
16.srt	00:18:26.740 --> 00:18:31.970	So, this was a single tone what in terms of frequency what you are seeing it.
16.srt	00:18:32.349 --> 00:18:36.549	So, approximately 2000 although it says 2100 hertz.
16.srt	00:18:36.859 --> 00:18:40.930	So, you are seeing as a peak at 2500 and rest of it.
16.srt	00:18:41.329 --> 00:18:43.150	it is vanishing it is not staying.
16.srt	00:18:43.150 --> 00:18:51.109	So, your speech of magnitude filtered output what it is showed and then went off.
16.srt	00:18:51.490 --> 00:18:55.029	So, if you want to design an IR filter.
16.srt	00:18:55.450 --> 00:19:00.250	So, I can give this I can select a low pass filter IR filter.
16.srt	00:19:00.720 --> 00:19:15.119	So, it will be saying that some of the speech file with noise sign tone what it has added is 3750 hertz which is going to be eliminated since we have seen the original already.
16.srt	00:19:15.380 --> 00:19:17.150	So, we will hear for a change.
16.srt	00:19:20.830 --> 00:19:23.340	So, if you are keen in observing the note.
16.srt	00:19:23.340 --> 00:19:29.000	So, you will be seeing the difference between 2100 and then 3750 hertz.
16.srt	00:19:29.600 --> 00:19:31.860	Now, you play the same filtered output.
16.srt	00:19:34.940 --> 00:19:42.900	So, you have seen the peak frequency which got added has got changed to 3500 approximately in the thing.
16.srt	00:19:43.250 --> 00:19:45.819	Scale has not been normalized.
16.srt	00:19:45.819 --> 00:19:48.600	I have expanded the thing and what was the output.
16.srt	00:19:49.490 --> 00:19:57.319	So, this eliminates the higher frequency component present in the thing and then it is allowing the speech to come out as clean.
16.srt	00:19:57.799 --> 00:20:08.079	This is how what you will be experimenting with FIR and IR filter together that is it is GUI.
16.srt	00:20:08.079 --> 00:20:15.450	Otherwise you can run the code in MATLAB create a dot m file and then you can run them also.
16.srt	00:20:15.450 --> 00:20:22.829	So, that is what one of the example what we have seen using the MATLAB filter.
16.srt	00:20:23.200 --> 00:20:24.909	So, we will see in.
16.srt	00:20:25.599 --> 00:20:31.500	So, if you want to save or whatever it will be showing.
16.srt	00:20:31.969 --> 00:20:39.069	So, we said that our sine generation using the DDS we had seen in the MATLAB.
16.srt	00:20:39.519 --> 00:20:45.569	So, we will see in our DSK6713 board TI board as I have been mentioning it.
16.srt	00:20:45.569 --> 00:20:50.779	So, how it is going to generate the sine wave.
16.srt	00:20:50.779 --> 00:20:54.029	So, this is the C code what we have written.
16.srt	00:20:55.409 --> 00:21:10.549	So, we have to use library function and then the math function and we are defining my length of the thing as 256 and we are keeping the rest of the code what we had used in the MATLAB function.
16.srt	00:21:10.549 --> 00:21:14.119	So, if you correlate the equations it remains the same thing.
16.srt	00:21:14.119 --> 00:21:28.049	So, your desired frequency is 1000 and then the sampling frequency amplitude is 32000 and then pi in this case we have to define because there is no built in.
16.srt	00:21:28.349 --> 00:21:34.179	pi value in this case like in MATLAB in C as you know you have to specify that.
16.srt	00:21:34.619 --> 00:21:39.409	And then we have given the phase increment here and sampling frequency chosen as 48000.
16.srt	00:21:39.669 --> 00:21:43.689	So, I can generate both out 1 and then out 2.
16.srt	00:21:43.929 --> 00:21:46.719	So, what is this out 1 and out 2 we will see in a while.
16.srt	00:21:47.089 --> 00:21:57.959	So, one thing one has to keep it in mind when you are using the board if you declare them as global variable then you will be able to.
16.srt	00:21:59.319 --> 00:21:59.729	see their output.
16.srt	00:21:59.729 --> 00:22:04.889	So, if it is a local variable, so you may not be able to plot them.
16.srt	00:22:04.949 --> 00:22:12.149	So, that is the reason why output is kept as a global variable.
16.srt	00:22:12.289 --> 00:22:21.849	Then we will be using the equation for i is equal to 0 less than i less than n like even in math lab we did the thing.
16.srt	00:22:21.879 --> 00:22:31.419	So, we will be doing the phase increment and then what is it is desired divided by f is what we have it.
16.srt	00:22:31.829 --> 00:22:38.229	desired is 1000, f s is 48 kilohertz what we have used it and then increment the phase.
16.srt	00:22:38.559 --> 00:22:42.499	So, we are checking if phase is greater than or equal to 2 pi.
16.srt	00:22:42.969 --> 00:22:53.849	So, if it is so, then we will be subtracting it with 2 pi minus we will be subtracting with 2 pi.
16.srt	00:22:54.199 --> 00:22:59.719	So, we are counting as a modulus 2 star pi operation in this line.
16.srt	00:23:02.769 --> 00:23:12.069	Then, what we are calculating first one is the output 1 of i, this is magnitude multiplied by sine function what we are calling with the phase.
16.srt	00:23:12.529 --> 00:23:23.759	So, scaled what we call it as L in output and then we can feed it as a left hand sine one side and then the other one can be cos.
16.srt	00:23:24.039 --> 00:23:32.429	So, you will be seeing that output 2 is given as amplitude into cos f with respect to phase what you have calculated here.
16.srt	00:23:34.549 --> 00:23:54.859	So, when I So, these are the dot c file what I am showing it as a main dot c. Now, one of the thing is automatically when you open the new what we call it as give it as a new CCS project if I select it.
16.srt	00:23:55.249 --> 00:23:58.289	So, it will ask me what is the file name I wanted.
16.srt	00:23:58.629 --> 00:24:04.219	So, I will call it as here in this case sign dds because I have given underscore there.
16.srt	00:24:04.789 --> 00:24:16.769	Then, it will ask me whether I want the executable, we will say yes and then what is the family I am going to choose is C6000 and then we have given DSK6713.
16.srt	00:24:17.109 --> 00:24:27.119	If you are using the board then I have to use spectrum digital DSK EVM EZDSP onboard USB emulator.
16.srt	00:24:27.639 --> 00:24:34.499	So, and then you can give finish then you will be seeing that your main dot C along with it is going to be.
16.srt	00:24:34.759 --> 00:24:39.849	So, here you can write your code and then run the thing.
16.srt	00:24:40.199 --> 00:24:47.719	So, for that and then it will show this is the active debug folder or project which is selected.
16.srt	00:24:48.019 --> 00:24:51.199	So, for because we have already written the code.
16.srt	00:24:51.549 --> 00:24:53.389	So, you can go and then insert it.
16.srt	00:24:53.389 --> 00:24:58.519	So, I will be selecting this is my active code to be run in this case.
16.srt	00:24:58.849 --> 00:25:00.409	So, then I will select.
16.srt	00:25:00.569 --> 00:25:08.559	So, if I do this it will be doing the compilation and even the build is going to be done in this.
16.srt	00:25:08.869 --> 00:25:13.149	So, if there is any error in the thing please go and then fix them.
16.srt	00:25:13.709 --> 00:25:22.579	So, otherwise I can go directly for debugging, then what happens it debugs and then it is loaded on to the processor.
16.srt	00:25:22.579 --> 00:25:26.759	So, you are seeing your cursor has entered into the main function.
16.srt	00:25:27.339 --> 00:25:30.969	So, we will see that we will be going for the debug operation.
16.srt	00:25:30.969 --> 00:25:33.939	So, you have this has to come when you are doing it.
16.srt	00:25:34.219 --> 00:25:46.429	It says it has used spectrum digital DSK EVM DSP on board 671X what is the thing taken and then it has entered the main function.
16.srt	00:25:46.929 --> 00:25:56.469	And then interrupt what it is going to have is c underscore interrupt 0 0 it will be going into the boot that is the entry point for the thing.
16.srt	00:25:56.859 --> 00:26:00.689	So, to see that my output is coming out correctly.
16.srt	00:26:00.689 --> 00:26:08.409	So, if I run completely then I may not be able to see whether my output 1 and then 2 are sine and cos functions.
16.srt	00:26:08.799 --> 00:26:10.969	What I put is a break point here.
16.srt	00:26:10.969 --> 00:26:17.159	So, if you double click on it it clears it and then if you double click again it is going to.
16.srt	00:26:17.579 --> 00:26:18.489	put a break point.
16.srt	00:26:18.599 --> 00:26:23.749	So, we will run this code and then you will see that it stops here.
16.srt	00:26:24.329 --> 00:26:31.279	Now, what I have to do is see whether I am getting the sign a wave generated correctly or not.
16.srt	00:26:31.599 --> 00:26:36.539	So, I will be going to the tools and then I will be selecting a single time graph.
16.srt	00:26:36.879 --> 00:26:41.399	So, I have to specify what is my length of it.
16.srt	00:26:41.719 --> 00:26:47.739	So, we said 250 and then my output data type what I have declared is float.
16.srt	00:26:47.939 --> 00:26:55.839	So, I can use 32 bit floating point and then I will be giving this start address as output 1.
16.srt	00:26:57.659 --> 00:27:06.049	So, then if I give the thing, so you will be seeing that your sine wave has got generated using the DDS method.
16.srt	00:27:06.359 --> 00:27:13.069	So, if you want to again plot one more graph that is single time I will call it.
16.srt	00:27:13.339 --> 00:27:20.009	So, this also is going to be 250 and then this again what I have is a floating point.
16.srt	00:27:20.509 --> 00:27:22.009	32 bit floating point.
16.srt	00:27:22.329 --> 00:27:28.669	So, I want to see my output 2, where I am getting the sine wave.
16.srt	00:27:30.099 --> 00:27:40.849	Sorry, you will be seeing that this is the single time, this is what you have it, the other one is shown here.
16.srt	00:27:41.409 --> 00:27:53.149	So, you will be seeing that this is starting from 0 what you are having it, whereas your cos file you will be seeing that it starts from 1 which is in this case 32000.
16.srt	00:27:53.619 --> 00:27:56.109	is amplitude what we have taken.
16.srt	00:27:56.109 --> 00:27:59.229	So, that is what it is showing and then it is repeating.
16.srt	00:27:59.579 --> 00:28:22.899	So, if you want to see their FFT magnitude whether you are generating the sorry correct this thing frequency is getting displayed or not I can select the FFT magnitude.
16.srt	00:28:25.909 --> 00:28:31.089	So, taking is a 250 and then what I have is a 32 bit floating point.
16.srt	00:28:31.549 --> 00:28:47.879	So, I can give start addresses for one of it we will see the other one you can see it yourself output 1 and then what is the frame size we will be taking up spectrum analysis in little later classes.
16.srt	00:28:48.149 --> 00:28:50.749	So, if you want you can change the order of it.
16.srt	00:28:50.749 --> 00:28:54.869	So, I will give it as 10 2 power 10 will be my order of the FFT.
16.srt	00:28:55.199 --> 00:28:56.539	So, you will be seeing that.
16.srt	00:28:56.959 --> 00:29:01.559	This is how what it is represented because 1024.
16.srt	00:29:02.119 --> 00:29:04.329	So, if you want to represent in a lower thing.
16.srt	00:29:04.399 --> 00:29:06.049	So, to get 1 kilohertz.
16.srt	00:29:06.419 --> 00:29:10.869	So, you can multiply what is the magnitude of it.
16.srt	00:29:11.259 --> 00:29:20.599	So, the value what you are going to get it is going to show multiply with your sampling frequency into 1024.
16.srt	00:29:20.599 --> 00:29:24.079	So, you will be getting what is the frequency what you are getting it.
16.srt	00:29:24.389 --> 00:29:27.179	This is our k point where it is shown.
16.srt	00:29:27.559 --> 00:29:37.409	So, if you want to change it you can change your order of the filter and then see what output you will be getting whether you will get the 1 kilohertz represented or not.
16.srt	00:29:37.759 --> 00:29:46.039	So, this shows how we can use our DSK board using C function to generate sine wave.
16.srt	00:29:58.489 --> 00:30:05.709	So, in the next class we will in the next lab we will be seeing how to do the filtering after generating a sine wave that is using IR filter in the oscillatory mode and using do the filtering with different low pass and then high pass what we have seen in the MATLAB same way we will see it in code composer studio.
16.srt	00:30:06.239 --> 00:30:06.679	Thank you.
14.srt	00:00:01.219 --> 00:00:25.170	Welcome back to real time digital signal processing course.
14.srt	00:00:25.530 --> 00:00:31.010	So, we discussed about IR filters little bit last in the last class, today we will continue with the.
14.srt	00:00:31.390 --> 00:00:32.109	same thing.
14.srt	00:00:32.640 --> 00:00:44.030	So, as a recap as I said we have discussed little bit on IR filter how we have to design from analog domain to digital domain what we have seen the thing.
14.srt	00:00:44.400 --> 00:00:46.359	So, today we will continue on that.
14.srt	00:00:46.679 --> 00:00:54.100	So, what we said was it was structured one what we had taken the thing or direct form one.
14.srt	00:00:54.500 --> 00:00:57.920	So, here we will see how biquad has to be designed.
14.srt	00:01:03.490 --> 00:01:30.280	In the continuous domain first we will see the thing and later on we will go back to the digital So, we know that impulse response with biquad with poles sigma plus r minus j b where with sigma less than 0 or I can take it as a which is less than 0, but no 0s then the impulse response is given in the analog domain H of t is equal to c into e power minus s t cos bt plus theta.
14.srt	00:01:31.359 --> 00:01:33.230	So, pure sinusoid.
14.srt	00:01:33.810 --> 00:01:40.520	when our A is equal to 0 and pure decay when B becomes 0.
14.srt	00:01:41.320 --> 00:01:58.320	So, how we can implement in the breadboard what it is given nowadays nobody does the breadboard design, but one can test it how it is going to be and if you are satisfied you can go for implementation in the regular PCB.
14.srt	00:01:58.930 --> 00:02:05.870	So, we consider a single pole where is it is at minus 1 by RC.
14.srt	00:02:06.280 --> 00:02:17.830	So, we consider 1 percent tolerance for our breadboard R and C values and then C tolerance for the pole location what we assume is 2 percent.
14.srt	00:02:18.480 --> 00:02:31.439	So, we will say that how many decimal digits corresponds to 2 percent tolerance one has to look at it and how many bits correspond to 2 percent tolerance one has to look at it.
14.srt	00:02:31.909 --> 00:02:36.980	So, what we want is the maximum quality factor is about what we say is 25 for.
14.srt	00:02:37.530 --> 00:02:42.990	implementation of analog filters using breadboard resistors and capacitors.
14.srt	00:02:43.500 --> 00:02:58.530	So, if we use this switched capacitor filters, the quality factor what we said was maximum what we can achieve is approximately 40 that is for the tolerance approximately 0.2 percent.
14.srt	00:02:58.590 --> 00:03:04.980	And then integrated circuit implementation can achieve maximum up to 80.
14.srt	00:03:04.980 --> 00:03:08.969	So, breadboard you can see that.
14.srt	00:03:09.660 --> 00:03:13.719	it is going to be half of that of the Isis design.
14.srt	00:03:13.980 --> 00:03:18.780	So, coming to the discrete part of it.
14.srt	00:03:19.100 --> 00:03:25.810	So, we will be representing a plus r minus j b is equal to we put it in r into e power j theta.
14.srt	00:03:26.280 --> 00:03:31.110	So, where r is given by root of a square plus b squared is the pole radius.
14.srt	00:03:31.460 --> 00:03:39.240	So, assume because it is within the unit circle we assume r is less than 1 for stability with y is equal to.
14.srt	00:03:39.850 --> 00:03:40.780	2 a.
14.srt	00:03:41.480 --> 00:03:53.939	Then what happens to our quality factor q which is given by square root of 1 plus r square to the power of square minus y square divided by 2 into 1 minus r square.
14.srt	00:03:54.460 --> 00:04:00.360	Where we assume that half is less than or equal to r q which is less than or equal to infinity.
14.srt	00:04:00.930 --> 00:04:03.770	So, what happens when the poles are real?
14.srt	00:04:04.410 --> 00:04:09.970	We know that b is equal to 0, a is in between minus 1 and then 1.
14.srt	00:04:10.560 --> 00:04:41.689	So, r becomes magnitude of a and y will be equal to plus or minus 2 a and what we call that is q is becomes half that is impulse response is c naught into a power n in that into u of n plus c 1 into n a to the power of n into u of n. So, if the poles are on the unit circle then r will be equal to 1.
14.srt	00:04:42.230 --> 00:04:55.340	So, q becomes infinity that is we call it as oscillatory response and imaginary poles if we have it then a becomes 0.
14.srt	00:04:56.160 --> 00:05:15.340	What happens to our r becomes it is the magnitude of b and y will be equal to 0 and we call q will be equal to half into 1 plus r square by 1 minus r square which is nothing, but 1 by 2 into 1 plus b square divided by 1 minus b square.
14.srt	00:05:16.089 --> 00:05:25.569	So, in the 16 bit fixed point digital signal processor, so we say 40 bit accumulator will achieve a Qmax of 40.
14.srt	00:05:25.569 --> 00:05:38.100	So, you will be wondering when we took up the architecture we said the maximum adder length is going to be 40 bit accumulator what we will consider.
14.srt	00:05:38.100 --> 00:05:46.120	And filter design programs often use R as a approximation of quality factor.
14.srt	00:05:48.539 --> 00:05:51.609	So, how to implement IR filter?
14.srt	00:05:52.399 --> 00:05:59.189	Same approach in discrete and continuous time filter what we will be considering it.
14.srt	00:05:59.629 --> 00:06:04.149	So, the classical IR filter designs what is going to be considered.
14.srt	00:06:04.669 --> 00:06:18.099	So, filter order of n will have n by 2 conjugate roots if n is even or 1 real root and then n minus 1 divided by 2 conjugate roots if n is.
14.srt	00:06:18.360 --> 00:06:22.889	So, response is very sensitive to perturbations in pole locations.
14.srt	00:06:22.889 --> 00:06:41.750	Rule of thumb for implementing IR filter what is it decompose IR filter into second order section that is biquats what we call it and cascade these biquats from input output in order of ascending quality factors.
14.srt	00:06:42.649 --> 00:06:48.009	We will see little later also how we will be working it out what happens to our pole positions.
14.srt	00:06:48.430 --> 00:06:55.540	and then how it will be affecting the cutoff frequency we will see with little problems later.
14.srt	00:06:56.160 --> 00:07:07.389	So, for each pair of conjugate symmetric poles in a biquad conjugate 0 should be chosen as those closest in Euclidean distance to the conjugate poles.
14.srt	00:07:07.750 --> 00:07:11.110	This we will see it in the next class how it is going to be chosen.
14.srt	00:07:12.170 --> 00:07:19.350	Several IR filter design how it is done differ in the shape of their magnitude responses.
14.srt	00:07:20.480 --> 00:07:31.420	So, the first one what we call it as the Butterworth filter which is monotonically decreases in pass band and stop band will not have any ripple in that.
14.srt	00:07:32.400 --> 00:07:42.500	And when we consider Chebyshev type 1 which is monotonically decreases in pass band, but has ripples in the stop band.
14.srt	00:07:42.780 --> 00:07:50.910	The Butterworth you will be seeing it this is what we call it as monotonically decreasing and then will not have any ripples in the pass band.
14.srt	00:07:51.449 --> 00:07:57.170	So, when we come to the Chebyshev type 1, so we say I am considering the low pass filter.
14.srt	00:07:57.639 --> 00:08:04.060	So, here it is what it says is monotonically decreasing, but we will be having the ripples in this.
14.srt	00:08:04.519 --> 00:08:16.149	So, when you come to Chebyshev type 2, we will have ripples in the pass band and then it is going to be a flat response in the case of stop band.
14.srt	00:08:21.699 --> 00:08:25.500	When I come to elliptical, so you will be seeing that we will be having both ripples in pass band and then stop band.
14.srt	00:08:25.949 --> 00:08:28.269	So, which one do we prefer?
14.srt	00:08:28.810 --> 00:08:31.790	So, that is one of the challenge one has to look at it.
14.srt	00:08:32.029 --> 00:08:38.309	So, when we consider the order of the filter, it is an increasing order in this way.
14.srt	00:08:38.309 --> 00:08:48.340	And when you see the pass band attenuation whether you are going to meet a stop band attenuation what which one you want to meet it.
14.srt	00:08:48.340 --> 00:08:51.889	So, we call this is my delta is basically where it is coming.
14.srt	00:08:53.649 --> 00:09:16.529	And, this is my 1 plus delta p what we had represented this is 1 minus delta p. So, in this case whether we are going to select Butterworth I said the order is going to be more whereas, elliptical order is going to be very less compared to other filters, but I will be having the ripple in pass band as well as stop band.
14.srt	00:09:24.190 --> 00:09:24.659	Whereas, Chebyshev 1 has ripple in the stop band whereas, Chebyshev 2 have ripple in the band.
14.srt	00:09:24.750 --> 00:09:40.950	So, compared to which frequency we want to meet most of the time when we use a impulse invariance method it is better to go for the Chebyshev 2 which is going to be in between order.
14.srt	00:09:41.549 --> 00:09:49.570	So, I can allow little bit of ripples in the pass band, but I want to meet the flat response in my stop band.
14.srt	00:09:49.570 --> 00:09:52.809	So, that no aliasing is going to happen.
14.srt	00:09:55.600 --> 00:10:04.300	So, coming to Order of the filter it is as we said that with respect to Butterworth and then Elliptic it stands in between.
14.srt	00:10:04.800 --> 00:10:20.690	So, what it says is classical IR filters have poles and zeros except continuous time low pass butter filters only have poles ok. And all classical filters have bike paths with high Q factors.
14.srt	00:10:21.230 --> 00:10:25.290	So, we will be seeing why we go for the bike path.
14.srt	00:10:25.650 --> 00:10:28.270	in a while.
14.srt	00:10:28.670 --> 00:10:31.000	How we are going to do the optimization?
14.srt	00:10:31.740 --> 00:10:47.160	So, we will be starting with an existing basically classical filter design we are going to use it and we will do IR filter optimization packages from UT Austin which is developed in MATLAB simultaneously you can optimize on the filter order.
14.srt	00:10:47.590 --> 00:10:55.490	So, you will be optimizing on the magnitude response, linear phase in passband what we can achieve using IR filter also.
14.srt	00:10:55.960 --> 00:11:06.420	And then how we are going to control the peak overshoot in step response and how we are going to take care of the quality factors one has to decide and then do the design.
14.srt	00:11:07.100 --> 00:11:11.470	So, we will do little bit comparison of FIR and IR filter in this slide.
14.srt	00:11:11.910 --> 00:11:15.190	So, when we talk about the implementation complexity.
14.srt	00:11:15.190 --> 00:11:20.540	So, we will be comparing the same piece wise constant magnitude specification.
14.srt	00:11:20.950 --> 00:11:28.750	So, for that FIR filters will have higher order whereas, IR filters what we can achieve is with the lower.
14.srt	00:11:29.130 --> 00:11:36.450	So, the factor may be 4 lower compared to higher FIR filters.
14.srt	00:11:36.610 --> 00:11:41.700	Coming to minimum order design when we want to do the thing.
14.srt	00:11:42.100 --> 00:11:46.360	So, we can use Pax-McAleenan or Ramez exchange algorithm.
14.srt	00:11:46.360 --> 00:11:50.400	So, what is the consequence of it?
14.srt	00:11:50.400 --> 00:11:58.230	Coming to estimate minimum order for this algorithm by case may be off by 10 percent.
14.srt	00:11:58.230 --> 00:12:03.910	So, we have to search for minimum order is often needed in this case.
14.srt	00:12:03.910 --> 00:12:08.450	So, whereas, in the IR filter design we know that if we.
14.srt	00:12:09.210 --> 00:12:12.970	a low deviation both in the pass band and then stop band.
14.srt	00:12:13.430 --> 00:12:20.840	So, we can achieve elliptic design algorithm gives us the minimum order.
14.srt	00:12:21.490 --> 00:12:27.950	So, whether it is stable when we are putting a question mark we know that FIR filter is always stable.
14.srt	00:12:28.440 --> 00:12:34.090	So, we say that IR filter may become unstable when implemented.
14.srt	00:12:34.500 --> 00:12:41.150	So, it can tune design to implementation target to minimize the risk of it.
14.srt	00:12:41.650 --> 00:12:50.360	So, we have to see that all the poles are inside the unit circle so that we will get a stable filter.
14.srt	00:12:51.040 --> 00:12:53.490	Coming with the linear phase width can we achieve?
14.srt	00:12:53.490 --> 00:13:03.990	So, we know that if impulse response is symmetric or anti symmetric about midpoint then we always achieve a linear phase using FIR filters.
14.srt	00:13:11.820 --> 00:13:15.530	Whereas, in IR filters we will not achieve it, but phase may be made approximately linear pass band or other band in this case.
14.srt	00:13:16.310 --> 00:13:27.550	So, to conclude on the IR filter biquad section we will see that choice of IL filter structure matters for both analysis and implementation.
14.srt	00:13:28.200 --> 00:13:38.010	So, keep roots computed by filter design algorithms and then polynomial deflation that is routing reliable in floating point.
14.srt	00:13:38.580 --> 00:13:43.770	So, we will it is going to have polynomial inflation that is expansion.
14.srt	00:13:44.160 --> 00:13:46.110	may degrade the roots of it.
14.srt	00:13:46.610 --> 00:13:50.540	So, more than 20 IR filter structures in use.
14.srt	00:13:51.000 --> 00:13:56.610	So, that is direct forms and cascade of bicats are very common choices.
14.srt	00:13:57.180 --> 00:14:02.330	So, why we go for the cascade in our IR filter?
14.srt	00:14:03.050 --> 00:14:06.440	So, we will discuss it in a with a problem later.
14.srt	00:14:06.440 --> 00:14:10.960	So, that you will become convinced that why I have to go for the cascade section.
14.srt	00:14:14.860 --> 00:14:29.660	In the direct form IR expand zeros and poles it may become unstable for large order filters usually order greater than 12th order what we call it due to degradation in pole locations from polynomial expansion.
14.srt	00:14:30.030 --> 00:14:38.240	So, most of the MATLAB when we design our filter we use the MATLAB FDA toolbox.
14.srt	00:14:38.570 --> 00:14:45.180	So, it provides us we call it as stable filter coefficients.
14.srt	00:14:45.470 --> 00:14:49.290	will be using it in our implementation.
14.srt	00:14:49.290 --> 00:14:52.730	Coming with the further conclusion.
14.srt	00:14:52.730 --> 00:15:00.420	So, cascade of by quads that is second order sections only poles and zeros of second order sections expanded.
14.srt	00:15:00.420 --> 00:15:12.170	So, what happens to this if it is a direct form if there is any quantization in my polar 0.
14.srt	00:15:12.580 --> 00:15:18.550	So, the complete structures becomes may become unstable whereas, in the by quads.
14.srt	00:15:19.000 --> 00:15:30.520	If any of this pulses 0s is quantized only it is limited to that structure and it will not affect the other order second order sections.
14.srt	00:15:31.450 --> 00:15:35.880	Biquets placed in order of ascending quality factors.
14.srt	00:15:35.940 --> 00:15:47.490	So, this is going to become an optimization problem one has to look at it and then see that how I can achieve this and that is the way the biquets section will be.
14.srt	00:15:49.570 --> 00:15:55.200	optimal ordering of bike wads requires that is what it says exhaustive search.
14.srt	00:15:55.320 --> 00:16:03.840	And when filter order is fixed there exist no solution, one solution or an infinite number of solutions.
14.srt	00:16:04.050 --> 00:16:16.150	So, if you fix the order we may not have a solution or I may have one solution this is the way I have to connect all of them.
14.srt	00:16:16.670 --> 00:16:24.210	If it is a second order I do not have any choice only one bike wad section I can have it, but if it is more order.
14.srt	00:16:24.450 --> 00:16:52.400	is more than 2 then I can have if it is equal to 4 I may have in that case 2 options this can be first that can be later, but still my poles and zeros can I can alter from the sections and then see that I achieved the what I will say optimal filter structure as well as my instability is going to be much more reduced.
14.srt	00:16:53.120 --> 00:16:55.770	So, minimum order design not always.
14.srt	00:16:56.170 --> 00:16:58.030	most efficient in this case.
14.srt	00:16:58.510 --> 00:17:02.810	So, efficiency is going to depends on the target implementation.
14.srt	00:17:03.550 --> 00:17:12.730	Consider power of 2 coefficient design always and efficient designs may require search of infinite design space.
14.srt	00:17:13.140 --> 00:17:16.300	So, these are the drawbacks of IR filter design.
14.srt	00:17:17.390 --> 00:17:22.400	So, with this we will be still going ahead to design our IR filter.
14.srt	00:17:22.750 --> 00:17:28.220	So, what are the basic structures we need for.
14.srt	00:17:30.299 --> 00:17:32.230	designing our filters.
14.srt	00:17:32.660 --> 00:17:40.049	So, as previously we have seen the thing, but still to give a feel of that how a multiplier looks.
14.srt	00:17:40.309 --> 00:17:53.240	So, we will be putting an arrow and then if I say k then it is nothing, but k into x of n. And when we say adder accumulator is there it can be represented with sigma or plus sign also.
14.srt	00:17:53.660 --> 00:18:01.160	Then x of n and then w of n is the weight then we will be adding both of them x of n plus w of n.
14.srt	00:18:01.920 --> 00:18:08.670	If it is a delay of 1 time basically it can be represented by a square box.
14.srt	00:18:09.069 --> 00:18:14.000	So, you can either specify it as capital D here or Z minus 1.
14.srt	00:18:14.390 --> 00:18:17.390	So, then we know that it is a delay element.
14.srt	00:18:17.390 --> 00:18:21.710	So, x of n is the input output will be x of n minus 1.
14.srt	00:18:22.640 --> 00:18:29.240	So, coming to filter structures just now we said that comparison we did how the order of the filter is going to be.
14.srt	00:18:29.670 --> 00:18:32.279	So, here we are seeing.
14.srt	00:18:33.220 --> 00:18:36.960	second order biquad section for IR filter.
14.srt	00:18:37.440 --> 00:18:46.470	So, you will be seeing that it is a second order for the same magnitude response we need here FIR filter section is shown.
14.srt	00:18:46.500 --> 00:18:52.190	The equation for this is y of n is k is equal to 0 to n minus 1.
14.srt	00:18:52.980 --> 00:19:03.180	As an example in the table we have taken capital N is equal to 30, then how many structures and other things what it is required will be.
14.srt	00:19:03.409 --> 00:19:04.299	seeing in a while.
14.srt	00:19:05.049 --> 00:19:20.169	So, whereas, for the IR filter so, you will be separating this is my W of n centre point and then second order section what we have considered here.
14.srt	00:19:20.559 --> 00:19:30.210	So, W of n is given by x of n into x of n minus b 1 into W of n minus 1 minus b 2 into W of n minus 2.
14.srt	00:19:30.730 --> 00:19:32.529	What happens to my Y of n?
14.srt	00:19:34.930 --> 00:19:42.210	Y of n is nothing, but A naught into W of n minus A 1 into W of n minus 1 minus 8 into W of n minus 2.
14.srt	00:19:42.900 --> 00:19:51.150	So, since we have considered this is my feedback section and this is my feed forward section.
14.srt	00:19:51.589 --> 00:19:55.309	So, this is my whole equation of second order I a filter.
14.srt	00:19:55.859 --> 00:20:00.480	So, we will be seeing how many multiplications are required.
14.srt	00:20:00.529 --> 00:20:05.240	So, for the same magnitude what we said.
14.srt	00:20:05.690 --> 00:20:16.809	So, IR filter needs order 2 whereas, FIR filter needs 12th order then number of multiplications in this is going to be 12 h 0 to h 11.
14.srt	00:20:16.809 --> 00:20:21.539	And then whereas, in the IR filter because it is second order.
14.srt	00:20:21.930 --> 00:20:31.150	So, we will be seeing that number of multiplications in this is going to be 1, 2, 3, 4 and then 5.
14.srt	00:20:32.200 --> 00:20:34.079	So, that is what we represent.
14.srt	00:20:34.329 --> 00:20:36.329	How many additions do we needed?
14.srt	00:20:36.990 --> 00:20:50.030	Whereas, in this case we need 11 additions whereas, IR needs 4 additions you can count on the thing because we assume the addition and subtraction as equivalent.
14.srt	00:20:50.340 --> 00:20:55.540	So, you have 1 here 2 3 and then 4 additions.
14.srt	00:20:56.330 --> 00:21:00.670	And storage locations that is including coefficients and data.
14.srt	00:21:01.120 --> 00:21:05.140	So, how many we need it that is what one has to count.
14.srt	00:21:05.420 --> 00:21:07.019	We have 2.
14.srt	00:21:07.230 --> 00:21:23.370	12 multiplications and we have 12 what we say is coefficients for the h of n what we need it and 12 input what we need it and 1 output what we are going to have the thing.
14.srt	00:21:23.370 --> 00:21:38.940	If current sample is not consider x of n then we will be needing 24 locations to store both coefficient and data output we assume that it is going out of the memory or out of the port.
14.srt	00:21:38.940 --> 00:21:43.590	So, we need not have to have a storage for it whereas, in the IR filter.
14.srt	00:21:43.990 --> 00:22:01.010	As you will be seeing that we have 5 coefficients here basically and then the delay elements w n minus 1 n minus 2 and then what we have one of the input x of n what we needed.
14.srt	00:22:01.580 --> 00:22:11.630	So, you will be seeing that 5 plus 2 7 plus 1 8 is the number of locations that is memory what we need for this structure.
14.srt	00:22:11.630 --> 00:22:12.560	As the order goes.
14.srt	00:22:15.390 --> 00:22:24.290	very high in FIR filter you will be seeing that number of multiplications addition increase even the storage will be increasing it.
14.srt	00:22:24.880 --> 00:22:29.600	So, how we are going to consider the design stages for our digital filter.
14.srt	00:22:30.180 --> 00:22:45.370	So, we are going to start first we will be specifying the performance first and then calculate the filter coefficients and then if everything is according to our wish.
14.srt	00:22:45.880 --> 00:22:57.310	Then, we will go further realizing structure what we have to select and then see that finite word length effects analysis and solution.
14.srt	00:22:58.019 --> 00:23:10.300	Once we have selected that whether it is going to affect our input and output magnitude and then frequency responses or it becomes a unstable filter.
14.srt	00:23:10.970 --> 00:23:17.370	So, if everything is met then we will be going for hardware and our software implementation.
14.srt	00:23:17.870 --> 00:23:24.009	plus testing and then if it is not met here we will go for the redesign of it.
14.srt	00:23:24.410 --> 00:23:36.940	So, if any one of the stage here the finite word length is not met we can go and then fine tune any one of these stages.
14.srt	00:23:37.180 --> 00:23:43.160	So, if everything is feasible then we will stop our design.
14.srt	00:23:45.009 --> 00:23:48.539	So, as we said some of the structures also matters.
14.srt	00:23:48.809 --> 00:23:51.430	So, few FIR structures you will be seeing it.
14.srt	00:23:52.000 --> 00:23:52.480	effect.
14.srt	00:23:52.480 --> 00:24:00.029	This one gives our linear phase as you will be seeing that we said it is a symmetric or anti symmetric what we are going to take the thing.
14.srt	00:24:00.480 --> 00:24:16.000	So, here you will be seeing that this is h of 0 that is x of n and then x of what is the delay here you are going to get it.
14.srt	00:24:16.329 --> 00:24:20.309	So, 1, 2, 3, 4, 5 and then 6.
14.srt	00:24:20.309 --> 00:24:27.769	So, x of n and x of n minus 6 is combined and then you will be multiplying with h of 0.
14.srt	00:24:28.350 --> 00:24:36.400	The same way you can calculate which are the ones getting multiplied and then you will be summing up then you will get a linear phase.
14.srt	00:24:36.800 --> 00:24:41.330	So, if you want to use the transversal as you will be seeing that.
14.srt	00:24:41.660 --> 00:24:58.140	So, h of 0 to h of 6 are my impulse response and then x of n to x of n minus 6 will be the input and when you feed it into the thing.
14.srt	00:24:58.200 --> 00:25:00.440	So, you will be seeing single summation.
14.srt	00:25:00.930 --> 00:25:04.779	So, you may overflow or underflow in this case.
14.srt	00:25:05.130 --> 00:25:07.259	So, y of n will be the output.
14.srt	00:25:07.599 --> 00:25:09.789	How much tolerance you are going to give it?
14.srt	00:25:09.849 --> 00:25:13.319	As I said we are using the 40 bit adder.
14.srt	00:25:31.529 --> 00:25:33.199	So, the order of the filter in our sigma can usually we represent y of n equal to sigma k is equal to 0 to n minus 1 x of n minus k into H of k what we have it.
14.srt	00:25:34.059 --> 00:25:40.549	So, this value n can be up to 255.
14.srt	00:25:41.490 --> 00:25:48.039	So, which is in power of 2 if you take it 2 power 8 0 to 255.
14.srt	00:25:48.039 --> 00:25:51.559	So, it becomes 256 which is equivalent to 2 power 8.
14.srt	00:25:51.939 --> 00:25:58.709	So, what we say is if the our adder is 16 plus 16 bit what we are going to add.
14.srt	00:26:03.960 --> 00:26:12.509	or our registers are 32 bit I can allow a overflow of 8 more bit that is 32 plus 8.
14.srt	00:26:12.889 --> 00:26:16.279	We call this as the guard bits in our accumulator.
14.srt	00:26:16.809 --> 00:26:26.889	So, this we call it as a guard bit in our DSP processors to take care of 40 bit addition.
14.srt	00:26:27.180 --> 00:26:35.419	So, up to 255 that may not we may not have a overflow beyond that we may overflow in the.
14.srt	00:26:36.210 --> 00:26:37.490	FIR design.
14.srt	00:26:37.519 --> 00:26:46.150	So, one has to take care as we said it is almost stable, but the order goes very high then it may become unstable.
14.srt	00:26:46.920 --> 00:26:52.380	So, what are the DSP errors we are going to encounter in our design.
14.srt	00:26:52.829 --> 00:26:59.549	So, it has been listed main errors in DSP are first is our ADC quantization error.
14.srt	00:27:00.269 --> 00:27:05.970	So, this results from representing the input data by a limited number of bits.
14.srt	00:27:06.389 --> 00:27:16.539	So, I can choose 12 bit ADC, 10 bit, 8 bit depends on what type of ADC you want to have it.
14.srt	00:27:17.329 --> 00:27:25.230	And then next is as we have to have a coefficient to be represented in fixed point.
14.srt	00:27:25.539 --> 00:27:28.559	So, I am going to have the quantization error here.
14.srt	00:27:29.250 --> 00:27:35.829	So, that is what it says represent coefficients are DSP parameters by finite number of bits.
14.srt	00:27:36.359 --> 00:27:41.450	So, the coefficients a k and b k from stage 2 of filter design.
14.srt	00:27:41.900 --> 00:27:51.730	For example, are normally of very high precision, but in a DSP processor they must be quantized typically to the processor word length.
14.srt	00:27:53.150 --> 00:28:00.279	And then next is once I have done the coefficient quantization error I have looked in, next is overflow error.
14.srt	00:28:00.799 --> 00:28:08.079	As we are talking about addition or subtraction can give us overflow or an underflow.
14.srt	00:28:08.619 --> 00:28:12.220	So, we say addition of two large numbers of the same sign.
14.srt	00:28:12.669 --> 00:28:17.269	which produces a result that exceeds our permissible word length.
14.srt	00:28:17.769 --> 00:28:20.129	This is one more error what we have to look in.
14.srt	00:28:20.720 --> 00:28:22.809	The last one is the round off error.
14.srt	00:28:23.460 --> 00:28:24.569	So, what is this?
14.srt	00:28:24.569 --> 00:28:33.750	This is caused when the result of a multiplication is rounded or truncated to the discrete value or permissible word length.
14.srt	00:28:34.569 --> 00:28:38.269	So, when I do multiplication 16 bit into 16 bit.
14.srt	00:28:38.269 --> 00:28:46.159	So, I will be resulting in 32 bit, but I would not be able to represent that complete 32 bit as output.
14.srt	00:28:46.159 --> 00:28:48.750	So, I will be truncating them or rounding.
14.srt	00:28:49.420 --> 00:28:51.960	them to 16 bit and then I will be storing.
14.srt	00:28:51.960 --> 00:28:57.789	So, we have taken one example already in our fixed point multiplication and addition.
14.srt	00:28:58.509 --> 00:28:59.590	So, these are the errors.
14.srt	00:28:59.590 --> 00:29:05.470	So, first we will see how we are going to have ADC is going to cause as an error.
14.srt	00:29:05.470 --> 00:29:13.200	So, we know that in the analog domain the values are represented in continuous way.
14.srt	00:29:13.200 --> 00:29:18.539	So, my ADC input voltage what we have it.
14.srt	00:29:21.030 --> 00:29:30.080	on the x axis and y axis will represent what is the value or the depends on the number of bits what I have it.
14.srt	00:29:30.410 --> 00:29:32.670	So, I will be representing to one of them.
14.srt	00:29:33.120 --> 00:29:43.480	So, we know that so, from this 1 voltage to 2 voltage I will be representing with the same value and I will be changing it.
14.srt	00:29:43.780 --> 00:29:47.440	So, this is the staircase what you can look at it.
14.srt	00:29:51.970 --> 00:29:59.450	So, what we want ideal converter finite number of bits we say that ADC characteristics is one of the thing what it required.
14.srt	00:30:00.310 --> 00:30:05.790	So, what we say is it accepts analog input and generates a digital representation.
14.srt	00:30:06.290 --> 00:30:08.650	So, what is the quantization step?
14.srt	00:30:08.650 --> 00:30:10.110	We call it as delta.
14.srt	00:30:10.590 --> 00:30:17.080	So, it is going to be minus 1 LSB bit what it is going to be.
14.srt	00:30:17.120 --> 00:30:24.150	So, if we have full scale input range is represented as this thing minus 0.5 delta 2.
14.srt	00:30:25.410 --> 00:30:27.710	2 power n minus 0.5 times delta.
14.srt	00:30:27.710 --> 00:30:35.960	So, the total will be minus 1 what we are going to have LSB representation.
14.srt	00:30:35.960 --> 00:30:42.260	So, n is the number of bits that one processor has.
14.srt	00:30:42.410 --> 00:30:55.380	As an example if we assume it is a 3 bit processor, then the full voltage scale what we can represent with this representation is minus 0.5 delta 2.
14.srt	00:30:56.220 --> 00:30:59.300	So, this is the full scale range of our ADC.
14.srt	00:30:59.300 --> 00:31:04.290	To show that how the quantizer in expanded form.
14.srt	00:31:04.290 --> 00:31:06.640	So, what is this delta?
14.srt	00:31:06.640 --> 00:31:15.760	So, you will be seeing that from this point to this point this is we assume it as minus 0.5 and this side is minus 0.5.
14.srt	00:31:15.760 --> 00:31:21.870	So, which will be giving me delta.
14.srt	00:31:21.870 --> 00:31:27.860	So, that is what we say that is the error what we will be encountering from our ADC.
14.srt	00:31:28.580 --> 00:31:29.680	ADC quantization.
14.srt	00:31:30.230 --> 00:31:34.060	So, this is represents a zoom in staircase thing.
14.srt	00:31:34.550 --> 00:31:53.760	So, if we consider the pdf of quantization error, then I will be representing it as minus 1 by delta to 1 by delta and then this is your expected value what you will be getting it here p naught e which is what we call it as 1 by delta.
14.srt	00:31:54.560 --> 00:31:59.210	So, coming with the quantization error how we are going to calculate it.
14.srt	00:31:59.620 --> 00:32:00.970	So, we have to calculate.
14.srt	00:32:01.130 --> 00:32:02.330	take it as a noise.
14.srt	00:32:02.590 --> 00:32:09.290	So, will be noise variance sigma quantization noise squared what will be calculating.
14.srt	00:32:09.700 --> 00:32:13.890	So, which is nothing, but expected value of our error squared.
14.srt	00:32:13.890 --> 00:32:22.440	So, when we equate it is minus delta by 2 to delta by 2 into 1 by delta into E squared into delta E basically.
14.srt	00:32:31.780 --> 00:32:39.490	So, which is minus which is equivalent to 1 by delta into e cube by 3 and then you are substituting between minus delta by 2 to delta by 2.
14.srt	00:32:39.980 --> 00:32:44.680	So, when you expand it you will get it as delta square by 12.
14.srt	00:32:45.280 --> 00:33:07.510	So, we say that quantization noise sigma squared is given by or power is given by delta square by 12 and then we assume quantization noise we that is voltage quantization noise rms value is given as delta by square root of 12.
14.srt	00:33:08.210 --> 00:33:22.740	So, that is we say RMS value of a full scale sinusoidal input is given by if your maximum signal RMS value is represented as 2 power n by 2 divided by root 2 into delta.
14.srt	00:33:23.220 --> 00:33:30.290	Then we will be calculating maximum signal to noise ratio this is my signal and then this is my noise.
14.srt	00:33:30.700 --> 00:33:35.630	So, it is 20 log base what we will be calculating it.
14.srt	00:33:35.940 --> 00:33:38.620	This is my signal this is my noise.
14.srt	00:33:38.940 --> 00:33:40.660	So, when we equate this.
14.srt	00:33:40.910 --> 00:33:48.570	it approximately comes out as 20 log root of 6 by 2 plus 20 n log 2.
14.srt	00:33:48.760 --> 00:33:59.950	So, if we approximate it will be 1.76 plus 6.02 n. Accurate this equation is for n is greater than 3.
14.srt	00:34:11.559 --> 00:34:24.579	So, n is the effective number of bits what we are going to have it in our So, it is number of bits what it says is maximum signal to noise ratio minus 1.76 by 6.02 what will be getting the thing.
14.srt	00:34:24.579 --> 00:34:32.999	So, what it says is real converters do not quite achieve this performance due to other sources of error.
14.srt	00:34:32.999 --> 00:34:44.829	So, only we have taken signal to noise ratio there may be other errors we may like electronic noise or deviations from the ideal quantization level which will cause the error more.
14.srt	00:34:47.380 --> 00:34:49.870	To calculate for n is equal to 8.
14.srt	00:34:50.590 --> 00:35:06.750	So, what we are going to get signal to quantization noise ratio is going to be 50 dB what I can achieve 8 bit this one if I have n is equal to 8 then what I will be achieving is the 50 dB.
14.srt	00:35:07.160 --> 00:35:20.120	If n is equal to 12 I can achieve 74 dB signal to quantization noise ratio when it is 16 bits n then it will be 98 dB what I can achieve and if it goes to 20 bits.
14.srt	00:35:20.570 --> 00:35:23.369	what I can achieve is 122 dB.
14.srt	00:35:23.530 --> 00:35:29.150	CD quality what I was telling is approximately 90 dB what we want to have it.
14.srt	00:35:29.490 --> 00:35:35.700	So, we can achieve with 16 bit that quality signal to noise ratio.
14.srt	00:35:36.460 --> 00:35:39.170	So, coming we will work out a problem.
14.srt	00:35:39.170 --> 00:35:46.099	So, whether you have understood our dynamic range and then what should be number of bits required.
14.srt	00:35:46.539 --> 00:35:53.329	So, if the dynamic range of that is DR what we call it of an analog signal to be.
14.srt	00:35:53.869 --> 00:36:04.070	Digitized by our A to D converter is maintained at 60 dB by an automatic gain control amplifier preceding the A to D converter.
14.srt	00:36:04.570 --> 00:36:06.430	So, what are the things we have to determine?
14.srt	00:36:06.430 --> 00:36:13.570	One is minimum number of bits required in the A to D converter and what will be a signal to quantization noise ratio.
14.srt	00:36:13.570 --> 00:36:16.910	So, this is what we have to find out.
14.srt	00:36:17.019 --> 00:36:19.070	So, just we will solve the problem.
14.srt	00:36:19.599 --> 00:36:23.039	So, our dynamic range is given as 60 dB what we have to achieve.
14.srt	00:36:23.200 --> 00:36:25.430	So, we have the equation 20 log.
14.srt	00:36:25.940 --> 00:36:33.130	are log base 10 VFSR is the full voltage what we will be considering divided by delta.
14.srt	00:36:33.659 --> 00:36:40.800	So, in this case we will take it as n into delta where n is the number of quantization intervals what I want to have it.
14.srt	00:36:41.289 --> 00:36:53.730	So, when we substitute this it is going to be 20 log 10 n. So, n is equal to 10 power substitute them 60 by 20 which is going to give me 1000.
14.srt	00:36:54.250 --> 00:37:01.170	So, you know that minimum number of bits required in ADC to code n plus 1 always we take it.
14.srt	00:37:01.630 --> 00:37:11.590	quantization levels to n plus 1 different binary numbers is n should be greater than or equal to our log base to n plus 1.
14.srt	00:37:11.920 --> 00:37:15.670	So, if we do that log base to 1000 plus 1.
14.srt	00:37:15.989 --> 00:37:21.260	So, we say that what I need is 10 bits what I needed.
14.srt	00:37:21.719 --> 00:37:28.230	So, 2 per 10 we know that it is 1024 bits what I will be representing with that is the nearest.
14.srt	00:37:28.679 --> 00:37:34.039	So, now, we have to calculate signal to quantization noise ratio with number of bits selected as 10.
14.srt	00:37:34.420 --> 00:37:36.820	So, if you substitute 6.02 into n.
14.srt	00:37:37.610 --> 00:37:39.430	plus 1.75 dB.
14.srt	00:37:39.430 --> 00:37:46.670	So, which is substitute the thing what I will be getting is signal to quantization noise ratio of 61.77 dB.
14.srt	00:37:46.670 --> 00:38:01.630	So, the maximum what we can achieve what it says is number of bits if we substitute in this equation maximum signal to noise ratio minus 1.6 divided by 6.02.
14.srt	00:38:01.630 --> 00:38:08.060	So, if you see with this equation also you will be getting it as 9.67 bits what I needed.
14.srt	00:38:08.060 --> 00:38:10.930	So, the nearest one is 10 bits.
14.srt	00:38:14.170 --> 00:38:18.940	So, both way working out and using this equation what we had it.
14.srt	00:38:19.300 --> 00:38:22.690	So, both of them are giving us 10 bits.
14.srt	00:38:22.920 --> 00:38:30.050	So, you can try which is going to be less than 3 bits whether they are going to match or not ok.
14.srt	00:38:30.500 --> 00:38:35.630	So, this is what we cover in today's class.
14.srt	00:38:35.910 --> 00:38:44.139	So, we will see how the filter structure is going to affect our frequency component part of it center frequency.
14.srt	00:38:44.490 --> 00:38:45.610	in the next class.
14.srt	00:38:45.850 --> 00:38:46.230	Thank you.
28.srt	00:00:01.219 --> 00:00:17.809	Welcome back to real time digital signal processing course.
28.srt	00:00:17.809 --> 00:00:27.160	Today we will discuss continue with our fast Fourier transform.
28.srt	00:00:31.060 --> 00:00:48.510	So, in the last class we discussed about how to derive the equations from RDFT and then we drew the butterfly structure and then said that how our computation can be improved using FFT.
28.srt	00:00:48.850 --> 00:00:54.880	So, today we will see that what are the finite word length effects in FFT.
28.srt	00:00:55.370 --> 00:01:01.189	So, what are the one is the first one is we can have we are going to have round off errors.
28.srt	00:01:01.600 --> 00:01:07.509	So, which are produced when the product WKB as we can see is truncated or.
28.srt	00:01:08.040 --> 00:01:09.930	rounded to the system word length.
28.srt	00:01:11.469 --> 00:01:20.030	We have been seeing that when it is getting multiplied by this a butterfly structure will be going to be truncated or rounded.
28.srt	00:01:20.740 --> 00:01:23.680	Next one is what we have is the addition.
28.srt	00:01:24.100 --> 00:01:26.450	So, which is going to cause overflow.
28.srt	00:01:27.060 --> 00:01:27.950	So, errors.
28.srt	00:01:27.950 --> 00:01:33.790	So, which results when the output of a butterfly exceeds the permissible word length.
28.srt	00:01:34.290 --> 00:01:36.450	As you can see there is a addition.
28.srt	00:01:36.980 --> 00:01:37.660	So, when it.
28.srt	00:01:38.620 --> 00:01:42.460	exceeds the limit then we will have the overflow.
28.srt	00:01:43.130 --> 00:01:56.550	The other one is Rwk that is coefficients quantization errors this is the third one what we have it which result from representing that twiddles factors using a limited number of bits.
28.srt	00:01:57.189 --> 00:02:06.890	So, because we cannot represent Wk cell for infinite number of bits are not available depending on number of bits.
28.srt	00:02:06.890 --> 00:02:09.420	So, we have to truncate our twiddles factors.
28.srt	00:02:09.420 --> 00:02:19.300	So, that will be causing us coefficients quantization or sign and cause function what we are going to store them.
28.srt	00:02:19.870 --> 00:02:22.830	So, we will see first round of errors.
28.srt	00:02:23.200 --> 00:02:37.189	So, what is it we have we have taken here x naught plus j y naught instead of representing it as a we have taken split as x is input and this is x 1 plus j y 1.
28.srt	00:02:37.849 --> 00:02:43.069	So, this we have our twiddle factor is cos plus j sin function.
28.srt	00:02:43.069 --> 00:02:49.509	So, you are seeing the multiply sign and this is going to be multiplied by minus 1.
28.srt	00:02:50.139 --> 00:02:54.939	And, our output is going to be x naught dash plus j y naught dash.
28.srt	00:02:55.349 --> 00:03:19.740	So, what we are going to assuming that each butterfly generates identical, but uncorrelated errors the maximum noise power at each FFT output is approximately given as equivalent or W n it is nothing, but e power minus j 2 pi by n nothing, but cos 2 pi by n minus j sin 2 pi by n.
28.srt	00:03:20.459 --> 00:03:28.819	So, we represent cos function as c and then a sin function as s and we are taking the negative sin inside.
28.srt	00:03:28.849 --> 00:03:46.859	So, it is going to be c plus j minus of s and then we know that our a is cos into x 1 minus of minus sin function into y 1 same way our b is going to be represented in this fashion.
28.srt	00:03:46.899 --> 00:03:51.429	And then we know that x naught dash is equal to.
28.srt	00:03:53.069 --> 00:04:04.369	are real part x naught plus a what we have it a is given by this equation and y naught dash is nothing, but y naught plus b given by this equation.
28.srt	00:04:04.899 --> 00:04:10.869	And x 1 dash will be x naught minus a and y 1 dash is going to be y naught minus b.
28.srt	00:04:11.189 --> 00:04:14.849	You can verify whether we have got these equations correctly or not.
28.srt	00:04:15.539 --> 00:04:16.649	Then what happens?
28.srt	00:04:16.889 --> 00:04:24.759	Our butterfly computation requires four real multiplication what we have you can see the thing here what we need it.
28.srt	00:04:25.169 --> 00:04:33.029	So, 1, 2, 3 and then 4 real multiplications and 6 real additions.
28.srt	00:04:33.519 --> 00:04:41.679	So, how many of them you can count here this is 1, 2, 3 and then 4.
28.srt	00:04:42.089 --> 00:04:51.609	So, we have another 2 coming from your these 2 a and b here 4 plus 2 what we needed.
28.srt	00:04:51.879 --> 00:04:56.199	So, 6 real additions taking into account.
28.srt	00:04:56.769 --> 00:05:05.619	or subtraction is equivalent to addition that has to be kept in your back of mind whenever we do this additions.
28.srt	00:05:06.119 --> 00:05:15.539	And next what we see is then what happens to our round off noise power that is we call it as variance at the output of each butterfly is going to be given by.
28.srt	00:05:15.879 --> 00:05:20.339	So, we have derived our noise power as q squared by 12.
28.srt	00:05:20.739 --> 00:05:29.869	So, because we have 4 real multiplication so it is going to be 4 into q squared by 12 which is nothing but 1 by 3.
28.srt	00:05:30.109 --> 00:05:40.779	And, then we are substituting q is equal to 2 to the power of minus b minus 1 in terms of how many bits it becomes 1 by 3 into 2 to the power of minus 2 into b minus 1.
28.srt	00:05:41.579 --> 00:05:44.789	And then this is at each butterfly.
28.srt	00:05:45.149 --> 00:05:50.969	So, then we have how many butterflies we are going to have.
28.srt	00:05:51.370 --> 00:06:00.870	So, we approximate it as although we have n minus 1 is the thing number of stages what we are going to have it.
28.srt	00:06:01.339 --> 00:06:12.219	we have rounded it off to n. So, the noise power for n stages is going to be sigma naught squared is nothing, but n into sigma b squared.
28.srt	00:06:12.219 --> 00:06:23.049	So, when we substitute our butterfly sigma b squared which becomes n by 3 into 2 to the power of minus 2 minus b minus 1.
28.srt	00:06:23.779 --> 00:06:29.059	So, we need total number of butterflies required to produce an output sample is.
28.srt	00:06:29.539 --> 00:06:31.389	So, we will be seeing n by 2.
28.srt	00:06:31.789 --> 00:06:35.539	plus n by 4 so on 2 plus 1.
28.srt	00:06:35.949 --> 00:06:48.859	So, when you take the series expansion so you will be seeing that it is nothing but 2 to the power of m minus 1 no 2 to the power of m minus 2 so on plus 2 plus 1.
28.srt	00:06:49.219 --> 00:06:57.559	So, when you substitute it so which becomes equivalent to n minus 1 butterflies are required.
28.srt	00:07:04.139 --> 00:07:08.609	So, which was approximated as n. So, now you will be seeing that how the error is going to have its impact.
28.srt	00:07:09.019 --> 00:07:12.749	So, here you want to compute x of 0.
28.srt	00:07:13.129 --> 00:07:15.319	So, how many butterflies we need it?
28.srt	00:07:15.879 --> 00:07:18.419	We will we have to go back from here ok.
28.srt	00:07:18.729 --> 00:07:38.669	So, I need one butterfly here and the previous stage to compute this and this output here one butterfly is required in the stage 2 and this is the other butterfly required to compute the output of W this thing we need W n 0 in this case.
28.srt	00:07:39.029 --> 00:07:40.409	So, 3 butterflies.
28.srt	00:07:40.779 --> 00:07:46.639	And, in the previous case you will be seeing that we need all the 4 butterflies here.
28.srt	00:07:47.029 --> 00:07:52.839	So, this is 4 plus 2 6 plus 1 7.
28.srt	00:07:53.359 --> 00:07:58.929	So, it is nothing but n minus 1 butterflies contribute for 1 output.
28.srt	00:07:59.269 --> 00:08:04.249	This is x 0 if you take x 4 also what you will be needing the same thing.
28.srt	00:08:04.669 --> 00:08:09.699	So, as an further example if you take x of 2 ok.
28.srt	00:08:09.849 --> 00:08:10.399	This is x.
28.srt	00:08:10.609 --> 00:08:13.539	x0 and this is going to be x1 ok.
28.srt	00:08:13.999 --> 00:08:17.749	This is going to be x2 and this is x6 will be the output.
28.srt	00:08:18.089 --> 00:08:27.039	So, you will be seeing when you count how many butterflies are required you will be needing n minus 1 butterflies to compute 1 output.
28.srt	00:08:27.579 --> 00:08:39.709	So, that is the reason why what we call it as that is when we increase n that is doubling n which is equivalent to adding a stage to FFT.
28.srt	00:08:40.239 --> 00:08:42.169	So, that is what is going to happen.
28.srt	00:08:42.620 --> 00:08:50.799	doubles D noise power to retain the same noise power we increase the word length by 1 bit.
28.srt	00:08:51.199 --> 00:09:03.509	So, we will be seeing that sigma naught squared is nothing, but we are doubling the n 2 into n divided by 3 into 2 power 2 b and then increasing 1 bit.
28.srt	00:09:04.129 --> 00:09:08.909	So, it becomes 2 b minus 1 plus 1 which is going to be 2 power 2 b.
28.srt	00:09:09.519 --> 00:09:10.459	Then what happens?
28.srt	00:09:10.750 --> 00:09:14.220	The real and imaginary parts of our input sequence are.
28.srt	00:09:14.819 --> 00:09:22.379	uncorrelated and that each has an amplitude density that is uniform between minus 1 and plus 1.
28.srt	00:09:22.909 --> 00:09:33.470	Then our sigma x squared input noise power is nothing but 2 square divided by 12 which is nothing but 1 by 3.
28.srt	00:09:33.959 --> 00:09:42.329	So, we can equate it to signal to noise ratio sigma x squared is equal to n times sigma x squared.
28.srt	00:09:43.000 --> 00:09:44.789	This is sigma.
28.srt	00:09:45.149 --> 00:09:56.299	So, then signal to noise ratio sigma x squared by sigma naught squared is equal to 2 to the power of 2 into b minus 1.
28.srt	00:09:56.870 --> 00:10:08.259	So, what the note we are going to carry from here for FFT algorithm a double length accumulator does not help us reduce round off noise.
28.srt	00:10:08.559 --> 00:10:16.450	Since the outputs of the butterfly computation must be stored in b bit registers at the output of each stage.
28.srt	00:10:16.979 --> 00:10:20.799	That is what the note what will be carrying from this.
28.srt	00:10:21.309 --> 00:10:36.429	Just like in FIR filter by increase then the length of our accumulator we could hold on to the result till the end of it, but here we would not be able to do it because we have to use it for the next stage.
28.srt	00:10:37.079 --> 00:10:41.589	So, now, we will see how the overflow is going to cause error.
28.srt	00:10:42.250 --> 00:10:48.579	So, how we can avoid it overflow cannot be avoided.
28.srt	00:10:48.939 --> 00:10:49.870	So, how you.
28.srt	00:10:50.419 --> 00:10:55.000	So, how can by scaling and other things how we can avoid the overflow errors?
28.srt	00:10:55.029 --> 00:11:09.379	There are three methods one is we can do a static scaling that is dividing the input at first stage by n that is a maximum this thing division what we are going to do it or any stage by 2.
28.srt	00:11:10.070 --> 00:11:14.679	So, that way we can incorporate the static scaling.
28.srt	00:11:14.720 --> 00:11:16.750	The other method what we have is.
28.srt	00:11:20.959 --> 00:11:36.959	that is basically based on the dynamic scaling that is dividing the input at any stage by 2, if the largest absolute input value is greater than or equal to less or equal to 0.5 ok.
28.srt	00:11:37.849 --> 00:11:45.740	So, then what happens that is we are taking the norm of magnitude of x of k which is less than 1.
28.srt	00:11:45.740 --> 00:11:51.469	So, 0 to less than or equal to k which is less than or equal to n minus 1.
28.srt	00:11:52.590 --> 00:11:57.480	So, how you will be taking the thing to find the norm.
28.srt	00:11:57.639 --> 00:12:08.419	So, will be equation is nothing, but n is equal to 0 to n minus 1 x of n to w k n. So, we have to take the norm of it, which is less than or equal to.
28.srt	00:12:08.750 --> 00:12:21.740	So, we have assumed that twiddle factors have been scaled and then that within the limit, then it becomes the magnitude of x of n by scaling my input then.
28.srt	00:12:22.209 --> 00:12:31.509	that is 0 less than or equal to k less than or equal to n minus 1 I can overflow error can be avoided.
28.srt	00:12:32.449 --> 00:12:47.159	Just like our FIR filters so if we have more than n minus 1 stages the addition what we can take care of in our accumulator by having guard bits and then later on we have to.
28.srt	00:12:52.820 --> 00:12:54.649	do the scaling ok.
28.srt	00:12:54.899 --> 00:13:23.019	So, the first one that is what we said is static scaling that is dividing the input at any stage by n. So, what happens to the noise to signal ratio increases as n squared or we call it as 1 bit per stage that is if n is doubled corresponding to adding one additional stage to the FFT that is what we just now saw it.
28.srt	00:13:23.470 --> 00:13:29.519	Then to maintain the same signal to noise ratio one bit must be added to our register length.
28.srt	00:13:30.029 --> 00:13:34.309	So, this is our equation what we have it.
28.srt	00:13:34.799 --> 00:13:38.789	So, we will be adding one more bit to that.
28.srt	00:13:39.129 --> 00:13:53.909	So, we say our magnitude of x of n we say that it is scaled by 1 by n. Then what happens to our sigma noise sigma x squared.
28.srt	00:13:54.360 --> 00:14:01.139	input basically 2 by n whole square divided by 12 which is nothing but 1 by 3 n squared.
28.srt	00:14:01.549 --> 00:14:22.240	So, we call it as this is our signal power sigma x squared is approximately equivalent to n and then signal to noise ratio will be our signal is sigma x squared by sigma naught squared which is going to be 2 to the power of 2 into b minus 1 by n squared.
28.srt	00:14:22.679 --> 00:14:33.240	So, what in this case the assumption of a white noise input signal is considered in that case it becomes 2 by n whole square divided by 12 is our signal.
28.srt	00:14:33.750 --> 00:14:34.000	power.
28.srt	00:14:34.060 --> 00:14:49.970	For a variety of other inputs the noise to signal ratio is still proportional to what we call it as n squared with only the constant of proportionality is going to change as you can see the thing here ok.
28.srt	00:14:50.240 --> 00:14:59.759	So, if we do dividing the input at any stage by 2 what is the thing is going to happen.
28.srt	00:15:00.290 --> 00:15:07.269	So, I think there should be some trigger in your mind because why we call it by 2.
28.srt	00:15:07.480 --> 00:15:11.730	2 is we have a barrel shifter.
28.srt	00:15:12.220 --> 00:15:20.919	So, we can shift the dividing is nothing, but right shift by 1 bit is going to give us divide by 2.
28.srt	00:15:21.319 --> 00:15:27.100	So, that we need not have to spend any time in shifting our input.
28.srt	00:15:27.779 --> 00:15:28.779	What happens?
28.srt	00:15:28.779 --> 00:15:42.759	Very little noise only a bit or 2 what we are going to get affected is present in the final array and most of the noise has been shifted out of the binary word by the scalings.
28.srt	00:15:43.230 --> 00:15:57.629	So, you will be seeing that sigma naught squared is approximately equivalent to 4 into sigma b squared just we saw that because of the 4 butterfly which is nothing, but 4 by 3 into 2 to the power of minus 2 into b minus 1.
28.srt	00:15:58.230 --> 00:16:11.970	And then we are assuming our magnitude our norm of x of n is less than 1 by n in this range then what happens to our input noise power.
28.srt	00:16:12.370 --> 00:16:13.620	So, which becomes.
28.srt	00:16:14.190 --> 00:16:44.100	2 square assumption here also it is white noise signal what it is assumed then it will be 2 squared by 12 and then this is 1 by 3 which is equivalent to sigma x squared is nothing but 1 by 3 n. So, the result of an increase of half a bit per stage holds for a broad class of signals with only the constant multiplier in this equation being dependent on the signal.
28.srt	00:16:44.420 --> 00:16:53.800	So, what happens to our signal to noise ratio in the final sigma x squared by sigma naught squared you will be seeing that 2 to the power of 2 into b minus 1 divided by.
28.srt	00:16:54.220 --> 00:16:57.430	4 n in this case after substitution.
28.srt	00:16:58.180 --> 00:17:05.720	So, the other one is we call it as dynamic scaling that is we use the block floating point.
28.srt	00:17:06.349 --> 00:17:11.829	So, what is it definition you may be wondering what is the thing.
28.srt	00:17:12.400 --> 00:17:25.230	What we say is the original array is normalized to the far left of the computer word with the restriction that our magnitude of x of n is less than 1.
28.srt	00:17:25.970 --> 00:17:35.370	And, the computation proceeds in a fixed point manner except that after every addition there is an overflow test fine.
28.srt	00:17:35.710 --> 00:17:43.990	If there is a overflow detected the entire array can be divided by 2 and the computation is going to continue.
28.srt	00:17:44.759 --> 00:17:53.370	So, the number of necessary divisions by 2 are counted to determine a scale factor for the entire final array.
28.srt	00:17:53.980 --> 00:18:00.690	Then we will be calculating the signal to noise ratio depends strongly on how many overflows occur.
28.srt	00:18:01.320 --> 00:18:04.370	And, at what stage of the computation they occur.
28.srt	00:18:05.330 --> 00:18:11.810	So, the positions and timing of overflows are determined by the signal being transformed.
28.srt	00:18:12.440 --> 00:18:22.960	Thus, to analyze the signal to noise ratio in a block floating point implementation of the AFFT we would need to know the input signal.
28.srt	00:18:33.510 --> 00:18:37.400	So, when we call the block floating point is because each a stage we have different stages.
28.srt	00:18:37.890 --> 00:18:42.530	So, we know each stage what is the input required.
28.srt	00:18:42.940 --> 00:18:54.220	So, we will scale this input x of n what we will call it the first stage or I can call it as x 1 of n and then keep those values here.
28.srt	00:18:55.730 --> 00:18:59.630	Do this in the fixed point mode operation.
28.srt	00:19:00.190 --> 00:19:05.140	Then when we are coming out of it either take this values and scale.
28.srt	00:19:05.200 --> 00:19:28.650	So, we will call it as y1 of n which goes as input as an x stage ok which we call it as x2 of n. We can multiply and then do the rescaling of this or in the end what we can do is if there is a overflow then we will be dividing it by 2 in these cases.
28.srt	00:19:35.320 --> 00:19:44.690	If it is not so then we will keep these values till the end and when I come out of here whatever final I will put it stage I will multiply with these values and bringing back into floating point value.
28.srt	00:19:46.270 --> 00:19:52.610	So, that is one value where I know that just as an example.
28.srt	00:19:52.670 --> 00:20:05.030	So, we have 0 0 1 1 ok and the next one is 0 0 1 1 1 or the next value may be 0 1 1.
28.srt	00:20:07.050 --> 00:20:29.500	So, I know that So, these two bets I can call it as left shift and then keep it as 0.11 and then I will be working that is block floating point I will calculate whichever the common take it out and then use the rest of them to for my computation of FFT here ok.
28.srt	00:20:29.500 --> 00:20:31.410	Stage 1 or whatever may be the thing.
28.srt	00:20:31.410 --> 00:20:36.450	This is how our block floating point is going to work in our case.
28.srt	00:20:37.610 --> 00:20:43.490	So, coming to the what are the real time FFT considerations we are going to have it.
28.srt	00:20:43.990 --> 00:20:54.870	So, one of the thing is we have to consider the signal bandwidth, our sampling frequency, number of points FFT n what we wanted and what is the resolution.
28.srt	00:20:54.900 --> 00:20:57.250	So, we have seen the DFT resolution.
28.srt	00:20:57.250 --> 00:21:04.990	So, what we need it Fs by n and maximum time to calculate our n point FFT.
28.srt	00:21:05.460 --> 00:21:06.380	So, that is.
28.srt	00:21:07.320 --> 00:21:14.820	N by F s what we are going to have it whether we want to do fixed point versus floating point DSP.
28.srt	00:21:15.260 --> 00:21:26.810	So, in the lab we have done floating point implementation to do the fixed point implementation we may have to consider the block floating point and then do it.
28.srt	00:21:27.290 --> 00:21:33.210	So, whether we want the radix 2 FFT or radix 4 FFT.
28.srt	00:21:33.580 --> 00:21:40.200	So, if it is power of 4 whatever input it is advantages to use radix 4.
28.srt	00:21:41.590 --> 00:21:46.970	Because It is going to be minus 1 or minus j coefficients what we have to compute in radix 4.
28.srt	00:21:47.420 --> 00:21:56.000	You can refer to the literatures to how to do the radix 4 implementation.
28.srt	00:21:56.090 --> 00:22:03.280	So, we have seen the radix 2 here, but divide that is even and odd parts what we have taken and then how we have computed.
28.srt	00:22:03.840 --> 00:22:10.520	So, the next one is because most of the application is going to be will be using in the windowing filtering.
28.srt	00:22:10.670 --> 00:22:14.370	So, what are the windowing requirements one has to consider.
28.srt	00:22:14.370 --> 00:22:19.480	So, we saw an example in the lab that is.
28.srt	00:22:21.050 --> 00:22:23.610	case a window and then the rectangular window.
28.srt	00:22:24.010 --> 00:22:27.090	So, how our output is going to get affected with the thing.
28.srt	00:22:27.600 --> 00:22:33.130	So, now, to put the thing different radix implementation can be done.
28.srt	00:22:33.170 --> 00:22:47.870	So, if it is power of 2 all of them what is taken is power of 2, some of them of power of 4, some of them are power of 8 what you will be seeing it.
28.srt	00:22:48.530 --> 00:22:50.580	So, if it does not.
28.srt	00:22:51.080 --> 00:23:01.500	fit into any of this category and you are taking some radix format how we can do the split radix format also.
28.srt	00:23:01.500 --> 00:23:16.300	One can be 8 and then if it is order is 2 power 12 if we take the thing I can have radix 8 1 and radix 4 what I can combine and then how I can do the split radix.
28.srt	00:23:16.860 --> 00:23:19.590	So, that is what it shown in this table.
28.srt	00:23:19.590 --> 00:23:26.440	So, as an example this is the least n is equal to 16 what is considered and radix.
28.srt	00:23:26.960 --> 00:23:40.120	So, this 2 needs real multiplications of 24 whereas, as you can see it is come down to 20 because this is power of 4 number of multiplications real multiplications has come down to 20.
28.srt	00:23:40.660 --> 00:23:56.960	In the split radix it needs also 20 in the case whereas, real additions in case of radix 2 we need 152 additions in radix 4 it is 148 and split radix is 148.
28.srt	00:23:57.640 --> 00:24:01.670	we will see the last one 1024 rest of it you can look at yourself.
28.srt	00:24:02.070 --> 00:24:16.320	So, what we radix 2 as you can see that it needs 10248 real multiplications and 7856 in the case of radix 4.
28.srt	00:24:16.800 --> 00:24:26.820	So, you will be seeing that how much difference you are going to have with radix 4 with radix 2 and then we cannot implement the centred x 8.
28.srt	00:24:27.130 --> 00:24:29.170	So, that is why no nothing has been given.
28.srt	00:24:29.560 --> 00:24:49.530	and in the split radix still you can come down to 7172 ok. And then same thing with respect to your real additions it takes 30728 whereas, radix 4 takes 2336 and then split radix is still lesser.
28.srt	00:24:49.810 --> 00:25:08.580	So, depending on your application which radix format what you want to have it that is the application may need 1024 or 2048 or 4096 or if you want to implement much more than that you can see which radix format.
28.srt	00:25:08.930 --> 00:25:20.580	or different radix format at each stage what you can have it and then combine and then take the output if it is not power of 2 also ok.
28.srt	00:25:20.860 --> 00:25:35.050	So, we will see that how the our butterfly structure is represented in a flow graph that is radix 2 8 point decimation in time what algorithm what it has been taken.
28.srt	00:25:35.400 --> 00:25:38.240	So, you will be seeing each point what we have it.
28.srt	00:25:38.580 --> 00:25:42.540	So, you will be seeing that here you are seeing the.
28.srt	00:25:43.140 --> 00:25:52.290	4 butterflies here and in the next stage also 4 butterflies and then in the last stage also what you have the butterfly.
28.srt	00:25:52.870 --> 00:25:59.320	And multiplication and other things are represented with your weight factors as it is shown.
28.srt	00:26:00.050 --> 00:26:12.260	And then we said that to contribute for any of the 2 1 product we need n minus 1 butterflies.
28.srt	00:26:12.570 --> 00:26:16.060	So, there we have drawn everything.
28.srt	00:26:16.360 --> 00:26:24.170	With the flow graphs it is easy to see that we need n minus 1 butterflies ok.
28.srt	00:26:24.520 --> 00:26:27.960	So, we saw just now the signal to noise ratio.
28.srt	00:26:28.350 --> 00:26:44.600	So, you can go through the thing we have number of bits is equal to b bits and then we have seen that noise generated by a butterfly at one stage is fed into the subsequent stages that is in this case n minus 1 stages.
28.srt	00:26:47.590 --> 00:26:48.480	what we call it.
28.srt	00:26:48.760 --> 00:26:57.550	So, then our we said that our noise is represented in this way that is n minus 1 into sigma b squared.
28.srt	00:26:57.550 --> 00:27:08.350	And now you will be realizing for large n we can represent it as n into sigma b squared which assumed it in the previous case.
28.srt	00:27:09.300 --> 00:27:18.780	And then we have signal to noise ratio in this case is approximately given by this equation that is 2 by n to the power of 2 b minus 1.
28.srt	00:27:21.440 --> 00:27:30.990	So, if I want to this thing signal to noise ratio we call it as proportional or inversely proportional to n and directly proportional to number of bits.
28.srt	00:27:31.310 --> 00:27:36.530	As you can see that n is in the denominator and b is in the numerator.
28.srt	00:27:37.020 --> 00:27:44.430	So, that is how by increasing 1 bit you can nullify on whatever signal to noise ratio what you want to get it.
28.srt	00:27:44.870 --> 00:28:04.380	So, we said that overflow errors and scaling in FFT what it has to be done maximum what we call it as that is you will be making it a dash is equal to 1 and b dash is equal to 1 in that case it will be less than or equal to 2 times max of.
28.srt	00:28:04.910 --> 00:28:06.190	A and then B.
28.srt	00:28:06.540 --> 00:28:14.110	So, this implies that the maximum modules of the butterfly output increase from stage to stage by a factor of 2.
28.srt	00:28:14.530 --> 00:28:27.860	So, if the inputs of butterfly of each scale by 0.5, the output should not overflow provided the magnitude of the input data is within the permissible world length what we call it.
28.srt	00:28:27.860 --> 00:28:40.770	So, as an this thing a scaling how we have considered 0.5 as the scaling factor and then deriving what will be the magnitude of it is illustrated by this example.
28.srt	00:28:48.110 --> 00:29:05.520	So, we consider a dash is equal to our real part and then B, B r into cos x plus B i into sin x and this is our imaginary part and then we assume a dash is equal to 2.4142 plus j and then B dash is equal to minus 0.4142 plus j.
28.srt	00:29:05.590 --> 00:29:07.830	So, how we have got this?
28.srt	00:29:07.830 --> 00:29:18.800	If x is equal to 2 pi k by n which is 45 degrees then our cos 45 degree is equal to sin 45 degree which is nothing but root 2 by 2.
28.srt	00:29:19.920 --> 00:29:27.510	So, without scaling and with real and imaginary parts of inputs each is set to 1.
28.srt	00:29:28.070 --> 00:29:34.800	The limiting case we have from the equations from these above what is it?
28.srt	00:29:35.100 --> 00:29:47.080	a dash is nothing, but 1.2071 plus 0.5 g and then b dash will be this value if all of them are set to 1 this is what we will be getting it.
28.srt	00:29:47.080 --> 00:29:48.410	So, we know that.
28.srt	00:29:50.800 --> 00:29:56.040	what will be our maximum output from this butterfly structures.
28.srt	00:29:56.550 --> 00:30:14.360	So, to see that by adjusting how many bits are required to keep our signal to quantization noise ratio required, we will see that processor one problem in this case.
28.srt	00:30:14.800 --> 00:30:21.860	So, what it says a hardware FFT processor uses a fixed point arithmetic in its butterfly computations.
28.srt	00:30:22.210 --> 00:30:25.420	So, estimate the maximum word length required to.
28.srt	00:30:25.790 --> 00:30:31.980	perform a 1024 point FFT with an output signal to noise ratio of 40 dB.
28.srt	00:30:32.520 --> 00:30:35.700	In this case you are lucky to have just 40 dB.
28.srt	00:30:36.170 --> 00:30:45.200	So, assume that the input to each butterfly is going to be scaled by 0.5 which is nothing but 1 by 2 throughout the FFT.
28.srt	00:30:45.270 --> 00:30:56.100	So, then signal to noise ratio equal because we are scaling by 2 it is going to be 1 by 2 n into 2 to the power of 2 into b minus 1.
28.srt	00:30:56.760 --> 00:31:05.750	So, we have been given signal to noise ratio in dB as 40 dB substitute this put it as 10 log on the right hand side.
28.srt	00:31:06.110 --> 00:31:17.020	So, you will be solving this then I need b minus 1 is equal to 12.14 bits which is nothing, but 13 bits approximate it to the next higher number.
28.srt	00:31:17.050 --> 00:31:23.040	Then system word length for this is equal to be b is equal to 14 bits.
28.srt	00:31:23.130 --> 00:31:28.640	So, you can see if I want to have the CD quality which is 91 dB.
28.srt	00:31:30.710 --> 00:31:34.090	So, if you are this thing scaling is 0.5.
28.srt	00:31:34.090 --> 00:31:42.110	So, you can see that how many bits are required you can work it out and then come back with the answer.
28.srt	00:31:42.160 --> 00:31:53.940	So, this we have seen that how the quantization is going to affect our number of bits and then how many end points what we have to choose it.
28.srt	00:31:53.940 --> 00:32:00.100	And in the next class we will be covering overlap add and overlap save techniques.
28.srt	00:32:04.310 --> 00:32:14.660	to compute long input signal because as you are seeing in the present case the length of the input is also restricted to n minus 1.
28.srt	00:32:15.020 --> 00:32:20.190	Whereas, in our real time application input is coming continuously.
28.srt	00:32:20.460 --> 00:32:27.710	So, how we can apply this FFT using overlap add and then save in the next class.
28.srt	00:32:27.710 --> 00:32:28.200	Thank you.
29.srt	00:00:00.770 --> 00:00:01.560	Namaskara.
29.srt	00:00:31.899 --> 00:00:36.719	So welcome back to real time digital signal processing lab this time, so we have seen how overlap add and then same method is with an example.
29.srt	00:00:36.850 --> 00:00:47.429	So, we will use MATLAB code to see that how it is going to work in real time and then we will be seeing on the board also.
29.srt	00:00:47.609 --> 00:00:58.079	So, as you can see here some of the codes I have able to show you in the last class for DFT and FFT.
29.srt	00:00:58.549 --> 00:01:02.519	So, I had not explained you overlap although we have run some of it.
29.srt	00:01:02.879 --> 00:01:04.859	So, here it is going to run on.
29.srt	00:01:05.240 --> 00:01:06.980	an audio signal.
29.srt	00:01:07.460 --> 00:01:21.360	So, you will be generating what is it TIMIT 2 dot AAC file that is the speed sampled at 8 kilohertz with 16 bits what it is going to it is already stored actually.
29.srt	00:01:21.360 --> 00:01:26.860	So, if you want you can record your own speed signal and then load it in this area.
29.srt	00:01:27.250 --> 00:01:32.890	So, it can be if you have sampled at 8 kilohertz.
29.srt	00:01:32.890 --> 00:01:38.670	So, you can do it or you can change your sampling frequency and then record your own signal.
29.srt	00:01:39.200 --> 00:01:43.120	And, use that particular sampling frequency in running this code.
29.srt	00:01:43.660 --> 00:01:59.480	So, first we will be running the original speech and then you will be seeing that sound SC the stimative what file it has it and then it is getting sampled FS frequency and 16 bits what it is used.
29.srt	00:01:59.480 --> 00:02:03.440	So, you will be playing it first then what is it now.
29.srt	00:02:03.590 --> 00:02:08.200	So, your length of speech file as you will be seeing it for draw.
29.srt	00:02:10.500 --> 00:02:15.200	1 minute or whatever it will be there however long you have stored it that you will be using it here.
29.srt	00:02:15.200 --> 00:02:31.110	So, first you have to take the length of the signal and then your n is going to vary 0 to n x minus 1 and then f what we are going to introduce is 1 kilohertz.
29.srt	00:02:31.629 --> 00:02:34.850	So, frequency of sine wave is noise in this.
29.srt	00:02:35.180 --> 00:02:39.930	So, that will be using the filter in overlap add method.
29.srt	00:02:41.710 --> 00:03:08.120	So, we will be taking omega is equal to 2 pi f by f s and sine wave created with that amplitude is 2000 and then create this with sine of omega into number of samples is n that is throughout your speech signal this frequency is going to be present ok.
29.srt	00:03:08.450 --> 00:03:11.490	So, now, next one is what is that?
29.srt	00:03:11.890 --> 00:03:22.530	So, you will be combining with the speech signal, sine wave signal what you have generated that is basically corrupt speech by 1 kilohertz tone.
29.srt	00:03:22.640 --> 00:03:36.090	So, if you want you can have any other noise random noise or white noise you can add it and then see that you are going to eliminate using your filter basically.
29.srt	00:03:36.090 --> 00:03:43.120	So, we will be displaying thus and then you will be hearing the.
29.srt	00:03:43.700 --> 00:03:46.390	noisy speech signal with this command.
29.srt	00:03:46.560 --> 00:03:51.260	Then you can have a display of it how it is going to look like.
29.srt	00:03:51.440 --> 00:03:58.650	So, as we have discussed in the theory you can calculate the spectrogram using MATLAB function.
29.srt	00:03:59.260 --> 00:04:13.950	Here you will be using the case of window and then number of points what you will be putting it is 200 order and you are 256 points and then.
29.srt	00:04:14.500 --> 00:04:28.670	F is what you will be calculating and then if you are using the this is the latest MATLAB what it says you can select if you give a help on spectrogram you will be getting what are the parameters you have to use it.
29.srt	00:04:29.020 --> 00:04:37.780	So, earlier one what it says is older MATLAB will be using this only number of points and then sampling frequency what you have to give it along with the input signal.
29.srt	00:04:38.130 --> 00:04:44.330	So, you can give title to that noisy signal and then you can.
29.srt	00:04:44.820 --> 00:04:49.770	it the spectrogram and then pause it and then until you press the next key.
29.srt	00:04:49.870 --> 00:04:51.890	So, you can view your spectrogram there.
29.srt	00:04:51.890 --> 00:05:01.600	Now, you can define the window because sine wave what we have created is 1000 hertz that is 1 kilohertz.
29.srt	00:05:01.970 --> 00:05:04.370	So, I want to eliminate that.
29.srt	00:05:04.939 --> 00:05:14.910	So, your filter has to be band stop filter or a notch filter what you can design use the filter design toolbox or you can use here in command.
29.srt	00:05:16.480 --> 00:05:17.820	window also.
29.srt	00:05:18.210 --> 00:05:21.630	So, the stop band region is 1000.
29.srt	00:05:21.630 --> 00:05:32.050	So, you have given 900 to 1100 as your transition band and the sampling frequency is fs by 2 which is 4 kilohertz in this or 4000 hertz.
29.srt	00:05:32.490 --> 00:05:50.330	Then you compute the filter coefficients b, you can use the FIR 1 filter with what is the order of the filter you are going to provide 128 order filter what you are designing it, W n is whatever you have specified here stop band.
29.srt	00:05:50.750 --> 00:05:56.530	And, then you are calling it as a stop band filter what you want to design.
29.srt	00:05:56.980 --> 00:06:04.780	So, then you will be FIR filtering using overlap add method what you will be calling directly.
29.srt	00:06:05.340 --> 00:06:10.180	FFT filter will be using the overlap add method.
29.srt	00:06:10.180 --> 00:06:21.200	So, you will be giving Y n F s n then 16, b is your filter length and then F s is the X n is the input and then you will be seeing that.
29.srt	00:06:21.560 --> 00:06:33.800	when you pass it filtered signal through your sound sc command and you can plot your spectrogram also with respect to this.
29.srt	00:06:34.379 --> 00:06:39.350	So, what we will do is we will put a break point here.
29.srt	00:06:39.490 --> 00:06:41.710	So, then run the code.
29.srt	00:06:42.069 --> 00:06:52.019	So, the previous one you will be seeing it is a overlap with different frequencies what you are seeing it sine and cos function.
29.srt	00:06:54.400 --> 00:07:00.410	So, it has come to overlap of two spectral lines due to frequency.
29.srt	00:07:00.870 --> 00:07:05.550	So, you will be seeing it 60 and 61 what we had done.
29.srt	00:07:05.550 --> 00:07:08.460	She had your dark suit in greasy wash water all year.
29.srt	00:07:11.000 --> 00:07:15.050	This is the spectrum of the speed signal as you can see the thing.
29.srt	00:07:15.570 --> 00:07:26.170	So, now, it is going to do the filtering as you can see the thing overlap add technique what it is going to use to.
29.srt	00:07:26.520 --> 00:07:29.370	She had your dark suit in greasy wash water all year.
29.srt	00:07:29.770 --> 00:07:36.920	There it was the previous selected speech signal, now also you have selected the normal speech.
29.srt	00:07:37.100 --> 00:07:40.380	Now, you will be seeing that it is waiting for any key to be pressed.
29.srt	00:07:44.510 --> 00:07:47.410	She had your dark suit in greasy wash water all year.
29.srt	00:07:47.410 --> 00:07:56.190	As previously shown that is you have a sine wave constant, you are seeing that at 1 kilohertz what you have it ok.
29.srt	00:07:56.190 --> 00:07:57.440	So, and then these are the speech.
29.srt	00:07:57.440 --> 00:08:01.270	So, this is how you have overlapped with the speech signal you are.
29.srt	00:08:02.710 --> 00:08:03.990	noisy sign wave.
29.srt	00:08:04.330 --> 00:08:09.160	So, now, it is going to waiting for one more time to do filtering.
29.srt	00:08:09.430 --> 00:08:10.460	So, you will be.
29.srt	00:08:10.900 --> 00:08:18.290	She had your dark suit in greasy wash water all year.
29.srt	00:08:18.290 --> 00:08:23.430	So, you have heard that although there is a little sign tone is left out, but most of them have been eliminated.
29.srt	00:08:24.080 --> 00:08:29.650	So, now, you can generate your cause.
29.srt	00:08:33.400 --> 00:08:42.140	And, then take the this thing power spectrum what you can calculate to find the power spectral density and other things.
29.srt	00:08:42.170 --> 00:08:53.700	So, if we run the complete code you will be seeing that your power signal what it is going to be the complete signal y how it is it.
29.srt	00:08:54.170 --> 00:09:02.340	So, this is one sided power spectrum of your y and then you have the signal here.
29.srt	00:09:02.800 --> 00:09:10.120	So, one sided power spectrum of y y what you have it and then signal here what you have recovered.
29.srt	00:09:10.460 --> 00:09:37.180	So, you will be seeing that how both of them are look like and then you will be seeing in the output power signal y what dB or word length what it has it and y y what is it here will be seeing that you are finding the use the periodogram function with the rectangular window.
29.srt	00:09:37.570 --> 00:09:49.310	that is what you have used it in this case previous one was the case of window and then trying to do that here there is no overlap is going to have.
29.srt	00:09:50.080 --> 00:09:55.440	So, then what are the power signal what you will be achieving it is shown in this.
29.srt	00:09:55.840 --> 00:10:03.280	So, now, we will go with the resolution just now we discussed about it.
29.srt	00:10:03.670 --> 00:10:07.940	So, what is the thing is going to happen with n is equal to.
29.srt	00:10:08.200 --> 00:10:14.200	8 and then the sampling frequency chosen as 8000 we saw in the theory.
29.srt	00:10:14.200 --> 00:10:17.220	So, we will look at it how it is going to look like.
29.srt	00:10:17.560 --> 00:10:33.240	So, you will be having 0s padded here and then you will be computing sine wave and then you will be taking the FFT of the signal which have been combined here.
29.srt	00:10:33.600 --> 00:10:35.280	So, we will run the thing.
29.srt	00:10:35.820 --> 00:10:38.750	So, you will be seeing that for 8 bit.
29.srt	00:10:39.200 --> 00:10:43.970	this is what the resolution is going to be of your coefficients.
29.srt	00:10:44.210 --> 00:10:52.310	So, if I increase it to 16, so you will be seeing the magnitude spectra how it is going to look like.
29.srt	00:10:52.630 --> 00:11:02.450	So, one can use the subplot to plot one over the other and then see that how both for 16 point and then 8 point how it is going to look like.
29.srt	00:11:10.400 --> 00:11:14.030	So, the next one what it does is you can have a quantization effect built into this.
29.srt	00:11:14.400 --> 00:11:43.130	So, you will be seeing that what is it your sampling frequency is 1 into e power 6 and then your f x is 15 to e power 3 and then your f is magnitude is 1 and you are telling n is 2 to the power of 11 point fft what you are going to have and then you will be taking the input signal is a cos basically.
29.srt	00:11:43.530 --> 00:12:14.670	multiplied with magnitude 1 and then this is the normalized position what you can look at it and plot the signal and then you will be calculating N FFT as n point and then your s what you are going to define is 1 by N FFT into absolute of FFT of y comma N FFT and then your frequency you will be seeing the line space one sided power spectrum of y.
29.srt	00:12:15.230 --> 00:12:24.110	And, what you will be getting is you can see the periodogram with the rectangular window what you are going to use for the y signal.
29.srt	00:12:24.630 --> 00:12:34.750	And signal 2 what you will be taking is here you will be defining b is equal to 2 and delta is 2 by 2 to the power of b.
29.srt	00:12:35.700 --> 00:12:40.790	And then your fs is this and cycles what you will be choosing is 67.
29.srt	00:12:41.760 --> 00:12:46.130	And your yy signal whatever you are going to get it is this one.
29.srt	00:12:46.530 --> 00:12:59.050	So, then compute your power spectrum from the thing and you can do the quantization how it is going to look like ok.
29.srt	00:12:59.310 --> 00:13:10.060	So, we will run this and see you will be seeing the same thing what we had got it in the previous one.
29.srt	00:13:10.060 --> 00:13:15.590	This is our y, y by signal and then y 1 what is the output.
29.srt	00:13:15.760 --> 00:13:18.320	And this is the quantized one is the.
29.srt	00:13:18.850 --> 00:13:38.980	So, you can see that with number of quantized points what you have given the thing and this represents your original signal and then error between the original signal and then quantized signal you will be seeing that this is how the error is going to creep in.
29.srt	00:13:39.390 --> 00:13:48.460	So, you are seeing to the original one sided power to the quantized one you will be seeing there are little peaks what.
29.srt	00:13:48.900 --> 00:13:50.190	it is going to appear.
29.srt	00:13:50.660 --> 00:14:01.560	So, how much you can tolerate after quantization to fixed point what you can have a look at it in the case fine.
29.srt	00:14:02.020 --> 00:14:16.250	So, coming to we have discussed about overlap add and add method already usually students what then I give them is to design both overlap add and then save.
29.srt	00:14:16.790 --> 00:14:20.510	So, in this case I will be showing you what they have designed.
29.srt	00:14:20.960 --> 00:14:31.940	So, this is the sampling frequency we assume it as 8 kilohertz in the thing and then the whatever you have to generate 40 samples in one period.
29.srt	00:14:32.570 --> 00:14:42.220	So, that is 8000 divided by 40s the signal what you will be generating is 200 hertz signal in this case.
29.srt	00:14:42.820 --> 00:14:49.600	So, they will be using as we discussed in the IER filter.
29.srt	00:14:51.450 --> 00:14:59.850	to our FFT calculation we use sine generation using IR in the oscillatory mode.
29.srt	00:15:00.000 --> 00:15:06.460	So, to generate 200 hertz these are the values what it has to be generated.
29.srt	00:15:06.770 --> 00:15:15.820	So, your y 1 is 0 y 1 of 2 is given with these values and then for k is equal to 3 to 10000.
29.srt	00:15:16.130 --> 00:15:22.390	So, you will be generating your sine wave y 1 of k with respect to.
29.srt	00:15:23.030 --> 00:15:42.190	As you can see this is the IR filter, this all is your amplitude and then y 1 of k minus 1 is your feedback signal and then y 1 of k minus 2 is the second feedback signal, what you will be providing to oscillate the filter.
29.srt	00:15:42.650 --> 00:15:51.820	So, then what is it here one of the frequencies here it is 200 hertz.
29.srt	00:15:54.320 --> 00:15:57.160	So, you have to generate 3 sine waves usually I ask them to do the thing.
29.srt	00:15:57.570 --> 00:16:11.730	In this case they have taken x 1 is 30 samples which is going to give us 267 hertz and in the same way third one is 400 hertz what it is generated using our IR filter in the oscillatory mode.
29.srt	00:16:12.280 --> 00:16:16.030	Then combine all these 3 y 1 y 2 and y 3.
29.srt	00:16:16.030 --> 00:16:22.440	So, you will be getting 3 frequencies which you can plot it ok.
29.srt	00:16:22.590 --> 00:16:24.670	So, take the absolute FFT.
29.srt	00:16:25.110 --> 00:16:31.260	defined by the function in this case and then plot their magnitude.
29.srt	00:16:31.750 --> 00:16:41.740	Now, you will be generating FIR bandpass filter of 237 to 297 hertz to get the second frequency of order 350.
29.srt	00:16:42.090 --> 00:16:47.780	So, you can see that FIR 1 is a 350 order.
29.srt	00:16:48.370 --> 00:16:55.840	So, something should be striking in your mind to eliminate in a short this thing frequency.
29.srt	00:16:56.180 --> 00:17:03.680	So, what they have given is that is 237 to 297 is their transition band what it is being used.
29.srt	00:17:04.070 --> 00:17:11.160	So, this is the high order to eliminate one of the frequency from the 3 frequencies what it has been generated.
29.srt	00:17:11.640 --> 00:17:19.040	So, this will be passed through you will be seeing that filter basically what you can do the thing.
29.srt	00:17:19.530 --> 00:17:27.270	So, length going to implement direct convolution first what you will be doing it length of y.
29.srt	00:17:27.740 --> 00:17:41.740	And, then you are doing the convolution of it and generating the remaining length minus l length plus 1 elements of output what you will be doing again the second convolution.
29.srt	00:17:41.740 --> 00:17:45.400	So, this is how your overlap add method has been done.
29.srt	00:17:45.400 --> 00:17:50.060	So, here first one is overlap save method what it is going to be.
29.srt	00:17:50.400 --> 00:17:57.730	So, FFT length is defined as 512 and then the length of whatever the filter is.
29.srt	00:17:58.329 --> 00:18:04.170	what you have assuming it and then size of each signal segment is 162.
29.srt	00:18:04.670 --> 00:18:19.690	Then you will be padding with 0s and then your FFT of H is nothing but FFT of your H that is you are taking the FFT of your response of the filter.
29.srt	00:18:19.690 --> 00:18:25.740	And then you will be output array for final output what it is defined here.
29.srt	00:18:30.390 --> 00:18:34.850	And, you will be having the for k is equal to 1 what you will do it.
29.srt	00:18:34.850 --> 00:18:38.460	So, FFT of the first signal what you will do it.
29.srt	00:18:38.460 --> 00:18:48.580	So, you have 0s and then y 1 to s length and first you are padding with 0s and then y you have taken the thing.
29.srt	00:18:49.250 --> 00:19:01.039	And, then you will be doing the as you can see it is a convolution basically FFT of H dot into FFT of s that is.
29.srt	00:19:01.650 --> 00:19:12.480	basically in the DFT domain you are multiplying 2 DFT signals here both H and then S. Then you will be outputting the IFFT of this output.
29.srt	00:19:12.769 --> 00:19:28.799	So, this you will be plotting it and you will be doing for first one you have done it for k is equal to 1 and then 2 and then 3 and then afterwards you will be going up to the length by 2.
29.srt	00:19:31.810 --> 00:19:38.640	So, this is how you do overlap save method and the last one you will be doing it manually fine.
29.srt	00:19:38.870 --> 00:19:44.120	So, the thing you will be seeing that the first one is a overlap save method.
29.srt	00:19:44.440 --> 00:19:50.840	So, what we will do is we will put a break point here and then run our overlap save method.
29.srt	00:19:51.610 --> 00:20:03.430	So, you will be seeing that this is how we have generated.
29.srt	00:20:06.250 --> 00:20:17.120	3 distinct frequencies as you can see that it is 240 hertz, 297 and then 400 hertz if I am correct.
29.srt	00:20:17.480 --> 00:20:23.660	These are the 3 frequencies what it was generated and then you will be seeing at the fs was 8000.
29.srt	00:20:23.760 --> 00:20:29.790	So, you will be seeing the mirror image of the 3 frequencies on the left side also.
29.srt	00:20:30.330 --> 00:20:35.330	So, this is the input to overlap add save method the first one.
29.srt	00:20:35.820 --> 00:20:40.080	And, then after it is using a band pass filter as you can see.
29.srt	00:20:40.460 --> 00:20:50.360	So, it has eliminated the other two frequencies and then your can you tell me what kind of filter it is.
29.srt	00:20:50.360 --> 00:20:58.330	In the previous case we saw it was a band stop filter, here it is going to be a band pass filter.
29.srt	00:20:58.380 --> 00:21:03.519	So, you are using only one frequencies to be passed.
29.srt	00:21:03.830 --> 00:21:05.310	So, if you check the thing.
29.srt	00:21:05.839 --> 00:21:18.529	value what you will be getting it as 267 is passed the other 2 frequencies have been eliminated and that is using your overlap save method.
29.srt	00:21:18.900 --> 00:21:22.849	This was the direct convolution using direct convolution the same thing.
29.srt	00:21:23.279 --> 00:21:26.430	So, using the overlap save method also you have got the same thing.
29.srt	00:21:26.799 --> 00:21:31.819	Now, it is going to be using overlap add method.
29.srt	00:21:32.359 --> 00:21:37.420	So, we have discussed in theory the how it is going to work this is how this has been.
29.srt	00:21:37.970 --> 00:21:48.210	implemented as you will be seeing that how the 0s have to be introduced and then you will be adding the previous length and then doing it.
29.srt	00:21:48.210 --> 00:21:55.750	So, you will be seeing somewhere down the line the addition of it ok plus 1.
29.srt	00:21:55.750 --> 00:22:03.000	So, all the your x 1, x 2, x 3 till the length of it what you will be adding them.
29.srt	00:22:08.240 --> 00:22:19.519	So, then you will be calculating your inverse FFT and then adding them here out a what you will be seeing it here concatenation is going to happen here and you will output.
29.srt	00:22:19.869 --> 00:22:36.029	So, you can see that here also you will be seeing that only using the overlap add method this frequency what is it basically your 267 harmonic overlap save method this frequency is left out.
29.srt	00:22:38.629 --> 00:22:47.970	So, this shows that how our overlap add and save method to run different ways of it.
29.srt	00:22:47.970 --> 00:23:07.639	One we saw it with the audio file and then we have seen with the frequency generated using IAR filter in the oscillatory mode to eliminate the two frequencies only passed only one of the frequency using this method a using MATLAB.
29.srt	00:23:07.669 --> 00:23:10.589	So, we will take a break and then.
29.srt	00:23:10.930 --> 00:23:13.470	come back for CCS.
29.srt	00:23:14.200 --> 00:23:14.769	Thank you.
15.srt	00:00:01.219 --> 00:00:24.980	Welcome back to the course real time digital signal processing.
15.srt	00:00:25.239 --> 00:00:28.800	So, we are continuing with the IR filter.
15.srt	00:00:29.339 --> 00:00:30.460	Today we will see that.
15.srt	00:00:30.929 --> 00:00:36.859	quantization and then how it is going to affect our design basically.
15.srt	00:00:36.859 --> 00:00:59.109	As a recap we have been discussing from past two lectures IR filters you know how it is going to have effect on the quantization and then how to design it, why we have chosen IR filter and then compared to FIR filter except linear phase we are going to have.
15.srt	00:01:01.570 --> 00:01:05.859	few number of filter coefficient which is going to be designed.
15.srt	00:01:05.859 --> 00:01:13.000	So, that is the advantage of it and then we know that most of the earlier work goes on using analog filters.
15.srt	00:01:13.000 --> 00:01:25.349	So, we will see what are the quantization values what we are going to get it is here it is going to show me H of n. So, you will be seeing the FIR filter continuous signal.
15.srt	00:01:25.349 --> 00:01:32.349	The values which are represented is minus 1.2.
15.srt	00:01:32.950 --> 00:01:38.920	10 power minus 4 to you will be seeing that some more values are present.
15.srt	00:01:39.280 --> 00:01:46.469	So, when I do the quantization of it what we call it as H q of n quantized thing.
15.srt	00:01:46.759 --> 00:01:52.420	So, you will be seeing threshold what we will be putting these are the values which are not going to be represented.
15.srt	00:01:52.819 --> 00:02:04.759	So, you will be seeing up to some of the very low values which are going to become 0, then rest of it are going to be quantized to certain values.
15.srt	00:02:05.039 --> 00:02:07.469	So, you will be seeing in the end also.
15.srt	00:02:07.789 --> 00:02:08.810	So, some of the.
15.srt	00:02:09.490 --> 00:02:12.710	coefficients are made 0 although they have the values.
15.srt	00:02:12.969 --> 00:02:16.840	So, this is the quantization what it is going to happen.
15.srt	00:02:17.219 --> 00:02:18.400	So, in the FIR filter.
15.srt	00:02:18.550 --> 00:02:22.090	So, how the response is going to be we will see it in a while.
15.srt	00:02:22.490 --> 00:02:31.659	So, you will be seeing that the black representation shows that this is the frequency response with respect to magnitude.
15.srt	00:02:32.280 --> 00:02:38.069	So, you will be seeing based on the quantization which is shown in the dotted lines.
15.srt	00:02:40.810 --> 00:02:45.340	So, you will be seeing that my cutoff frequency or stop band just gets moved up.
15.srt	00:02:45.590 --> 00:02:52.240	So, from minus whatever it is around greater than minus 80 dB.
15.srt	00:02:52.570 --> 00:02:59.960	So, which will be dropped down to around minus 40 or 30 it is in the range minus 30 to 40 dB.
15.srt	00:03:00.410 --> 00:03:03.230	So, this is the coefficient quantization.
15.srt	00:03:03.230 --> 00:03:08.000	So, one has to consider when we are doing using in the hardware.
15.srt	00:03:08.350 --> 00:03:11.930	So, our design has to account for this quantization effects.
15.srt	00:03:12.380 --> 00:03:13.370	So, coming to.
15.srt	00:03:14.400 --> 00:03:19.199	So, the this thing this is the passband region what it has been taken.
15.srt	00:03:19.590 --> 00:03:27.960	So, you will be seeing how it is going to be represented this is in the terms of magnitude and this is in frequency in kilohertz.
15.srt	00:03:28.300 --> 00:03:39.000	So, this is black one shows are unquantized and then the dotted lines it shows that it is the quantized.
15.srt	00:03:39.270 --> 00:03:42.939	So, here I am supposed to get a flat response.
15.srt	00:03:43.280 --> 00:03:45.400	So, where what is the thing is happening?
15.srt	00:03:45.400 --> 00:03:46.280	So, there is a.
15.srt	00:03:46.840 --> 00:03:51.280	a ripple in my pass band in the representation.
15.srt	00:03:51.610 --> 00:03:54.790	So, these are the effects one has to consider.
15.srt	00:03:55.460 --> 00:04:00.310	So, what is the thing is going to happen with this quantization?
15.srt	00:04:00.310 --> 00:04:02.430	So, we will see in effects of it.
15.srt	00:04:02.960 --> 00:04:11.259	So, whatever we have h of n if it is un quantized then output is going to be a normal.
15.srt	00:04:11.530 --> 00:04:18.449	So, if there is an error because of the thing so, which is going to be added with respect to that.
15.srt	00:04:19.439 --> 00:04:24.410	output will be my impulse response coefficients what I will be getting it.
15.srt	00:04:24.740 --> 00:04:36.610	So, in terms of frequency domain we know that h of n is going to be represented as h of omega and then our error function is represented as a of omega.
15.srt	00:04:36.970 --> 00:04:45.150	So, output will be quantized basically h q of omega what will be the response of the filter.
15.srt	00:04:49.000 --> 00:04:51.720	So, how it is going to affect we will see in this.
15.srt	00:04:52.470 --> 00:04:59.759	block diagram that is basically dynamic range and accuracy requirement of different applications one needs it.
15.srt	00:05:00.160 --> 00:05:02.689	So, we know that in noise cancelling.
15.srt	00:05:03.170 --> 00:05:08.730	So, dynamic range in number of bits what we will be telling 32 bits what we needed.
15.srt	00:05:09.150 --> 00:05:22.210	So, whereas, accuracy it is 20 bits is enough whereas, in the radar processing it is 32 and then same thing 20 bits whereas, in case of broadcast quality picture processing.
15.srt	00:05:22.509 --> 00:05:25.319	So, both what we need is 20 bits.
15.srt	00:05:25.810 --> 00:05:29.220	So, we see in the image processing it is 30 and 20.
15.srt	00:05:29.500 --> 00:05:33.680	So, medical spectrum analysis if you are doing it both can have 20.
15.srt	00:05:34.170 --> 00:05:42.900	So, when you are going for the seismic data processing you will be seeing that the dynamic range what we need it 70 bits to 20 bits.
15.srt	00:05:43.200 --> 00:05:51.660	So, most of the cases whatever we are designing 6 7 1 3 DSK board what we are using it which is 16 bit.
15.srt	00:05:51.990 --> 00:05:55.530	So, almost it is nearer to the thing what we can.
15.srt	00:05:55.910 --> 00:06:07.660	So, coming to quantization so, all of us know that what we have to do is because most of the signal in nature is analog in nature.
15.srt	00:06:08.189 --> 00:06:16.540	So, we represent it analog input as x of t. So, if I want to do what is it band limit the signal.
15.srt	00:06:16.540 --> 00:06:20.850	So, I have to pass it through the low pass filter.
15.srt	00:06:21.390 --> 00:06:26.920	So, we call this as a anti aliasing filter also.
15.srt	00:06:26.920 --> 00:06:27.970	So, that will be.
15.srt	00:06:28.569 --> 00:06:32.769	limiting the stop band frequencies which are going to creep in.
15.srt	00:06:33.139 --> 00:06:38.269	Most of the stop band frequencies we say higher the frequencies are the noise.
15.srt	00:06:38.550 --> 00:06:43.639	So, we are limiting it and then we will be feeding it into our sample and hold circuit.
15.srt	00:06:44.009 --> 00:06:50.220	So, when it is closed you will be seeing that more than whatever the value of it.
15.srt	00:06:50.220 --> 00:06:58.629	So, we will be getting the output it sample and hold circuit is going to work then we are going to do the quantization.
15.srt	00:06:58.730 --> 00:07:01.360	So, we know that depends on number of bits.
15.srt	00:07:01.659 --> 00:07:07.350	So, the representation will be 0 to 2 to the power of n minus 1, n is the number of bits.
15.srt	00:07:07.829 --> 00:07:10.159	ADC circuit what it is going to have.
15.srt	00:07:10.529 --> 00:07:23.989	So, we have to do the encoding of this number, we use a logic circuit to do the thing and x of n will be my our digital output coming out of our ADC.
15.srt	00:07:24.469 --> 00:07:34.929	So, we have seen the different structures, here we are going to see that this is my direct form 2 what we derived it in the last class.
15.srt	00:07:35.239 --> 00:07:40.429	So, what are the coefficients for it is b naught b 1 b 2 and a 1 and a 2.
15.srt	00:07:40.889 --> 00:07:46.889	and then x of n y of n w of n and then w of n minus w of n minus 2.
15.srt	00:07:47.299 --> 00:07:50.689	So, these are the parameters what I have to store it.
15.srt	00:07:51.049 --> 00:07:54.129	So, when I see the direct form one structure.
15.srt	00:07:54.439 --> 00:08:04.479	So, we will be seeing that this is a 0s are in the feed forward whereas, poles are in the feed backward stages.
15.srt	00:08:11.509 --> 00:08:21.899	So, you will be seeing that I need so many coefficients to are 5 in this case also except that we need y of n minus 1 y of n minus 2 output also in the case of it.
15.srt	00:08:22.209 --> 00:08:31.419	So, that is 3 plus 2 5, but we need output to be fed back into the system.
15.srt	00:08:31.749 --> 00:08:43.669	Whereas, as we can see here I have one adder as I have discussed in the last class also the quantization effect may nullify sometimes here.
15.srt	00:08:45.819 --> 00:08:48.189	Whereas, in this case we have it may little bit over write.
15.srt	00:08:48.539 --> 00:09:08.519	So, that is the representation we have y of n is as we know about it is b naught into x of n plus b 1 into x of n minus 1 plus b 2 into x of n minus 2 minus a 1 into y of n minus 1 minus a 2 into y of n minus 2.
15.srt	00:09:08.899 --> 00:09:16.439	So, in both the cases it is the same, but the delay elements here what we need is.
15.srt	00:09:16.879 --> 00:09:21.599	4 delays whereas, in this case it becomes only 2 delays in the case.
15.srt	00:09:22.139 --> 00:09:32.529	So, that is the reason why most of the applications use direct form 2 structure compared to direct form 1 structure.
15.srt	00:09:33.989 --> 00:09:38.379	So, now, we have to see that when we have taken the direct form 2.
15.srt	00:09:38.769 --> 00:09:48.909	So, how the coefficients are going to be represented whether they are going to cause any instability so, we will be seeing that.
15.srt	00:09:49.249 --> 00:09:53.389	It is the coefficient values for a stable second order IR filter.
15.srt	00:09:53.899 --> 00:09:55.979	So, what should be the region of it?
15.srt	00:09:56.389 --> 00:10:01.639	So, we say this is our coefficients a 1 and then a 2 what we are representing.
15.srt	00:10:02.209 --> 00:10:08.309	Most of the time it is the poles which are going to have instability for the filter.
15.srt	00:10:08.719 --> 00:10:13.609	So, we will be considering a 1 and then a 2 coefficients what we have plotted.
15.srt	00:10:13.879 --> 00:10:18.189	So, we call this is the triangle which is going to be represented.
15.srt	00:10:18.549 --> 00:10:19.739	So, we know that.
15.srt	00:10:20.119 --> 00:10:29.649	1 is maximum and then minus 1 in this and then we will be having 2 for a 1 and minus 2.
15.srt	00:10:29.999 --> 00:10:40.369	So, the rest of the thing represented minus a 1 will be this is equal to 1 plus a 2 this location and then this is a 1 is equal to 1 plus a 2.
15.srt	00:10:40.709 --> 00:10:44.459	So, how we have arrived at this is shown with the poles here.
15.srt	00:10:50.419 --> 00:10:51.639	So, we consider the feed backward section and then analyze it.
15.srt	00:10:51.639 --> 00:11:02.899	So, what we have is 1 plus a 1 into z minus 1 plus a 2 into z minus 2 which is nothing, but 1 minus p 1 into z minus 1 into 1 minus p 2 into z minus 1.
15.srt	00:11:03.299 --> 00:11:10.019	So, we represent a 1 is equal to p 1 plus p 2 and a 2 will be p 1 into p 2.
15.srt	00:11:10.529 --> 00:11:15.789	So, we see that poles must lie inside the unit circle for our stability.
15.srt	00:11:16.239 --> 00:11:21.669	So, that means, that magnitude of a p 1 should be less than 1.
15.srt	00:11:22.209 --> 00:11:28.959	And, magnitude of P2 should be less than 1 in this case.
15.srt	00:11:30.339 --> 00:11:40.509	So, magnitude of P2 also has to be 1, then what happens magnitude of A2 what it is given by magnitude of P1 into P2.
15.srt	00:11:40.789 --> 00:11:42.229	So, which is less than 1.
15.srt	00:11:42.599 --> 00:11:52.169	So, A1 as you can see it is 1 plus A2, so it will be magnitude of it can go up to.
15.srt	00:11:52.649 --> 00:12:00.169	2 that is what we get it from this triangle this is how it has been plotted.
15.srt	00:12:00.699 --> 00:12:07.269	So, coming to the advantages of cascade section we will see with an example here.
15.srt	00:12:07.689 --> 00:12:17.799	So, impulse response of the filter in z domain is given as h of z is equal to 1 by 1 minus 0.9 z minus 1 plus 0.2 z minus 2.
15.srt	00:12:17.799 --> 00:12:25.459	So, if we consider the pole then what happens z is equal to 0.4 and z is equal to 0.5.
15.srt	00:12:27.109 --> 00:12:37.559	So, in the cascade form representation we represent this as h1 of z into h2 of z.
15.srt	00:12:38.069 --> 00:12:40.109	So, what is it?
15.srt	00:12:40.159 --> 00:12:52.049	We will be having h1 of z is nothing, but so 1 by 1 minus 0.4 z minus 1 and then h2 of z is going to be 1 by 1 minus 0.5 z minus 1.
15.srt	00:12:52.049 --> 00:12:58.389	So, actually this has been converted into 1 minus 0.4 z minus 1 into.
15.srt	00:13:00.109 --> 00:13:09.229	1 minus 0.5 z minus 1 will realize this equation that is how the poles are there.
15.srt	00:13:09.229 --> 00:13:15.949	So, if we say that I am going to represent it with 4 bits you have to call back our number system then what happens.
15.srt	00:13:15.949 --> 00:13:21.679	So, we have to represent all these values we will see in a while that is 0.9, 0.2, 0.4 and 0.5.
15.srt	00:13:21.679 --> 00:13:26.249	So, what is the nearest number I can represent with all these values.
15.srt	00:13:26.249 --> 00:13:33.409	So, this is the direct form what I have taken this is the second order section what we have taken the thing.
15.srt	00:13:35.629 --> 00:13:40.289	0.9 is represented as 0.875 and then 0.2 is represented as 0.125.
15.srt	00:13:40.289 --> 00:13:50.059	So, in the case of 0.4 we will represent it as 0.375 and then 0.5 directly is represented as 0.5 in our fixed format.
15.srt	00:13:50.059 --> 00:13:56.089	So, coming with the thing so, this is what we have done the second cascade section.
15.srt	00:13:56.089 --> 00:13:58.479	So, what happens to the pole locations?
15.srt	00:13:58.479 --> 00:14:07.569	In the direct form what we call it as because this is the quantized values what we are going to represent it.
15.srt	00:14:10.599 --> 00:14:15.689	H dash z is r z is equal to 0.1 and z is equal to 0.695.
15.srt	00:14:15.689 --> 00:14:21.509	In the cascade form what happens to our H dash of z.
15.srt	00:14:21.509 --> 00:14:26.409	So, here it is going to be z is equal to 0.375 and then 0.5.
15.srt	00:14:26.409 --> 00:14:35.229	So, you will be seeing that instead of point what we are supposed to get is 0.4 and 0.5.
15.srt	00:14:35.229 --> 00:14:39.019	So, in the direct form pole location is at 0.1 and 0.695.
15.srt	00:14:42.929 --> 00:14:54.089	So, you will be seeing it that very far apart whereas, in the cascade form you are seeing that they are nearer to whatever the values what we have represented.
15.srt	00:14:54.479 --> 00:15:01.559	So, that is the reason why we use the cascade form compared to the direct form.
15.srt	00:15:01.559 --> 00:15:05.469	So, you will be seeing that the poles are nearer.
15.srt	00:15:13.099 --> 00:15:14.679	The poles cascade realizations are closer to the desired or impulse response in the z domain what it shows.
15.srt	00:15:15.209 --> 00:15:23.489	So, now, how the because we are going to have many cascade sections it is only second order one section what we have taken the thing.
15.srt	00:15:23.859 --> 00:15:30.709	If we have multiple sections how we are going to combine because we will be arriving at poles and 0s.
15.srt	00:15:31.109 --> 00:15:41.649	So, how we are going to combine them is shown by this diagram that is first what we do the thing complex conjugate poles what we are considering here.
15.srt	00:15:42.119 --> 00:15:49.689	So, they have been named as first conjugate pole here and then the second set and this is the third set.
15.srt	00:15:50.029 --> 00:15:53.329	So, we say the closest to the unit circles.
15.srt	00:15:53.789 --> 00:16:11.179	So, that is which is closer to unit circle is named as 1 responsible for the greater overshoot are paired with complex conjugate zeros closer in frequency that is angle on unit circle.
15.srt	00:16:11.809 --> 00:16:16.089	So, we pair this one with this one.
15.srt	00:16:16.139 --> 00:16:18.569	So, that is the reason why we have colored them.
15.srt	00:16:19.049 --> 00:16:25.629	The first one which is shown with green is paired with this green, the next one is the blue.
15.srt	00:16:25.979 --> 00:16:33.469	So, that is what it says then the process iterate with the next complex conjugate closest to the unit circle.
15.srt	00:16:33.939 --> 00:16:42.709	So, this one with next 0s and then one is nearer to the 0 is connected with the nearer to the pole of 0s.
15.srt	00:16:42.959 --> 00:16:54.379	So, otherwise one has to do trial and error method or you have to see how the pairing is going to happen as we have seen in the last class.
15.srt	00:16:57.369 --> 00:17:03.939	So, the So, quality factor how it is going to affect our pairing also is one of the important aspect.
15.srt	00:17:04.329 --> 00:17:07.939	So, this is one of the method what one can use.
15.srt	00:17:07.939 --> 00:17:13.789	So, that we may get a good pairing of poles and zeros in our cascade section.
15.srt	00:17:13.789 --> 00:17:30.319	So, coming to the thing as we know that direct form 1, we said that there is no overflow it may or may not have it, but definitely we have in the cascade section.
15.srt	00:17:31.819 --> 00:17:34.319	2 adders which are coming in.
15.srt	00:17:34.559 --> 00:17:43.899	So, because it is the same what magnitude what it is going to be added or same sign magnitudes are going to be added.
15.srt	00:17:43.979 --> 00:17:46.129	So, I may have a overflow or an underflow.
15.srt	00:17:46.129 --> 00:17:52.349	So, to avoid this overflow and underflow we have to have a scaling factor.
15.srt	00:17:52.349 --> 00:18:08.559	So, you will be triggered with why did we choose a scaling thing that is barrel shifter what we call it either shift right or shift left which is required for scaling my input also in this case.
15.srt	00:18:08.679 --> 00:18:16.319	So, that is what it is shown here to prevent our overflow in storing at node W.
15.srt	00:18:16.579 --> 00:18:23.439	N ok, we need a scale factor to have a 0 dB gain from input to this node.
15.srt	00:18:24.959 --> 00:18:35.009	This scale factor what we call it as alpha k is commonly computed depending on the nature of signal that will be processed.
15.srt	00:18:35.009 --> 00:18:48.549	So, for narrow band signal in this case we have we use the L infinity norm, then we get alpha 1 as 1 by.
15.srt	00:18:48.980 --> 00:18:54.929	norm of 1 by A of f infinity norm what we are taking it.
15.srt	00:18:55.269 --> 00:19:00.939	So, if we want to process the wide band signal we usually use L2 norm.
15.srt	00:19:01.589 --> 00:19:12.109	In that case our alpha 2 scaling is going to be 1 by norm of L2 norm of 1 by A f input signal.
15.srt	00:19:12.109 --> 00:19:19.079	So, further more we have alpha 2 greater than or equal to A 1.
15.srt	00:19:19.599 --> 00:19:28.759	always this is at a higher this thing value compared to alpha 1 we are going to have the scaling.
15.srt	00:19:28.789 --> 00:19:31.769	This is the maximum scaling what we can provide.
15.srt	00:19:32.509 --> 00:19:46.819	So, how we are going to order that is what we said criteria for scale factor computation we are going to have it as L infinity or L2 norm one way one of the thing what we will be selecting it.
15.srt	00:19:47.199 --> 00:19:52.459	So, which norm of the quantization noise we want to minimize whether we want to L.
15.srt	00:19:52.649 --> 00:20:00.129	infinity that is the maximum value or L2 norm that is the power which is going to be considered.
15.srt	00:20:00.509 --> 00:20:03.159	So, these are the rules one has to apply.
15.srt	00:20:03.619 --> 00:20:15.489	So, L infinity for scale factor and L2 for noise that is we will be ordering the second order section ascending order of overshoot.
15.srt	00:20:16.089 --> 00:20:28.259	So, when we have L2 for scale factor and L infinity for noise then we will be having descending order of overshoot what we have to look into the thing based on this will be.
15.srt	00:20:28.559 --> 00:20:33.939	or second order section in ascending order or descending order depending on one of this.
15.srt	00:20:33.939 --> 00:20:38.499	So, if the same norm is used, so there is no preferred order.
15.srt	00:20:38.979 --> 00:20:43.029	So, you can go in whatever order you want to have it.
15.srt	00:20:43.159 --> 00:20:49.379	So, what is the practical application of IR parameter?
15.srt	00:21:00.109 --> 00:21:07.159	So, here we have considered P i is our pole positions which is given by R So, r is the radius of the circle into e power plus or minus j omega naught.
15.srt	00:21:08.269 --> 00:21:10.919	Omega naught is the angle of frequency what we are considering.
15.srt	00:21:10.949 --> 00:21:14.779	So, we assume that r p is in the range 0 and then 1.
15.srt	00:21:15.539 --> 00:21:30.359	So, the transfer function can be expressed in that case as we have h of z is equal to a divided by 1 minus r p into e power j omega naught into z minus 1.
15.srt	00:21:31.559 --> 00:21:38.419	into 1 minus r p into e power plus or minus j omega naught z minus 1.
15.srt	00:21:38.899 --> 00:21:45.129	So, when you this is my conjugate poles what I have taken the thing.
15.srt	00:21:45.499 --> 00:21:52.969	So, will be this is the second order sections what we are representing this is the first one and this is the second one what we are multiplying it.
15.srt	00:21:53.359 --> 00:22:01.759	So, then I expand the thing it becomes a by 1 minus 2 cos omega naught z minus 1 plus r p squared into z minus 2.
15.srt	00:22:02.409 --> 00:22:08.249	So, we represent these values as a1 and then a2.
15.srt	00:22:08.759 --> 00:22:12.779	So, what happens in the frequency domain?
15.srt	00:22:13.099 --> 00:22:25.759	So, if we are considering the normalized filter, the magnitude response is given by that is we will be substituting z is equal to e power minus j omega naught in this equation.
15.srt	00:22:26.109 --> 00:22:32.229	Then it becomes h of omega naught magnitude of it is given by a divided by 1 minus.
15.srt	00:22:32.529 --> 00:22:41.709	r p into e power j omega naught into j e power minus j omega naught and then the second term what you will be getting it.
15.srt	00:22:42.059 --> 00:22:50.429	So, the this condition can be solved to obtain the gain that is what is my a is equal to.
15.srt	00:22:50.839 --> 00:22:52.719	So, the magnitude of this.
15.srt	00:22:53.039 --> 00:23:05.549	So, some quantized values q minus r p what we will be assuming it into 1 minus root of 1 minus 2 r p into cos 2 omega naught plus.
15.srt	00:23:05.759 --> 00:23:11.149	So, how we can represent this ok.
15.srt	00:23:11.609 --> 00:23:21.759	So, this is my magnitude a x of n is the input and then what I have is z minus 1 is the delay.
15.srt	00:23:21.759 --> 00:23:30.759	So, the equation has in from the previous case what we are taking 2 r p cos 2 omega naught here.
15.srt	00:23:31.329 --> 00:23:36.789	So, that is what 2 r p cos omega naught is represented as a coefficient.
15.srt	00:23:37.279 --> 00:23:42.019	and this is my minus r p squared is the other coefficient.
15.srt	00:23:42.469 --> 00:23:47.439	So, which are fed into my adder and y of n is the output.
15.srt	00:23:47.789 --> 00:23:52.259	So, we say that this is the signal flow graph of our second order section.
15.srt	00:23:52.689 --> 00:24:02.419	So, what will be y of n if I consider this is the filter as the name says it is a resonator filter I will comment on it in a while.
15.srt	00:24:03.029 --> 00:24:07.519	This is a into x of n minus r.
15.srt	00:24:07.789 --> 00:24:12.579	a1 into y of n minus 1 minus a2 into y of n minus 2.
15.srt	00:24:13.049 --> 00:24:23.879	So, where we have a1 is equal to minus 2 rp cos omega naught t sorry cos omega naught and a2 is rp squared.
15.srt	00:24:24.429 --> 00:24:38.799	So, consider two causal impulse responses that is hc of n is given as cos omega that is the cos function what you have considered cos omega naught n into u of n.
15.srt	00:24:39.209 --> 00:25:00.219	So, the second one I can consider it as a sine function h s of n is equal to sine omega naught into omega naught n into u of n. So, then the equation as you will be seeing that the cos function is given by this equation and then sine function is represented this way.
15.srt	00:25:09.159 --> 00:25:17.569	Then what happens to my y c of n is nothing, but W of n minus cos omega naught into cos into W of or n minus 1 and y as sine function is given as sine omega naught into W of n minus 1.
15.srt	00:25:18.029 --> 00:25:33.059	So, we where we say W of n is an internal state variable that is updated as using this equation W of n is equal to cos 2 omega naught into W of n minus 1 minus W of n minus 2.
15.srt	00:25:33.539 --> 00:25:35.339	So, coming to the resonator.
15.srt	00:25:35.639 --> 00:25:43.149	So, all of us know that infinite impulse response why the name comes is once I remove the input.
15.srt	00:25:43.549 --> 00:25:49.339	So, I can remove the x of n. So, the system is going to oscillate on its own.
15.srt	00:25:49.409 --> 00:25:53.279	So, what is the advantage of it?
15.srt	00:25:53.719 --> 00:26:01.929	So, this resonating response what we will be using it in our generating sine wave.
15.srt	00:26:01.979 --> 00:26:14.479	So, we will see in the lab how we can giving only these 3 coordinates as we know that sine function is represented using the.
15.srt	00:26:15.129 --> 00:26:27.489	table, you can do the thing or we derived the harness way of representing it by expanding in series or you can use the math function, sine or cos function.
15.srt	00:26:27.489 --> 00:26:34.919	All of us know that when we use these functions, it is going to take a long time to compute.
15.srt	00:26:47.849 --> 00:26:56.489	So, with this IR filter with 2 feedback, we know that we can calculate the amplitude with 2 input because it is a LTI system usually we give initially 0 then automatically by giving x of n equal to 1.
15.srt	00:26:56.489 --> 00:27:06.859	So, it automatically start resonating and then we can generate different kinds of sine frequencies and then we can use it in our sine generation.
15.srt	00:27:06.919 --> 00:27:11.859	So, the next application is in the recursive quadrature oscillators.
15.srt	00:27:12.099 --> 00:27:21.329	So, those who are comfortable with communication you know where you need the quadrature oscillator.
15.srt	00:27:21.639 --> 00:27:23.719	So, how we are going to generate this?
15.srt	00:27:24.029 --> 00:27:30.089	So, you will be seeing this is a W of n and then W of n minus 1 in this case also.
15.srt	00:27:30.369 --> 00:27:31.639	So, you will be seeing that.
15.srt	00:27:31.999 --> 00:27:42.639	2 cos omega naught is the feedback signal what it is going and then feed forward what we have is a multiplication with sin omega naught.
15.srt	00:27:43.009 --> 00:27:55.219	And you will be seeing 2 delays this is W n minus 2 which you will be subtracting with the thing and you will be getting your cos and then here you will be getting the sin.
15.srt	00:27:55.299 --> 00:27:56.689	So, how you are going to get it?
15.srt	00:27:56.999 --> 00:28:03.139	So, you will be seeing that Ys of n is nothing, but a into X of n.
15.srt	00:28:03.499 --> 00:28:24.969	So, that is what you are getting the thing minus a1 into ys of n minus 1 minus a2 into ys of n minus 2 which is nothing, but if you simplify it is going to be 2 cos omega naught ys of n minus 1 minus ys of n minus 2.
15.srt	00:28:25.569 --> 00:28:34.449	So, with the initial conditions ys of 1 is equal to a sin omega naught and ys of 0 is equal to 0.
15.srt	00:28:34.959 --> 00:28:47.809	Then, I can calculate the frequency of it as cos inverse my magnitude of a 1 by 2 into f s by 2 pi into in terms of hertz.
15.srt	00:28:48.039 --> 00:28:59.599	This is the frequency what I will be generating it, where the coefficient magnitude of a 1 should be less than or equal to 2 which we caught it in our triangular representation ok.
15.srt	00:28:59.849 --> 00:29:08.389	So, this completes our IR filter for with respect to structure and then what is the quantization effect.
15.srt	00:29:08.639 --> 00:29:16.589	So, we will be solving some of the problems how a center frequency is going to change with quantization.
15.srt	00:29:16.929 --> 00:29:23.319	So, without quantization at with number of bits that is represented.
15.srt	00:29:23.319 --> 00:29:26.439	So, we will be seeing in our next class.
15.srt	00:29:26.849 --> 00:29:27.359	Thank you.
15.srt	00:29:27.709 --> 00:29:31.089	Happy learning in this class.
39.srt	00:00:00.340 --> 00:00:26.730	Namaste, welcome back to real time digital signal processing lab.
39.srt	00:00:27.070 --> 00:00:31.140	So whatever we have studied in theory regarding the adaptive filter will be.
39.srt	00:00:31.679 --> 00:00:40.030	seeing the demo first in MATLAB in the next class we will be seeing on the board using the code composer studio.
39.srt	00:00:40.649 --> 00:00:44.009	So today we will present the MATLAB.
39.srt	00:00:44.710 --> 00:00:51.359	So we will see the autocorrelation function with an example using MATLAB.
39.srt	00:00:51.829 --> 00:01:01.969	So what is it number of samples is chosen as 1024 and f1 is the frequency of sine wave what we will consider and f2 is.
39.srt	00:01:03.320 --> 00:01:12.219	other frequency component which is 200 hertz, f 1 is 1 hertz which is the sampling frequency both of them.
39.srt	00:01:12.950 --> 00:01:22.090	And then we will first we have to generate the sine wave using the sine function in this case what we are using it.
39.srt	00:01:34.640 --> 00:01:36.359	So, as we have discussed in the sine generation you can use any of the method either you can use the table, you can use IAR filter as an oscillatory function or you can use the sign function basically.
39.srt	00:01:36.359 --> 00:01:45.890	In this case we have taken sign function and then we can do the subplot and then see how it is going to look like.
39.srt	00:01:46.230 --> 00:01:56.860	Then what we this is the frequency what it is generated with sampling frequency of this thing what is it 8 kilohertz.
39.srt	00:01:57.180 --> 00:02:04.570	So, one it depicts that as the 1000 hertz and 200 will be 2 kilohertz what.
39.srt	00:02:05.350 --> 00:02:06.800	it is going to be generated.
39.srt	00:02:07.460 --> 00:02:30.270	So, then you will be calling the autocorrelation function in MATLAB Rxx which is nothing but X correlation of X basically and then we will plot it and then we can Rxx is getting plot and then we will see how it is going to look like.
39.srt	00:02:30.740 --> 00:02:34.200	So, this is the function in MATLAB what will be running it.
39.srt	00:02:34.620 --> 00:02:35.980	So, we will check the thing.
39.srt	00:02:37.070 --> 00:02:41.660	So, it will be asking me from which folder it has to take a default it may be there.
39.srt	00:02:42.140 --> 00:02:47.040	Since I have opened it or you have to go to that particular directory and open the file.
39.srt	00:02:47.580 --> 00:02:50.440	So, all the files are here as you can see.
39.srt	00:02:50.880 --> 00:02:51.890	So, it is running.
39.srt	00:02:52.370 --> 00:03:01.340	Now as you will be seeing the thing this is the sine wave which is correlated with the other sine wave.
39.srt	00:03:01.710 --> 00:03:06.960	So, you will be seeing the peak in the center and then which is going to be.
39.srt	00:03:08.320 --> 00:03:10.110	dying down in this case.
39.srt	00:03:10.510 --> 00:03:25.150	So, this is how it works and we will see that if we change the add a noise to it.
39.srt	00:03:25.220 --> 00:03:30.760	So, we have generated that is between the correlation between the two sine waves.
39.srt	00:03:31.060 --> 00:03:40.030	Now, if the sine wave is buried in a random noise what will be generating get so that is x plus the.
39.srt	00:03:40.250 --> 00:03:52.200	noise added and see whether we can see in that particular noise the correlation between the whatever input what we want to get that.
39.srt	00:03:52.510 --> 00:04:09.000	So, again we will be checking why is our noisy signal along with the original signal which has got embedded and then with the original signal we are trying to correlate and what will be our we call this is the cross correlation.
39.srt	00:04:11.230 --> 00:04:17.590	So, in this case because we are taking the correlation between two different signals.
39.srt	00:04:17.939 --> 00:04:23.580	So, if it is with the same signal we know that it is autocorrelation here it is between two signals.
39.srt	00:04:23.900 --> 00:04:30.490	So, we call it as the cross correlation basically and we will see how the output is going to look like.
39.srt	00:04:32.650 --> 00:04:38.930	So, this is the sine wave which is buried noise signal what you are seeing the thing.
39.srt	00:04:39.390 --> 00:04:41.160	So, this is y of n.
39.srt	00:04:41.550 --> 00:04:45.939	So, you are unable to make out the thing when I take the cross correlation.
39.srt	00:04:46.259 --> 00:04:54.530	So, you will be seeing that your signal is present that is what the cross correlation is going to show in this case.
39.srt	00:04:54.889 --> 00:05:01.060	So, now what is the next one we will see cross correlation.
39.srt	00:05:01.740 --> 00:05:08.000	So, this is between sine wave and then cosine wave first example what we will be seeing it.
39.srt	00:05:08.389 --> 00:05:09.699	So, you will be seeing that.
39.srt	00:05:12.370 --> 00:05:25.370	So, these are the T and T2 are the two frequencies what will be taking it, wave periods what you will be multiplying with and then sample period what you will take it.
39.srt	00:05:25.650 --> 00:05:41.379	Here over sample is 1024 in this case and frequency is 1 kilohertz and then you will be this is the sample period with the by over sample what you will be taking it.
39.srt	00:05:41.379 --> 00:05:46.790	So, you will be doing the generation of sine wave here.
39.srt	00:05:47.189 --> 00:05:57.990	and cosine wave and then you can see the correlation between sine wave, cos wave and then the sine wave and then see how it is going to look like.
39.srt	00:05:58.410 --> 00:06:08.730	So, we will run the code and you will be seeing that this is what our code looks like.
39.srt	00:06:17.990 --> 00:06:18.750	What we will do is, one thing what I have to do is for you to look at the think correctly.
39.srt	00:06:18.780 --> 00:06:28.350	So, I will try to reduce the display settings, so that you can view the thing correctly.
39.srt	00:06:28.390 --> 00:06:35.280	So, I will make it 100 percent and then only for the letters we may have to have it little bigger.
39.srt	00:06:35.670 --> 00:06:40.740	So, I can make it this is little bigger for you to view the signal.
39.srt	00:06:41.160 --> 00:06:45.580	So, you will be seeing that these are the two signals.
39.srt	00:06:45.930 --> 00:06:49.040	So, when you do the subtraction of it.
39.srt	00:06:49.530 --> 00:06:57.189	there will be something correlation coefficient is going to be more in this case.
39.srt	00:06:57.670 --> 00:07:11.160	So, that is what we will look at it and then we will see for the I will be passing sine wave and then I will be passing the other one is a exponent.
39.srt	00:07:11.520 --> 00:07:14.260	So, how does it look like we will see it.
39.srt	00:07:14.500 --> 00:07:26.410	So, I will be commenting the cos wave and then I am calling the with the same name because I need not have to change at this place also, but this is now the exponential decaying signal.
39.srt	00:07:26.530 --> 00:07:29.410	So, minus 0.1 into.
39.srt	00:07:30.290 --> 00:07:39.660	T whatever T is getting generated here in the same way ok. Then we can see it in T2 also what is the thing is going to look like.
39.srt	00:07:40.040 --> 00:07:42.350	So, we will run this again.
39.srt	00:07:43.240 --> 00:07:56.400	So, you are seeing that this is what your that is cross correlation between your exponentially decaying signal and then the sine wave.
39.srt	00:07:56.819 --> 00:08:00.980	When you add them out you will be seeing that it becomes 0.
39.srt	00:08:02.069 --> 00:08:04.970	So, that that shows that they are not correlated.
39.srt	00:08:05.459 --> 00:08:17.250	So, as we discussed in the theory if it is plus 1 it is positively correlated, if it is negative negatively correlated or if it is 0 it is uncorrelated.
39.srt	00:08:17.980 --> 00:08:19.860	So, this is what it will show.
39.srt	00:08:20.129 --> 00:08:29.300	So, we will see that with respect instead of t we will put it as t 2 and see whether it is going to make any difference here.
39.srt	00:08:33.210 --> 00:08:37.620	t 2 was the sample period which was getting generated with respect to.
39.srt	00:08:38.039 --> 00:08:40.059	are cause with signal.
39.srt	00:08:40.059 --> 00:08:41.459	So, we will run the thing.
39.srt	00:08:41.490 --> 00:08:57.409	So, you will be seeing that it is how the distance is when you add both of them you will be seeing that it is going to become 0 irrespective of whatever changes you have done.
39.srt	00:08:57.799 --> 00:09:04.789	So, this shows that how our correlation is going to look like some other functions are there.
39.srt	00:09:08.579 --> 00:09:18.600	So, you will be seeing that how to generate But, if you see the thing this is generating 64 samples of this thing sine wave with frequency 1 kilohertz.
39.srt	00:09:19.039 --> 00:09:26.079	So, how you can run that and then the other one will be how to generate your exponential signal.
39.srt	00:09:26.110 --> 00:09:38.230	So, you will be seeing that this is what how the exponential looks like which we this thing run the cross correlation with this exponent and then the sine wave generated.
39.srt	00:09:39.040 --> 00:09:58.850	And, then the other one you will be seeing it is generating what is it 64 with this thing unit impulse signal how to generate it what it is going to show some of the signal generation what you will be looking at it.
39.srt	00:09:58.850 --> 00:10:01.570	So, this is the unit response.
39.srt	00:10:01.899 --> 00:10:11.090	So, at 0 it is going to be 1 and rest of the places it is going to be 0s as you know how to generate it using MATLAB these functions show.
39.srt	00:10:11.699 --> 00:10:18.419	Now, with this correlation so, what we will do is we will go to adaptive filter.
39.srt	00:10:19.449 --> 00:10:25.620	So, we have already seen this adaptive filter in the last class.
39.srt	00:10:25.929 --> 00:10:36.769	So, what we will do is how to generate our LMS and then NLMS algorithm and then see the difference application what we discussed in the class.
39.srt	00:10:42.409 --> 00:11:02.129	We will look at it noise cancellation and other things and then how to generate our echo and then scrambler and equalizer with respect to matlab what we will see it and then the same thing we can look at it in the code composer studio also.
39.srt	00:11:02.169 --> 00:11:09.969	And we will be seeing these are the assignments done by as I have been mentioning by different students.
39.srt	00:11:10.069 --> 00:11:16.409	So, how they do that and then how your code also can be what we will look at it.
39.srt	00:11:16.469 --> 00:11:17.419	So, this.
39.srt	00:11:23.539 --> 00:11:28.649	will be a m file what it is going to run it.
39.srt	00:11:28.649 --> 00:11:35.849	I will be closing because we have finished the thing.
39.srt	00:11:35.949 --> 00:11:37.179	So, we can open this.
39.srt	00:11:37.309 --> 00:11:38.799	So, here it is doing a GUI.
39.srt	00:11:38.839 --> 00:11:42.879	So, LMS algorithm demo what we have seen the thing.
39.srt	00:11:51.519 --> 00:12:22.730	So, we will see NLMS and then RLS those who are interested can look into the thing and then see that how it is going to work want to work because it is a very complex equations one has to write and then it will take time for most of the applications either we will be running LMS algorithm which has faster because we know that time consumption for inversion of a matrix and other things will take longer time in our hardware.
39.srt	00:12:23.129 --> 00:12:25.049	So, we will be trying to avoid ok.
39.srt	00:12:25.339 --> 00:12:26.919	So, you will be seeing that.
39.srt	00:12:27.309 --> 00:12:34.440	So, this is what the how the creation of our LMS algorithm.
39.srt	00:12:34.440 --> 00:12:46.850	So, the order is defined with 20 if you want to change the order you can do the thing and then the weight functions are initially set to 0 and then mu is set to 0.006.
39.srt	00:12:46.850 --> 00:12:52.700	So, we have seen that varying the mu how it is going to get affected ok.
39.srt	00:12:52.700 --> 00:12:57.620	So, you will be seeing that up to the length of X minus order.
39.srt	00:12:57.620 --> 00:12:59.529	So, you will be putting it.
39.srt	00:13:00.069 --> 00:13:18.899	So, our y out of i is going to be ok. What I will do is now before running the thing I can increase the font size so that you would be able to see them properly ok.
39.srt	00:13:19.209 --> 00:13:27.399	I will make it as 125 and then when I am running the thing if the graphs are coming then we may have to reduce the thing.
39.srt	00:13:27.399 --> 00:13:32.899	So now you will be seeing length of x minus the order of your filter.
39.srt	00:13:33.339 --> 00:14:03.609	you will be putting that what is it buffer is initialized and then y out of i is buffer of into our y into your this thing weight function w into 2 and then error function is calculated of y i minus buffer into w and this is the weight function which is getting updated w plus buffer dot star mu into our error of i.
39.srt	00:14:04.019 --> 00:14:08.730	So, update the weights and then we will be computing it.
39.srt	00:14:09.299 --> 00:14:14.740	So, the next one is NLMS algorithm.
39.srt	00:14:15.069 --> 00:14:17.409	So, here we will be defining alpha.
39.srt	00:14:17.720 --> 00:14:21.309	Alpha is equal to 1 we said it is equivalent to LMS algorithm.
39.srt	00:14:21.610 --> 00:14:27.870	So, here alpha is chosen as 0.005 and then your constant what you will be calling it as 0.7.
39.srt	00:14:27.949 --> 00:14:32.730	So, you will be doing the same thing with.
39.srt	00:14:34.439 --> 00:14:39.549	your mu is calculated on the go as you can see it here.
39.srt	00:14:39.869 --> 00:14:45.799	It is 2 times alpha divided by because we said some small constant what we have to assume.
39.srt	00:14:45.799 --> 00:14:57.469	So, that divide by 0 is not going to happen and then you will be doing the buffer squared in this case ok. And then your weight function is going to be updated.
39.srt	00:14:58.269 --> 00:15:08.219	So, as you can see that this division also has to happen which is a costly affair as we have seen in the.
39.srt	00:15:08.559 --> 00:15:08.749	class.
39.srt	00:15:09.179 --> 00:15:21.619	So, multiplication is easier to do it we saw Braun multiplier, but division successive subtraction what we have to do it which is costly.
39.srt	00:15:21.619 --> 00:15:28.979	So, that that is the reason why most of the cases will be assuming mu and then will be running the LMS algorithm.
39.srt	00:15:28.979 --> 00:15:33.559	In the worst case if it is not ok then we may have to go for this.
39.srt	00:15:33.929 --> 00:15:39.899	So, the other one is RLS algorithm you will be seeing that.
39.srt	00:15:40.409 --> 00:15:53.269	So, your this thing will be calling it as a random function and then you have to length of the w is going to be 0s and then some constant what you will be providing.
39.srt	00:15:53.579 --> 00:16:01.989	In this case gamma is one of the constant one has to use it which is almost nearer to 1 what it is shown in the thing.
39.srt	00:16:02.569 --> 00:16:11.229	And then the equation you will be seeing that how you will be calculating your temporary value and then error.
39.srt	00:16:12.039 --> 00:16:21.319	function what you are calculating and then alpha is going to be calculated in this case using gamma plus r buffer basically.
39.srt	00:16:21.639 --> 00:16:44.609	And then g is the constant p into buffer divided by alpha what we will take and then the weight is updated based on these constants basically g value and then you will be calculating the that is p value power of the thing by gamma and then your y out is.
39.srt	00:16:44.929 --> 00:17:11.500	n is going to be your y temporary what you have calculated here earlier ok. And this is how you will be updating your this thing what is it mu value which is going to be calculated and then as you will be seeing that lot of division and then multiplication are involved in the RLS algorithm.
39.srt	00:17:11.869 --> 00:17:16.559	So, we will see but it is much more precise than the both of the algorithm.
39.srt	00:17:16.989 --> 00:17:42.679	So, we will run the algorithm as you will be ok I was able to see the thing otherwise I had to reduce my size of the what I will put it as screen to in any case to have a better clarity what we will do is put it in the 100 percent our display size.
39.srt	00:17:42.679 --> 00:17:45.649	So, that you will be able to see them clearly.
39.srt	00:17:46.249 --> 00:17:47.689	So, as you can see here.
39.srt	00:17:49.609 --> 00:17:52.109	I will make it maximize.
39.srt	00:17:52.489 --> 00:17:56.079	So, I will be loading the noisy signal.
39.srt	00:17:56.079 --> 00:18:07.169	So, I have to select the thing this is the noisy signal what I have it and then I have to load the reference signal both has to be fed into our algorithm.
39.srt	00:18:07.619 --> 00:18:09.979	So, this is the desired signal.
39.srt	00:18:10.519 --> 00:18:23.999	So, now, we have run it already in the previous class LMS algorithm, but to have the better understanding of it I will run the LMS algorithm and you are seeing that this is the noise.
39.srt	00:18:24.619 --> 00:18:31.889	added signal what it is shown this is the original signal when you do the LMS algorithm you are getting back.
39.srt	00:18:32.169 --> 00:18:36.699	So, we will play the thing it is the same speed signal what we will be doing it.
39.srt	00:18:36.839 --> 00:18:40.039	Remember the force will be with you always.
39.srt	00:18:41.129 --> 00:18:43.049	So, you will be seeing with the noise.
39.srt	00:18:48.029 --> 00:18:49.689	Remember the force will be with you always.
39.srt	00:18:49.689 --> 00:18:55.259	Here also single tone as we demonstrated in the filters same thing has been used for a adaptive algorithm.
39.srt	00:18:55.609 --> 00:18:57.309	So, you will be hearing the output.
39.srt	00:18:58.299 --> 00:19:01.339	Remember the force will be with you always.
39.srt	00:19:01.789 --> 00:19:04.109	So you can see initially there was a dip.
39.srt	00:19:04.399 --> 00:19:09.539	So we will run the same thing with an LMS algorithm ok.
39.srt	00:19:09.849 --> 00:19:17.969	So you have seen that the thing is little bit shifted and we will hear it how it is different from the LMS algorithm.
39.srt	00:19:18.259 --> 00:19:21.369	Remember the force will be with you always.
39.srt	00:19:22.659 --> 00:19:27.459	So now we will run the RLS algorithm which is much more precise.
39.srt	00:19:27.859 --> 00:19:39.649	as you will be seeing that this is your input signal and this is with the noise and you are seeing your output almost your complete noise is removed.
39.srt	00:19:39.649 --> 00:19:41.579	So, we will play this.
39.srt	00:19:42.549 --> 00:19:47.469	Remember the force will be with you always.
39.srt	00:19:47.469 --> 00:19:53.759	So, one has to pay for computation if you want to have much more clarity ok.
39.srt	00:20:00.099 --> 00:20:05.659	So, we will get back to our 125 percent so that we can see the thing and then when we running the code will go back again to our 100 percent.
39.srt	00:20:05.979 --> 00:20:09.089	So, this shows our NLMS and this thing algorithm.
39.srt	00:20:09.089 --> 00:20:18.509	So, what we will do is again as I said different students do different way here everything put together.
39.srt	00:20:18.589 --> 00:20:28.029	So, the other students what they do is some of them they do it in a different way it is directly LMS algorithm.
39.srt	00:20:30.819 --> 00:20:32.579	here it is going to run ok.
39.srt	00:20:32.979 --> 00:20:46.579	So, that is what is it you will be algorithm remains the same thing your order of the filter may vary and what tone you will be taking it is going to be different.
39.srt	00:20:46.929 --> 00:20:54.019	So, this is going to start from 120 this thing x and y arrays basically.
39.srt	00:20:54.359 --> 00:20:55.939	So, what you are storing it.
39.srt	00:21:00.939 --> 00:21:09.739	So, this will be your LMS algorithm i is equal to L you will be starting from L value down to 2 actually that is why minus 1.
39.srt	00:21:10.069 --> 00:21:14.419	So, you will be updating your X i in the reverse direction ok.
39.srt	00:21:14.679 --> 00:21:21.919	So, this consumes less time when you are doing the from the other end to this end.
39.srt	00:21:22.969 --> 00:21:25.469	Basically circular convolution should happen.
39.srt	00:21:25.869 --> 00:21:28.319	So, that is what is implemented here.
39.srt	00:21:28.789 --> 00:21:30.419	So, you will be seeing that.
39.srt	00:21:31.029 --> 00:21:33.169	x filter through the thing.
39.srt	00:21:33.219 --> 00:21:51.089	So, that is up to the filter length you are calculating your y, x of i into your w of i because n minus i what it is the thing what it is taking x of n i minus n you can take it and then you will be multiplying with w of i.
39.srt	00:22:02.279 --> 00:22:15.489	And then this is your error function which is given by WI that is desired signal big of n minus y you will be knowing even you may name it in a different way ok. And then update of W is going to happen.
39.srt	00:22:15.929 --> 00:22:24.529	So, that is mu error is calculated as mu into en error and you will be updating the WI.
39.srt	00:22:25.239 --> 00:22:35.629	You may be wondering why this has been done earlier why not in the other student what he had done was it is inside this loop.
39.srt	00:22:36.189 --> 00:22:40.769	I will be updating my error and then I will be using it.
39.srt	00:22:41.279 --> 00:22:49.899	So, can you guess what is the thing is going to happen because I am putting in the loop every time this constant has to be multiplied.
39.srt	00:22:50.299 --> 00:22:58.659	Otherwise I can there are going to be how many multiplications along with it 2 more multiplications I have to provide.
39.srt	00:22:58.659 --> 00:23:04.989	Here I have reduced it by 1 so that which is pre-computed this is not going to change.
39.srt	00:23:05.959 --> 00:23:10.509	according in the loop and then you can multiply and get the result.
39.srt	00:23:10.869 --> 00:23:17.739	So, you will be getting your error basically shown this way.
39.srt	00:23:18.139 --> 00:23:21.169	So, let me run the thing and then.
39.srt	00:23:23.409 --> 00:23:24.049	So, ok.
39.srt	00:23:36.999 --> 00:23:50.509	So, let me run the thing.
39.srt	00:23:50.959 --> 00:23:55.250	So, one of the thing is what is it?
39.srt	00:23:56.129 --> 00:23:58.769	This has not been calculated.
39.srt	00:23:58.849 --> 00:24:14.240	So, what we will do is I have to hopefully I will be able to uncomment it and then we will save it and then try to run the thing.
39.srt	00:24:15.740 --> 00:24:18.929	While it is giving an.
39.srt	00:24:54.739 --> 00:25:05.659	in the can you guess what is the thing it is unable to get voice and then tone dot wave file actually sorry I have missed to put the thing what will do is I can bring the thing from the other one and then put it here here both you have been I will put the copy it here and then we will see and then change the name with this name.
39.srt	00:25:17.399 --> 00:25:32.079	That is nice see sorry I should use capital save it and then I can run.
39.srt	00:25:34.019 --> 00:25:46.879	There is this thing because it is you will be seeing that index in position 2 exceeds array bounds this should not exceed what it says.
39.srt	00:25:47.199 --> 00:26:02.529	So, the problem with this is because it is a different signal what I have taken because they would have set it to their requirement as you will be seeing it I had to get this file here and then run the.
39.srt	00:26:03.239 --> 00:26:19.519	So, that we can see it in the hopefully I have the that thing it has not been copied for the thing.
39.srt	00:26:19.519 --> 00:26:31.959	I will get that signal so that otherwise we have to.
39.srt	00:26:36.089 --> 00:26:42.049	So, whatever error is coming what it shows is it is a two channel what it has to take it.
39.srt	00:26:42.049 --> 00:26:45.109	So, here it is having only one channel.
39.srt	00:26:45.109 --> 00:26:48.079	So, unable to read this file.
39.srt	00:26:48.079 --> 00:26:53.889	So, when they have combined the two thing together we have to read them.
39.srt	00:26:53.889 --> 00:27:09.159	So, what I will do either we have to correct this or because it may give some more error in the thing the way they have implemented it because it is two channel what it has taken the thing this is.
39.srt	00:27:09.459 --> 00:27:13.779	They are putting it as a first channel and this is going to take from the second channel.
39.srt	00:27:14.189 --> 00:27:16.439	As you know it is a stereo input.
39.srt	00:27:16.879 --> 00:27:22.279	So, stereo input the first channel what you can input is your desired signal.
39.srt	00:27:22.799 --> 00:27:30.779	In the second this thing that is left channel will be desired signal, right channel you can put the noise basically.
39.srt	00:27:31.179 --> 00:27:43.779	So, that you are depicting whatever we discussed in the class that is the signals are coming from two sources one is the desired signal the other one is your what is it.
39.srt	00:27:44.079 --> 00:27:52.709	noise separately captured from two places which has been combined and then put it as a audio basically in.
39.srt	00:27:52.779 --> 00:27:58.889	So, this has to be merged using the MATLAB code and then you we must be taking it in.
39.srt	00:27:59.279 --> 00:28:06.039	Here it is only one channel what it present that is why it is giving me error.
39.srt	00:28:06.039 --> 00:28:07.829	So, thank you for listening.
39.srt	00:28:07.989 --> 00:28:12.949	In the next class we will take up the scrambling and then.
39.srt	00:28:16.479 --> 00:28:22.669	what I will put it as echo generation, reverberation and then scrambler together.
39.srt	00:28:23.199 --> 00:28:24.549	Thank you.
11.srt	00:00:01.219 --> 00:00:15.779	Welcome back.
11.srt	00:00:15.779 --> 00:00:28.399	So, we are discussing about Pipelining and then Parallel Processing for Low Power Applications.
11.srt	00:00:28.769 --> 00:00:30.160	Continuing with the thing.
11.srt	00:00:30.439 --> 00:00:35.969	So, because we need for parallel processing the data has to be fed in parallel.
11.srt	00:00:36.369 --> 00:00:52.849	So, from sequential how will be converting into parallel we will see in the this figure that is what we say is critical path has remained unchanged in these cases, but the interaction period is going to be reduced in this.
11.srt	00:00:53.370 --> 00:01:01.480	So, what we say is x of n is the input then we if we consider in this case as we are seeing we will be considering.
11.srt	00:01:01.909 --> 00:01:03.439	4 parallel lines.
11.srt	00:01:03.789 --> 00:01:16.399	So, that it will give you a flavor of how 2 parallel lines we have to take it, how 3 and then now we will see 4 parallel line parallel units if we consider then what is the thing is going to happen.
11.srt	00:01:16.670 --> 00:01:22.840	So, the sample period what we will do is we will subsample it to T by 4 in this case.
11.srt	00:01:23.189 --> 00:01:34.169	Then we will go for serial to parallel converter and then we will be getting x of 4k plus 3, x of 4k plus 2, x of 4k plus 1 and x of 3.
11.srt	00:01:34.530 --> 00:01:48.969	k in this case and then in this case the clock period is going to be t for multiple input and multiple output system and output all the 4 of them will be coming out parallelly.
11.srt	00:01:49.719 --> 00:01:55.829	And then we have to convert back this parallel into serial converter.
11.srt	00:01:56.259 --> 00:01:58.340	So, how we can incorporate that?
11.srt	00:01:58.799 --> 00:02:05.209	So, in this way clock period is going to be t by 4 and we will convert back this parallel into serial.
11.srt	00:02:05.239 --> 00:02:06.199	So, which will be.
11.srt	00:02:06.869 --> 00:02:12.030	coming out from the circuit as y of n in serial mode.
11.srt	00:02:13.259 --> 00:02:20.209	So, we will see using the switches how serial to parallel converter and then parallel to serial converter is going to work.
11.srt	00:02:20.519 --> 00:02:25.469	So, this is my x of n and then input is t by 4.
11.srt	00:02:25.819 --> 00:02:37.799	So, we will provide the delay element in our path and we will be providing the switches basically to see that all the output whatever input has been given.
11.srt	00:02:38.539 --> 00:02:40.629	will have 4 of them.
11.srt	00:02:40.959 --> 00:02:43.209	So, every t by 4 clock cycle.
11.srt	00:02:43.599 --> 00:02:46.249	So, you will be switching on one of the unit.
11.srt	00:02:46.459 --> 00:02:52.239	So, all the 4 inputs are ready after my t by t clock cycle.
11.srt	00:02:52.779 --> 00:02:59.119	So, then what will be this is how will be feeding in all the 4 parallely.
11.srt	00:02:59.469 --> 00:03:04.599	Now, this parallel has to be converted into serial basically.
11.srt	00:03:04.599 --> 00:03:05.909	What we are going to do?
11.srt	00:03:06.369 --> 00:03:11.219	What we have it is via 4k plus 3.
11.srt	00:03:11.799 --> 00:03:15.069	2 and then plus 1 and then 4k.
11.srt	00:03:15.649 --> 00:03:35.799	So, what we have is this is going to operate at 4k the switch and then you will be closing them every t by 4 as you are seeing it in this y of n is the input and one of them is going to be opened and then you will be sending after a delay.
11.srt	00:03:36.229 --> 00:03:42.059	So, for the first this thing switching all of them will be switched parallely.
11.srt	00:03:42.059 --> 00:03:42.849	So, you will be.
11.srt	00:03:43.449 --> 00:04:09.049	Taking all the 4 inputs, so this will have a 0 initially what you will be putting it and then you will be switching on this and then you will be seeing that 0 is going to be percolated first and then you will be operating on one after the other 4k will be coming out first and then next this one after 1 unit of time and then next this one.
11.srt	00:04:09.389 --> 00:04:13.490	So, each one is clocked at T by 4.
11.srt	00:04:14.120 --> 00:04:20.850	So, in a 1 clock cycle in the 4 clock cycle so, you will be getting 4 outputs.
11.srt	00:04:21.240 --> 00:04:27.870	This is how we will be doing the serial and parallel conversion and then parallel to serial conversion.
11.srt	00:04:28.290 --> 00:04:31.990	So, what happens why parallel processing is required.
11.srt	00:04:32.629 --> 00:04:45.370	So, parallel leads to duplicating many copies of hardware and the cost is going to increase as well as if we are operating with same units.
11.srt	00:04:45.649 --> 00:04:53.919	or same voltage we know that our speed is going to be increased and power consumption is going to be more.
11.srt	00:04:54.419 --> 00:04:56.109	So, then why use this?
11.srt	00:04:56.509 --> 00:05:02.949	So, we say answer lies in the fact that the fundamental limit to the pipelining is at I-O bottlenecks.
11.srt	00:05:02.949 --> 00:05:10.659	So, that is referred to as communication bound composed of I-O pad delay and the wire delay.
11.srt	00:05:10.789 --> 00:05:21.740	So, in this case you know chip 1 and chip 2 is there, this is the between the two chips this is the communication delay what we are going to have it.
11.srt	00:05:22.709 --> 00:05:34.369	So, in the case of pipelining if my communication cost is more than pipelining then no point in going for the pipelining stages number of stages to be increased.
11.srt	00:05:34.739 --> 00:05:43.249	Then it is better to switch over to parallel processing then I can work on independent data in these cases.
11.srt	00:05:43.699 --> 00:05:48.759	So, what we call it as this is the parallel transmission what I can have it.
11.srt	00:05:49.309 --> 00:05:52.739	So, you will be seeing that T is my computation.
11.srt	00:05:53.109 --> 00:06:00.759	So, taking in the data from chip 2 to here and data going from chip 1 to chip 2.
11.srt	00:06:01.269 --> 00:06:02.969	So, this defines the thing.
11.srt	00:06:03.119 --> 00:06:08.929	So, we will see that how we can combine or find grain pipelining and then parallel processing.
11.srt	00:06:09.199 --> 00:06:17.809	So, you will be seeing the iteration we said that sample period is equal to T sample in this case.
11.srt	00:06:18.279 --> 00:06:24.969	Then what happens if I put both of them pipelining and then parallelism it becomes 1 by.
11.srt	00:06:25.659 --> 00:06:27.279	L m into t clock.
11.srt	00:06:27.599 --> 00:06:44.919	So, that means, to say 1 by sixth of t m plus 2 a it is going to be at iteration every iteration I will be getting one sixth of my what is it I have increased my clock speed.
11.srt	00:06:45.009 --> 00:06:48.089	How I can do this fine grain parallelism?
11.srt	00:06:48.179 --> 00:06:52.049	So, you will be seeing that input is x of 3k plus 2.
11.srt	00:06:56.529 --> 00:06:57.560	So, x of 3k plus 1 and x of 3k.
11.srt	00:06:57.879 --> 00:07:10.569	So, this is our parallel unit and then when I come to multiplier I can bifurcate in them into pipeline mode that is m 1 becomes 6 clock units and the other one I can take it as 4 clock units.
11.srt	00:07:28.509 --> 00:07:32.370	So, I have provided 2 pipelining basically m is equal to 2 and l is equal to 3 then my iteration time that is how it is going to be 1 by lm is 1 by 6 original time what it will be I will be getting the output.
11.srt	00:07:32.699 --> 00:07:38.870	So, you will be seeing just all the multipliers we have made it as pipeline multipliers.
11.srt	00:07:39.239 --> 00:07:50.370	So, that multiply clock time is made equal to the other side of the leg what we considered in the previous example.
11.srt	00:07:51.759 --> 00:07:55.219	So, what is the underlying low power concept we have to look in?
11.srt	00:07:55.649 --> 00:08:03.359	We said by I can increase 6 times the clock speed for my both the pipelining and parallelism or.
11.srt	00:08:04.120 --> 00:08:13.089	at the clock rate one sixth of it what I can operate, but how we are going to have a power low power getting the thing.
11.srt	00:08:13.810 --> 00:08:18.100	So, initially we said that this is the propagation delay equation what we had it.
11.srt	00:08:18.100 --> 00:08:30.990	So, the time period you will be seeing that for the sequential power consumption we call it as c total v naught square into f into t sequential is our clock period what we will be taking for every bit of data.
11.srt	00:08:37.339 --> 00:09:06.449	So, then what happens our delay is given by propagation delay P d is given by C into charge basically my capacitor charging time and then V naught what is the power input power and then k is a constant because this is proportional to we are assume the k and V naught is our input voltage and V t is the threshold we know that in CMOS circuit.
11.srt	00:09:06.809 --> 00:09:08.979	So, we have a threshold unit.
11.srt	00:09:09.349 --> 00:09:17.899	So, in NMOS we will be seeing that 1.5 volts whereas, in CMOS it is going to be 0.5 volts above that we consider it as 1 volt.
11.srt	00:09:17.899 --> 00:09:23.329	So, that way we will see that power consumption is given by P is equal to C total into.
11.srt	00:09:24.600 --> 00:09:26.950	V naught square into f ok.
11.srt	00:09:27.289 --> 00:09:44.519	So, for the sequential filter when I apply this, this is what I will be getting it and then when I put the propagation delay is substituted, I will be getting C charge into V naught divided by k into V naught minus V t whole squared.
11.srt	00:09:45.029 --> 00:09:54.019	So, we are substituting V naught with this and then into f. So, which is going to be 1 by time for sequential.
11.srt	00:09:56.590 --> 00:09:59.709	So, do the pipelining what is the thing is going to happen?
11.srt	00:10:00.039 --> 00:10:27.679	We say it is M level pipeline system, the critical path we say is 1 by M. So, that is capacitance tends to be charged in a single clock cycle becomes 1 by M. So, as you are seeing in the sequential I have to charge this capacitor in T sequential whereas, in the pipeline if I assume M is equal to 3 then the capacitor has to be charged as you will be seeing the time.
11.srt	00:10:28.179 --> 00:10:33.069	is going to be reduced basically we call that as beta into v naught.
11.srt	00:10:33.659 --> 00:10:37.479	So, here initially it was v naught and we will assume beta into v naught.
11.srt	00:10:37.870 --> 00:10:46.229	The clock frequency is if we maintain the same clock frequency and we say the power supply can be reduced to beta times v naught.
11.srt	00:10:46.839 --> 00:10:54.750	We say it is 0 is less than or equal to beta which is less than 1, 0 is less than beta which is less than 1.
11.srt	00:10:55.529 --> 00:10:58.129	So, coming to low power continuation.
11.srt	00:10:58.319 --> 00:11:07.619	We say power consumption what we said for the pipelining it is going to be c total into beta squared into v naught squared into the frequency.
11.srt	00:11:07.979 --> 00:11:14.559	So, which we apply it as a sequential thing which is beta squared into p sequential.
11.srt	00:11:15.039 --> 00:11:17.389	Then what happens to our propagation delay?
11.srt	00:11:17.769 --> 00:11:29.039	So, that is t sequential we will be having c charge into v naught divided by k into v naught minus v t whole squared and for the pipeline case.
11.srt	00:11:29.259 --> 00:11:36.409	We said the charging unit is reduced by m whatever in this case we have taken it as 3.
11.srt	00:11:36.809 --> 00:11:49.219	So, otherwise in normal C charged by m what it has to be charged to the in pipelining into beta into v naught we are substituting v naught with beta, beta into v naught.
11.srt	00:11:49.269 --> 00:11:56.689	And here also we will be substituting k into beta into v naught minus v t whole squared.
11.srt	00:11:57.179 --> 00:12:00.279	Then we will apply that sequential is equal to.
11.srt	00:12:00.659 --> 00:12:03.469	of pipelining stage.
11.srt	00:12:04.399 --> 00:12:13.249	If we substitute them then what happens by simplifying it you will be getting it m into beta into v0 minus vt whole squared.
11.srt	00:12:13.629 --> 00:12:23.119	So, which is equivalent to b into v0 minus vt whole square from this equation we will be getting our beta.
11.srt	00:12:23.739 --> 00:12:26.829	So, we will consider an example here.
11.srt	00:12:27.299 --> 00:12:35.099	So, we will consider a 3 tap FIR filter and it is fine grain pipeline version what we will be assuming it.
11.srt	00:12:35.459 --> 00:12:44.759	So, it is shown in the following figure that this is the original or 3 tap FIR filter and this is our fine grain parallelism what we have considered.
11.srt	00:12:44.819 --> 00:12:53.189	So, in this case what the parameters have been given is my multiplier unit is going to take 10 units of time.
11.srt	00:12:53.639 --> 00:13:00.929	And my adder will be taking 2 units of time and you have been given the threshold voltage is given as 0.6 volts.
11.srt	00:13:01.779 --> 00:13:14.039	and then V naught that is the supply voltage it is operating at 5 volts and the capacitor of multiplier is equivalent to 5 times that of the capacitor of the adder.
11.srt	00:13:14.609 --> 00:13:33.759	So, you will be seeing that pipeline filter the multiplier is broken into 2 parts M1 and then M2 with computation time of 6 units and then 4 units which will be totally accounting for 10 unit of time with capacitance of 3 times and 2 times that of an adder.
11.srt	00:13:34.139 --> 00:13:37.909	adder respectively what we will be considering it.
11.srt	00:13:38.329 --> 00:13:41.789	So, what happens to the our equation?
11.srt	00:13:41.789 --> 00:13:48.009	So, original what we had was C charge was given by C m plus C a.
11.srt	00:13:48.459 --> 00:13:53.599	So, we said C m is 5 times of C a which is going to be 6 times C a.
11.srt	00:13:53.829 --> 00:14:06.639	In the fine grain it is going to be C charge equal to C m1 which is equal to C m2 plus C a because we have.
11.srt	00:14:07.259 --> 00:14:09.219	1 pipeline stage there.
11.srt	00:14:09.709 --> 00:14:15.479	So, which is equal to 3 times that of C a what it is going to be.
11.srt	00:14:16.129 --> 00:14:36.969	So, then our equation we will be seeing that m is equal to 2 in this case we have assumed and then supply voltage v naught is 5 times beta minus v t is 0.6 threshold which is whole squared is equal to which is equal to beta into 6 is our.
11.srt	00:14:38.879 --> 00:14:42.619	basically minus 0.6 whole squared.
11.srt	00:14:42.619 --> 00:14:48.679	So, which comes there are as when you solve this equation.
11.srt	00:14:48.829 --> 00:14:55.459	So, it is going to be beta will be equal to 0.6033 or 0.0239.
11.srt	00:14:55.829 --> 00:15:09.469	So, we say that because our threshold voltage is 0.6 voltage what it has been given this value is much below that threshold.
11.srt	00:15:09.469 --> 00:15:12.429	So, capacitor will not be switching on.
11.srt	00:15:12.429 --> 00:15:14.489	So, we say that this is infeasible.
11.srt	00:15:14.489 --> 00:15:17.059	So, it becomes 0.6033 is the.
11.srt	00:15:20.159 --> 00:15:32.449	supply voltage what we can reduce to that is a ratio is we call it as beta squared when I take it the reduction is going to be 36.4 percent.
11.srt	00:15:32.539 --> 00:15:41.089	But we say that pipelining should have given me 50 percent, but in this case only the reduction can be 36.4 percent.
11.srt	00:15:41.429 --> 00:15:44.079	So, as you can see in this case.
11.srt	00:15:53.979 --> 00:16:13.809	When we do the comparison how it is going to be that is system is power is reference And, sequential FIR original if I take it that is in terms of my power reference and pipeline FIR without reducing the V naught what I will be getting is 2 times the original one I am supposed to get the output.
11.srt	00:16:14.309 --> 00:16:24.509	And then in case of with reduction in the voltage so, it becomes 0.364 times the whatever power consumed with respect to reference.
11.srt	00:16:26.429 --> 00:16:38.349	And, the clock period unit time what we are assuming is here it is going to take 12 units of time in the original because multiplier is 10 units and then adder is 2 units which is 12.
11.srt	00:16:38.909 --> 00:16:56.969	And, then in the case of pipelined so, it will be taking 6 unit of time whereas, when I without reducing the voltage, but if we reduce the voltage so, we know that the clock period remains as the original one which will be having 12 units of time.
11.srt	00:16:57.629 --> 00:17:08.449	And, sample period we know that this is 12 units and here it becomes 6 units whereas, in the pipeline with reducing power it will be still 12 units.
11.srt	00:17:09.109 --> 00:17:14.909	So, we will see that parallel processing for low power how we are going to achieve it.
11.srt	00:17:15.329 --> 00:17:24.259	So, we say that we have L parallel system since maintaining the same sample rate clock period is increased to L times the sequential one.
11.srt	00:17:24.919 --> 00:17:29.689	So, this means that your C charge is charged in.
11.srt	00:17:29.940 --> 00:17:35.129	L into T sequential and the power supply can be reduced to beta times V naught.
11.srt	00:17:35.769 --> 00:17:44.809	So, we are seeing that in the sequential the capacitor that is going to be charged with respect to T sequential at V naught voltage.
11.srt	00:17:45.169 --> 00:17:48.730	Whereas, in the parallel if I we are assuming L is equal to 3.
11.srt	00:17:49.129 --> 00:18:01.149	So, then what happens this becomes 3 times T sequential all of them and power the voltage reduction is going to be beta into V naught what we will consider.
11.srt	00:18:01.569 --> 00:18:06.469	So, we will same thing what we will be applying the equation.
11.srt	00:18:06.879 --> 00:18:21.919	So, the parallel will be L into c total into b into beta into v naught whole squared plus our frequency by L because I will be getting 3 outputs in 1 clock cycle.
11.srt	00:18:21.959 --> 00:18:31.199	So, I will be my frequency can be f by L. So, which we will be equating it as beta squared into p sequential.
11.srt	00:18:31.699 --> 00:18:34.059	Then, what happens to our propagation delay?
11.srt	00:18:34.419 --> 00:18:38.599	So, this is t sequential original c charge into v naught by this one.
11.srt	00:18:39.019 --> 00:18:48.529	In the parallel case c charge into beta into v naught whole divided by k into beta into v naught minus v t whole squared.
11.srt	00:18:48.849 --> 00:18:52.179	So, then l into t sequential is equal to t parallel.
11.srt	00:18:52.459 --> 00:19:01.459	So, we will be applying both together l into beta into v naught minus v t whole squared which is equal to beta into r v naught minus v t whole squared.
11.srt	00:19:01.719 --> 00:19:03.989	So, we will be getting beta from this.
11.srt	00:19:04.299 --> 00:19:04.879	equation.
11.srt	00:19:05.269 --> 00:19:18.689	As an example, we consider a 4 tap FIR filter shown in this figure basically and we have going to consider 2 parallel versions of this one.
11.srt	00:19:18.949 --> 00:19:27.619	Here we will be considering the first version in the next slide we will consider the second version what is the thing is going to happen we will see that.
11.srt	00:19:27.619 --> 00:19:38.990	The 2 architectures are operated the sample period 9 unit of time assume your multiplier is going to take 8 units of time and adder is going to take.
11.srt	00:19:39.519 --> 00:19:48.779	1 unit of time and the threshold in this case voltage is given as 0.45 volts above that capacitor is going to be charged 1.
11.srt	00:19:48.779 --> 00:20:05.209	So, V naught is equal to 3.3 volts what it is given that is supply voltage and then C m what we are going to have is capacitor for the multiplier is equivalent to 8 times that of the adder.
11.srt	00:20:05.240 --> 00:20:11.519	So, it is asking the question is what is the supply voltage of the 2 parallel filter.
11.srt	00:20:13.000 --> 00:20:18.319	And, what is the power consumption of the two parallel filter as a percentage of the original filter?
11.srt	00:20:18.799 --> 00:20:22.900	So, you are seeing the two parallel filter what we have considered.
11.srt	00:20:23.400 --> 00:20:30.769	So, here in this case what is it original or capacitor charge is equal to C m plus C a.
11.srt	00:20:31.500 --> 00:20:40.200	And, then in the case of two parallel section what happens C m plus 2 C a which is nothing but 10 times C a.
11.srt	00:20:40.200 --> 00:20:42.579	And, then if we apply the.
11.srt	00:20:42.890 --> 00:20:58.090	So, we will be seeing that 9 times 3.3 into beta minus 0.45 whole squared which is equal to 5 times beta into 3.3 minus 0.45 is the threshold voltage whole squared.
11.srt	00:20:58.090 --> 00:21:13.799	So, in this case beta becomes 0.6589 or 0.0282 as previous case we have to ignore this because this is less than the old.
11.srt	00:21:17.060 --> 00:21:18.170	voltage of 0.45.
11.srt	00:21:18.320 --> 00:21:29.210	So, we will be considering 0.6589 as beta, then for the parallel section 0.6589 into 3.3 volts which is going to come down to 2.1743 voltage.
11.srt	00:21:29.210 --> 00:21:34.980	So, how much reduction we are able to get it 43.41 percent in this case.
11.srt	00:21:34.980 --> 00:21:45.920	So, coming to the next section that is parallel here what we have done is.
11.srt	00:21:48.160 --> 00:22:03.690	you have the 4 this thing multipliers here and here also 4 multipliers and you will be seeing that x of 2k and x of 2k plus 1 are the input to this structure.
11.srt	00:22:04.089 --> 00:22:19.400	So, we will see that by modifying it the structure in this way what we have taken is x of 2k structure with little arrangement that is we call it as a linear phase.
11.srt	00:22:19.880 --> 00:22:40.900	FIR filter if I consider the thing H0 and H2 can be here and then the other thing I can derive from that that is H0 plus H1 will be multiplied here and the other one is H2 plus H3 what I can combine and H1 and then H3 are coming from this parallel section.
11.srt	00:22:41.430 --> 00:22:51.349	So, by doing little modification to the previous structure what we will be getting is output is going to remain Y2 of k and Y2 of k plus 1.
11.srt	00:22:51.799 --> 00:22:54.349	So, one of the assignment for you is.
11.srt	00:22:54.659 --> 00:23:07.929	what will be the output at here junction A and then junction B what you have to calculate as well as at C. So, we call this is area efficient 2 parallel multiplier.
11.srt	00:23:08.079 --> 00:23:15.309	So, you have to count how many adders and how many multipliers are present in this case.
11.srt	00:23:15.759 --> 00:23:23.339	So, we assume that we are charge is C m plus C a what we are assuming it which is going to be.
11.srt	00:23:26.839 --> 00:23:46.059	9 times CA because 8 cm plus 1 CA is equal to 9 CA and we have new 2 parallel that is charge of the capacitor is equal to cm plus 4 times CA what we will be having it because we have 2 parallel section.
11.srt	00:23:46.130 --> 00:23:51.480	So, which is equivalent to 12 times your original adder capacitor.
11.srt	00:23:51.990 --> 00:23:56.460	So, if we substitute in thus because here also it is 2 parallel section.
11.srt	00:23:57.170 --> 00:24:06.630	2 into 9 will be achieving this equivalent to 12 times beta into 3.3 minus 0.45 whole square.
11.srt	00:24:06.630 --> 00:24:10.680	So, then beta turns out to be 0.745 or 0.025.
11.srt	00:24:11.060 --> 00:24:22.320	So, as earlier cases this is infeasible and we consider our pipeline the parallel version of it is going to have 2.45857 volts.
11.srt	00:24:28.690 --> 00:24:37.630	And, then the ratio with respect to this you will be calculating it as 43.6 percent the saving in the voltage.
11.srt	00:24:37.680 --> 00:24:55.360	So, in the previous case you have saved 43.41, here you are saving 43.6 percent with area efficient because I have reduced my the adders and multiplies by introducing the delay in a proper.
11.srt	00:24:55.360 --> 00:24:56.920	So, please look into this.
11.srt	00:24:58.870 --> 00:25:10.370	So, now, can we combine pipelining and then parallelism together and then try to achieve better voltage reduction that is what we will look in this slides.
11.srt	00:25:10.410 --> 00:25:11.220	What is it?
11.srt	00:25:11.220 --> 00:25:21.260	We have the sequential as usual and then pipelining we have C char divided by m whereas, in the case of R parallel it becomes L time T sequential.
11.srt	00:25:29.050 --> 00:25:48.230	So, which implies that I will be making the left hand side as number of stages for pipeline into number of stages for parallelism which is given by m and l into beta into V naught minus Vt whole square which is equal to this.
11.srt	00:25:48.580 --> 00:25:58.950	So, if we consider both of them m is equal to l is equal to 2, then we are operating V naught at 5 volts, then what threshold is given as 0.6 volts.
11.srt	00:25:58.950 --> 00:26:01.140	So, if we compute the values.
11.srt	00:26:02.100 --> 00:26:05.690	beta becomes 0.4, then beta squared will be 0.16.
11.srt	00:26:06.070 --> 00:26:11.360	So, this is how we will be doing the thing, this is our sequential.
11.srt	00:26:11.360 --> 00:26:17.920	So, what we have done is 3 parallel units what we are going to have it.
11.srt	00:26:17.920 --> 00:26:20.780	So, and then one pipeline what we have considered.
11.srt	00:26:20.780 --> 00:26:29.440	So, to conclude this pipelining for low power, we discussed about 3 tap FIR filter for pipelining.
11.srt	00:26:36.270 --> 00:26:41.740	And then we consider for parallel processing also 3 tap and then 4 tap and 2 tap filters.
11.srt	00:26:42.350 --> 00:27:03.190	And then pipelining and parallel processing together how you can achieve low power that is what would demonstrated you can work out some of the problems and then see that how it is going to improve on your power consumption that is what it is going to be reduced.
11.srt	00:27:03.520 --> 00:27:07.550	So, in the next class we will be discussing about IR filters.
11.srt	00:27:07.980 --> 00:27:11.740	that is low pass and little bit on high pass filter.
11.srt	00:27:11.740 --> 00:27:20.470	And then as we know that IR filter is going to lag in the case of linear phase will be achieving only in FIR filter.
11.srt	00:27:20.730 --> 00:27:22.960	So, IR filter becomes non-linear.
11.srt	00:27:22.960 --> 00:27:25.630	So, we will look into that in the next class.
11.srt	00:27:25.630 --> 00:27:25.960	Thank you.
10.srt	00:00:00.910 --> 00:00:27.539	Today, we will discuss about Pipelining and Parallel Processing for Low Power Applications.
10.srt	00:00:28.129 --> 00:00:33.869	The recap of the last classes, we discussed about Linear Phase FIR Filter in length.
10.srt	00:00:34.490 --> 00:00:38.509	And, then how to build it that is what we have seen in the last class.
10.srt	00:00:38.589 --> 00:00:48.009	In today's class how we can use the architecture that is pipeline and parallel architecture to build a FIR filter for low power applications.
10.srt	00:00:48.579 --> 00:01:03.759	So, when I talk about the low power in this case we will be considering the capacitive load power consumption which is given by P L is equal to C L into V c c square into F naught into N S W. So, we say that.
10.srt	00:01:03.990 --> 00:01:13.929	the power is proportional to we say the frequency and square of voltage what we call it.
10.srt	00:01:14.259 --> 00:01:25.530	So, we can if we reduce the voltage we know that the power consumption is going to come drastically, but for speed we have to increase our frequency.
10.srt	00:01:25.840 --> 00:01:33.590	So, we have seen that we can use the architecture for speeding up our computation using pipeline and parallel.
10.srt	00:01:34.030 --> 00:01:46.039	So, the frequency is going to be increased, but in this case we will see that how we can use the thing by reducing our power consumption that use by reducing our operating voltage.
10.srt	00:01:46.079 --> 00:02:04.689	So, here we will give it P L as a capacitive load power consumption and V CC is a supply voltage and F naught is our output signal frequency and C L we call it as external load capacitance basically and N SW will be.
10.srt	00:02:05.140 --> 00:02:07.620	total number of outputs switching.
10.srt	00:02:07.950 --> 00:02:14.030	So, if we assume 1 bit what we are transmitting, so it becomes n is equal to 1.
10.srt	00:02:14.240 --> 00:02:16.840	So, switching load will be 1 in this case.
10.srt	00:02:16.840 --> 00:02:23.050	So, if we have more number of bits that also will be contributing to our power consumption.
10.srt	00:02:24.490 --> 00:02:38.509	So, we will see what is the basic idea of pipelining which I have already discussed that is we took either a car assembly in this case example is given Henry Ford in 1908.
10.srt	00:02:39.310 --> 00:02:45.320	So, what we call that example we took the water pipe in the last class.
10.srt	00:02:45.670 --> 00:03:01.820	So, we will be seeing that the pipe of the length of the water pipe is less than our latency is going to be less, but if it is long then we know that it is going to have a maximum latency we call it as critical path.
10.srt	00:03:02.430 --> 00:03:08.700	So, further increase the clock speed or sampling speed to or reduce the power consumption.
10.srt	00:03:09.270 --> 00:03:13.490	to for the same speed in a DSP system.
10.srt	00:03:14.290 --> 00:03:20.630	So, for the parallel processing we will have multiple outputs are computed in parallel in a clock period.
10.srt	00:03:21.120 --> 00:03:30.740	The effective sampling speed is increased by the level or parallelism if you want to increase the speed or we can reduce the power consumption.
10.srt	00:03:31.629 --> 00:03:34.860	So, why do we need pipelining and parallelism?
10.srt	00:03:35.780 --> 00:03:40.170	One is to reduce our critical path that is the longest path delay.
10.srt	00:03:40.740 --> 00:03:47.770	And, increase the clock speed or sample speed what we are putting it or achieve a reduced power consumption.
10.srt	00:03:47.910 --> 00:04:04.030	Same thing with the parallel processing not reduce the critical path here, not increase the clock speed, but increase sample speed and then we can use it for reduced power consumption.
10.srt	00:04:04.640 --> 00:04:10.080	So, we will see the data flow in parallel and pipeline structure how it is going to be implemented.
10.srt	00:04:10.480 --> 00:04:11.820	So, we say that.
10.srt	00:04:12.280 --> 00:04:25.250	We have 4 processors here P1, P2, P3, P4 if there is no data dependencies we know that all the 4 processors will be working on different data sets.
10.srt	00:04:25.639 --> 00:04:29.860	So, if we have the same number of processors in pipeline processing.
10.srt	00:04:29.949 --> 00:04:42.310	So, we say that each processor has to wait for the previous data to be finished computation to be finished and then it should be coming into.
10.srt	00:04:44.930 --> 00:04:46.000	the next stage.
10.srt	00:04:46.410 --> 00:04:57.610	So, each processor you will be seeing that the latency of this P4 processor is it has to wait for 4 clock cycles till it can operate.
10.srt	00:04:57.870 --> 00:05:03.760	So, once all the data have been filled then they can work in parallel.
10.srt	00:05:04.340 --> 00:05:13.780	So, that is what the latency of the pipeline whereas in the parallel processing all of them there are there should not be any dependency between the data in this case.
10.srt	00:05:14.350 --> 00:05:15.840	So, when we say that.
10.srt	00:05:16.200 --> 00:05:20.230	How it is going to have this thing data dependence?
10.srt	00:05:20.570 --> 00:05:27.970	We say that in parallel processing requires no data dependence between the processors, then only we they can run in parallel.
10.srt	00:05:28.250 --> 00:05:36.550	So, as you are seeing it that data flow in P1 processor is going to go in horizontal way same thing with respect to rest of the processor.
10.srt	00:05:36.910 --> 00:05:42.570	Whereas, in the case of pipeline we said there is a data dependency between the two processors.
10.srt	00:05:42.920 --> 00:05:45.960	So, P2 is waiting the data from P1.
10.srt	00:05:46.500 --> 00:05:52.430	The same way P 3 will wait from P 2 and then P 4 will be waiting from P 3.
10.srt	00:05:52.800 --> 00:05:58.980	So, this is how the data will be if they are dependent then the flow is going to be in this fashion.
10.srt	00:05:59.580 --> 00:06:05.470	So, coming to the usage of pipeline processing how we can do the thing?
10.srt	00:06:05.590 --> 00:06:14.170	We can do by inserting latches or registers between combinational logic circuits.
10.srt	00:06:14.540 --> 00:06:17.100	So, that way we will be reducing the critical.
10.srt	00:06:17.650 --> 00:06:19.720	path or it can be shortened.
10.srt	00:06:20.079 --> 00:06:29.740	So, the consequence of introducing this is will be reducing the clock cycle time and increase the clock frequency.
10.srt	00:06:30.530 --> 00:06:37.210	So, it is suitable for DSP applications that have we call it as infinity long data stream.
10.srt	00:06:37.610 --> 00:06:42.080	So, we are assuming that input data is coming continuously.
10.srt	00:06:42.080 --> 00:06:44.509	So, we have to operate on that.
10.srt	00:06:45.009 --> 00:06:50.680	So, method to incorporate this pipelining how we are going to do it we will see it in a while.
10.srt	00:06:51.200 --> 00:06:56.500	using the cut set and then do the retiming of the circuits.
10.srt	00:06:56.879 --> 00:07:03.230	So, we will define the cut set we call that as a set of edges of a graph.
10.srt	00:07:03.710 --> 00:07:20.990	If these edges are removed from the original graph the remaining graph will become two separate graphs that is there are no dependence between the two graph they have to become independent then only we call that as a cut set.
10.srt	00:07:21.500 --> 00:07:25.900	Usually, we apply feed forward cut set in our filter.
10.srt	00:07:25.970 --> 00:07:36.220	So, in this case we call feed forward because data move in the forward direction and all the edges of the cut set.
10.srt	00:07:36.629 --> 00:07:39.970	So, there will not be any feed backward data flow.
10.srt	00:07:40.580 --> 00:07:48.710	So, only we consider the if there is a feed forward data then we call that cut set as a feed forward cut set.
10.srt	00:07:49.290 --> 00:07:51.040	The other one is read timing.
10.srt	00:07:51.490 --> 00:07:54.879	So, how we are going to see the read timing.
10.srt	00:07:55.410 --> 00:08:03.730	of an algorithm is readjusted while keeping the partial ordering of execution unchanged.
10.srt	00:08:04.170 --> 00:08:06.569	So, that the results are correct.
10.srt	00:08:07.030 --> 00:08:09.660	So, we will see that how we will be doing that.
10.srt	00:08:10.300 --> 00:08:16.910	So, as an example we will take that this is the data flow graph what we have it.
10.srt	00:08:17.250 --> 00:08:27.210	So, data is moving from A1, A2, A4 and then A6 is the last thing or it can flow in this direction.
10.srt	00:08:27.639 --> 00:08:32.779	So, we say that d means there is a delay in this data path.
10.srt	00:08:33.710 --> 00:08:41.009	So, what will be the longest delay that is what we have to see in this graph or we call it as the critical path.
10.srt	00:08:41.009 --> 00:08:57.759	Since there is a delay, so we will assume that it will be going into this register, it can be a register or so that it is going to hold the data and then in the next clock cycle it will be going into this.
10.srt	00:08:58.200 --> 00:09:08.639	So, here we will be seeing that from A3 the data has to flow to A5 and then to A4 and then to A6.
10.srt	00:09:09.210 --> 00:09:12.740	This is the longest path in this.
10.srt	00:09:12.940 --> 00:09:25.690	So, which we call it as it is going to take 4 clock cycle or 4 unit time to get the data from one node to the last node in this case.
10.srt	00:09:25.690 --> 00:09:29.220	So, we said that we will put a cut set basically.
10.srt	00:09:29.290 --> 00:09:34.670	So, I can cut the graph into two pieces in this way.
10.srt	00:09:35.460 --> 00:09:41.200	And then we said we are going to introduce delay units wherever we have put the cut set.
10.srt	00:09:41.990 --> 00:09:46.370	So, or a shift register one of the thing what we will be using it.
10.srt	00:09:46.720 --> 00:09:54.520	As we can see that we have cut this into two parts this way, but we have forgotten to put a delay unit here.
10.srt	00:09:54.910 --> 00:09:59.520	So, that is how it says this is an error basically.
10.srt	00:09:59.780 --> 00:10:05.560	So, how if we cut this properly and then put all the delay units in the cut set.
10.srt	00:10:05.980 --> 00:10:09.320	Then what happens to our critical path what we will see it.
10.srt	00:10:09.720 --> 00:10:31.230	So, we say that from A3 to A4 I have a delay path and then from A4 to A6 it is direct and then what we have is from the delay unit if I take that the data is moving it has to move to A4 and then A6.
10.srt	00:10:31.510 --> 00:10:37.080	So, that way it takes 2 clock units to reach the.
10.srt	00:10:37.700 --> 00:10:41.970	maximum delay in this circuit or in the data flow graph.
10.srt	00:10:43.040 --> 00:10:44.180	So, what is it?
10.srt	00:10:44.580 --> 00:10:53.600	So, some of the concept what we will see how we will be representing our pipelining and parallel concept is represented.
10.srt	00:10:54.060 --> 00:10:59.230	In the pipelining we introduce pipelining latches along the data path.
10.srt	00:10:59.680 --> 00:11:09.640	So, this is the original circuits x of n is the input and then this is one of the a of n is the coefficient b of n minus 1 can be the other coefficient.
10.srt	00:11:10.009 --> 00:11:12.270	So, y of n is going to have it as.
10.srt	00:11:12.700 --> 00:11:19.820	A of n into X of n plus your V of n minus into X of n basically.
10.srt	00:11:20.470 --> 00:11:31.430	So, this is my Y of n when I say that the critical path is going in this case is 2 adders.
10.srt	00:11:31.430 --> 00:11:40.279	So, it has to pass through them to get my Y of n. So, I want in a single clock cycle my Y of n has to come out.
10.srt	00:11:42.990 --> 00:11:50.379	Then what I do is I cut this line into two parts and introduced a delay line.
10.srt	00:11:50.740 --> 00:11:53.350	So, I am putting increasing the hardware.
10.srt	00:11:53.659 --> 00:12:17.019	So, x of n is this it will be added in one clock cycle and this is going to be latched here and in the next clock cycle I will be adding with whatever data coming from here and the output in the current state is going to be y of n minus 1 and then in the next clock cycle I will be getting the y of n. So, I will have compared to.
10.srt	00:12:17.230 --> 00:12:25.420	previous structure I will be getting one delay output initial output after that it is going to come continuously.
10.srt	00:12:25.850 --> 00:12:30.420	When we talk about the parallel processing so we will be duplicating the hardware.
10.srt	00:12:30.909 --> 00:12:44.190	So here we have duplicated 2 units basically then what happens to the input it has to be x of 2k to the 1 of the stage for the other one x of 2k plus 1.
10.srt	00:12:44.800 --> 00:12:51.420	So here even the coefficients as you will be seeing it becomes a of 2k and b of 2k.
10.srt	00:12:51.860 --> 00:12:57.960	So, k will be varying from 0 to n minus 1 in this case only 2 what we have it.
10.srt	00:12:58.400 --> 00:13:05.960	So, the other input to the second structure is a of 2k plus 1 and then b of 2k plus 1.
10.srt	00:13:07.260 --> 00:13:15.110	So, coming to the thing when we use FIR filter we will consider as a 3 tap FIR filter.
10.srt	00:13:15.220 --> 00:13:26.830	So, if we use the direct form structure as you are seeing that I am talking about the structure even the structure is going to matter when we are designing our circuit.
10.srt	00:13:28.020 --> 00:13:33.800	So, here we have used the direct form in that case what is the equation for my FIR filter?
10.srt	00:13:34.280 --> 00:13:41.740	y of n is nothing, but a into x of n plus b into x of n minus 1 plus c into x of n minus 2.
10.srt	00:13:42.510 --> 00:13:58.940	So, we say that the sample period t sample should be greater than or equal to tm that is the multiplier plus the longest path in this is going to be from here to here which is going to incorporate 2 adders.
10.srt	00:13:59.290 --> 00:14:03.280	So, my sample period has to be tm plus 2 ta.
10.srt	00:14:03.550 --> 00:14:10.700	When I talk about the sampling frequency should be less than or equal to 1 divided by tm plus 2 ta.
10.srt	00:14:11.540 --> 00:14:20.620	So, depending on the time it is going to take to multiply and then add will decide my sampling frequency for this 3 tap FIR filter.
10.srt	00:14:21.300 --> 00:14:29.170	So, the coefficients what we have assumed is a b and then c. So, how will I get my y of n what is shown here.
10.srt	00:14:29.510 --> 00:14:36.440	x of n is the input and these are the delay lines x of n minus 1 and then x of n minus 2.
10.srt	00:14:36.810 --> 00:14:49.960	So, as the equation suggests here y of n is equal to a into x of n and b into x of n minus 1 plus c into x of n minus 2.
10.srt	00:14:50.280 --> 00:14:52.940	So, that is what my 3 tap FIR filter.
10.srt	00:14:53.010 --> 00:14:59.080	When I consider the sampling frequency what should be for this.
10.srt	00:14:59.750 --> 00:15:21.610	So, if I talk about the sampling period T sample should be greater than or equal to the time taken to do multiplication and because the longest or the critical part delay what we call it here is 2 adders what it is included 1 multiplier and then 2 adder.
10.srt	00:15:21.950 --> 00:15:26.260	So, it becomes Tm plus 2 times time for addition.
10.srt	00:15:26.700 --> 00:15:30.210	So, the sampling rate is going to be less than or equal to 1 by 2.
10.srt	00:15:30.710 --> 00:15:32.450	Tm plus 2 Ta.
10.srt	00:15:33.080 --> 00:15:35.640	So, we will see how we will avoid this.
10.srt	00:15:36.040 --> 00:15:46.590	One of the thing is as we said we can have a cut set in the because as you are seeing in the structure all of them in the feed forward path the flow what it is going.
10.srt	00:15:46.910 --> 00:15:48.700	So, I can have a cut set.
10.srt	00:15:49.010 --> 00:15:56.060	So, we said that it is taking 2 clock cycle to add whether I can reduce it to 1 clock cycle.
10.srt	00:15:56.410 --> 00:16:01.310	Then what I am going to do is I am going to put a cut set here as you are seeing in the blue line.
10.srt	00:16:01.820 --> 00:16:04.649	in the forward path that is what it is shown here.
10.srt	00:16:05.060 --> 00:16:11.730	Then I have to introduce 2 delays in the path because I have cut 2 lines here.
10.srt	00:16:12.200 --> 00:16:15.220	So, there will be addition of delays in this case.
10.srt	00:16:15.540 --> 00:16:19.899	Now you will be seeing the longest path in this case is going to be.
10.srt	00:16:20.420 --> 00:16:23.940	So, one multiplication and one addition.
10.srt	00:16:24.220 --> 00:16:33.190	So, we will come back what we are going to define what is my longest path ok. And from here to here also it is going to take 1 clock cycle.
10.srt	00:16:33.549 --> 00:16:38.569	and from this delay to my output is going to have one clock cycle.
10.srt	00:16:38.649 --> 00:16:45.259	So, we make this structure as first unit and the second unit what we have it.
10.srt	00:16:45.610 --> 00:16:55.110	So, what happens to the output that is what it says is critical path from 2a plus tm which is changed to ta plus tm.
10.srt	00:16:55.829 --> 00:17:03.340	So, the clock will see the what will be the output at 0 it the input to this is x of 0 then.
10.srt	00:17:03.559 --> 00:17:19.099	Node 1 what we call it, what is going to happen in this clock cycle is it will be multiplying a into x of 0 and then it will take b into x of minus 1 in this case.
10.srt	00:17:19.660 --> 00:17:33.369	So, in the next clock cycle, so you will be seeing that x of 1 will be the input to this unit and then the thing is going to be node 1, it is going to compute a into x of 1.
10.srt	00:17:33.750 --> 00:17:35.769	plus b into x of 0.
10.srt	00:17:36.409 --> 00:17:40.359	So, in node 2 because this has moved to the next clock cycle.
10.srt	00:17:40.359 --> 00:17:55.389	So, it will be a into x of 0 previous one plus b into x of minus 1 and in node 3 what we call it is here which is going to be c x of minus 2 and this will be my y 0.
10.srt	00:17:56.349 --> 00:18:00.449	And same thing you will be seeing that in the third clock cycle.
10.srt	00:18:00.839 --> 00:18:03.599	So, the all the units become full.
10.srt	00:18:03.989 --> 00:18:09.449	Then, y2 will be my output which is completely correct.
10.srt	00:18:09.659 --> 00:18:17.589	So, compared to the previous one you can draw this sketch for the one which did not have the cut set.
10.srt	00:18:17.909 --> 00:18:33.049	So, output will be start coming from here y0, y1, y2, y3, but in the this thing pipeline case, the in this case since we have put only one cut set the delay is going to be 1 clock cycle.
10.srt	00:18:33.429 --> 00:18:36.009	So, we will not be getting anything here it is.
10.srt	00:18:36.439 --> 00:18:37.699	or it is garbage what we will have it.
10.srt	00:18:37.699 --> 00:18:39.139	So, output starts coming from here.
10.srt	00:18:39.639 --> 00:18:41.579	We will see effect of pipelining.
10.srt	00:18:42.239 --> 00:18:43.759	What are the drawbacks?
10.srt	00:18:43.759 --> 00:18:54.629	We will be increasing the delay elements, number of delay elements, what we call it as registers or latches in the critical path.
10.srt	00:18:54.679 --> 00:18:57.309	This is a hardware addition what we have to provide.
10.srt	00:18:57.809 --> 00:19:01.309	This causes increase in latency.
10.srt	00:19:01.799 --> 00:19:05.559	Then what we say is a clock period limitation we will see it.
10.srt	00:19:05.929 --> 00:19:08.729	So, the critical path may be between.
10.srt	00:19:09.199 --> 00:19:18.389	an input and a latch we call it a latch and an output or between two latches on input and an output.
10.srt	00:19:18.439 --> 00:19:21.869	So, this we call it as the critical path.
10.srt	00:19:21.869 --> 00:19:37.629	So, this is how we measure how many multipliers or accumulators or how many hardware is in between these two things that will be the maximum critical path what I have to consider.
10.srt	00:19:40.739 --> 00:19:47.439	So, we say pipelining latches can only be placed across any feed forward cut set of the graph.
10.srt	00:19:47.469 --> 00:19:53.989	This we will be specifying every time and then we have to go through the thing.
10.srt	00:19:54.449 --> 00:20:03.029	Next one is as I was talking about the structure can we have a transposition theorem incorporated in the signal flow graph.
10.srt	00:20:03.569 --> 00:20:10.969	That is what we are going to do is reversing the direction of all edges in a SFG signal flow graph.
10.srt	00:20:11.369 --> 00:20:17.439	and interchanging the input and then output ports preserve the functionality of the system.
10.srt	00:20:17.789 --> 00:20:24.299	So, we say that x of n is the input y of n is the output this is in the feed forward what we have it.
10.srt	00:20:24.729 --> 00:20:34.149	So, this delay can be represented as a d or in the z domain we will call it as z minus 1 is going to be the delay.
10.srt	00:20:34.789 --> 00:20:42.049	So, each node will be representing my this as an adder and this is a multiplier.
10.srt	00:20:42.449 --> 00:20:57.089	So, now what we are going to do is my output I will be changing it as an input and then input as an output and all the direction are going to be reversed basically that is what the transposition theorem says.
10.srt	00:20:57.389 --> 00:21:03.559	So, as you see the thing y of n and then we will be keeping a b c as it is.
10.srt	00:21:03.559 --> 00:21:05.679	So, this has got changed.
10.srt	00:21:06.349 --> 00:21:08.549	Now what is the thing is going to happen?
10.srt	00:21:09.039 --> 00:21:12.329	So, we will incorporate in our data flow graph here.
10.srt	00:21:12.660 --> 00:21:20.589	from the signal flow graph, we call that as a direct form 2 structure, we call that as a data broadcast structure.
10.srt	00:21:21.019 --> 00:21:30.910	And in this case you will be seeing that the critical path without adding any delay elements it has become Tm plus Ta, we will see it in a while how it is going to be.
10.srt	00:21:31.299 --> 00:21:45.529	So, to have the understanding correctly what we have done from the previous thing, we have reversed the implementation of this graph actually so that.
10.srt	00:21:45.859 --> 00:21:48.679	We are not comfortable going from right to left.
10.srt	00:21:48.909 --> 00:21:53.389	So, we will put it back as a forward path itself.
10.srt	00:21:53.569 --> 00:22:01.059	So, you will be seeing that x of n is going to be broadcast to all the 3 multipliers.
10.srt	00:22:01.519 --> 00:22:08.469	Here it is c, here it is b and then a and then we have a delay element already present in the original one.
10.srt	00:22:08.469 --> 00:22:09.799	This is the original.
10.srt	00:22:09.799 --> 00:22:17.879	Now, you see the thing the critical path in this case is going to be one multiplier and one adder.
10.srt	00:22:18.849 --> 00:22:34.369	This is from input to output and then from input to latch is also 1 unit and then here also it is going to be input to latch is here only have a 1 multiplier delay ok.
10.srt	00:22:34.589 --> 00:22:39.019	So, the maximum that is critical path is 1 multiplier and 1 adder.
10.srt	00:22:39.059 --> 00:22:50.349	So, you can see that the structure if you choose it properly I need not have to have any cut set or any pipelining introduced in some of the.
10.srt	00:22:50.889 --> 00:22:54.349	graphs that one has to consider.
10.srt	00:22:55.199 --> 00:23:02.589	Now, we will say that all of us know that multiplier is going to take longer time compared to my adder.
10.srt	00:23:02.979 --> 00:23:07.489	So, as an example we call this as a fine grain pipelining.
10.srt	00:23:07.489 --> 00:23:19.929	So, let T m is equal to 10 unit time and adder takes 2 unit time and the desired clocks period what we want is 6 unit of time.
10.srt	00:23:20.539 --> 00:23:24.219	So, how we can achieve because multiplier is going to 10 units.
10.srt	00:23:24.629 --> 00:23:33.919	2 units will be my longest path in the broadcast section if I am computing it, but my clock period has to be 6 unit.
10.srt	00:23:34.379 --> 00:23:42.909	Then what we do is we can bifurcate or multiply into 2 smaller units with processing time of 6 and 4 units.
10.srt	00:23:43.249 --> 00:23:53.059	So, you will be seeing that 1 multiplier M1 is going to take 6 units and then M2 multiplier will take 4 units.
10.srt	00:23:53.059 --> 00:23:55.529	So, we are doing a cut set here in the forward.
10.srt	00:23:55.729 --> 00:24:02.899	path and then put a delay element in all the 3 legs of my filter.
10.srt	00:24:02.899 --> 00:24:23.529	And then we will be seeing that from anywhere to anywhere that is input to my this latch is 6 units in all the cases and from here you will be seeing this latch to this latch is only 4 units and the whatever shown in the blue will be the my critical paths basically.
10.srt	00:24:23.829 --> 00:24:30.219	From this latch to this latch it has 1 multiplier and 1 adder so which will be taking 6.
10.srt	00:24:30.419 --> 00:24:33.839	units of time and from here to here also.
10.srt	00:24:33.839 --> 00:24:39.109	So, this we call it as fine grain parallelism or sorry pipelining.
10.srt	00:24:39.789 --> 00:24:44.359	So, the next one we will see that parallel processing how we are going to work on.
10.srt	00:24:46.159 --> 00:24:57.389	We say they are dual basically and if a computation can be pipelined it can also be processed in parallel that is what we say.
10.srt	00:24:57.389 --> 00:25:00.009	So, how we are going to do this?
10.srt	00:25:00.429 --> 00:25:07.979	We say convert a single input single output SISO is my single input single output that is what x of n to this.
10.srt	00:25:08.449 --> 00:25:15.339	system into a multiple input multiple output we call it as MIMO system via parallelism.
10.srt	00:25:15.339 --> 00:25:24.269	So, you will have seen here input is x of 3k, x of 3k plus 1 and x of 3k plus 2.
10.srt	00:25:24.619 --> 00:25:30.929	You will be wondering what is it initially we took example parallel for 2 this thing parallel systems.
10.srt	00:25:31.259 --> 00:25:33.819	Here we are assume 3 parallel systems.
10.srt	00:25:34.069 --> 00:25:41.429	So, you will be seeing that your x of n will be changed as x of 3k in this case.
10.srt	00:25:41.719 --> 00:25:46.839	and y will also be y of 3k, y of 3k plus 1 and 3k plus 2.
10.srt	00:25:47.269 --> 00:25:49.189	So, this is 3 parallel system.
10.srt	00:25:50.199 --> 00:25:55.889	Then what happens to my input and output representation?
10.srt	00:25:56.319 --> 00:26:05.029	We have original what we have is y of n is a into x of n plus b into x of n minus 1 plus c into x of n minus 2.
10.srt	00:26:05.419 --> 00:26:14.099	When I pass this in 3 parallel section, what will be my output is y of 3k, 3k plus 1 and 3k plus 2.
10.srt	00:26:14.439 --> 00:26:17.139	How the inputs have to be you will be seeing it.
10.srt	00:26:17.539 --> 00:26:29.589	So, I will be replacing n with 3k, a into x of 3k plus b into x of 3k minus 1 plus c into x of 3k minus 2.
10.srt	00:26:30.139 --> 00:26:36.679	So, in the next case 3k plus 1 what will be adding with respect to n is 3k plus 1.
10.srt	00:26:36.679 --> 00:26:44.729	So, if you substitute that 3k plus 1 and then 3k plus 1 minus 1 will become 3k x of 3k in this case.
10.srt	00:26:45.209 --> 00:26:48.169	and then in the next case c into x of 3k minus 1.
10.srt	00:26:48.169 --> 00:26:52.499	So, you will be seeing even y of 3k plus 2 will be represented in this way.
10.srt	00:26:52.929 --> 00:26:54.179	Then what happens?
10.srt	00:26:54.419 --> 00:27:01.449	We call time taken for iteration is equivalent to t sample what we call it.
10.srt	00:27:01.509 --> 00:27:06.889	Here in this case it becomes 1 by L into t clock.
10.srt	00:27:07.199 --> 00:27:14.019	So, which is greater than or equal to because number of parallel section I have assumed is in 3 here.
10.srt	00:27:17.339 --> 00:27:22.279	So, which becomes 1 by 3 into 1 multiplier plus 2 adder because I have not put any pipelining here.
10.srt	00:27:22.449 --> 00:27:26.519	So, adder delay is going to be 2 units in this case.
10.srt	00:27:27.269 --> 00:27:37.999	So, what happens to 3 tap FIR filter how I will be representing it in the direct form 2 as you will be seeing it.
10.srt	00:27:38.319 --> 00:27:41.339	So, if we use the direct form 2 what is the thing.
10.srt	00:27:41.339 --> 00:27:50.729	So, this is the output what I want y of 3 k 3 k plus 1 and 3 k plus 2 and we will consider y of 3 k plus 1 rest of it you can work it out.
10.srt	00:27:51.089 --> 00:27:54.359	So, we will see that how we are going to get a into 3.
10.srt	00:27:54.659 --> 00:27:59.939	of A into x of 3k plus 1 what I wanted the first output.
10.srt	00:28:00.249 --> 00:28:11.789	So, you will be seeing that x of 3k plus 1 is coming here and then which is fed to my here this multiplier which is A into x of 3k plus 1.
10.srt	00:28:12.009 --> 00:28:13.809	So, which goes into the adder.
10.srt	00:28:14.209 --> 00:28:18.459	So, what the next one what I want is B into x of 3k.
10.srt	00:28:18.799 --> 00:28:25.209	So, you will be seeing B is here and then x of 3k is the thing which is coming here.
10.srt	00:28:25.569 --> 00:28:30.549	which is going to be multiplied with your b x of 3k.
10.srt	00:28:30.799 --> 00:28:32.409	So, which gets added.
10.srt	00:28:32.719 --> 00:28:35.079	So, what is the last one what I wanted?
10.srt	00:28:35.209 --> 00:28:39.679	c into x of 3k minus 1 what I want in this case.
10.srt	00:28:40.009 --> 00:28:41.609	So, how we are going to get the thing?
10.srt	00:28:42.049 --> 00:28:56.579	So, what we will do is I can take x of 3k plus 2 because when I introduce a delay line in this because this is the 3 parallel structure what we have taken the thing.
10.srt	00:28:56.899 --> 00:28:59.029	So, delay is going to be 3 units.
10.srt	00:28:59.299 --> 00:29:02.299	So, this becomes x of 3k plus 2.
10.srt	00:29:02.589 --> 00:29:03.749	minus 3.
10.srt	00:29:04.009 --> 00:29:06.229	So, which is with 1 delay.
10.srt	00:29:06.229 --> 00:29:17.959	So, it is going to be x of 3 k minus 1 this input which is going to be multiplied with c. So, all of them get added and then we will be getting y of 3 k plus 1.
10.srt	00:29:18.309 --> 00:29:25.299	So, you can check the rest of them whether you are going to get the this equation correctly with the structure or not.
10.srt	00:29:25.759 --> 00:29:29.479	So, thank you for hearing this lecture.
38.srt	00:00:00.340 --> 00:00:26.870	Namaste, welcome back to real time digital signal processing course.
38.srt	00:00:27.210 --> 00:00:30.699	So today we will look at adaptive filter.
38.srt	00:00:31.080 --> 00:00:46.500	So, in the previous class we discussed about the LMS algorithm, Leakey LMS and then NLMS algorithm how with little modification we can implement the adaptive filter.
38.srt	00:00:46.960 --> 00:00:52.129	So, today we look at little bit on the application of adaptive filter.
38.srt	00:00:52.570 --> 00:00:56.530	The first one what we will take is adaptive prediction.
38.srt	00:00:56.969 --> 00:01:01.070	So, how we are going to predict the system.
38.srt	00:01:01.440 --> 00:01:03.859	which is connected to the system ok.
38.srt	00:01:04.109 --> 00:01:16.849	So, what it says is the linear predictor it is going to estimate the values of signal at future time applied to a wide range of applications such as speech coding and then separating.
38.srt	00:01:17.290 --> 00:01:33.069	The equation for this is given as y of n is i is equal to 0 to l minus 1, w l of n into x of n minus delta minus l. So, you will be seeing according to the figure.
38.srt	00:01:33.549 --> 00:01:47.129	there is a delay of the signal which is going to be fed into the system to find out the error of the function.
38.srt	00:01:47.659 --> 00:02:04.909	So, y of n is taken out here and then we have the LMS algorithm here which is going to decide our weights on the system basically and this is the delayed signal that is x of n minus delta.
38.srt	00:02:05.340 --> 00:02:14.640	which is going to come into the system and then y of n is the thing this is what y of n is the predicted one.
38.srt	00:02:14.640 --> 00:02:21.409	So, we will be subtracting and then taking it out minimizing the error then what happens.
38.srt	00:02:21.599 --> 00:02:26.939	So, we will be predicting what is y of n basically in this case.
38.srt	00:02:49.229 --> 00:02:53.449	So, the filter coefficients are going to be updated by the LMS algorithm as you will be seeing that w of n my plus 1 is given by w of n plus mu is step size into x of n minus delta is the input to the this thing a weight function and then e of n that is error which is fed back into our LMS algorithm.
38.srt	00:02:54.000 --> 00:03:04.439	So, we say where x of n minus delta is nothing, but x of n minus delta is the first sample that is delayed by delta units.
38.srt	00:03:04.789 --> 00:03:19.089	So, the other ones are delayed as earlier we take it x of n minus delta minus 1 so on and then x of n minus delta minus L plus 1 transpose what will be giving as an input.
38.srt	00:03:19.370 --> 00:03:26.519	So, L is the length of the filter that is what we are going L small l is equal to 0 to capital L minus 1.
38.srt	00:03:27.059 --> 00:03:49.649	we are calculating our y of n. So, then as usual like LMS algorithm what we have is e of n is x of n minus y of n and filter using the reference input x of n minus delta to predict its future value x of n where delta is the number of delay samples.
38.srt	00:03:50.259 --> 00:03:53.509	So, continuing with the predictor.
38.srt	00:03:54.019 --> 00:04:02.599	So, we are going to consider an application of using an adaptive predictor to enhance the primary signal which consists of.
38.srt	00:04:02.849 --> 00:04:06.799	M sinusoids corrupted by white noise.
38.srt	00:04:07.129 --> 00:04:19.139	So, which is expressed as our x of n is the s of n plus b of n, b of n is our white noise basically what it is being considered.
38.srt	00:04:19.180 --> 00:04:33.550	Then what happens to our output M is equal to 0 to capital M minus 1, a M into because we have take considering the sign signal here.
38.srt	00:04:34.039 --> 00:04:37.500	So, a sign W M n plus phi M.
38.srt	00:04:37.699 --> 00:04:50.049	is the phase of the signal plus V of n, where V of n is the 0 mean white noise with unit variance assumed as sigma v squared.
38.srt	00:04:50.529 --> 00:04:53.529	So, then what is the thing is going to happen?
38.srt	00:04:53.579 --> 00:04:55.179	This is the error signal.
38.srt	00:04:55.699 --> 00:05:05.359	So, you will be seeing that and then it start coming down and then settles with the whatever the value of it.
38.srt	00:05:05.589 --> 00:05:07.739	So, now, you will be seeing that.
38.srt	00:05:08.109 --> 00:05:14.509	This is our output y of n and x of s of n is our input.
38.srt	00:05:14.879 --> 00:05:23.449	So, you will be seeing that initially it was small after that they are going to merge and then go one another.
38.srt	00:05:23.449 --> 00:05:30.659	So, we will be able to generate our whatever sign function what we have given the thing.
38.srt	00:05:31.059 --> 00:05:33.869	So, we are able to predict this is our output.
38.srt	00:05:35.009 --> 00:05:36.549	So, coming with.
38.srt	00:05:39.669 --> 00:05:43.039	Next, application is the adaptive noise cancellation.
38.srt	00:05:43.739 --> 00:05:47.969	So, why do we have to cancel we will see the noise.
38.srt	00:05:48.359 --> 00:05:57.129	So, here we are going to give a suitable delay that is unit delay of z minus delta is inserted in the primary channel.
38.srt	00:05:57.199 --> 00:06:08.989	So, here we are going to have the this is the signal source and this is our noise source and this is our primary reference signal and here is the.
38.srt	00:06:10.869 --> 00:06:14.859	reference sensor which is going to collect our noise source.
38.srt	00:06:15.229 --> 00:06:42.119	So, when we apply this we call it as the reference sources x of n and then primary signal source whatever we are collecting through the primary source which is going to be delayed by delta delay what we are going to give the thing and we say this is my desired signal what I wanted and this we will be adapting according to the LMS algorithm which is y of n.
38.srt	00:06:42.579 --> 00:06:58.079	and then we will be subtracting desired signal with output and then this error what we try to minimize and then which is fed back and then the weights are going to be updated based on our error function.
38.srt	00:06:58.079 --> 00:06:59.869	So, how we are going to define this?
38.srt	00:07:00.199 --> 00:07:06.379	Will be desired signal is nothing but S of n plus X dash of n basically.
38.srt	00:07:06.429 --> 00:07:11.499	So, what is that where if Y of n is equal to X dash n.
38.srt	00:07:15.839 --> 00:07:21.859	We obtain E of n as the desired signal S of n. So, what is it?
38.srt	00:07:21.859 --> 00:07:31.759	The widespread use of cell phones has significantly increased the use of voice devices under high acoustic noise environments.
38.srt	00:07:32.469 --> 00:07:42.409	Most of you would have observed that when you are using your mobile in the completely noisy environment.
38.srt	00:07:42.759 --> 00:07:49.609	So, sometimes what you would try to do is close one of the ear and then try to hear from the.
38.srt	00:07:49.819 --> 00:07:50.429	other ear.
38.srt	00:07:50.909 --> 00:07:54.759	So, that is what we are going to do the thing.
38.srt	00:07:55.039 --> 00:08:02.979	So, how you can do adaptively noise cancellation within the mobile based on the surrounding noise ok.
38.srt	00:08:03.319 --> 00:08:12.559	So, what happens that is intense background noise often corrupts our speech and then degrades the effectiveness of communication.
38.srt	00:08:13.159 --> 00:08:19.719	So, you will be using the adaptive noise canceller basically employs an adaptive filter with.
38.srt	00:08:20.439 --> 00:08:28.769	LMS algorithm and can be applied to cancel the noise components embedded in the primary signal.
38.srt	00:08:29.249 --> 00:08:32.919	So, we if we know the noise source and other things.
38.srt	00:08:33.199 --> 00:08:36.419	So, we can capture and then try to subtract it.
38.srt	00:08:36.419 --> 00:08:43.719	So, that will be cancelling the noise and then our output can be a clean speech signal.
38.srt	00:08:44.569 --> 00:08:51.189	So, as an example so, to apply adaptive noise cancellation effectively.
38.srt	00:08:51.610 --> 00:08:55.299	So, these are the two conditions which has to be satisfied.
38.srt	00:08:55.669 --> 00:08:56.320	What is it?
38.srt	00:08:56.620 --> 00:09:08.669	That reference noise picked up by the reference sensor must be highly correlated with the noise components in the primary signal picked by our primary sensor.
38.srt	00:09:09.220 --> 00:09:14.769	So, because we know that primary data is getting corrupted with the noise.
38.srt	00:09:15.080 --> 00:09:22.080	So, the noise sensor should pick up this noise from this thing and then it should be fed.
38.srt	00:09:22.460 --> 00:09:25.970	So, the reference sensor should only pick up noise.
38.srt	00:09:26.440 --> 00:09:31.169	That is it must avoid picking up signals from the signal source.
38.srt	00:09:31.610 --> 00:09:35.320	So, you are going to have a contradiction in this case.
38.srt	00:09:35.639 --> 00:09:37.789	So, one has to look at this.
38.srt	00:09:37.789 --> 00:09:39.370	So, how it is going to be?
38.srt	00:09:39.669 --> 00:09:55.929	So, you will be seeing that X0 n is the input or this thing phase shift that is we are going to give 90 degrees phase shift for the thing which we call it as X1 of n. And then you are seeing the FIF filter what we have.
38.srt	00:09:56.269 --> 00:10:02.259	used in this case to fine tune and then do the noise cancellation.
38.srt	00:10:02.259 --> 00:10:12.200	So, W naught n to W 1 of n are filter thing what you are looking at it that is second order filter what you have seen it.
38.srt	00:10:12.490 --> 00:10:22.750	So, this is going to be fine tuned based on what is the thing like our LMS filter.
38.srt	00:10:23.210 --> 00:10:26.809	So, this is the desired signal what I have given as a input.
38.srt	00:10:27.279 --> 00:10:34.769	and then based on this we will be calculating our y of n and then as usual we will be subtracting it.
38.srt	00:10:35.159 --> 00:10:42.200	So, now, what is this error signal is fed into our LMS algorithm.
38.srt	00:10:42.550 --> 00:10:54.889	So, this is going to take both x naught n and then x 1 of n as input and then adjust the weights based on our error.
38.srt	00:10:55.399 --> 00:10:57.730	Basically it is written little below so that.
38.srt	00:10:58.040 --> 00:11:05.890	we are not smudging our crossover of the line is going to happen from this input and this input and it is shown separately.
38.srt	00:11:06.280 --> 00:11:14.770	This is what we call it a single frequency adaptive notch filter what we have designed in this case.
38.srt	00:11:15.000 --> 00:11:28.270	So, you will be seeing that what is the desired signal is given here and then you will be seeing that output error signal E of n. So, which is going to correspond to our.
38.srt	00:11:28.610 --> 00:11:33.920	output basically what we are going to get out of the thing fine.
38.srt	00:11:34.200 --> 00:11:39.540	So, noise cancellation has happened in this case and then we will get the signal correctly.
38.srt	00:11:40.470 --> 00:12:02.610	The other one is how we are going to inverse model the channel in this case example is our communication channel is one of the application what it will be considered that is what it says in practical applications we have to estimate the inverse model of an unknown system in order to compensate its effect.
38.srt	00:12:03.030 --> 00:12:17.370	severe distortion can be solved by designing an adaptive equalizer in the receiver that contracts the tracks the unknown and changing channels.
38.srt	00:12:17.730 --> 00:12:19.670	How we are going to design this?
38.srt	00:12:19.920 --> 00:12:24.790	So, you will be seeing W of z is nothing, but 1 by C of z.
38.srt	00:12:25.170 --> 00:12:35.390	So, we are taking we assume that C of z is the filter at the transmission end at the receiver end.
38.srt	00:12:35.670 --> 00:12:39.930	you will be designing the inverse filter.
38.srt	00:12:40.300 --> 00:12:44.680	So, one must be thinking how the inverse filter is going to be designed.
38.srt	00:12:45.029 --> 00:12:51.110	So, you should have what we call it as minimum order filter basically.
38.srt	00:12:51.409 --> 00:12:57.720	So, all the poles and zeros of the input filter should be inside our unit circle.
38.srt	00:12:57.720 --> 00:13:05.060	So, that when we design the filters 1 by C of z.
38.srt	00:13:06.220 --> 00:13:10.389	So, which is both 0s and then poles will be getting interchange.
38.srt	00:13:10.389 --> 00:13:13.850	So, they should not be going out of the unit circle.
38.srt	00:13:36.669 --> 00:13:39.250	So, this is what one has to design and then what we call that when we do the cross multiplication c of z into w of z should be equal to 1 such that our x hat of n is equal to x of n. So, this is what shown in our equalizer as an example of inverse modeling.
38.srt	00:13:39.600 --> 00:13:40.659	So, what is it?
38.srt	00:13:40.899 --> 00:13:58.959	So, we have the input x of n and then this is c of z what we have the thing and then output is y of n and then which is FET or LMLS algorithm as well as our weight function for calculation.
38.srt	00:13:59.519 --> 00:14:06.789	It passes through the filter here and then the x hat of n is the output what we are.
38.srt	00:14:07.389 --> 00:14:17.979	calculating and then this x of n is going to be delayed by delta and then which is fed as desired signal.
38.srt	00:14:18.309 --> 00:14:37.669	So, when the difference is minimal then we will be knowing that x hat of n is equal to x of n. So, this is how we will be trying to get our out whatever we have passed through the communication channel will be received in this.
38.srt	00:14:38.019 --> 00:14:51.479	So, almost it is equivalent whatever we receive x hat of n is equivalent almost x of n. And as usual our error will be through the LMS algorithm and then taking the input from y of n. So, we will be designing our weight function.
38.srt	00:14:51.529 --> 00:15:03.839	So, how we are going to do the channel equalization is shown in this because this is an experiment where it is going to be used.
38.srt	00:15:09.529 --> 00:15:25.199	adaptive equalizer using the complex LMS algorithm for a simplified ITU standard communication standard what you will be taking it V.29 is a fax modem.
38.srt	00:15:25.199 --> 00:15:32.980	So, for various other this thing we call it as audio or speech we have different standards.
38.srt	00:15:33.689 --> 00:15:38.059	So, in this case for the fax modem this is the standard.
38.srt	00:15:41.129 --> 00:15:42.740	one uses.
38.srt	00:15:43.319 --> 00:15:57.069	So, according to this V.29 recommendation the modem operates at speed up to 9600 bits per second on the general switched telephone network lines.
38.srt	00:15:57.069 --> 00:16:04.730	And the equalizer for modems can be realized using our adaptive FIR filter what it is shown here.
38.srt	00:16:04.730 --> 00:16:14.960	So, in the absence of noise and inter symbol interference the modem receiver decision logic output can precisely match the.
38.srt	00:16:15.730 --> 00:16:20.029	transmitted symbols and the error signal will converge to 0.
38.srt	00:16:20.259 --> 00:16:26.649	This is the ideal case one is considering then error can reach to 0.
38.srt	00:16:26.940 --> 00:16:32.060	So, what is the this thing graphical representation as it is shown.
38.srt	00:16:32.389 --> 00:16:37.500	So, we have the received signal and we have the received filter constructed here.
38.srt	00:16:37.639 --> 00:16:51.340	So, the output of which is going to go to our adaptive algorithm and then the same thing will be going for the adaptive equalizer weights calculation.
38.srt	00:16:51.910 --> 00:16:58.170	And then we will be putting a decision device here depending on the thing.
38.srt	00:16:58.620 --> 00:17:17.090	So, either the switch will be turned on to find out the error, if it is this thing adapting to the channel noise and if there is no noise you can put the decision to this one, change over to here ok, the output will be coming.
38.srt	00:17:17.470 --> 00:17:21.740	So, here you will be passing it to the training of the signal.
38.srt	00:17:22.420 --> 00:17:32.160	if the decision is on the other side and you will be using this training the signal to adapt itself ok.
38.srt	00:17:32.390 --> 00:17:34.269	So, algorithm uses the thing.
38.srt	00:17:34.650 --> 00:17:39.430	So, we will be here also we will be trying to minimize our output of the error.
38.srt	00:17:39.769 --> 00:17:45.310	So, this will be our equalization output what we will be getting it.
38.srt	00:17:46.060 --> 00:17:50.200	So, the next application what we call it as voice crampling.
38.srt	00:17:50.820 --> 00:17:54.880	So, we will be using filtering and then modulation techniques here.
38.srt	00:17:55.400 --> 00:17:57.380	to do the scrambling of the voice.
38.srt	00:17:57.720 --> 00:18:01.640	Why one has to scramble the voice we will see it.
38.srt	00:18:02.080 --> 00:18:14.190	So, the approach makes use of basic algorithms for filtering and then modulation with voices and input the resulting output is scrambled voice we will get it.
38.srt	00:18:30.059 --> 00:18:53.329	So, the original de-scrambled voice is recovered when the output of this from the kit if we are using the hardware or if we are using the MATLAB the output of this is given to to input to a second kit running the same program or in the same place we can run this our program and then imitate that we are depicting that two places that is wherever we have recorded the voice we have scrambled it because I want to have it as a private one.
38.srt	00:18:53.649 --> 00:19:03.450	So, that I know how I have scrambled my speech or audio then at the receiving end the person knows how the scrambling has happened.
38.srt	00:19:03.450 --> 00:19:06.960	So, he will use the same concept to.
38.srt	00:19:07.889 --> 00:19:13.589	So, that way you will be calling it as a watermarking on speech and then audio signals.
38.srt	00:19:13.829 --> 00:19:22.109	So, how we can do it using scrambling we will see in the experiments both using MATLAB and then our code composer studio.
38.srt	00:19:22.109 --> 00:19:38.639	So, even in the code composer studio what you can use is if you have two kits you can connect one kit to do the scrambling the other kit will be re scrambling and then you can get the correct speech depicting both.
38.srt	00:19:39.519 --> 00:19:41.990	transmission and then receiving concept.
38.srt	00:19:41.990 --> 00:19:48.689	So, the commonly referred to as frequency inversion in this case is going to happen.
38.srt	00:19:48.750 --> 00:19:57.480	It takes an audio range in that is 300 hertz to 3 kilohertz.
38.srt	00:19:57.819 --> 00:20:08.519	So, we call this as our narrow band frequency what we will be using it and which will be welding because we are going to scramble with.
38.srt	00:20:09.829 --> 00:20:12.569	whatever the input frequency.
38.srt	00:20:12.959 --> 00:20:24.599	In this case we will be using 3.3 kilohertz as the carrier signal in this case and we will be merging with the thing will it will be folded and then it will be sent.
38.srt	00:20:24.599 --> 00:20:38.219	So, the frequency inversion is achieved by multiplying or modulating the audio input by a carrier signal causing a shift in the frequency spectrum with upper and lower side bands.
38.srt	00:20:38.219 --> 00:20:48.980	So, we will be getting both higher one with 3 and then 3.3 it will be 9.9 kilohertz and then the difference will be 0.3 kilohertz.
38.srt	00:20:48.980 --> 00:20:52.649	So, one will be upper and the other one will be.
38.srt	00:20:53.769 --> 00:20:54.269	lower one.
38.srt	00:20:54.269 --> 00:21:06.819	So, this lower side band that represent this audible speech range the low tones are high tones and the vice versa.
38.srt	00:21:06.940 --> 00:21:07.559	What happens?
38.srt	00:21:07.559 --> 00:21:17.690	So, these low tones becomes high tones when we have received it whereas, the high tones will be converted into low tones.
38.srt	00:21:18.019 --> 00:21:23.819	So, this is what we will be getting it as an example how it is going to be done is shown in the figure.
38.srt	00:21:24.359 --> 00:21:26.630	So, I have taken input as a.
38.srt	00:21:27.190 --> 00:21:32.440	this thing audio input which is sampled with 8 kilohertz.
38.srt	00:21:32.809 --> 00:21:47.960	So, or a speech signal which is going to be sampled at 8 kilohertz then we will be representing between 300 to 3 kilohertz is our speech signal which is going to come.
38.srt	00:21:48.529 --> 00:21:56.080	So, then this has to be this thing what we want is the frequencies above 3 kilohertz has to be cut off.
38.srt	00:21:56.580 --> 00:22:01.779	So, we will be putting the low pass filter with cut off frequency of 3 kilohertz.
38.srt	00:22:02.380 --> 00:22:04.600	and then we call this as point A.
38.srt	00:22:05.040 --> 00:22:21.840	Then we take 3.3 kilohertz as our carrier signal that is using the sign generator which you will be multiplying with our this thing input signal which is cut off at 3 kilohertz and we will be generating B.
38.srt	00:22:22.570 --> 00:22:35.080	So, this can be fed through the 3 kilohertz low pass filters eliminating high frequencies and we will be getting C as the scrambled signal as our.
38.srt	00:22:35.730 --> 00:22:51.740	So, what it shows is scrambling at point A we have an input signal band limited to our 3 kilohertz and at point B we have a double sideband signal with suppressed carrier basically.
38.srt	00:22:52.210 --> 00:23:01.100	And then at point C the upper sideband and the section of the lower sideband between 3 and 3.0 kilohertz are filtered out.
38.srt	00:23:01.100 --> 00:23:04.860	So, the scheme is attractive because of its simplicity.
38.srt	00:23:06.550 --> 00:23:16.660	Only simple DSP algorithms namely filtering sine wave generation and then amplitude modulation are required for this implementation.
38.srt	00:23:16.660 --> 00:23:25.810	So when we come to the reverse of it we can rewrite the C can be given to our as a input signal ok.
38.srt	00:23:25.940 --> 00:23:36.390	I will write instead of my input C is the one and same thing C kilo 3 kilo hertz low pass filter we can design the thing.
38.srt	00:23:37.090 --> 00:23:45.320	then this is given to our multiplier and then same reference signal what I am going to keep it as 3.3 kilohertz ok.
38.srt	00:23:46.800 --> 00:23:57.520	So, this goes to our this thing make a multiplier here and then the output B is going to be pass through 3 kilohertz low pass filter.
38.srt	00:23:57.520 --> 00:24:06.220	So, output will be equivalent to our input whatever we have given at the.
38.srt	00:24:10.540 --> 00:24:16.660	end, this is the thing is going to happen at the I will put it as this is transmission.
38.srt	00:24:20.090 --> 00:24:37.570	And here at the receiver when you want to recover your voice or your audio if you have want to protect your thing, this is the way one can do it and then you can at the whoever wants to receive it you can tell them how you have done your modulation.
38.srt	00:24:37.850 --> 00:24:45.680	So, they can depict this in hardware and then at the receiver they will be getting whatever input you are.
38.srt	00:24:45.960 --> 00:24:47.730	intent for that particular person.
38.srt	00:24:47.800 --> 00:24:50.820	So, that is how the scrambler is going to work.
38.srt	00:24:50.850 --> 00:25:10.150	So, then continuing with the thing ok, how it is going to will be seeing how the carrier frequency and then low pass filter will be mixed and then how our filter response is going to be in the frequency domain is shown here.
38.srt	00:25:10.700 --> 00:25:12.180	So, what is going to happen?
38.srt	00:25:12.180 --> 00:25:23.400	First the sample speed signal is filtered by a low pass filter we said, h of n is the order of the filter whose cut off frequency what we will be calling it as f naught.
38.srt	00:25:23.820 --> 00:25:28.120	is high enough not to cause distortions of the speech signal.
38.srt	00:25:28.740 --> 00:25:35.650	So, that is the ideal filter what we are going to call it here as you can see in the figure.
38.srt	00:25:36.030 --> 00:25:39.810	This is the low pass filter and then what is it?
38.srt	00:25:40.290 --> 00:25:53.870	Its band is minus f naught to f naught and then what happens to the thing the sampling rate f is the sampling frequency is chosen such that.
38.srt	00:25:54.630 --> 00:26:10.970	4 times f naught is less than f s. So, that means, to say that your sampling frequency has to be greater than 4 times of the frequency component what you want to pass.
38.srt	00:26:11.420 --> 00:26:17.960	So, the filtering operation can be represented by the convolutional normal expansion.
38.srt	00:26:18.360 --> 00:26:30.760	So, we have y naught n is nothing but m is equal to 0 to order of the filter you can take it as l minus 1 or if it is the l th order or m th order m minus 1.
38.srt	00:26:31.220 --> 00:26:33.860	So, we will have h of m into x of m.
38.srt	00:26:34.100 --> 00:26:43.770	So, if you have taken L as the thing so it will be becoming h of L into x of n minus L is our convolution thing.
38.srt	00:26:43.770 --> 00:26:48.400	So, the notation can be any one of it what you assume.
38.srt	00:26:49.150 --> 00:27:06.500	So, the filter output y naught n gets modulated as this thing cosinusoidal carrier signal whose frequency coincides when the filters cutoff frequency f naught resulting in the signal as shown here.
38.srt	00:27:06.890 --> 00:27:07.560	filter, what is it?
38.srt	00:27:07.900 --> 00:27:23.750	y1 of n as you can see that x of n which is uses a low pass filter with cutoff frequency f naught which will be equal to y naught n and then this is the carrier frequency what you have chosen as f naught.
38.srt	00:27:24.200 --> 00:27:30.080	So, which is that is desired signal s of n what you will be putting it.
38.srt	00:27:30.690 --> 00:27:37.570	So, you will be multiplying them and y of 1 of n is the output of it what are the.
38.srt	00:27:37.890 --> 00:27:39.010	things it contains.
38.srt	00:27:39.490 --> 00:28:05.190	So, S of n into y naught n where your S of n is equal to 2 times cos omega naught n where omega naught is given by 2 pi f naught by f s. So, then you will be passing it through your low pass filter with cutoff frequency as same as this one f naught to eliminate the higher frequency component present in it.
38.srt	00:28:05.700 --> 00:28:09.610	And then output is y 2 of n is the scrambled signal.
38.srt	00:28:10.010 --> 00:28:16.350	So, when you can see that in the frequency domain how the thing is going to be getting shifted what you can see it.
38.srt	00:28:16.870 --> 00:28:21.960	So, that is f minus f naught is the shift what you have given the thing.
38.srt	00:28:22.490 --> 00:28:33.940	So, the signal you will be seeing that it is shifted spectrum what you are seeing in this case and then when you take the inversion at the receiving signal.
38.srt	00:28:34.350 --> 00:28:43.210	So, this is how the inverted signal looks like this is our y 2 of f here in the with respect to frequency domain.
38.srt	00:28:43.240 --> 00:28:48.700	So, this is minus f naught to f naught and we have f s by 2 what it is.
38.srt	00:28:49.020 --> 00:28:50.640	marked in this case.
38.srt	00:28:51.030 --> 00:29:08.060	So, this is how what you have to say that your f is greater than 4 times the frequency component of your basically filter cutoff frequency f naught of the filter what one has to assume ok.
38.srt	00:29:08.420 --> 00:29:21.100	So, continuing with the thing how it is going to be represented that is unscramble the signal already I have put the thing one may apply the scrambling steps y naught y1 y2 whatever it was shown.
38.srt	00:29:21.680 --> 00:29:26.790	to the scrammed to the scrambled signal itself.
38.srt	00:29:27.210 --> 00:29:35.030	So, this works because the inverted spectrum will be inverted again recovering in the original spectrum.
38.srt	00:29:35.600 --> 00:29:43.370	So, in the lab so, you will be studying a real time implementation of the above procedures.
38.srt	00:29:43.370 --> 00:29:45.670	So, we will be demonstrating.
38.srt	00:29:46.060 --> 00:29:53.240	So, those who are interested can look into the code and other things they can run your own algorithm to.
38.srt	00:29:53.490 --> 00:29:56.640	equation for designing the hamming window.
38.srt	00:29:56.640 --> 00:30:04.940	So, which is 0.54 constant minus 0.46 into cos 2 pi n divided by m, n is going to be your input sample.
38.srt	00:30:04.940 --> 00:30:09.620	So, when you pass through that this is passing through your hamming window.
38.srt	00:30:09.620 --> 00:30:15.520	So, our convolution equation is given as y 2 of n is our output.
38.srt	00:30:26.220 --> 00:30:42.050	So, this will be depending on your order of m in this case 0 to 99 what it is going to be h of m into y 1 of n minus m and then h of n is going to be our impulse response has to be restricted with respect to window because this is a continuous minus infinity to infinity what we assume.
38.srt	00:30:42.410 --> 00:30:51.180	So, this is w of n into sin omega naught n minus m by 2 whole divided by pi into n minus m by 2.
38.srt	00:30:51.580 --> 00:30:58.800	So, here n is between 0 and then m basically and omega naught is given by R.
38.srt	00:30:59.019 --> 00:31:09.040	2 pi f0 by fs in this case it is 3.3 divided by 16 kilohertz and W n is the hamming window which is given by this equation.
38.srt	00:31:09.040 --> 00:31:16.800	So, n will be between 0 and m whatever we have designed in this case we have assumed it as 100 ok.
38.srt	00:31:17.680 --> 00:31:21.910	So, the next application what we will be doing it is echo.
38.srt	00:31:22.190 --> 00:31:28.410	So, here we will be doing the generation in the next class we will take up the cancellation.
38.srt	00:31:30.420 --> 00:31:35.519	So, how the echoes are going to be generated first synthetically we can do the generation.
38.srt	00:31:35.869 --> 00:31:42.619	So, most of you would have visited where you have a rocks and other things when you speak.
38.srt	00:31:42.660 --> 00:31:50.880	So, you will be hearing the echo coming back to you, your own voice goes and reflects that is what we say reflection of sound.
38.srt	00:31:50.930 --> 00:31:56.960	So, which is going to come back to you little bit delayed ok. How we can synthetically generate?
38.srt	00:31:56.960 --> 00:32:00.349	So, using our code what will be.
38.srt	00:32:03.519 --> 00:32:09.400	So, approaching at the listener later than the direct sound.
38.srt	00:32:09.820 --> 00:32:13.530	So, as you can see is this is the sound source.
38.srt	00:32:13.790 --> 00:32:24.680	So, you will be seeing that all the places it will be reflected your sound when you are speaking and there is a hard surface that is what you will be seeing it.
38.srt	00:32:24.980 --> 00:32:29.980	What happens it goes and hits and then it comes back to you.
38.srt	00:32:30.110 --> 00:32:38.810	The first one is the direct sound what your it is coming to you the later on you will be getting the reflected sound.
38.srt	00:32:39.870 --> 00:32:43.720	to your listener this we call it as a echo basically.
38.srt	00:32:44.300 --> 00:32:49.220	What it says a true echo is single reflection of the original sound.
38.srt	00:32:49.680 --> 00:32:59.130	So, that is what we call it as echo ok. We will see if multiple of reflection comes what we call in the next slide.
38.srt	00:32:59.580 --> 00:33:04.290	The time delay is the ratio of the extra distance to the speed of sound.
38.srt	00:33:05.070 --> 00:33:10.180	An echo can be realized as a signal wave that has been reflected by a signal wave.
38.srt	00:33:10.570 --> 00:33:21.480	medium which has the discontinuity in the propagation medium and returns with sufficient magnitude and delay to be perceived by our human here.
38.srt	00:33:21.820 --> 00:33:26.510	Some places it gets absorbed then you may not be able to hear it as echo.
38.srt	00:33:26.820 --> 00:33:33.810	So, where you have sufficient magnitude and then delay then we will be hearing it as an echo.
38.srt	00:33:34.250 --> 00:33:40.770	So, that in echo effect the true sound and the artificial sound are clearly separated.
38.srt	00:33:41.180 --> 00:33:44.870	with gain what we can get the echo signal.
38.srt	00:33:45.430 --> 00:33:53.940	So, we assume gain should be less than 1 in this case because we have the magnitude of input is 1.
38.srt	00:33:54.220 --> 00:34:05.140	So, we assume this is less than 1 due to losses in the echo path that is what we are going to imitate and then look at it.
38.srt	00:34:05.560 --> 00:34:09.040	So, this is again continuing with the generation.
38.srt	00:34:09.430 --> 00:34:15.150	So, as it is seen that signal propagates from the source to the listener in 2 paths.
38.srt	00:34:15.570 --> 00:34:22.760	In this case we have assumed that this is going to reflect and these are going to be absorbed only 1 path get reflected as I said.
38.srt	00:34:23.270 --> 00:34:30.770	signal from the source goes directly to the listener, second the signal goes to the wall and then reflected to the user.
38.srt	00:34:31.380 --> 00:34:35.740	So, the second process will take more time than the first process.
38.srt	00:34:36.070 --> 00:34:48.220	So, the listener will hear two sounds in a different period of time and the signal power from the second process will be attenuated due to the reflection process this is what we discussed.
38.srt	00:34:48.460 --> 00:34:54.960	So, how we can digitally generate an echo by showing in this diagram.
38.srt	00:34:55.350 --> 00:34:56.800	So, how we are going to do the thing.
38.srt	00:34:57.200 --> 00:35:09.810	So, when dealing with audible frequencies human ear cannot recognize the identity of an echo from the original sound if the delay is less than one tenth of a second.
38.srt	00:35:10.190 --> 00:35:15.350	So, as you can see that if it is within this then you may not hear it as an echo.
38.srt	00:35:16.070 --> 00:35:29.790	Thus since the velocity of sound is approximately what we call it as 343 meter per second at a normal room temperature of about 20 degree centigrade the reflecting object must be more than.
38.srt	00:35:30.070 --> 00:35:37.330	16.2 meters from the sound source for an echo to be heard by a person at the source.
38.srt	00:35:37.540 --> 00:35:46.580	So, these are the thing then only you will hear you would be wondering wherever I speak I should be able to hear my voice back.
38.srt	00:35:46.580 --> 00:35:55.610	So, most of the you will be seeing sound recording rooms you will be having a what we call it as a echo cancellers.
38.srt	00:35:55.610 --> 00:35:59.200	So, padding width.
38.srt	00:36:00.950 --> 00:36:03.490	not to reflect the sound ok.
38.srt	00:36:03.520 --> 00:36:10.190	So, it is going to absorb so that only the pure voice is going to be heard.
38.srt	00:36:10.360 --> 00:36:23.010	So, you as an example even I am sitting in a room where recording room where my voice is going to be only heard and then outside noise and everything is cancelled even whenever my voice hits the wall.
38.srt	00:36:23.190 --> 00:36:26.990	So, you will not be getting any reflection in this place.
38.srt	00:36:27.070 --> 00:36:28.060	So, in most situations.
38.srt	00:36:31.780 --> 00:36:41.360	With human hearing echoes are about one half second or about half this distance since sounds grow fainter with distance.
38.srt	00:36:41.770 --> 00:36:52.890	So, the strength of an echo is frequently measured in dB sound pressure level what we call it as SPL sound pressure level relative to the directly transmitted wave.
38.srt	00:36:53.250 --> 00:36:58.060	So, we will be generating in the lab that is input is given.
38.srt	00:36:58.340 --> 00:37:00.590	So, the same input will delay.
38.srt	00:37:00.590 --> 00:37:05.160	We can see that by varying the delay how we will be perceiving it.
38.srt	00:37:05.440 --> 00:37:20.890	And, then we are going to multiply with the gain and then this is the delayed input which gets added with the normal input and output what will be hearing it as the echoed signal in the output.
38.srt	00:37:21.590 --> 00:37:25.150	So, the next one is application is the reverberation.
38.srt	00:37:25.750 --> 00:37:29.770	As we said you can see that there is a sound signal here.
38.srt	00:37:30.270 --> 00:37:43.290	So, you will be seeing that one can be direct and then there are multiple reflections in this case that is what I said it is a single reflection what we call it as echo when it happens with the multiple reflections.
38.srt	00:37:43.290 --> 00:37:46.870	So, what you will be seeing that.
38.srt	00:37:47.160 --> 00:37:56.690	This may be coming early and then the other after heating here it may be coming these are the late ones what you will be getting it.
38.srt	00:37:57.150 --> 00:37:58.510	This may come early.
38.srt	00:37:58.550 --> 00:38:11.610	So, you will be hearing multiple this thing reflections that is what it says reverberation is the persistence of sound in a particular space after the original sound is removed.
38.srt	00:38:12.240 --> 00:38:28.150	And in the reverberation or reverb what we call it is observed when a sound is created in an enclosed space causing multiple echoes to build up and then slowly decay as the sound is damped by surrounding walls and then air.
38.srt	00:38:28.830 --> 00:38:32.660	It is the sum of all sound reflections what we will put it.
38.srt	00:38:33.180 --> 00:38:43.290	Most noticeable when the sound source stops, but the reflections are going to continue decreasing in amplitude until can no longer be heard.
38.srt	00:38:43.790 --> 00:38:53.450	So, the principle of reverberations is more like echo, but in reverb the sound reflections comes very often in a short period of time.
38.srt	00:38:53.750 --> 00:39:02.680	So, you will be seeing that this is the direct sound what it is happening and then these are the earlier reflected what you will be seeing it.
38.srt	00:39:03.040 --> 00:39:07.200	This we call it as during the pre delay what you will get it.
38.srt	00:39:07.720 --> 00:39:20.950	And, then these are the early reflection time from here to here what will be perceiving it after that these are the late reflections you will be seeing that it is slowly dying it out.
38.srt	00:39:21.210 --> 00:39:27.550	So, this is the reverberation time what we call it when it is going to die down slowly.
38.srt	00:39:28.150 --> 00:39:38.850	So, considering the thing comparison to distinct echo that is 50 to 100 millisecond after the initial sound reverberation is many times.
38.srt	00:39:39.100 --> 00:39:47.000	1000s of echoes that arrive in very quick succession that is 0.01 to 1 millisecond between echoes.
38.srt	00:39:47.200 --> 00:39:55.070	So, with the elapse of time the intensity of the multiple echoes is reduced till the echoes are inaudible.
38.srt	00:39:55.680 --> 00:40:04.360	So, in reverberation how we are going to generate the thing output will be input plus delayed output into gain.
38.srt	00:40:04.720 --> 00:40:13.350	So, in this case we will be considering the this thing feedback signal that is A into y of.
38.srt	00:40:13.920 --> 00:40:38.980	n minus d output is getting delayed by d plus with the input x of n. So, then the response of the system is given by h of z is nothing, but 1 by 1 minus a into z to the power of minus d this is the delay in the RZ domain.
38.srt	00:40:39.060 --> 00:40:44.400	There are two important parameters reverberation which are the ones.
38.srt	00:40:44.770 --> 00:40:55.540	One is the pre delay as we have seen in the previous case we have the pre delay and then we have the amount of time of the first sound reflection.
38.srt	00:40:55.950 --> 00:41:02.490	Then the reverb decay is the period amount of time that reverberation since the input stop.
38.srt	00:41:02.490 --> 00:41:09.860	So, we have seen that this the reverberation this is the pre delay which is the early reflection which has going to come.
38.srt	00:41:10.390 --> 00:41:15.930	Then how does it look like because we have said n minus d.
38.srt	00:41:16.370 --> 00:41:18.860	are the delays what we are going to have it.
38.srt	00:41:18.860 --> 00:41:35.610	So, this each reflection you will be saying that they are spaced at 2 pi by d. So, I will be getting a peak here, next peak is going to be 4 pi d and 6 pi d and so on till 2 pi.
38.srt	00:41:35.840 --> 00:41:44.730	So, and then you will be seeing that this is our unit circle and then we have the this is our this thing.
38.srt	00:41:47.750 --> 00:41:58.840	2 pi by d spacing what we are going to have it and rho will be the radius of the or where the poles have been located.
38.srt	00:41:58.960 --> 00:42:19.340	So, you are seeing that poles are all around the circle and that is what it says is these are the poles what you will be putting across the thing at distance of 2 pi by d. So, coming with the reverberation.
38.srt	00:42:19.700 --> 00:42:26.930	This shows the thing that is this is our microphone what we have it and the performer is here.
38.srt	00:42:27.310 --> 00:42:35.440	From here to microphone you comes direct and we know that loudspeakers are in the sideways.
38.srt	00:42:35.700 --> 00:42:57.190	So, sometimes as you will be seeing that even in the mobile or when we are switching on for conference call or something we will be telling if there is one more loudspeaker we have it or this thing input we will ask them to switch it off and keep only one performer signal this thing receiving end also both mic and speaker should be switched on.
38.srt	00:42:57.190 --> 00:43:00.740	If both the speakers are on even now you would be hearing that.
38.srt	00:43:03.540 --> 00:43:05.450	the echo will be coming.
38.srt	00:43:05.980 --> 00:43:13.840	So, whenever because I think pandemic has taught us very nicely that online classes and other things.
38.srt	00:43:14.160 --> 00:43:26.570	So, when two devices are on side by side we will say that please mute the other device and only one devices of the two of them are sitting together be on.
38.srt	00:43:26.570 --> 00:43:33.150	So, that will not have any echoes or we call it as a reverberation coming into our picture.
38.srt	00:43:33.440 --> 00:43:39.100	So, how to generate just like our echo digital reverberation is shown in this figure.
38.srt	00:43:39.570 --> 00:43:40.870	This is our input.
38.srt	00:43:41.500 --> 00:43:51.680	And, then the output is going to be delayed and then fed back there in the echo case input itself is delayed and then fed into our system.
38.srt	00:43:51.960 --> 00:43:58.720	Here the output is going to be delayed and then fed with into the system with gain actually.
38.srt	00:43:58.950 --> 00:44:03.210	So, this is delayed output what will be hearing the reverberation.
38.srt	00:44:03.660 --> 00:44:10.560	So, you have to differentiate between an echo and then reverberation when we run the example.
38.srt	00:44:10.980 --> 00:44:15.410	So, thank you very much in the next class we will be considering echo cancellation.
38.srt	00:44:15.950 --> 00:44:18.760	and then equalizer why do we need it.
38.srt	00:44:19.110 --> 00:44:22.120	So, what will be taking it up in the next class.
38.srt	00:44:22.540 --> 00:44:23.700	Thank you for listening.
12.srt	00:00:01.209 --> 00:00:26.449	Welcome back once again to real time digital signal processing course.
12.srt	00:00:26.570 --> 00:00:29.170	So, today we will discuss about IR filters.
12.srt	00:00:32.369 --> 00:00:45.170	So, as a recap in the last two classes we discussed about FIR filters, their linear phase and how we can represent them, how we can design using the window techniques.
12.srt	00:00:45.170 --> 00:00:52.509	So, today we will see little bit on recap of FIR filter that is we said it is a linear phase filter.
12.srt	00:00:52.509 --> 00:01:00.159	So, the importance of it as you can see with an example in the speed signal.
12.srt	00:01:02.269 --> 00:01:06.759	We use phase differences in arrival to locate the speaker.
12.srt	00:01:07.219 --> 00:01:15.049	So, in this case it is we may not need the phase part of it if there is any delay in the thing.
12.srt	00:01:15.509 --> 00:01:33.539	So, you locate them that is we call it as delta D is equal to C into delta T. So, this is how the speaker thing and then our ear automatically adjust to whatever there is a delay in the phase of it that is what it is shown here.
12.srt	00:01:33.539 --> 00:01:40.259	Once speaker is located ears are relatively insensitive to phase distortion in speech from that speaker.
12.srt	00:01:40.750 --> 00:01:52.939	So, this is used in speech compression and cell phones, where linear phase is crucial we will see in the audio signals in images and in communication systems.
12.srt	00:01:53.419 --> 00:02:05.959	So, in these cases we need linear phase response filters, FIR filters and then a realizable IR filters cannot achieve this linear phase response over all frequencies.
12.srt	00:02:06.329 --> 00:02:14.899	So, coming to one more example of where the phase is important.
12.srt	00:02:15.229 --> 00:02:20.899	that is vital visual information in face is shown with the matlab original image here.
12.srt	00:02:21.369 --> 00:02:37.099	So, when you take the FFT of the image and set face to 0 and take inverse FFT as you will be seeing only you will be seeing the blank that is a black in this case no picture whatever was in the originally seen.
12.srt	00:02:45.619 --> 00:02:47.199	Whereas, if you take the FFT of the image and set magnitude to 1 take inverse FFT as keep imaginary part.
12.srt	00:02:47.539 --> 00:02:57.209	So, this is how the imaginary part looks like when you take the IFFT and this is with respect to real part if you take IFFT.
12.srt	00:02:57.529 --> 00:03:01.549	So, combined will give us the original image.
12.srt	00:03:02.329 --> 00:03:13.309	So, coming to representation of our finite impulse response filters, we know that duration of impulse response h of n is in this case is finite.
12.srt	00:03:13.719 --> 00:03:18.809	So, this is 0 valued for n outside interval 0 to m minus 1.
12.srt	00:03:19.379 --> 00:03:34.439	So, we say that y of n is nothing, but x of n into convolution with h of n which is represented in the sigma notation in this way and then this is minus infinity to infinity.
12.srt	00:03:34.469 --> 00:03:45.449	So, in our case FIR filter is going to be because we will be designing order of the filter is m. So, the summation will be between 0 to m minus 1.
12.srt	00:03:46.129 --> 00:03:51.459	So, in this case output depends on current input and previous m minus 1 inputs.
12.srt	00:03:51.989 --> 00:04:04.639	And, summation to compute our y of k reduces to a vector dot product between n input n input samples in the vector domain as it is seen here.
12.srt	00:04:05.259 --> 00:04:11.469	X of n is represented in vector and then our impulse response is represented in vector.
12.srt	00:04:11.469 --> 00:04:16.109	Then it is going to be a vector multiplication what we will call it.
12.srt	00:04:16.279 --> 00:04:25.139	So, we know that filters play many roles we have seen the thing just to give one more brief.
12.srt	00:04:26.239 --> 00:04:33.459	So, look at the thing is noise removal, signal and noise spectral is separated basically in that case.
12.srt	00:04:33.459 --> 00:04:42.939	Example is we can use band pass filtering to suppress out of band noise and in the case of analysis synthesis and compression.
12.srt	00:04:43.009 --> 00:04:55.519	So, for we use a spectral analysis basically to see how much of data what we needed and which are the ones we can do the compression in the frequency domain.
12.srt	00:04:56.699 --> 00:04:59.120	method is in the spectral shaping.
12.srt	00:04:59.670 --> 00:05:12.870	So, that is in basically for data conversion we use the filters and for the channel equalization we know that in communication input channel has to be reconstructed.
12.srt	00:05:12.870 --> 00:05:22.620	So, we take inverse filter basically there and then do the channel equalization whatever noise coming out of the channel.
12.srt	00:05:23.250 --> 00:05:29.199	And then in the symbol timing recovery also will be using the filters and in carrier frequency and phase recovery.
12.srt	00:05:29.600 --> 00:05:30.699	we need filters.
12.srt	00:05:31.060 --> 00:05:37.759	Coming to next is the infinite impulse response IAR filter.
12.srt	00:05:38.480 --> 00:05:42.279	So, we see that impulse response of infinite duration that is what we call it.
12.srt	00:05:42.420 --> 00:05:45.420	So, what is that mean we will be seeing in a while.
12.srt	00:05:45.420 --> 00:05:55.449	So, if I give the impulse response h of n is equal to half to the power of n into u of n that is the step function.
12.srt	00:05:55.970 --> 00:06:03.509	So, the same thing in our frequency domain or in the z domain what we represent is h of z.
12.srt	00:06:03.979 --> 00:06:18.360	which is n is equal to 0 to infinity half to the power of n into z minus n. So, which will be representing it as change it to 0 to infinity.
12.srt	00:06:18.849 --> 00:06:26.099	So, expand this summation which becomes 1 plus half z minus 1 plus etcetera.
12.srt	00:06:26.529 --> 00:06:31.740	So, we will be getting 1 by 1 minus half to the z power minus 1.
12.srt	00:06:32.339 --> 00:06:34.199	So, how to implement this?
12.srt	00:06:34.680 --> 00:06:37.280	IR filter by computer what we look at it.
12.srt	00:06:37.740 --> 00:06:45.639	So, we say let x of k be the output signal and y k the input signal and then y k be the output signal.
12.srt	00:06:46.250 --> 00:06:55.699	Then what happens is that z domain representation is going to be y of z for our output and then x of z.
12.srt	00:06:56.120 --> 00:07:02.040	Then the impulse response h of z in the z domain is represented as y z by x of z.
12.srt	00:07:05.399 --> 00:07:12.560	So, or If we want y of z then we know that impulse response into our input x of z.
12.srt	00:07:12.860 --> 00:07:24.110	Then what we have taken this is our impulse response y of z will be becoming 1 by 1 minus half into z minus 1 into x of z.
12.srt	00:07:24.870 --> 00:07:39.009	Then if we simplify the thing it becomes half into z minus 1 into y of z that is y of z minus half into z minus 1 into y of z which is equal to x of z.
12.srt	00:07:39.579 --> 00:08:12.029	So, what happens to our when we take the inverse Z transform what happens to our y of n which is equal to half y of n minus 1 that is a previous sample which is equal to x of n. So, if we transform this half y of n minus 1 to the other side we will be seeing that y of n will be equal to half into y of n minus 1 plus x of n. So, x of n is the current sample and y of n is n minus 1 is the previous sample.
12.srt	00:08:12.319 --> 00:08:18.149	output sample which is used for calculating the currents output sample.
12.srt	00:08:18.579 --> 00:08:35.169	So, what we say is recursively compute output y of n for n greater than or equal to 0 given y of minus 1 and then x of n. So, how we can represent this filter in a different way?
12.srt	00:08:35.529 --> 00:08:38.269	So, we will be seeing the difference equation first.
12.srt	00:08:38.599 --> 00:08:45.939	So, y of n is given as half into y of n minus 1 plus 1 by 8 into y of n minus 2 plus.
12.srt	00:08:46.309 --> 00:08:56.600	x of n. So, that is we are going to do the recursive computation needs what are the input values what we need is y minus 1 and then y minus 2.
12.srt	00:08:57.190 --> 00:09:17.039	For the filter to be linear time invariant, so we assume that y of minus 1 equal to 0 and y of minus 2 equal to 0 and the block diagram to represent this difference equation is shown in this figure x of n is the input and y of n is the output.
12.srt	00:09:17.330 --> 00:09:28.370	So, with the delay we will be generating y of n minus 1 which is going to be multiplied by half and then other unit delay will give us y of n minus 2.
12.srt	00:09:28.660 --> 00:09:32.240	So, which is multiplied by weight vector 1 by 8.
12.srt	00:09:32.700 --> 00:09:38.629	So, all the 3 are getting summed up and then we will be taking y of n as the output.
12.srt	00:09:39.129 --> 00:09:44.879	So, the transfer function what we see is it assumes a linear time invariant system.
12.srt	00:09:45.310 --> 00:09:50.220	So, y of z is represented as half into z minus 1.
12.srt	00:09:50.860 --> 00:10:10.270	into y of z plus 1 by 2 into z minus 2 into y of z plus x of z and impulse invariance response of this is given by y of z by x of z which is nothing but 1 by 1 minus half into z minus 1 minus 1 by 8 into z minus 2.
12.srt	00:10:10.690 --> 00:10:16.350	So, we say that poles are at minus 0.183 and plus 0.683.
12.srt	00:10:21.310 --> 00:10:23.660	How we are going to design this?
12.srt	00:10:24.030 --> 00:10:33.780	We say it is designed with respect to biquad 0, z 0 and z 1 and poles will be represented as p naught and p 1.
12.srt	00:10:34.270 --> 00:10:37.440	So, always we use the biquad section.
12.srt	00:10:37.800 --> 00:10:49.040	So, in that case how it is going to represented h of z is given by c is the weight factor what we have it z minus z naught into z minus z 1 by z minus p naught.
12.srt	00:10:52.830 --> 00:10:54.250	into z minus p 1.
12.srt	00:10:54.660 --> 00:10:57.530	So, how we represent the magnitude response?
12.srt	00:10:57.880 --> 00:11:06.990	We will be taking in the frequency domain we substitute z is equal to e power j omega then take the magnitude response.
12.srt	00:11:07.260 --> 00:11:15.220	So, our z is equal to e power j omega has to be put in here also and this represents our magnitude response.
12.srt	00:11:15.220 --> 00:11:24.280	And then our we say that magnitude of a minus b is distance between our complex numbers a and b.
12.srt	00:11:28.310 --> 00:11:38.910	And, e power j omega minus p naught magnitude is a distance from our point on unit circle e power j omega and pole location at p naught.
12.srt	00:11:39.330 --> 00:11:55.460	So, that is how we represent the thing when poles and 0s are separated in angle and poles near unit circle indicate filters pass bands and 0s on near unit circle indicate the stop band.
12.srt	00:11:55.960 --> 00:11:57.850	So, we can see that.
12.srt	00:11:58.100 --> 00:12:08.690	how the poles and 0s have to be placed to achieve our pass band response and then this stop band attenuation how we can arrive at.
12.srt	00:12:09.570 --> 00:12:31.900	So, coming to biquad example continuing with the thing the transfer function is given by this equation and when transfer function coefficient are real valued then poles we say x are conjugate symmetric or real valued and then 0s we represented with 0 or conjugate symmetric.
12.srt	00:12:32.220 --> 00:12:33.900	or real valued.
12.srt	00:12:34.300 --> 00:12:39.190	So, filters below have what magnitude response one has to answer this.
12.srt	00:12:39.510 --> 00:12:47.240	So, what you see is these are the two complex conjugate poles here and corresponding 0s are outside the unit circle.
12.srt	00:12:47.610 --> 00:12:51.440	This is our real axis and this is our imaginary axis.
12.srt	00:12:51.860 --> 00:12:57.970	So, as we say that 0s are on the unit circle basically.
12.srt	00:12:58.250 --> 00:13:02.910	And here you will be seeing that poles and 0s are.
12.srt	00:13:03.720 --> 00:13:12.480	inside the unit circle and the other one you will be seeing it poles are inside whereas, 0s are outside the unit circle.
12.srt	00:13:12.850 --> 00:13:22.880	So, poles have radius r 0s have radius 1 by r that is what we represented.
12.srt	00:13:23.570 --> 00:13:32.740	So, we have what kind of filters we can design using IR method or FIR method low pass filter, high pass, band pass.
12.srt	00:13:34.190 --> 00:13:40.760	band stop or all pass or even notch filter what we can design the thing.
12.srt	00:13:41.460 --> 00:13:47.500	So, first we will see the direct form IR realization how it is going to be represented.
12.srt	00:13:48.330 --> 00:13:51.080	So, rational transfer function what we call it.
12.srt	00:13:51.410 --> 00:13:55.910	So, our impulse response H of z is given by y of z by x of z.
12.srt	00:13:56.450 --> 00:14:04.310	So, we say that b of z represents our zeros and a of z represents our poles.
12.srt	00:14:04.550 --> 00:14:15.300	So, which is given by b naught plus b 1 into z minus 1, b n will be z b n into z minus n. So, we have n 0s and we say m poles.
12.srt	00:14:15.580 --> 00:14:31.030	So, 1 minus a 1 into z minus 1 plus etcetera or minus etcetera a m into z minus m. So, which implies that my y of z is represented as 1 minus.
12.srt	00:14:35.110 --> 00:14:43.320	sigma small m is equal to 1 to m a m into z minus 1.
12.srt	00:15:06.200 --> 00:15:22.130	So, this is my represents my poles basically which is equal to x of z into this will be varying k is equal to 0 to n b k are the 0s into z minus k. We say direct form realization that is dot product of vector n plus 1 what we are assuming it coefficients and vector of current input and previous inputs what we call it as FIR section for our 0s and dot product of vector of m coefficients and vector of previous m outputs.
12.srt	00:15:22.310 --> 00:15:30.470	So, that is FIR filtering of previous output values what we will be taking it here as it is represented.
12.srt	00:15:31.040 --> 00:15:38.620	And then computation of m plus n plus 1 multiply accumulate what we need it as we can see the thing.
12.srt	00:15:39.360 --> 00:15:54.540	And, memory is also going to be m plus n words for previous inputs and outputs and then m plus n plus 1 words for the coefficients as it is represented here.
12.srt	00:15:55.040 --> 00:16:02.610	This is our previous output and this is our input represented with the coefficients bk.
12.srt	00:16:03.080 --> 00:16:09.470	So, when we represent this equation in this form.
12.srt	00:16:10.700 --> 00:16:20.830	Now, what happens to our structure we will see x of n is the input and we see that b naught b 1 b n coefficients are in the feed forward.
12.srt	00:16:20.830 --> 00:16:36.470	So, we have the unit delay and this is x of n minus 1 to x of n minus n which are going to be summed up in this unit and then output is going to be R y of n. So, what is the feedback here?
12.srt	00:16:36.470 --> 00:16:46.060	So, we will be delaying with 1 unit delay and coefficient is going to be multiplied with a 1.
12.srt	00:16:46.380 --> 00:16:49.240	So, will be a 1 into y of n minus 1.
12.srt	00:16:49.530 --> 00:16:53.510	So, which goes up to y of n minus m into a m.
12.srt	00:16:54.400 --> 00:17:00.040	all this is the we call it as the feed forward path and this is the feed backward path.
12.srt	00:17:00.470 --> 00:17:09.920	So, completely added here if there is as we have seen in the earlier case it is minus a 1 into r y of n minus 1.
12.srt	00:17:10.220 --> 00:17:25.080	So, some of the coefficients as we will see they may add and then get subtracted and then they may nullify and we may not have the overflow may or may not we can.
12.srt	00:17:25.930 --> 00:17:34.100	tell that y of n may be overflowing or not overflowing in these cases depends on the coefficients what we are using it.
12.srt	00:17:34.390 --> 00:17:37.400	See we call it is when we want the full precision.
12.srt	00:17:37.800 --> 00:17:42.370	So, what we need is word length of y of 0 is going to be 2 words.
12.srt	00:17:42.880 --> 00:17:47.570	So, as we have seen the thing multiplication and then addition.
12.srt	00:17:47.600 --> 00:17:49.940	So, it will be going up to 2 words.
12.srt	00:17:50.060 --> 00:17:58.160	So, what happens to word length of y n if we start putting y of with 2 words.
12.srt	00:17:59.250 --> 00:18:04.580	will be seeing the output next time is going to be forward surge it goes on increasing.
12.srt	00:18:04.730 --> 00:18:16.070	To avoid this what we have to do is we have to come back our y n representation with whatever n bit representation.
12.srt	00:18:16.070 --> 00:18:29.180	So, that we are not going to have overflow in our representation of y of n. So, and then m and n may be different we do not know what kind of order of the filter we are going to design.
12.srt	00:18:29.600 --> 00:18:34.350	So, they may be same or they can have different values for them.
12.srt	00:18:35.450 --> 00:18:42.560	Then, how we are going to represent again the direct form of IAR filter as it is shown here.
12.srt	00:18:43.010 --> 00:18:50.940	So, will be rearranged transfer function to be cascade of an all pull IAR filter followed by an FIR filter.
12.srt	00:18:51.450 --> 00:18:56.790	So, that is y of z into x of z into b z divided by a of z.
12.srt	00:18:57.240 --> 00:19:04.600	So, we represent this as a v of z x of z by a of z as v of z.
12.srt	00:19:05.420 --> 00:19:10.410	into B of z where that is what V of z is given by this equation.
12.srt	00:19:11.120 --> 00:19:19.760	And then we say here V of n is the output of an all pole filter applied to x of n that is what we call it.
12.srt	00:19:19.760 --> 00:19:36.140	So, V of n will be x of n plus all the poles m into V of n minus m basically m will be varying of 1 to m. And Y of n you will be seeing that it is represented with our 0s.
12.srt	00:19:36.410 --> 00:19:52.610	multiplied by V of n minus k. So, the implementation complexity it we can assume m can be greater than or equal to n, then number of computation what we need is m plus n plus 1 max in this case.
12.srt	00:19:53.080 --> 00:20:02.220	And memory is going to be m double words for past values of e n and m plus n plus 1 equals for the coefficients.
12.srt	00:20:02.590 --> 00:20:07.350	How this is going to represented as you can see here, this is our V of n.
12.srt	00:20:07.740 --> 00:20:12.670	n point and we have summation here and summation here.
12.srt	00:20:13.170 --> 00:20:23.950	So, x of n is going to be multiplied with all IAR filter feedback basically that is this is the feedback structure.
12.srt	00:20:24.280 --> 00:20:30.180	So, V of n minus 1 V of n minus m which is going to be summed up.
12.srt	00:20:30.620 --> 00:20:38.320	So, which is going to be given as you will be seeing that that is our V of n.
12.srt	00:20:38.700 --> 00:20:54.440	which is getting multiplied we will be seeing that b k into v of n minus k with that and then summed up here with all feed forward are 0s and y of n will be output.
12.srt	00:20:54.890 --> 00:21:00.910	So, as you notice from single summation what we have come down to double summation.
12.srt	00:21:01.300 --> 00:21:15.960	So, the critical path what we call it is or overflow or underflow because here all of them are negative we may underflow in this case and all of them are positive we may overflow also.
12.srt	00:21:16.930 --> 00:21:19.380	are the two critical nodes what we call it.
12.srt	00:21:19.760 --> 00:21:26.550	One has to take care that summation is not going to overflow or underflow in these two points.
12.srt	00:21:26.690 --> 00:21:43.050	From one single critical node we have bifurcated into two critical nodes, but as you can see that the delay units have come down by two compared to the previous direct form structure representation.
12.srt	00:21:43.600 --> 00:21:44.920	So, that is what the advantage.
12.srt	00:21:45.520 --> 00:21:50.650	Now, comes with the stability because we are more worried with respect to stability.
12.srt	00:21:50.960 --> 00:21:55.610	So, we will be seeing that our linear time invariant system is.
12.srt	00:21:56.030 --> 00:22:00.759	what we say is bounded input bounded output Bebo's table what we call it.
12.srt	00:22:01.160 --> 00:22:18.940	So, if for any bounded input x of n such that x of n is within this bounds what we call it between x of n is less than or equal to our some bound value which is less than infinity.
12.srt	00:22:18.940 --> 00:22:27.370	Then the filter response y of n is also bounded what we claim it that is whatever b 2 it should be less than infinity.
12.srt	00:22:28.980 --> 00:22:34.060	So, coming with the FIR filter that is h of n what we have it.
12.srt	00:22:34.400 --> 00:22:55.220	So, we said x of n is bounded already then when the FIR filter is going to be stable that is BIBOS stable if and only if what we claim is magnitude of our impulse response h of n is less than infinity for n is varying from minus infinity to infinity.
12.srt	00:22:55.290 --> 00:23:00.970	So, we say every finite impulse response of LTI system.
12.srt	00:23:01.400 --> 00:23:07.470	even after implementation is going to be bounded input bounded output stable.
12.srt	00:23:08.570 --> 00:23:22.390	So, we say causal infinite impulse response LTI system is BIBO stable if and only if its poles lie inside the unit circle that is what the meaning of it.
12.srt	00:23:23.300 --> 00:23:24.760	So, continuing with the thing.
12.srt	00:23:25.170 --> 00:23:32.260	So, what we says is rule 1 is for a causal sequence poles are inside the unit circle.
12.srt	00:23:32.780 --> 00:23:43.690	applies to Z transform functions that are ratios of 2 polynomials or the rule 2 is unit circle is in the region of convergence.
12.srt	00:23:44.269 --> 00:23:51.759	In continuous time imaginary axis would be in region of convergence of Laplace transform what we claim.
12.srt	00:23:52.200 --> 00:24:03.910	As an example a to the power of n into units step function when we take the Z transform of it which is nothing, but 1 by 1 minus a Z minus 1.
12.srt	00:24:04.390 --> 00:24:08.950	for all magnitude of z greater than magnitude of a.
12.srt	00:24:09.340 --> 00:24:30.520	So, stable if magnitude of a is less than 1 by rule 1 applying it or equivalently stable if magnitude of a is less than 1 by rule 2 also because magnitude of z is greater than magnitude of a and magnitude of a is less than 1.
12.srt	00:24:30.520 --> 00:24:34.900	So, that way we will be achieving the stability.
12.srt	00:24:36.050 --> 00:24:43.460	So, we will see how we can represent z and then Laplace transform what is the relationship.
12.srt	00:24:44.060 --> 00:24:51.310	So, that is transform differential equations into algebraic equations that are easier to solve.
12.srt	00:24:51.960 --> 00:25:05.610	So, our complex valued functions of a complex frequency variable what we call it as Laplace in transform what we represent S is equal to sigma plus j 2 pi f.
12.srt	00:25:05.940 --> 00:25:11.759	Whereas, in the Z transform we will have Z is equal to r into e power j omega.
12.srt	00:25:12.490 --> 00:25:21.970	So, the transform kernels are complex exponentials, eigen functions of linear time invariant systems what we call it.
12.srt	00:25:22.370 --> 00:25:41.039	So, we have Laplace is equal to e power minus s t is equal to e power minus a small sigma t minus j 2 pi f t. So, which is nothing, but e power minus sigma t and then these are the exponential function to exponential function what we are representing.
12.srt	00:25:41.549 --> 00:25:53.670	So, in the z domain what we have z minus n is equal to r into e power j omega to the power of minus n that is z we are replacing with r into e power j omega.
12.srt	00:25:54.269 --> 00:25:59.819	So, which is nothing but r power minus n and then e power minus j omega.
12.srt	00:25:59.890 --> 00:26:14.150	So, we constitute that e power minus sigma t and then r minus n as dampening factor whereas, the other exponential factors e power minus j to pi ft.
12.srt	00:26:14.620 --> 00:26:21.090	e power minus j omega n are the oscillation term in our representation.
12.srt	00:26:21.330 --> 00:26:26.940	So, no unique mapping from z to Laplace domain or from Laplace to z domain.
12.srt	00:26:27.549 --> 00:26:37.110	So, we can have mapping one complex domain to another is not going to be unique and one possible mapping is impulse invariance.
12.srt	00:26:37.110 --> 00:26:45.190	So, make impulse response of a discrete time linear time invariant system be a sample version of the.
12.srt	00:26:45.730 --> 00:26:49.730	impulse response of the continuous time LTI system.
12.srt	00:26:50.119 --> 00:27:16.650	So, how what is that I have a function f of n. So, in the z domain I represent pass it through with h of z that is my impulse response and what I will get output is y of n. Whereas, in the case of Laplace transform so, will be continuous time signal is represented with f tilde t which is transformed using h of s. So, I will be getting the.
12.srt	00:27:19.180 --> 00:27:32.340	y of t. So, how do we represent in that case h of s is given as h of z at z is equal to e power st that is we call it as impulse invariance mapping.
12.srt	00:27:33.000 --> 00:27:40.269	So, coming to the mapping how it is going to happen in the impulse invariance what it is shown here.
12.srt	00:27:40.740 --> 00:27:48.470	Mapping is z is equal to e power st where t sampling time what we call it as t s basically.
12.srt	00:27:51.410 --> 00:27:55.789	So, we will be seeing the axis, our real axis and then imaginary axis.
12.srt	00:27:56.160 --> 00:28:05.200	The poles on the left hand side of our what we call it as Laplace transform which is going to be mapped inside the unit circle.
12.srt	00:28:05.200 --> 00:28:16.549	And our imaginary axis which is shown in blue actually s is equal to j 2 pi f t gets mapped on the unit circle which becomes 1.
12.srt	00:28:23.470 --> 00:28:29.569	And then the 0s on the right hand side of side of it can be mapped to outside r unit circle.
12.srt	00:28:30.029 --> 00:28:36.859	So, this is how from Laplace transform to Z transform the transformation is going to happen.
12.srt	00:28:37.269 --> 00:28:53.009	So, what we have is omega max is nothing but 1 in this case which is f max which is given by 1 by 2 pi f which is implied that f should be greater than 1 by pi.
12.srt	00:28:57.069 --> 00:29:00.949	So, we assume let F s is equal to 1 hertz what we are assuming it.
12.srt	00:29:01.429 --> 00:29:16.399	Then what happens are poles s minus 1 plus or minus 1 j in the is getting mapped in the z domain as 0.198 plus or minus j 0.31 into t minus 1 second.
12.srt	00:29:17.109 --> 00:29:29.239	So, 0s will be getting mapped as s minus 1 plus or minus j is getting mapped as in the z domain 1.469 plus or minus j.
12.srt	00:29:30.499 --> 00:29:32.899	2.287 into t minus 1 second.
12.srt	00:29:32.899 --> 00:29:45.759	So, you will be seeing the Laplace domain left hand plane inside the unit circle which we discussed and imaginary axis is the unit circle and right hand plane is going to be our outside unit circle.
12.srt	00:29:45.759 --> 00:29:55.619	So, what we say is with this we will be having low pass, high pass, band pass, band stop, all pass are notch filter what it is going to be designed.
12.srt	00:29:55.619 --> 00:30:00.809	So, how we are going to represent our continuous time IR biquad section.
12.srt	00:30:01.999 --> 00:30:16.159	So, second order filter section with 2 poles and 0 to 2 poles what we can have 0 to 2 0s that means, to say I need not have to have any 0s in our second order filter.
12.srt	00:30:16.649 --> 00:30:27.079	If m and n are different if they are equal then we will be having 2 poles and then 2 0s and that is what will be representing.
12.srt	00:30:27.439 --> 00:30:32.419	And in the transfer function is a ratio of 2 real valued polynomials what we consider.
12.srt	00:30:33.049 --> 00:30:37.479	and then poles and 0s occur in conjugate symmetric pairs.
12.srt	00:30:38.159 --> 00:30:48.589	And what we define the quality factor it is technology independent measure of sensitivity of our pole locations to perturbations.
12.srt	00:30:49.079 --> 00:31:03.439	For an analog biquad with poles at a plus r minus j b where a is less than 0 then the quality factor what Q is given by.
12.srt	00:31:04.079 --> 00:31:14.439	root of a square plus b square divided minus 2 a, where it is going to be half less than or equal to q which is less than or equal to infinity.
12.srt	00:31:14.999 --> 00:31:19.309	So, if we have the real poles then b will be 0.
12.srt	00:31:19.709 --> 00:31:25.459	So, the quality factor will be half that is we call it as exponential decay response.
12.srt	00:31:25.859 --> 00:31:30.079	And if we have imaginary poles a will be 0.
12.srt	00:31:30.419 --> 00:31:32.909	So, q becomes infinity.
12.srt	00:31:33.209 --> 00:31:36.459	So, we say we are going to have the oscillatory response.
12.srt	00:31:36.869 --> 00:31:37.249	Thank you.
13.srt	00:00:01.219 --> 00:00:25.809	Welcome back to second lab of real time digital signal processing.
13.srt	00:00:25.920 --> 00:00:29.989	As I was mentioning in the first lab.
13.srt	00:00:30.980 --> 00:00:33.230	anybody is ready to dirty their hand.
13.srt	00:00:33.500 --> 00:00:35.350	So, you can start doing it.
13.srt	00:00:35.469 --> 00:00:40.090	So, we will start with first in this lab sign generation.
13.srt	00:00:40.640 --> 00:00:41.850	So, what is it?
13.srt	00:00:42.010 --> 00:00:50.689	As a recap we discussed how to use code composer studio and for dot products and then sign generator what we did.
13.srt	00:00:51.079 --> 00:00:55.140	Today we will see that only one sign wave generation last class we have seen.
13.srt	00:00:55.420 --> 00:00:59.010	So, we have multiple ways of representing sign generation.
13.srt	00:00:59.370 --> 00:01:03.060	So, we will be using both matlab and then code composer studio.
13.srt	00:01:03.449 --> 00:01:06.739	today and then how to create a basic music.
13.srt	00:01:06.950 --> 00:01:14.209	So, people who are music lovers you can create your own music and then hear how it is going to come.
13.srt	00:01:14.649 --> 00:01:20.699	So, the first sign generation what we will say it as direct digital synthesizer technique.
13.srt	00:01:21.310 --> 00:01:30.509	So, in this case we will have variable initialization section that is we say lines 2 to 6 here.
13.srt	00:01:30.909 --> 00:01:33.329	So, we will be initializing.
13.srt	00:01:33.799 --> 00:01:39.019	or amplitude as 32000 signal amplitude what we can call it.
13.srt	00:01:39.420 --> 00:01:48.269	So, compared to this detail on the left hand side the code is given on the right hand side for MATLAB implementation.
13.srt	00:01:48.930 --> 00:02:01.560	And some codes function are constrained to the range between plus or minus 1 which requires an amplitude scale factor of a what we call it or the.
13.srt	00:02:03.890 --> 00:02:18.620	DAC output whenever we want to output it on to DAC of our board then we have to enhance the amplitude of it for that we have taken some amplitude equal to 32000 in this case.
13.srt	00:02:19.129 --> 00:02:28.979	So, we use the tiny portion of the full range of what we call it as plus 327672 minus 32768.
13.srt	00:02:29.419 --> 00:02:32.189	I think there should be an alarm ringing in your thing.
13.srt	00:02:32.430 --> 00:02:37.479	So, we are using the 16 bit signed representation in this case.
13.srt	00:02:37.479 --> 00:02:44.050	So, the number of bit for the fractional representation what we will be using is 15 bits one for signed bit.
13.srt	00:02:44.590 --> 00:03:09.790	So, for a constant output frequency the calculation of the phase increment that is what is shown in line here phase enhancement which is given by the equation 2 times pi into frequency component what it is chosen f as 1000 that is 1 kilohertz here divided by the sampling frequency.
13.srt	00:03:10.100 --> 00:03:15.860	In this case sampling frequency f is assumed as 48 kilohertz.
13.srt	00:03:16.320 --> 00:03:20.390	So, we will be calculating the phase increment based on this unit.
13.srt	00:03:20.960 --> 00:03:40.530	And for a constant output frequency the calculation of phase increment as we said in line 9, the calculated value of the phase increment must be usually we restrict between minus pi to pi.
13.srt	00:03:40.810 --> 00:03:46.540	Here that is what it will be less than or equal to pi or signal aliasing is going to happen.
13.srt	00:03:47.010 --> 00:04:08.439	So, for that reason so, you will be seeing the actual algorithm to generate our sinusoidal signal requires only 3 lines of code that what you are seeing line 13 to or 15 basically is the code to generate our sine wave in this case.
13.srt	00:04:08.490 --> 00:04:12.860	Rest of them are initialization functions.
13.srt	00:04:13.290 --> 00:04:18.500	So, inside a for loop and then simulate the.
13.srt	00:04:19.199 --> 00:04:24.930	or execution of interrupt service routine in C if we are writing it.
13.srt	00:04:25.379 --> 00:04:37.199	We will consider this writing of interrupt service routine in the next lab class that is called each time a new sample is going to arrive.
13.srt	00:04:37.750 --> 00:04:49.050	So, these lines of code accomplish the following three task each time an interrupt service routine is going to be called.
13.srt	00:04:49.439 --> 00:04:52.710	What is the first one that is line 13 basically.
13.srt	00:04:54.310 --> 00:05:12.870	adding the phase increments value to the phase accumulator and then in the line 14 you will be calculating perform a modulus basically that is 2 pi operation to keep the phase accumulator in the range 0 to 2 pi.
13.srt	00:05:13.209 --> 00:05:19.980	Either you can have minus pi to pi or 0 to 2 pi is the range what we are going to take it.
13.srt	00:05:25.120 --> 00:05:31.410	Here in this case we will be seeing that if it is going to cross 2 pi then output is going to be modulo value what will be taking it.
13.srt	00:05:32.500 --> 00:05:43.149	In the line 15 we will calculate the systems output value by scaling the sign of the phase accumulator value by a.
13.srt	00:05:43.149 --> 00:05:50.579	So, that is what we are going to do in the thing just we will see that how this is going to run.
13.srt	00:05:51.000 --> 00:05:54.550	So, we will run the MATLAB code in this case.
13.srt	00:05:57.639 --> 00:06:03.839	You will be seeing the code sign generation dot m using the DDS method.
13.srt	00:06:04.379 --> 00:06:15.750	So, you will be seeing that your magnitude a in this case I can assume 1 or there it was 32000 we can vary we will see it in a while.
13.srt	00:06:16.389 --> 00:06:23.310	And then my frequency component what I want is 1000, 1 kilohertz frequency what I want to generate.
13.srt	00:06:23.699 --> 00:06:26.629	This is a variable so you can play around with it.
13.srt	00:06:27.089 --> 00:06:34.370	And then you will be initializing your accumulator that is phase accumulator as 0 and sampling frequency 48 kilohertz.
13.srt	00:06:34.370 --> 00:06:37.929	So, this also you can vary depending on your requirement.
13.srt	00:06:38.529 --> 00:06:45.049	And then your this thing number of terms what in this case we are generating 50.
13.srt	00:06:45.149 --> 00:06:50.639	This also if you want more waves basically you can increase that.
13.srt	00:06:50.989 --> 00:06:55.319	That is what it says is calculate this number of terms basically.
13.srt	00:06:55.839 --> 00:07:00.769	And then calculated and then output terms are going to be your phase increment.
13.srt	00:07:01.199 --> 00:07:03.899	this is the increment what we are providing it.
13.srt	00:07:04.269 --> 00:07:10.089	So, the phase increment and this is the one loop what it is going to be implemented.
13.srt	00:07:10.369 --> 00:07:15.899	So, for i is equal to 1 to number of terms because we need 50 terms.
13.srt	00:07:16.159 --> 00:07:18.719	So, we are accomplishing this one.
13.srt	00:07:19.049 --> 00:07:30.179	So, instead of putting it on the DAC here what I am doing is I am going to store the output in a loop basically array which is given by this equation.
13.srt	00:07:31.519 --> 00:07:37.839	And, then if you have to have the interrupt service routine algorithm for the sign loop we will be providing it here.
13.srt	00:07:38.249 --> 00:07:45.509	And, then this output will be going through the interrupt service routine to our DAC output in the real time scenario.
13.srt	00:07:46.049 --> 00:07:55.909	So, here at the end of our routine we can plot and see whether I have able to generate using this function.
13.srt	00:07:56.329 --> 00:08:06.459	So, what MATLAB does is any of the MATLAB version you can take it in this case I am using MATLAB 2020 B version.
13.srt	00:08:07.059 --> 00:08:09.479	So, you can use any one of them.
13.srt	00:08:09.479 --> 00:08:15.449	So, when I run this code, so you will be seeing that.
13.srt	00:08:18.739 --> 00:08:20.969	So, my sign generation is running.
13.srt	00:08:27.649 --> 00:08:30.949	So, the 50 samples is the output what I have given.
13.srt	00:08:31.299 --> 00:08:35.729	So, you will be seeing that you are getting in complete one.
13.srt	00:08:37.249 --> 00:08:42.259	a period of 50 samples here.
13.srt	00:08:42.739 --> 00:08:48.449	So, by varying this value this is one way of generating our sine wave.
13.srt	00:08:48.489 --> 00:08:52.389	So, if I increase my magnitude to whatever was given in that I can do it as 32000.
13.srt	00:08:52.509 --> 00:08:52.749	So, ok.
13.srt	00:08:52.979 --> 00:08:55.619	So, I can rerun my code.
13.srt	00:08:55.649 --> 00:08:57.479	So, you will be seeing that.
13.srt	00:09:09.039 --> 00:09:15.149	the magnitude which was 1 in the earlier case it has gone up to 10 power 4 in this case.
13.srt	00:09:15.539 --> 00:09:20.179	So, if you want to change your sampling frequency and the frequency part of it.
13.srt	00:09:20.529 --> 00:09:41.049	So, you can vary here f can be I can give it as here now 2000 hertz basically and sampling frequency I can keep it at 8000 hertz also because I have been meeting my whatever the sampling theorem says twice that of the maximum frequency.
13.srt	00:09:41.109 --> 00:09:46.839	So, f n is 2000 which is greater than or equal to twice that of it.
13.srt	00:09:46.839 --> 00:09:47.469	So, I am.
13.srt	00:09:47.909 --> 00:09:49.720	little more than the thing.
13.srt	00:09:49.720 --> 00:09:55.070	So, I can rerun this code as you will be seeing it.
13.srt	00:09:56.769 --> 00:10:01.429	So, you are able to get 2000 hertz whatever.
13.srt	00:10:01.730 --> 00:10:05.590	So, how do you know that you have got the 2000 hertz signal?
13.srt	00:10:06.049 --> 00:10:18.320	So, you have to wait for A50 class or you can run if you are comfortable with MATLAB you can put the A50 magnitude if you calculate the thing you will be getting.
13.srt	00:10:18.559 --> 00:10:21.009	the as we can see that.
13.srt	00:10:27.230 --> 00:10:29.000	So, we can rerun the thing.
13.srt	00:10:32.000 --> 00:10:40.949	So, you will be seeing that my FFT function has a what is it error in the thing.
13.srt	00:10:41.259 --> 00:10:48.809	So, you can go back and then correct it and then see that you will be getting your magnitude function.
13.srt	00:10:48.809 --> 00:10:51.710	So, what is the frequency you have represented.
13.srt	00:10:52.240 --> 00:11:00.299	So, coming back to my slide what is the other method of running our generating our sine wave.
13.srt	00:11:00.340 --> 00:11:07.059	So, this was the first one that is direct digital synthesizer what we have taken.
13.srt	00:11:07.690 --> 00:11:11.120	Next one can be using a table lookup technique.
13.srt	00:11:11.610 --> 00:11:15.409	So, what how do you generate your table?
13.srt	00:11:23.169 --> 00:11:32.479	So, as you can see in the right hand side here so, you have the signal represented as 32000, 0 minus 32000 then 0 that is we call it as a cosine signal values.
13.srt	00:11:32.809 --> 00:11:38.609	So, what you have chosen f is by 4 case what we have taken the thing.
13.srt	00:11:39.179 --> 00:11:49.899	So, coming with the thing it is a variable initialization section that is what lines 2 to 4 on the right hand side what it is going to be.
13.srt	00:11:50.620 --> 00:11:52.889	So, what it will take.
13.srt	00:11:53.460 --> 00:12:06.919	Then we will be establish the code and then variable signal that stores the required values of the output signal and then you will be reusing them.
13.srt	00:12:07.330 --> 00:12:20.289	So, what is that we will be doing the period determination from the line 7 as you can see it is n is equal to length of signal what you have taken the thing.
13.srt	00:12:20.879 --> 00:12:22.649	So, will be period.
13.srt	00:12:24.000 --> 00:12:37.080	determination is done by this code and then actual algorithm to generate our continuous sinusoidal signal is again lies from 11 to 15.
13.srt	00:12:37.370 --> 00:12:42.360	So, you are checking whether index has increased to n plus 1.
13.srt	00:12:42.750 --> 00:12:48.770	So, what the range we want is 1 to n. So, length of the signal.
13.srt	00:12:48.770 --> 00:12:55.670	So, if it is exceeded n plus 1 then you will be starting index again from.
13.srt	00:12:55.950 --> 00:13:11.620	So, this will be if statement what will be using it and then my for loop is going to end here and then output is going to be signal of index and then index you will be incrementing it by 1.
13.srt	00:13:11.980 --> 00:13:19.920	So, your interrupt service routine can be written here and then we will be ending the code for the for loop basically.
13.srt	00:13:27.020 --> 00:13:33.230	So, we will go back and then see again in MATLAB whether it is running correctly or So, I have chosen this.
13.srt	00:13:33.230 --> 00:13:54.760	So, you will be seeing that signal is represented by these values and index is 1 and number of terms also I have chosen in this case 50 and then n is going to be length of signal whatever you have chosen and then for i is equal to 1 to number of our terms.
13.srt	00:13:55.100 --> 00:13:57.800	So, this code is going to be repeated.
13.srt	00:13:58.320 --> 00:14:15.730	If n is greater than or index is greater than n for the n plus 1 index will be reset to 1 and output again putting it in a array so that we can plot it and then see whether we are getting it correctly.
13.srt	00:14:16.070 --> 00:14:17.550	So, we will run the code.
13.srt	00:14:18.460 --> 00:14:27.520	So, you will be seeing that it has generated our sine wave as you can see in this case.
13.srt	00:14:28.010 --> 00:14:29.620	So, this is how.
13.srt	00:14:30.000 --> 00:14:35.700	second method what you can run with lookup table.
13.srt	00:14:36.170 --> 00:14:43.370	So, it is going to help us that you have pre-calculated and then kept the thing.
13.srt	00:14:43.370 --> 00:14:47.070	So, it depends on how much memory what you need it.
13.srt	00:14:47.070 --> 00:14:55.410	So, just as I was telling so to generate using the sign concept can we generate a musical note.
13.srt	00:14:55.410 --> 00:15:05.710	In this case basic of music what I have taken it is Carnatic music whatever you call it it is Sarigamapada Nisa what will be generating it.
13.srt	00:15:06.380 --> 00:15:22.870	So, what is the thing is going to happen we will set the sampling frequency is 8000 hertz and then t will be varying between 1 and then fs and my sur note what we have chosen the basic note in this case is 440 hertz.
13.srt	00:15:23.220 --> 00:15:28.510	So, that is what we put here and then we will be generating the notes.
13.srt	00:15:28.770 --> 00:15:38.720	The next note is as you can see is 494 either you can use the equation whatever the you know musical literature gives.
13.srt	00:15:39.070 --> 00:15:46.410	and then do it or if you have pre calculated I can select the frequency part of it for all the node.
13.srt	00:15:47.100 --> 00:16:09.960	So, in this case Ga is going with 554 and then Ma will be going with 587 and then Pa with 660 and Da with 698 and then Ni will be 784 and then the last node as you know it will be twice that of the first whatever base node what you have taken the thing.
13.srt	00:16:10.260 --> 00:16:12.450	which is going to be 88 hertz.
13.srt	00:16:12.760 --> 00:16:23.280	So, and then what we do is we will be concatenating them that is all of them will be horizontal concatenation is going to happen.
13.srt	00:16:23.280 --> 00:16:30.940	So, we have the function horizontal cat actually all these notes and then we will be playing that.
13.srt	00:16:31.020 --> 00:16:33.900	So, just hold on a while.
13.srt	00:16:34.220 --> 00:16:38.930	So, we will see how our music is going to come out of it.
13.srt	00:16:40.750 --> 00:16:42.340	So, this is the code written.
13.srt	00:16:42.780 --> 00:16:51.060	So, if you want you can treat it nicely and then say that with the comments what you can put the thing.
13.srt	00:16:51.490 --> 00:16:56.110	So, here basic thing what I wanted to show in this lecture.
13.srt	00:16:56.690 --> 00:16:58.490	So, go to the editor.
13.srt	00:16:58.690 --> 00:17:00.990	So, you will be running this.
13.srt	00:17:01.500 --> 00:17:09.590	So, you will be hearing it and then you have to comment whether you have heard the Saragamapadani correctly or not.
13.srt	00:17:10.850 --> 00:17:21.070	Want to hear it once again.
13.srt	00:17:21.309 --> 00:17:22.309	I will play the thing.
13.srt	00:17:22.379 --> 00:17:50.999	So, if you have your notes basically some of the students played their own happy birthday song and then our national anthem, so which we can play when everybody is around.
13.srt	00:17:51.630 --> 00:18:03.010	So, you can go and then write your own musical compositions and then generate it and here that you are getting it correctly.
13.srt	00:18:03.280 --> 00:18:11.320	So, the other way of doing it is whether I can do sign generation using my polynomial approximation.
13.srt	00:18:11.680 --> 00:18:14.170	We call it as GNU math library here.
13.srt	00:18:14.540 --> 00:18:22.720	So, this is the approach using the scientific library which stores the first 11 coefficients of the approximation.
13.srt	00:18:23.110 --> 00:18:26.820	So, what it calls is harness form is used.
13.srt	00:18:27.160 --> 00:18:30.110	What is that harness form we will see it once now.
13.srt	00:18:30.690 --> 00:18:45.360	The number of operations required in this case is a to the power of 10 into 10 plus a power 9 into 9 plus a power 8 into 8 plus etcetera.
13.srt	00:18:45.880 --> 00:18:47.770	So, this will be a power 0.
13.srt	00:18:47.800 --> 00:18:53.110	So, you will be seeing that how the harness form is going to be.
13.srt	00:18:53.480 --> 00:18:56.760	You will be doing a power 10.
13.srt	00:18:57.590 --> 00:19:08.680	into your this thing what is it 0 x, x is the input value what you have to give it plus a power 9 into x.
13.srt	00:19:09.120 --> 00:19:12.780	So, and then plus a power 8 into x.
13.srt	00:19:13.060 --> 00:19:21.830	So, so on what you will be putting the thing so that your power calculation is going to be reduced plus a 0 what you will be doing.
13.srt	00:19:30.350 --> 00:19:32.450	So, to generate sinusoidal frequency f naught we need only few stage for each steps for each sample.
13.srt	00:19:33.040 --> 00:19:40.460	So, you will be calculating the cos theta via the approximation above and then send the value to the DAC.
13.srt	00:19:41.010 --> 00:19:59.790	And then increment theta by omega naught is equal to 2 pi f naught by f s and then check if theta is going to exceed 2 pi f basically, then 2 pi if it does subtract 2 pi to prevent the overflow or loss precision.
13.srt	00:20:00.160 --> 00:20:06.850	I want you to write the code for this in MATLAB and see whether you have got the.
13.srt	00:20:07.400 --> 00:20:12.400	sine wave generated correctly using this polynomial approximation.
13.srt	00:20:12.740 --> 00:20:24.250	So, what this says is this method produces a very accurate signal, but requires roughly 20 multiplications and 20 additions as you can see in the bracket there.
13.srt	00:20:24.800 --> 00:20:28.480	Per sample in addition to the storage of the coefficients.
13.srt	00:20:28.780 --> 00:20:32.110	So, you have to store all the coefficients and then run them.
13.srt	00:20:38.320 --> 00:20:46.640	And then it is also extremely flexible since at us to change the frequency as we please by simply changing the amount at which we increment theta.
13.srt	00:20:47.080 --> 00:20:49.980	So, by doing theta increment varying.
13.srt	00:20:50.120 --> 00:20:55.570	So, you will be able to get whatever frequency you want to generate.
13.srt	00:20:56.040 --> 00:21:06.500	So, coming to the next one some of the lab thing component we will be seeing that how to generate real time sine wave generation and FIR filters.
13.srt	00:21:06.500 --> 00:21:11.680	So, you have enjoyed the sine wave generation and then music generation in MATLAB.
13.srt	00:21:12.190 --> 00:21:15.560	So, the same thing what we will see in the next lab class.
13.srt	00:21:15.960 --> 00:21:17.780	on DSP processor.
13.srt	00:21:18.240 --> 00:21:23.050	So, you can play with it with whatever music you love.
13.srt	00:21:23.260 --> 00:21:23.770	Thank you.
13.srt	00:21:24.260 --> 00:21:26.170	So, see you in the next lab session.
22.srt	00:00:01.219 --> 00:00:25.030	Welcome back to real time digital signal processing course.
22.srt	00:00:25.030 --> 00:00:29.800	So today we will discuss discrete Fourier transform in detail.
22.srt	00:00:32.359 --> 00:00:39.759	So, coming to the previous class, so we covered the FIR and IAR filters in the previous module.
22.srt	00:00:40.259 --> 00:00:59.549	So, we saw how quantization affects the frequency response for the IAR filter and then how we have to do the scaling and other parameters what we have to take it into consideration to design our IAR filter.
22.srt	00:01:00.170 --> 00:01:03.230	So, coming to now we will go to the frequency domain.
22.srt	00:01:03.649 --> 00:01:05.659	Why we have to go to the frequency domain?
22.srt	00:01:06.150 --> 00:01:11.340	So, first of all what we have to say from analog time domain we have to move to frequency.
22.srt	00:01:11.890 --> 00:01:18.810	So, the time domain the components which we are unable to see basically.
22.srt	00:01:19.150 --> 00:01:28.120	So, whether the other domain that is in the transform domain which is going to give us the parameters what we are looking for.
22.srt	00:01:28.569 --> 00:01:35.159	So, for that we go to the Fourier domain basically that is frequency domain.
22.srt	00:01:35.640 --> 00:01:46.469	So, in this case today we will be discussing about discrete time Fourier transform first and then we will see that how discrete Fourier transform the thing is developed.
22.srt	00:01:46.939 --> 00:02:09.259	So, in that is what we are going to tell that is we introduce the discrete time Fourier transform for the theoretical analysis of our discrete time signals and systems and the discrete Fourier transform which can be computed by our digital hardware for practical applications.
22.srt	00:02:17.539 --> 00:02:44.780	So, coming to the definition, so we know that discrete time Fourier transform d t f t is for the discrete time signal x of n t is defined with this equation that is x of omega is equal to sigma n is equal to minus infinity to infinity x of n t into e power minus j omega n t. And we say x of omega is periodic function with period pi.
22.srt	00:02:45.340 --> 00:02:51.459	So, the frequency range of discrete time signal is unique over the range that is minus pi to pi.
22.srt	00:02:51.949 --> 00:02:54.590	or we can consider 0 to 2 pi.
22.srt	00:02:55.259 --> 00:03:02.799	So, d t of t of r x of n t can also be defined using the normalized frequency.
22.srt	00:03:03.159 --> 00:03:24.370	So, if we take that then it is going to be x of f which is equal to n is equal to minus infinity to infinity x of n t into e power minus j 2 pi n capital f into n where our f is frequency is given by omega by pi.
22.srt	00:03:24.839 --> 00:03:34.509	which is nothing, but f by f s by 2, f is the signal what we are interested in and f s is the sampling frequency.
22.srt	00:03:34.939 --> 00:03:40.899	So, we say that normalized digital frequency in cycles per sample.
22.srt	00:03:42.139 --> 00:03:46.689	So, how we are going to represent the spectrum of discrete time signal.
22.srt	00:03:47.569 --> 00:03:56.399	So, we said that it is periodic sampling imposes relationship between independent variables T and N as T is equal to.
22.srt	00:03:56.629 --> 00:04:00.219	which is nothing but n divided by fs.
22.srt	00:04:00.740 --> 00:04:13.020	So, that we can show that x of f is equal to 1 by t k is equal to minus infinity to infinity x of f minus k into fs.
22.srt	00:04:13.539 --> 00:04:29.870	So, we will be seeing that x of f is the sum of the infinite number of x of f what we are going to say which is the Fourier transform of our analog signal x of t.
22.srt	00:04:30.829 --> 00:04:38.329	It is scaled by 1 by t and then frequency shifted to k times fs.
22.srt	00:04:38.729 --> 00:04:47.329	So, it also state that x of f is a periodic function with period t is equal to 1 by fs.
22.srt	00:04:47.629 --> 00:04:49.859	So, we will be seeing the spectrum here.
22.srt	00:04:50.250 --> 00:04:59.709	This is our x of f what we are considering it and this is the maximum frequency in our input signal.
22.srt	00:05:00.459 --> 00:05:08.049	It varies between minus f m to f m and then f is the x axis.
22.srt	00:05:08.560 --> 00:05:18.279	So, coming to the next one if why we are going to have the replication that is discrete time signal caused by sampling basically.
22.srt	00:05:18.719 --> 00:05:27.289	So, this sampling extends original spectrum whatever we have considered x of f repeatedly on both sides.
22.srt	00:05:27.569 --> 00:05:31.299	So, we will be seeing this is extended on both sides.
22.srt	00:05:31.639 --> 00:05:33.370	So, we call this as.
22.srt	00:05:33.980 --> 00:05:37.279	minus fs by 2 and then fs by 2.
22.srt	00:05:37.529 --> 00:05:44.029	So, we will be getting the images of the spectrum basically.
22.srt	00:05:44.389 --> 00:05:54.970	So, what happens if our maximum frequency is less than or equal to our half the sampling frequency according to Shannon sampling theorem.
22.srt	00:05:55.610 --> 00:05:57.069	So, then what happens?
22.srt	00:05:57.069 --> 00:06:00.670	So, we will not be seeing any overlap in the thing.
22.srt	00:06:01.399 --> 00:06:04.009	So, that is what the theory says.
22.srt	00:06:04.450 --> 00:06:11.500	that our f m is going to be much away from our f s by 2.
22.srt	00:06:11.680 --> 00:06:28.780	So, in the next case if f m is what we say is more than our f s by 2 or f s amplic frequency is less than that why is the maximum frequency component present in our signal.
22.srt	00:06:29.330 --> 00:06:33.879	Then what we are going to have is we will be seeing the overlap of it.
22.srt	00:06:33.879 --> 00:06:35.770	So, f s by 2 is here.
22.srt	00:06:36.129 --> 00:06:41.449	minus f s by 2 is here or f m has more than f s by 2.
22.srt	00:06:41.449 --> 00:06:47.949	So, you will be seeing that we will be getting the aliased signal.
22.srt	00:06:48.620 --> 00:07:02.279	So, this we may not be able to reconstruct to the original signal it may map it to some other signal as we have seen aliasing in our sine wave generation also.
22.srt	00:07:02.959 --> 00:07:05.100	Coming to discrete Fourier transform.
22.srt	00:07:05.459 --> 00:07:09.959	So, what we have is it this is we call it as a finite duration.
22.srt	00:07:10.410 --> 00:07:16.339	whereas, DTFT was discrete in time, but frequency was continuous in omega.
22.srt	00:07:16.720 --> 00:07:22.920	Here both frequency and then time have been discretized.
22.srt	00:07:23.370 --> 00:07:40.740	So, x of n of length in is defined as given by x of k. So, n is equal to 0 to n minus 1 x of n into e power minus j 2 pi by n into k into n. k will be varying 0 to n minus 1.
22.srt	00:07:41.639 --> 00:07:45.379	And, then we will be seeing that n is varying 0 to n minus 1.
22.srt	00:07:46.019 --> 00:07:49.569	So, we call k is the frequency index.
22.srt	00:07:49.959 --> 00:07:55.350	So, we will be saying x of k is the kth DFT coefficient.
22.srt	00:07:56.209 --> 00:08:11.620	The summation bounds reflect the assumption that x of n is equal to 0 outside the range 0 to 0 less than or n which is less than or equal to n minus 1.
22.srt	00:08:12.379 --> 00:08:24.500	So, we call DFT that is n samples of DTFT of X of omega over the interval omega in between 0 and then 2 pi.
22.srt	00:08:25.079 --> 00:08:36.279	At n equally spaced discrete frequencies that is omega k what we call it 2 pi k by n here k is going to be 0 to n minus 1.
22.srt	00:08:37.080 --> 00:08:42.460	And the space between two successive X of k is nothing but.
22.srt	00:08:42.750 --> 00:08:48.200	2 pi by n we call it as a resolution of the DFT.
22.srt	00:08:48.649 --> 00:09:00.210	So, we say the unit for this is radiance and then if we represent in terms of sampling frequency it is going to be fs by n hertz.
22.srt	00:09:01.830 --> 00:09:10.100	So, then what we can see that as an example if the signal n is real valued and n is even number.
22.srt	00:09:12.920 --> 00:09:46.560	So, we can show that x of 0 if we substitute that is n is equal to 0 to n minus 1 which is nothing but x of n into e power minus j 0 which is nothing but x of n. And then x of n by 2 any other n divide by 2 is represented as this way n is equal to 0 n minus 1 e power minus j pi n into x of n. So, this is we know that e power minus j pi n is nothing but minus 1 to the power of n into x of n.
22.srt	00:09:46.860 --> 00:09:56.129	So, what we observe from this is the DFT coefficients x of 0 and x of n by 2 are real valued.
22.srt	00:09:56.129 --> 00:10:04.870	That means, if x of n is real valued then output even the DFT coefficients are real valued.
22.srt	00:10:05.500 --> 00:10:13.769	So, if n is an odd number x of 0 is still real, but x of n by 2 is not available.
22.srt	00:10:14.960 --> 00:10:16.460	Now, we will consider the.
22.srt	00:10:16.740 --> 00:10:30.230	sequence or signal of finite length which is given by x of n is equal to a power n, n is varying between 0 to n minus 1 and then a is in between 0 and 1.
22.srt	00:10:30.670 --> 00:10:46.639	Then DFT of x of n is computed as that is x of k substitute x of n with a power n and then we have e power minus j to pi k by n into n. So, by simplifying.
22.srt	00:10:47.020 --> 00:10:59.990	So, what we will be getting is 1 minus a to the power of n by 1 minus e power minus j 2 pi k by n and k is going to vary between 0 to n minus 1.
22.srt	00:11:00.730 --> 00:11:17.790	So, we can represent this DFT as W n k we call this as a twiddle factor which is given as e power minus j 2 pi k by n into k n. So, we know that we can split our exponential into cos and sin function.
22.srt	00:11:17.790 --> 00:11:21.930	So, cos 2 pi k n by n which is real.
22.srt	00:11:22.460 --> 00:11:26.379	and then minus j sin 2 pi k by n is the imaginary part.
22.srt	00:11:26.759 --> 00:11:31.290	Both k and n will be varying between 0 to n minus 1.
22.srt	00:11:31.770 --> 00:11:36.560	So, then if we substitute w and k in our equation.
22.srt	00:11:36.640 --> 00:11:46.310	So, x of k will be equal to n is equal to 0 to n minus 1 x of n into w n k n, k is varying between 0 to n minus 1.
22.srt	00:11:46.930 --> 00:11:53.920	So, that is what I said twiddle factors of DFT, w n k n are called.
22.srt	00:11:54.450 --> 00:12:00.800	And then we know that n roots of unity is a clockwise direction on the unit circle.
22.srt	00:12:01.240 --> 00:12:02.920	We will see it in a while hold on.
22.srt	00:12:03.260 --> 00:12:15.630	So, then what we call W n, n is nothing, but e power minus j 2 pi which is equal to 1 which is nothing, but equal to W n 0.
22.srt	00:12:16.250 --> 00:12:21.620	So, we can see that the DFT is periodic in nature.
22.srt	00:12:21.620 --> 00:12:27.130	So, that is the reason why we take 0 to n minus 1 when we.
22.srt	00:12:27.509 --> 00:12:36.170	substitute x of n is equal to n basically that is n is n then what happens?
22.srt	00:12:36.259 --> 00:12:46.330	k r n becomes n it becomes e power minus j 2 pi which is 1 which is nothing but w n 0.
22.srt	00:12:47.080 --> 00:12:58.240	So and then the centre point what we will check it up w n that is n by 2 which is equal to e power minus j pi so which is nothing but minus.
22.srt	00:12:58.540 --> 00:13:08.080	1 and W n k what we call it between the other values as k is equal to 0 to n minus 1.
22.srt	00:13:08.680 --> 00:13:13.420	So, if we extract the symmetry property then what happens?
22.srt	00:13:13.470 --> 00:13:28.520	We can split this into two parts that is W n k plus n by 2 which is equal to minus W n k. So, k is in between 0 to n by 2 minus 1.
22.srt	00:13:29.070 --> 00:13:34.040	And, if we consider the periodicity property then what happens?
22.srt	00:13:34.040 --> 00:13:45.190	W n k plus n is nothing, but W n k. So, we know that the inverse discrete Fourier transform we call it as IDFT.
22.srt	00:13:45.800 --> 00:13:59.509	So, is used to transform the frequency domain coefficients x of k back to time domain signal x of n. The IDFT is defined with this equation x of.
22.srt	00:13:59.750 --> 00:14:25.399	n is equal to 1 by n, k is equal to 0 to n minus 1, x of k into e power j 2 pi by n into k n. So, if we represent with twiddle factor, it will be 1 by n into k is equal to 0 to n minus 1, x of k into w n minus k n in this case, n will be varying between 0 to n minus 1.
22.srt	00:14:26.170 --> 00:14:31.180	So, we can see that how the twiddle factors of DFT.
22.srt	00:14:31.649 --> 00:14:37.120	in case of n is equal to 8 is assumed so on a unit circle.
22.srt	00:14:37.649 --> 00:15:01.610	So, we will be seeing that this is w 8 0 which is equal to 1 and then what we have is w 8 1 and then w 8 2 w 8 3 and then n by 2 what we just now saw that w 8 4 which is nothing but minus w 8 0 which is equal to minus 1 and then we know w 8.
22.srt	00:15:02.019 --> 00:15:11.349	5 is equal to minus W 8 1 and then W 8 6 will be equal to minus W 8 2.
22.srt	00:15:11.649 --> 00:15:24.559	And we know that when we come to W 8 7 it comes out to be minus W 8 3 you will be seeing that this is what it is minus W 8 3.
22.srt	00:15:24.870 --> 00:15:33.189	And when it becomes W 8 is equal to 8 just now we said n W n n is equal to W n 0.
22.srt	00:15:33.389 --> 00:15:39.879	here it is W 88 which is equal to W 80 equal to 1.
22.srt	00:15:40.609 --> 00:15:57.339	So, these are the twiddle factors depending on power of 2 if you are considering it will be on the unit circle this way and then it is going to be repeated after a period in this case we have assumed n is equal to 8.
22.srt	00:15:58.329 --> 00:16:03.379	So, the equation now again repeated for DFT what it is shown.
22.srt	00:16:03.919 --> 00:16:21.499	And then in terms of twiddle factors w what we call it w n k n where 0 is less than or equal to k and then n is less than or equal to n minus 1 both k and then n are in 0 to n minus 1.
22.srt	00:16:21.829 --> 00:16:30.859	How we can write the in a matrix form that is all these coefficients are first row is 1 and first column is 1.
22.srt	00:16:31.499 --> 00:16:33.599	After that we will have w n.
22.srt	00:16:34.049 --> 00:16:48.999	and then 4 1s in the column then this is W 4 1, W 4 2, W 4 3 and W 4 2, W 4 4 and W 4 6 so on in the last line odd you will be seeing it.
22.srt	00:16:49.469 --> 00:17:04.079	When you expand them so in terms of e power then you will be seeing that W 4 1 is nothing but minus j and W 4 2 is minus 1 and W 4.
22.srt	00:17:04.469 --> 00:17:08.919	3 is minus of w for 1 which is plus j.
22.srt	00:17:09.369 --> 00:17:17.049	So, here also you will be seeing the thing this is how we will enter the thing and we have been given x of n is this value.
22.srt	00:17:17.769 --> 00:17:26.649	So, this is our coefficient and then this are our x of n when we do the matrix multiplication.
22.srt	00:17:27.099 --> 00:17:33.519	So, the DFT of the sequence is nothing, but 2 1 minus j 0 and 1 plus j.
22.srt	00:17:34.099 --> 00:17:39.269	So, to see that whether our DFT is correct or not we will take the IDFT.
22.srt	00:17:39.809 --> 00:17:47.909	So, we assume that fk is equal to k into fs by n, k will be varying between 0 to n minus 1.
22.srt	00:17:48.469 --> 00:17:56.209	So, then what happens to our x which is nothing but 1 by 4 that is 1 by n in this case.
22.srt	00:17:56.689 --> 00:18:09.879	So, we will substitute our matrix is going to be just our DFT matrix, but you will be seeing that the twiddle factors are.
22.srt	00:18:10.169 --> 00:18:11.849	negative in this case.
22.srt	00:18:12.539 --> 00:18:19.639	So, we will be substituting all this values when we do that.
22.srt	00:18:19.929 --> 00:18:25.609	So, 1 by 4 this is our DFT coefficients in the IDFT basically.
22.srt	00:18:26.269 --> 00:18:38.049	So, you will be seeing that it is a complex conjugate of this DFT coefficients which it will be resulting in what is it?
22.srt	00:18:41.119 --> 00:18:47.659	After multiplication with our x of k that is 2 1 minus j 0 and 1 plus j.
22.srt	00:18:47.969 --> 00:18:52.939	So, we will be getting back our x of n that is 1 1 0 0.
22.srt	00:18:53.579 --> 00:19:05.969	So, you will be seeing that this is the DFT and IDFT with an example how there what I will call it as analysis and then synthesis equations what we call them.
22.srt	00:19:05.969 --> 00:19:11.919	So, what is the frequency resolution in this case?
22.srt	00:19:14.139 --> 00:19:25.069	So, we said identical to DFT with exception of the normalizing factor 1 by n and the opposite sign of the exponent of the twiddle factors that is what we said.
22.srt	00:19:25.579 --> 00:19:44.259	So, the DFT coefficients are equally spaced on the unit circle we saw that usually we call it as the z plane at frequency intervals of f s by n or it can be 2 pi by n because that is what we mapped.
22.srt	00:19:44.619 --> 00:19:54.619	in the omega that is in the frequency domain 0 to 2 pi and then here sampling frequency is f s up to 2 pi.
22.srt	00:19:55.869 --> 00:20:08.559	And we say that frequency resolution of our DFT delta is nothing, but f s by n this is the sample samples or the period between two samples.
22.srt	00:20:09.969 --> 00:20:13.849	Frequency sample x of k represent the discrete frequency.
22.srt	00:20:16.369 --> 00:20:20.679	So, where f k is given by K to Fs by n for K is equal to 0 to n minus 1.
22.srt	00:20:21.159 --> 00:20:43.859	So, we assume that if I do not know what is the frequency I am getting at the output, if I know the K is equal to I will put it as 1 and we have assumed Fs sampling frequency is 8 kilohertz and then I am going to pass it through n is equal to 8 to be simpler to calculate this.
22.srt	00:20:44.189 --> 00:20:48.379	Then what is the frequency FK component in this case is going to be?
22.srt	00:20:48.799 --> 00:20:57.659	k is 1 and I have chosen 8 kilohertz as my Fs divided by number of samples is 8.
22.srt	00:20:58.339 --> 00:21:05.789	So, then you will be seeing that Fk is what I am representing at k is equal to 1 is 1 kilohertz.
22.srt	00:21:06.059 --> 00:21:19.269	So, if I draw the thing, so this will be my magnitude x of e power j omega what I can put the thing magnitude of it and this is the Fs.
22.srt	00:21:19.459 --> 00:21:28.299	in kilohertz what I will put it and this is my 0, this is 1, 2, 3, I will put it as 8.
22.srt	00:21:28.619 --> 00:21:35.779	So, I will be getting the peak here which is my f k in this case what I am representing.
22.srt	00:21:36.289 --> 00:21:48.099	So, this is how you will be calculating depending on k value is going from 0 to here 7 in this case, 8 will be f s by 2 point.
22.srt	00:21:48.519 --> 00:21:50.149	So, it will be repeated.
22.srt	00:21:50.689 --> 00:21:59.189	So, this is how you calculate and then we know that DFT coefficients x is complex variable.
22.srt	00:21:59.689 --> 00:22:17.779	So, it can be expressed in polar form as x of k is equal to magnitude of x of k into e power j phi of k. So, this represents my phase and this represents my magnitude.
22.srt	00:22:18.629 --> 00:22:25.839	So, that is how we will be representing it here, how we can compute our magnitude and phase spectrum for a given signal.
22.srt	00:22:26.259 --> 00:22:40.829	So, the first is the magnitude spectrum will be calculating magnitude of x of k is nothing, but all of us know real part of x of k whole squared plus imaginary part of x of k whole squared under square root.
22.srt	00:22:41.319 --> 00:22:49.699	So, will give me the magnitude of x of k and then the phase spectrum always we represent in terms of tan inverse.
22.srt	00:22:58.079 --> 00:23:02.199	So, phi of k is equal to tan inverse imaginary part of x of k real part of x of k. If tan real part of x of k is greater than or equal to 0.
22.srt	00:23:02.669 --> 00:23:20.719	So, if it is less than 0 then we will be seeing that it will be pi plus tan inverse of imaginary part of x of k divided by real part of x of k. So, now, how we are going to represent our DFT and then Z transform.
22.srt	00:23:21.159 --> 00:23:23.859	What is the relationship we will see in the slide.
22.srt	00:23:24.319 --> 00:23:31.939	So, the DFT questions can be obtained by evaluating the Z transform of the length n sequences of x of n.
22.srt	00:23:32.379 --> 00:23:35.029	on the unit circle we have seen it already.
22.srt	00:23:35.359 --> 00:23:43.589	At n equally spaced frequencies wk which is given by 2 pi k by n, k will be varying between 0 to n minus 1.
22.srt	00:23:43.999 --> 00:23:56.449	So, we what is it x of k is equal to x of z, z is equated to e power j 2 pi by n k where k will be going from 0 to n minus 1.
22.srt	00:23:56.979 --> 00:24:02.619	So, some of the terms how we will be going from one domain to the other domain what is shown in this figure.
22.srt	00:24:10.079 --> 00:24:41.409	What is it x of t is my time domain by doing the sampling of the signal I will be entering into digital domain that is x of n t. And then if I take the Laplace transform for in the time domain then I will be going into Laplace domain which is represented as x of s. And then how I can traverse to my digital z domain by substituting a simplest impulse invariant method that is z is equal to e power st I can enter into a z transform basically in the digital domain.
22.srt	00:24:43.279 --> 00:24:56.429	or from the digital signal I can use that Z transform to calculate my X of Z and if I calculate the Fourier transform I will be entering into the Fourier domain that is X of omega.
22.srt	00:24:56.969 --> 00:25:08.069	And then how these two are related as you can see by substituting Z is equal to e power j omega I can get the frequency component from Z domain ok.
22.srt	00:25:08.109 --> 00:25:15.629	So, the sum of the units and then variables and relationship and range is shown in this table.
22.srt	00:25:18.759 --> 00:25:23.789	So, if we represent it as capital omega we call it as radiance per second.
22.srt	00:25:24.119 --> 00:25:37.409	So, we say that capital omega will be 2 pi f and this is the range for our capital omega that is minus infinity to infinity and f we call it as cycles per second in hertz.
22.srt	00:25:37.739 --> 00:25:45.599	So, which is f is equal to capital F by T which is capital F is assumed in this case as sampling frequency.
22.srt	00:25:46.229 --> 00:25:51.169	As you can see cycles per sample that is f by fs.
22.srt	00:25:51.989 --> 00:26:09.449	And, then this also varies between minus infinity to infinity and omega usually we represent it in radiance per sample and omega is equal to 2 pi f which varies between minus pi to pi omega or it can vary between 0 to 2 pi.
22.srt	00:26:09.839 --> 00:26:16.779	And, this is between minus half less than or equal to f less than or equal to half.
22.srt	00:26:17.199 --> 00:26:21.819	So, this is what the relationship with respect to.
22.srt	00:26:22.519 --> 00:26:24.179	Z transform and then DFT.
22.srt	00:26:25.419 --> 00:26:33.429	So, now we will assume that how to go with we said that DFT is a periodic function.
22.srt	00:26:33.829 --> 00:26:37.009	We will see how to calculate the circular convolution.
22.srt	00:26:37.469 --> 00:26:44.809	So, all of you must be conversant with your linear convolution and circular convolution.
22.srt	00:26:45.179 --> 00:26:49.389	Usually DFT will be represented as a circular convolution.
22.srt	00:26:49.389 --> 00:27:02.899	So, we have a x of n and h of n are real valued n periodic sequences, y of n is a circular convolution of x of n and h of n. So, which is represented as y of n is h of n into.
22.srt	00:27:03.379 --> 00:27:14.919	This is the circular convolution notation what we use it with x of n which is given as h of m into x of n minus m mod n what we will be taking it.
22.srt	00:27:15.099 --> 00:27:21.659	That means to say n minus 1 mod n non negative modular n operation will be considering it.
22.srt	00:27:22.059 --> 00:27:26.709	n is varying between 0 to n minus 1 in this case.
22.srt	00:27:27.319 --> 00:27:35.239	So, how we represent in the this is what we have in the time domain and in the frequency domain.
22.srt	00:27:35.509 --> 00:27:38.519	So, it results in the multiplication of.
22.srt	00:27:39.279 --> 00:27:53.829	2 Fourier transform of that is discrete Fourier transform of x and then h. So, y of k will be x of k into h of k where k will be varying between 0 to n minus 1.
22.srt	00:27:54.329 --> 00:28:04.659	So, that is what it says if the shortest sequence must be padded with 0s in order to have the same length for computing circular convolution.
22.srt	00:28:04.899 --> 00:28:06.489	So, what do we mean by that?
22.srt	00:28:06.829 --> 00:28:10.869	So, x of k and h of k are of different length.
22.srt	00:28:11.359 --> 00:28:16.199	So, to make them equal length one of them have to be padded with 0s.
22.srt	00:28:16.419 --> 00:28:19.879	So, we will see in that linear convolution in slide 21.
22.srt	00:28:19.879 --> 00:28:27.039	So, how we have padded with 0s and then made power of 2 and then used in our circular convolution.
22.srt	00:28:27.709 --> 00:28:30.779	So, how we are going to compute our circular convolution?
22.srt	00:28:30.779 --> 00:28:42.489	So, usually it is represented with two concentric circles and we will be seeing that this goes in the clockwise direction x of n and h of.
22.srt	00:28:42.769 --> 00:28:53.189	n are aligned actually then we will be moving h of 0 in this direction n minus n plus 1 and then so on.
22.srt	00:28:53.539 --> 00:28:58.119	And then next last one will be h of n minus 2 h of n minus 1.
22.srt	00:28:58.569 --> 00:29:11.359	Whereas you will be seeing that x of n goes in this direction anticlockwise x of n minus n plus 1 and then we will be coming to x of n minus 2 and x of n minus 1.
22.srt	00:29:12.009 --> 00:29:17.359	So, this is how we will represent we will see with an example how we are going to come.
22.srt	00:29:17.519 --> 00:29:18.299	compute this.
22.srt	00:29:18.819 --> 00:29:27.879	So, as an example as I have been mentioning x of n is given as 1, 2, 3, 4 and our h of n is 1, 0, 1, 1.
22.srt	00:29:28.209 --> 00:29:33.519	In this case as you can see both are of the same length we will do the circular convolution.
22.srt	00:29:33.919 --> 00:29:37.049	So, the steps have been written here.
22.srt	00:29:37.309 --> 00:29:42.629	So, how to arrive at this steps using our concentric circles we will see the thing.
22.srt	00:29:43.179 --> 00:29:50.199	So, my x of n is 1, 2, 3, 4 it is written in this way anti-clockwise.
22.srt	00:29:51.559 --> 00:29:57.359	and then h of n is 1 0 1 1 is in the anticlockwise.
22.srt	00:29:57.719 --> 00:30:01.699	Sorry this is in the clockwise the x of n is in the anticlockwise.
22.srt	00:30:22.619 --> 00:30:24.309	So, when I do the first time we have aligned the x of n and then h of n together and we multiply these two numbers and then all of them we multiply you will be seeing 1 into 1 is 1, 2 into 1 is 2, 0 into 4 is 0 and then here 1 into 2 3 is 3.
22.srt	00:30:24.629 --> 00:30:37.529	So, when you add it up this is what the step what it is given at n is equal to 0 y of 0 is given by 1 into 1, 1 into 2 plus 1 into 3 plus 0 into 4 which gives me 6.
22.srt	00:30:37.929 --> 00:30:52.269	So, then what we are going to do is I can move this as the arrow shows one step each time my h of n in this thing and I keep this one as it is.
22.srt	00:30:52.489 --> 00:30:54.259	So, when I do that next.
22.srt	00:30:54.489 --> 00:31:03.759	value is going to be 0 into 1 plus 1 into 2, 1 into 3 and 1 into 4 when added up summation it comes out as 9.
22.srt	00:31:04.339 --> 00:31:09.479	So, this is 6, 9, 8, 7 when I do the circular convolution.
22.srt	00:31:11.169 --> 00:31:18.609	So, you will be seeing that how we can implement linear convolution just if you have done the thing.
22.srt	00:31:18.989 --> 00:31:24.189	So, just I will write it here most of you would have used this method to.
22.srt	00:31:25.179 --> 00:31:27.279	compute your linear convolution.
22.srt	00:31:27.869 --> 00:31:51.619	So, when I put the thing all of us know that we put x of n I can put it here 1, 2, 3, 4 this is 1, 0, 1, 1 what I can represent then I will be multiplying with the 1 into this number this is 2, 0, 2, 2 and then 3, 0, 3, 3, 4, 4, 0, 4, 4.
22.srt	00:31:52.419 --> 00:31:54.019	So, how we are going to get the thing?
22.srt	00:31:54.679 --> 00:31:55.999	So, you will be knowing that.
22.srt	00:31:56.239 --> 00:32:03.329	This is the way we will be adding it up and then result in the linear convolution.
22.srt	00:32:03.329 --> 00:32:11.489	So, you will be seeing that this is 1, 2, 3, 7 and then 5, 7 and then 4.
22.srt	00:32:11.639 --> 00:32:14.379	This is the equivalent of linear convolution.
22.srt	00:32:14.799 --> 00:32:18.679	So, whereas circular convolution you can see that 6, 9, 8, 7.
22.srt	00:32:19.059 --> 00:32:23.249	Can I use this method to implement linear convolution?
22.srt	00:32:23.279 --> 00:32:26.069	That is what we will check in the next slide.
22.srt	00:32:28.229 --> 00:32:33.909	So, you will be seeing that what we have done is we have these are the two values.
22.srt	00:32:34.409 --> 00:32:48.619	So, that is for the linear convolution using circular convolution we have to do 0 pad of L plus M minus 1 is the length of the sequence what the result is going to be.
22.srt	00:32:49.079 --> 00:33:07.589	So, we have to pad both of them with these 0s L plus M minus 1 L is the length of X of n M is the length of H of n in this case we have both of them equal 4 plus 4 8 minus 1 7 will be the length what we have is 4 lengths.
22.srt	00:33:07.589 --> 00:33:08.879	So, we will be padding with.
22.srt	00:33:09.499 --> 00:33:14.689	3 zeros and then the other one also will be padding with 3 zeros.
22.srt	00:33:14.689 --> 00:33:31.499	So, now we have although we have the equal length to simplify if I want to compute power of 2 then what I have to do is I have to make them 8 as you will be seeing that 2 concentric circles I have divided into 8 parts.
22.srt	00:33:31.769 --> 00:33:38.369	So, we will be putting 1, 2, 3, 4 and then 4 zeros what we will be padding instead of 3 zeros.
22.srt	00:33:38.369 --> 00:33:42.929	Here also we will be doing 1, 0, 1, 1 and 4 zeros.
22.srt	00:33:43.189 --> 00:33:47.099	Same way as the previous one you can shift the thing.
22.srt	00:33:47.549 --> 00:34:02.449	The resulting values with circular convolution you will be seeing that 1 2 4 7 5 7 4 is achieved which can be evaluated verified using MATLAB or the next slide shows that how it has been implemented.
22.srt	00:34:02.749 --> 00:34:06.739	So, I showed you how it has been done in the previous example.
22.srt	00:34:07.049 --> 00:34:10.980	Same way if you do the thing you will be resulting with this value.
22.srt	00:34:11.019 --> 00:34:18.569	The last one will be 0 which you can discard and then keep these l plus m minus 1 values.
22.srt	00:34:18.819 --> 00:34:20.940	for your result.
22.srt	00:34:21.429 --> 00:34:32.339	So, you can see that we have taken little bit of DFT in to show that circular convolution property.
22.srt	00:34:32.699 --> 00:34:37.559	Other properties you can look into the book and then come out with it.
22.srt	00:34:37.909 --> 00:34:46.630	In the next class we will be seeing the complexity of filtering and how we will be deriving from DFT FFT equation.
22.srt	00:34:47.429 --> 00:34:47.819	Thank you.
36.srt	00:00:01.219 --> 00:00:26.160	Welcome back to real time digital signal processing course.
36.srt	00:00:26.530 --> 00:00:30.129	So, last class we were looking into.
36.srt	00:00:30.359 --> 00:00:33.780	So, we will see that how we are going to derive this one in today's class.
36.srt	00:00:33.880 --> 00:00:48.810	So, we have started with the adaptive filters, why do we need it and what are the applications it is going to be used one of the application we saw it as our hearing buds and then other things.
36.srt	00:00:48.840 --> 00:00:59.659	So, today we will see that how we can derive our adaptive filter that is basically least mean square LMS algorithm.
36.srt	00:01:05.440 --> 00:01:09.650	So, we discussed about the method of steepest descent in the last class.
36.srt	00:01:09.770 --> 00:01:25.680	So, that is it is a iterative or recursive process technique that starts from some arbitrary initial weight vector w 0 and it is going to descent to the bottom of the bowl what we said.
36.srt	00:01:26.290 --> 00:01:33.380	So, by moving on the error surface in the direction of negative gradient estimated at that point.
36.srt	00:01:33.450 --> 00:01:36.700	So, you will be estimating it and then going down in the thing.
36.srt	00:01:37.340 --> 00:01:39.750	So, for l is equal to 2.
36.srt	00:01:39.750 --> 00:01:49.410	So, this is the error surface what we have got it and this is the error contours in concentric circles what we will be getting it.
36.srt	00:01:50.230 --> 00:01:55.700	And then how we are going to calculate we said we will be deriving this shortly.
36.srt	00:01:56.100 --> 00:02:12.460	So, that is the weight update that is future weight update n plus 1 is going to be done with the current weight minus mu is our step size basically as you can see in the error surface how you will be coming down.
36.srt	00:02:13.170 --> 00:02:24.719	and then the gradient vector eta of n. So, that is what we call it as gradient of the mean square error function with respect to our weight function.
36.srt	00:02:25.129 --> 00:02:30.900	So, negative sign indicates that the weight vector is updated in the negative gradient direction.
36.srt	00:02:31.210 --> 00:02:38.610	So, we will take up an example and see how we will be coming with work on the steepest descent algorithm.
36.srt	00:02:39.040 --> 00:02:43.759	So, the function given we need to obtain the vector.
36.srt	00:02:44.300 --> 00:02:48.349	that would give us the absolute minimum what we are looking at.
36.srt	00:02:48.780 --> 00:02:50.969	So, y of c 1 comma c 2.
36.srt	00:02:51.349 --> 00:02:54.420	So, which is given capital C 1 square plus c 2 squared.
36.srt	00:02:54.890 --> 00:03:03.569	So, it is obvious that c 1 is equal to c 2 is equal to 0 give us the minimum basically.
36.srt	00:03:03.950 --> 00:03:08.020	So, this is the quadratic bowl c 1 is in this direction c 2.
36.srt	00:03:08.319 --> 00:03:11.650	So, we know that this is what we are expecting.
36.srt	00:03:11.650 --> 00:03:16.610	So, in the bowl how we will be traversing and coming down what we will see.
36.srt	00:03:17.280 --> 00:03:20.969	in practical applications we may not reach 0.
36.srt	00:03:21.479 --> 00:03:29.199	So, as an example so assume that c1 is equal to 5 and c2 is equal to 7 in the beginning.
36.srt	00:03:29.929 --> 00:03:40.049	And we are going to select the constant mu if it is too big we miss the minimum, if it is too small it would take us a lot of time to hit the minimum.
36.srt	00:03:40.539 --> 00:03:44.379	So, in this case we will select mu is equal to 0.1.
36.srt	00:03:47.519 --> 00:03:55.489	The gradient vector is defined by this which is dy by dc1 and then dy by dc2.
36.srt	00:03:56.139 --> 00:04:03.979	So, which is equal to 2c1 and then 2c2 what it is going to be.
36.srt	00:04:04.419 --> 00:04:16.969	So, our iterative equation is what we are going to have it is c1 and c2 of n plus 1 is given as c1 c2 n minus 0.2.
36.srt	00:04:18.319 --> 00:04:22.549	multiplied by R gradient vector.
36.srt	00:04:23.109 --> 00:04:34.249	So, which is nothing, but c 1 c 2 this thing n minus what we have is because we have 2 c 1 and 2 c 2.
36.srt	00:04:34.619 --> 00:04:36.039	So, if we take it out.
36.srt	00:04:36.449 --> 00:04:43.539	So, it is going to be c 1 c 2 n into 0.1 what we are going to get the thing.
36.srt	00:04:43.539 --> 00:04:49.179	So, when we substitute this 1 minus 0.1 will be.
36.srt	00:04:50.039 --> 00:04:50.319	are 0.9.
36.srt	00:04:50.469 --> 00:04:59.379	So, this is 0.2 divided by what you are going to have it is 2.
36.srt	00:04:59.379 --> 00:05:01.979	So, that is the reason why what you will be getting it as 0.1.
36.srt	00:05:02.009 --> 00:05:11.800	So, now, what we are going to substitute is iteration first what we have c 1 c 2 is 5 and then 7 is been given and in the second iteration.
36.srt	00:05:11.800 --> 00:05:21.480	So, c 1 c 2 according to this equation substitute c 1 c 2 and then solve the thing 0.9 c 1 c 2.
36.srt	00:05:22.709 --> 00:05:23.939	what we are going to have it.
36.srt	00:05:24.229 --> 00:05:29.259	So, the next iteration so, by multiplying c 1 c 2.
36.srt	00:05:29.259 --> 00:05:39.899	So, you will be getting it 0.9 times 5 is going to be 4.5 and this becomes 6.3 and then continue this in the iteration 3 4.5 into 0.9.
36.srt	00:05:40.209 --> 00:05:44.500	So, this is what we will be getting it and c 2 is this value.
36.srt	00:05:45.269 --> 00:05:51.609	So, at iteration 6 t as you can see that the value has come down to 0.01.
36.srt	00:05:54.129 --> 00:06:02.589	So, you will be seeing that initial guess what you have taken the things C1, C2 and then you are traversing down the thing.
36.srt	00:06:03.019 --> 00:06:05.519	So, here it is going to be 0.01, 0.013.
36.srt	00:06:05.639 --> 00:06:17.969	So, as we can see the vector C1, C2 converges to the value which would yield the function minimum and the speed of this convergent depends on our step size.
36.srt	00:06:18.099 --> 00:06:24.789	So, in this case we had taken it as point 1 is our step size mu basically.
36.srt	00:06:26.429 --> 00:06:29.469	that is what we have assumed in this case.
36.srt	00:06:29.979 --> 00:06:33.269	So, now what is the thing is going to happen?
36.srt	00:06:33.669 --> 00:06:43.389	So, how to calculate the mu or how to arrive at the least mean square algorithm what it is shown here.
36.srt	00:06:43.929 --> 00:06:54.689	So, in many practical application so, statistics of our desired signal d of n and x of n are going to be unknown that is input signal.
36.srt	00:06:55.149 --> 00:06:57.579	So, the method of the steepest descent.
36.srt	00:06:57.849 --> 00:07:06.699	cannot be used directly since it assumes the mean square error is available to compute the gradient vector.
36.srt	00:07:07.379 --> 00:07:12.379	So, then what happens you will be seeing the LMS algorithm developed by Widerow.
36.srt	00:07:12.859 --> 00:07:27.169	So, you can go to the net and then see he is the one who designed our least mean square algorithm uses the instantaneous squared error e squared of n to estimate the mean square error.
36.srt	00:07:29.709 --> 00:07:41.239	So, which is given by eta of n is you will be putting it as E squared of n. So, the gradient estimate is partial derivative of this cost function with respect to the weight vector.
36.srt	00:07:41.709 --> 00:08:00.369	Then what happens to our gradient which is going to be given by 2 times our gradient of error vector into error vector what we will be putting it E squared of n. So, then since we know that our error function is given by d of n minus y of n.
36.srt	00:08:00.699 --> 00:08:30.639	and y of n substituted with w transpose of n into x of n what is substituted then what we have is our gradient of E of n is given by when you take the gradient of it which results in minus x of n. So, the gradient estimate becomes as it is given by minus 2 into x of n into E of n.
36.srt	00:08:31.449 --> 00:08:53.759	And, the weight vector w of n plus 1 is going to be w of n plus mu x of n into e of n. So, what is the from where you got you have substituted the gradient thing with respect to this I think you can derive the thing.
36.srt	00:08:54.059 --> 00:09:00.349	So, the constant mu what will be putting it into our update vector here.
36.srt	00:09:01.729 --> 00:09:06.609	So, then how we are going to calculate our LMS algorithm.
36.srt	00:09:07.079 --> 00:09:31.699	So, the diagram on the right side it shows that it has an input and then we have the weight vector here and then y of n is our output and this is the desired signal the difference between the two will give us the error which is fed to our LMS algorithm which will modify the weights based on our input x of n.
36.srt	00:09:32.159 --> 00:09:45.129	So, this is what the figure shows and we will write down the steps which are going to be followed in the algorithm calculation or weight calculation and then the output calculation and error.
36.srt	00:09:45.659 --> 00:09:57.379	So, we are going to determine the values of L is the order of the filter, mu is the weight vector and W of 0 is the initial values for our weight vector.
36.srt	00:09:57.979 --> 00:10:02.250	So, that is what it gives the thing this is the step size and W 0 is the.
36.srt	00:10:02.719 --> 00:10:27.139	x of n. So, which is nothing, but it is l is equal to 0 to l minus 1 w l of n into x of n minus l. And we will be computing the error signal as e of n is given by in the second step d of n minus y of n. So, we have calculated y of n and weight vector initially we have assumed as 0 and then we will start with it.
36.srt	00:10:27.659 --> 00:10:32.569	And then whatever the desired signal what we have given minus the output.
36.srt	00:10:32.809 --> 00:10:33.649	will be the error.
36.srt	00:10:33.799 --> 00:10:36.579	Initially as we know that y of n may be 0.
36.srt	00:10:37.019 --> 00:10:53.539	So, it will be error will be very high because we have assumed the weight to be 0 and then x of n. So, error will be high and then you will be seeing once it starts coming down it will be adapting to weights are adjusted.
36.srt	00:10:53.929 --> 00:11:03.359	This is how we will be calculating our w l of n plus 1 is going to be given by w l of n plus.
36.srt	00:11:04.309 --> 00:11:14.419	mu into x of n minus l into E of n. So, where l is the length of the our filter which is going to vary from 0 to capital L minus 1.
36.srt	00:11:14.819 --> 00:11:32.489	So, hence you will be seeing that number of computations what it is going to have in calculating the LMS algorithm is 2 L additions and 2 L plus 1 multiplications what we are supposed to do to get the output.
36.srt	00:11:35.489 --> 00:11:39.369	So, that is what the computation complexity of the LMS algorithm.
36.srt	00:11:39.969 --> 00:11:44.489	So, coming to the thing how our graph is going to converge.
36.srt	00:11:44.939 --> 00:12:04.859	So, we will see the thing unknown channel of second order what we have chosen the thing and then this graph is going to illustrate that is what you have the initial guess here and then this is our E 1 and then C 1 and then C 2 what we have selected initially as we said.
36.srt	00:12:05.409 --> 00:12:13.819	So, then what happens so it will be traversing depending on our mu will be traversing in this way in the concentric circle.
36.srt	00:12:14.199 --> 00:12:16.999	and try to we are supposed to get to 0.
36.srt	00:12:17.369 --> 00:12:24.859	So, as we know that it is in practical situations it is not possible to achieve this.
36.srt	00:12:25.279 --> 00:12:34.399	So, we could only decrease the error below a desired minimum so that we will be able to work on it.
36.srt	00:12:35.419 --> 00:12:43.479	So, there are different modified LMS algorithms to reduce our computation time.
36.srt	00:12:44.829 --> 00:12:48.619	What are the thing there are 3 types to improve the computation?
36.srt	00:12:49.119 --> 00:12:50.799	One is the sign error.
36.srt	00:12:51.049 --> 00:12:52.149	LMS algorithm.
36.srt	00:12:52.539 --> 00:13:12.849	Here as you can see W of n plus 1 is given as W of n plus mu into x of n and you will be taking the sign of the error n. So, sign data LMS algorithm the other one sign of a of n is given as 1 or minus 1.
36.srt	00:13:13.319 --> 00:13:20.409	So, if error is greater than or equal to 0 we make it 1, if it is less than 0 it is going to be minus 1.
36.srt	00:13:22.019 --> 00:13:25.889	So, that it is either negative of it or positive.
36.srt	00:13:26.209 --> 00:13:31.919	So, that we are avoiding the multiplication by error of n in this case.
36.srt	00:13:32.629 --> 00:13:39.569	So, the sign the other one is sign LMS algorithm.
36.srt	00:13:39.949 --> 00:13:45.709	Here it is based on the sign error the other one is on the sign on the data what you are going to have it.
36.srt	00:13:51.729 --> 00:13:54.999	Then in this case what happens sign of X of n. So, that you are reducing your The other one is sine sine LMS algorithm.
36.srt	00:13:55.459 --> 00:14:06.619	So, this algorithm requires no multiplication and designed for mostly VLSI or ASIC implementation to save multiplications.
36.srt	00:14:07.029 --> 00:14:16.109	So, in adaptive differential pulse code modulation that is ADPCM uses for this algorithm for speech compression.
36.srt	00:14:16.509 --> 00:14:21.119	So, I think we will be taking the speech coding little later.
36.srt	00:14:21.119 --> 00:14:23.859	So, we will see why we need the compression.
36.srt	00:14:27.179 --> 00:14:27.809	there ok.
36.srt	00:14:27.809 --> 00:14:37.929	So, how it is going to work for a complex signals that is LMS algorithm we have seen the DFT and other things for the complex signals.
36.srt	00:14:38.250 --> 00:14:43.379	Here also we have to see that how it is going to work from least mean square.
36.srt	00:14:43.990 --> 00:14:58.709	Applications dealing with complex signals the frequency domain adaptive filtering require complex operations to maintain their phase relationships in this case and then the complex adaptive filter uses.
36.srt	00:14:59.240 --> 00:15:20.559	that is complex vector x of n and complex coefficients w of n. So, then x of n is real part of x of n plus j times imaginary part of n and w n of is also represented both in real and then imaginary parts in this way.
36.srt	00:15:21.189 --> 00:15:30.579	Then we know that complex output signal y of n is computed as y of n is w transpose of n into x of n what we have it.
36.srt	00:15:31.059 --> 00:15:36.100	So, where all multiplications additions are going to be complex operations.
36.srt	00:15:36.580 --> 00:16:02.980	So, the complex LMS algorithm adapts the real and then imaginary parts of W of n simultaneously as in this fashion W of n plus mu E of n into x conjugate of n. So, adaptive channel equalizers use x conjugate of n as x real of n minus j x imaginary of n.
36.srt	00:16:05.720 --> 00:16:10.230	So, we will see these applications little later.
36.srt	00:16:11.309 --> 00:16:16.649	So, we have to see the performance analysis of our LMS algorithm.
36.srt	00:16:17.360 --> 00:16:23.529	The as we know that IR filter we consider the stability constraints.
36.srt	00:16:23.990 --> 00:16:35.730	So, we have to see first one is the stability, next is how we are going to have the convergence rate and then we will be seeing that X is mean square error.
36.srt	00:16:36.269 --> 00:16:41.860	and how it is going to have the finite word length effects on our algorithm.
36.srt	00:16:42.730 --> 00:16:48.259	Just like any other our linear filter we have to see in the adaptive filter also.
36.srt	00:16:48.610 --> 00:16:51.569	So, how these parameters are going to affect us.
36.srt	00:16:52.039 --> 00:16:55.279	So, the first one is the stability constraint.
36.srt	00:16:55.720 --> 00:17:08.769	So, that is 0 less than our mu which is less than we have taken it as 2 by lambda max is the one lambda max is the largest eigen value of the autocorrelation matrix R.
36.srt	00:17:09.380 --> 00:17:22.100	So, as we have will be seeing in the lab that we selected wave mu is equal to 1 how our output was getting affected.
36.srt	00:17:22.170 --> 00:17:30.680	So, this is the wave otherwise arbitrarily we can choose the thing and then what is the thing is going to happen.
36.srt	00:17:30.680 --> 00:17:32.680	So, we have looked in the lab.
36.srt	00:17:32.980 --> 00:17:40.230	So, here what is should be the mu value which should be less than 2 times lambda max, lambda max is our autocorrelation matrix.
36.srt	00:17:40.620 --> 00:18:07.680	Now, eigen value of our autocorrelation matrix R. So, we know that computing our autocorrelation matrix and finding out the eigen value is compute intensive and then how we are going to take the thing that is lambda L are the eigen values of our matrix R in that the maximum value what will be taking it and then divide 2 by that value.
36.srt	00:18:10.600 --> 00:18:15.670	So, The other way of doing selecting our mu is from the stability point of view.
36.srt	00:18:40.660 --> 00:18:51.059	So, we can have a mu 2 divided by L into p x, L is the length of the filter and then p x is we know that it is the autocorrelation function of the first this thing input signal which is nothing, but expected value of x squared of n is the power of are x of n. So, this equation provides two important principles for determining the value of mu from these two constraints what is it?
36.srt	00:18:51.569 --> 00:18:57.720	The upper bound of the step size mu is inversely proportional to the filter length here.
36.srt	00:18:58.690 --> 00:19:05.160	Thus a smaller mu must be used for a higher order filter and vice versa.
36.srt	00:19:06.230 --> 00:19:11.049	Since, step size is inversely proportional to the input signal power.
36.srt	00:19:11.689 --> 00:19:16.959	A larger mu can be used for low power signal and vice versa.
36.srt	00:19:18.179 --> 00:19:33.929	The other way is more effective technique is to normalize the step size mu with respect to power p such that the convergence rate of the algorithm is independent of mu that is what one has to look at it.
36.srt	00:19:34.459 --> 00:19:38.269	So, now coming with the convergence speed continuing with the thing.
36.srt	00:19:38.730 --> 00:19:43.779	So, each adaptive mode has its own time constant for convergence.
36.srt	00:19:44.249 --> 00:19:53.749	So, which is going to be determined by the step size mu as we know and the eigenvalue associated with lambda L with that mode.
36.srt	00:19:53.749 --> 00:20:13.979	Thus the time needed for convergence is clearly limited by the slowest mode caused by the minimum eigenvalue and can be approximated as time to calculate minimum mean square error is approximated as.
36.srt	00:20:14.379 --> 00:20:17.169	1 by mu into lambda minimum.
36.srt	00:20:17.970 --> 00:20:26.409	So, lambda minimum is the minimum eigenvalue of the matrix R what we are considering this is the maximum time what it is going to take place.
36.srt	00:20:26.440 --> 00:20:32.069	If we choose a lambda max then we know that time to compute this is going to be lesser.
36.srt	00:20:46.319 --> 00:20:58.539	So, we say because our time tau mean square error is inversely proportional to the step size mu using a smaller mu will result in a larger time basically that is slower convergence and when our tau max is very large only a small mu can satisfy the stability constraint.
36.srt	00:20:58.920 --> 00:21:03.500	So, these are the things one has to consider when you are selecting your mu.
36.srt	00:21:04.420 --> 00:21:14.569	So, if lambda minimum is very small the time constant can be very large resulting in very slow convergence here also.
36.srt	00:21:17.990 --> 00:21:21.860	The slowest convergence occurs when using the smallest step size mu is equal to 1 by lambda max.
36.srt	00:21:22.340 --> 00:21:29.890	So, you will be seeing that both of them are inversely proportional to our mu step size and then lambda minimum.
36.srt	00:21:30.330 --> 00:21:37.180	So, both will be contributing to the slow computation time for our adaptive filter.
36.srt	00:21:37.670 --> 00:21:38.390	So, then what is it?
36.srt	00:21:38.440 --> 00:21:47.509	We say that our mean square error time is given by less than or equal to lambda max by lambda min.
36.srt	00:21:49.680 --> 00:22:10.869	And, which is by substituting lambda min we can do that which is less than or equal to lambda max divided by minimum is approximated as maximum x of omega that is magnitude of x of omega whole square divided by minimum of x of omega whole square.
36.srt	00:22:11.339 --> 00:22:12.940	So, how is this?
36.srt	00:22:13.569 --> 00:22:23.180	We know that x of omega is the dT of T of x of n. So, we will be seeing that eigenvalue spread can be efficiently approximated by the.
36.srt	00:22:23.599 --> 00:22:26.879	spectral dynamic range in this case.
36.srt	00:22:27.180 --> 00:22:31.059	So, we can see how the computation is going to be more.
36.srt	00:22:31.879 --> 00:22:37.680	So, now, other way of is how we can control our mean square error by using Xs mean square error.
36.srt	00:22:38.250 --> 00:22:45.909	So, which is eta Xs is given as L into Px into eta minimum.
36.srt	00:22:45.980 --> 00:22:47.460	So, we know that.
36.srt	00:22:48.069 --> 00:22:56.549	So, the approximations shows that the Xs mean square is directly proportional to our mu.
36.srt	00:22:57.349 --> 00:23:08.700	And, then use of larger step size mu is going to result in a faster convergence rate at the cost of degraded steady state performance by producing more noise.
36.srt	00:23:09.150 --> 00:23:20.769	This is what we saw in the lab or you will you can yourself see that by making mu larger step size only it will be giving you noise.
36.srt	00:23:21.130 --> 00:23:29.509	So, therefore, there is a design trade of between the excess mean square error and the convergence speed when choosing the value of mu.
36.srt	00:23:30.539 --> 00:23:38.740	So, now how we can normalize this mu basically or step function.
36.srt	00:23:39.159 --> 00:23:45.859	So, then later on what it was developed is normalized LMS algorithm.
36.srt	00:23:45.859 --> 00:23:55.899	So, which is given by this equation that is 0 is less than mu which is less than n by your p x.
36.srt	00:24:00.609 --> 00:24:04.349	So, as it L is the length of our filter and p x is the power what we have to calculate.
36.srt	00:24:04.349 --> 00:24:09.900	So, you will be seeing that it will take more time than LMS algorithm.
36.srt	00:24:10.269 --> 00:24:34.480	Then your update function for W of n plus 1 is given selecting this mu with our x of n and then a of n. So, you will be seeing that where mu of n is the time varying step size one has to calculate it is not pre computed as and when you are depending on your input power you will be calculating your step size.
36.srt	00:24:35.019 --> 00:25:05.440	And then it can be normalized by the filter length and signal power as mu of n is given as alpha constant divided by L into px of n plus some constant c where our px of n is the estimate of the power of x of n at time n. So, and alpha will be taking the value between 0 and 2 which is a constant and c is very small constant.
36.srt	00:25:05.819 --> 00:25:14.430	So, that we are not going to have when this becomes 0 division by 0 is avoided by this constant.
36.srt	00:25:14.430 --> 00:25:30.220	So, very small so that this is not going to get affected or using a very large substrate for a very weak signal at time n one has to note that Px of n can be estimated recursively.
36.srt	00:25:30.920 --> 00:25:36.700	So, an LMS algorithm will take little time compared to our LMS.
36.srt	00:25:37.129 --> 00:25:45.539	So, how we are going to choose this Px of 0 as the best a priori estimate of our input signal power.
36.srt	00:25:46.169 --> 00:25:59.669	So, a software constant may be required to ensure that mu of n is bounded if it is very small when the signal is going to be absent so that divide by 0 is avoided.
36.srt	00:26:00.149 --> 00:26:01.950	So, how we are going to do this one?
36.srt	00:26:02.180 --> 00:26:13.859	Software implementation is shown in with few steps that is we will be assigning our mu E of n is assigned as mu into E of n.
36.srt	00:26:14.999 --> 00:26:20.539	For l is equal to 0, l less than or length of the filter.
36.srt	00:26:21.099 --> 00:26:50.549	So, you will be continuing it this is the W of l is calculated with respect to mu into whatever you have calculate mu e n into x of l. So, that you will be you need not have to do this multiplication inside every time which is a consume you know that within the loop if you do the multiplication it will be adding on.
36.srt	00:26:51.209 --> 00:26:58.829	Instead of that you compute and keep it outside and then use it for you will be reducing the multiplication.
36.srt	00:26:58.869 --> 00:27:05.409	So, you can see that the updation can be done once in sampling period what we will be doing it.
36.srt	00:27:05.779 --> 00:27:12.769	Instead of every sample to reduce the computation and to take care of the pipelining delays.
36.srt	00:27:13.509 --> 00:27:21.689	So, the delayed LMS algorithm which is expressed as W n plus 1 is nothing, but.
36.srt	00:27:22.129 --> 00:27:34.149	W of n plus mu into E of n minus delta this is the delay what you are going to give it and even the input signal is going to be delayed by delta x of n minus delta.
36.srt	00:27:34.569 --> 00:27:52.269	So, if you assume delta is equal to 1 then E of n minus 1 that is previous sample what you will be taking it sorry previous error what you will consider and then even x of n minus 1 will be the previous sample what you will be calculating to.
36.srt	00:27:52.709 --> 00:27:58.629	update our weights in the future of it along with the current weight.
36.srt	00:27:58.739 --> 00:28:06.229	So next one is the finite precision effects one has to consider.
36.srt	00:28:06.229 --> 00:28:14.629	So, what is this we have seen this effect in case of IR filter the same thing we will be using it.
36.srt	00:28:14.979 --> 00:28:20.959	So, we have assumed the range input is going to be in the range between minus 1 and 1.
36.srt	00:28:21.459 --> 00:28:23.409	So, we will be scaling our signal.
36.srt	00:28:23.739 --> 00:28:30.559	So, that the input if it is a sine wave the magnitude is going to be between minus 1 and 1.
36.srt	00:28:31.039 --> 00:28:43.989	So, any either even the cause function if you have considered or any speech signal or any audio signal you will be considering the magnitude to be between minus 1 and 1.
36.srt	00:28:44.659 --> 00:28:52.759	So, later on we have to do scaling finite word effects and arithmetic errors can be considered.
36.srt	00:28:54.269 --> 00:28:57.839	So, However, we have done in the case of IR filter.
36.srt	00:28:58.189 --> 00:29:16.219	So, we will be taking care of the scaling and then finite word effects representing our coefficients even mu has to be approximated after the thing and then whatever additional what we are doing it the errors have to be considered.
36.srt	00:29:16.559 --> 00:29:24.829	So, we know that A of n that is feedback for coefficients scaling is going to be complicated.
36.srt	00:29:25.299 --> 00:29:30.509	So, what is it earlier in the FIR filter we did not have the feedback.
36.srt	00:29:31.009 --> 00:29:39.899	So, you will be seeing in the figure we have a from the error we are having a feedback path in the thing.
36.srt	00:29:40.579 --> 00:29:44.829	So, this also has to be considered then what happens?
36.srt	00:29:45.319 --> 00:29:54.569	Also the dynamic range of the filter output is determined by the time varying filter coefficients which are unknown at the design stage.
36.srt	00:29:55.129 --> 00:30:00.149	In the FIR filter we have computed our coefficients and then we knew that.
36.srt	00:30:00.529 --> 00:30:04.819	what will be the maximum precision what we are going to get it.
36.srt	00:30:04.819 --> 00:30:14.179	Here what is the thing is going to happen is because we are on the go our weight function is getting updated.
36.srt	00:30:14.789 --> 00:30:28.459	So, we say that it is a time varying filter coefficients what we have to calculate and we do not the design stage whether they are going to overflow or underflow or one has to consider that.
36.srt	00:30:29.069 --> 00:30:33.059	So, we say for adaptive air filter with LMS algorithm.
36.srt	00:30:33.639 --> 00:30:53.429	The scaling of the filter output and coefficients can be achieved by scaling the desired signal that is d of n. So, the scaling factor a which is in between 0 and 1 is used to prevent overflow of the filter coefficients during the coefficient update.
36.srt	00:30:54.219 --> 00:31:00.759	So, reducing the magnitude of d of n reduces the gain demand on the filter.
36.srt	00:31:01.349 --> 00:31:05.469	And by reducing the magnitude of the coefficient values.
36.srt	00:31:06.059 --> 00:31:09.549	Since, a only scales the desired signal.
36.srt	00:31:10.179 --> 00:31:18.859	So, it is not going to affect the convergence rate which depends on the magnitude spectrum and power of input signal.
36.srt	00:31:19.609 --> 00:31:28.679	So, that is x of n. So, d of n is not going to come into our spectral calculation or power calculation.
36.srt	00:31:29.069 --> 00:31:35.519	So, it is not going to degrade our performance when we do the scaling of desired signal.
36.srt	00:31:35.549 --> 00:31:37.549	So, y of n minus d of n.
36.srt	00:31:38.149 --> 00:31:44.149	So, which is going to be kept in not to overflow fine.
36.srt	00:31:44.239 --> 00:31:58.229	So, what will be the thing now continuing with the finite precision LMS algorithm can be how it is going to be described that is using the rounding operations.
36.srt	00:31:58.829 --> 00:32:04.329	So, we know that y of n is equal to that is value is going to be rounded.
36.srt	00:32:04.789 --> 00:32:11.389	So, here it is not the autocorrelation matrix what we are representing it is the rounding.
36.srt	00:32:11.980 --> 00:32:19.539	So, the magnitude of whatever the equation we have FIR filter equation which is going to be rounded.
36.srt	00:32:19.929 --> 00:32:35.789	Then E of n is going to be resulted as rounded of r a times d of n that is scaling of our desired signal minus y of n the magnitude of it will be rounding it.
36.srt	00:32:36.289 --> 00:32:39.849	Then what happens to our weight function updation function.
36.srt	00:32:40.329 --> 00:32:42.269	So, that is also going to be rounded.
36.srt	00:32:42.889 --> 00:32:54.879	And, then you will be having W of n this equation x of n minus l into e of n, l we will be varying between 0 to l minus 1.
36.srt	00:32:56.279 --> 00:33:03.319	So, that is what it says is R of x in this case fixed point rounding of the quantity x.
36.srt	00:33:04.199 --> 00:33:13.539	So, when updating coefficients the product whatever product we have it is a double precision number because.
36.srt	00:33:13.599 --> 00:33:26.500	E of n is floating point number even mu is also going to be floating point and x of n is also going to be either fixed point or floating point.
36.srt	00:33:26.669 --> 00:33:39.829	Still the result of two floating point numbers has to be double precision if we has used 32 bit for both of them then it becomes 64 bit which is double precision number.
36.srt	00:33:47.869 --> 00:33:55.359	So, which is added to the original stored weight value W1 of W L of n and then rounded to obtain the updated value W of L of n plus 1.
36.srt	00:33:56.209 --> 00:34:01.259	So, adaptation will stop when this update term is rounded to 0.
36.srt	00:34:01.919 --> 00:34:13.179	If its value is smaller than the LSB of the hardware what we consider this phenomenon is known as stalling or lock up.
36.srt	00:34:13.759 --> 00:34:18.569	So, this problem may be solved by using more bits.
36.srt	00:34:19.239 --> 00:34:25.819	And, are using larger step size mu to guarantee that convergence of the algorithm ok.
36.srt	00:34:26.190 --> 00:34:32.889	However, we know that using a larger step size will increase our X's mean square error.
36.srt	00:34:33.929 --> 00:34:39.730	So, the other variant of our LMS algorithm is the leaky LMS algorithm.
36.srt	00:34:40.400 --> 00:34:48.110	So, this is defined that is to reduce numerical errors accumulated in the filter coefficients.
36.srt	00:34:48.839 --> 00:34:51.059	So, this algorithm prevents.
36.srt	00:34:51.289 --> 00:35:05.939	coefficient update overflow from the finite precision implementation by providing a compromise between minimizing the mean square error and constraining the energy of the adaptive filter.
36.srt	00:35:06.579 --> 00:35:22.649	So, which is given by expression is given as V times W of n plus mu into X of n into E of n. So, where V is leakage factor one is going to consider it is going to be between 0 and 1.
36.srt	00:35:22.969 --> 00:35:26.749	So, if it is one we know that it is going to be LMS algorithm.
36.srt	00:35:27.349 --> 00:35:46.699	So, the Leakey LMS algorithm not only prevents unconstrained weight overflow, but also limits the power of output signal y of n in order to avoid non-linear distortion of the transducers basically such as loudspeakers driven by the filter output.
36.srt	00:35:56.619 --> 00:35:57.969	So, we know that when we are having a speech or audio work thing the output is going to loudspeakers.
36.srt	00:35:58.289 --> 00:36:04.209	So, this distortion is going to be reduced by using our Leakey LMS algorithm.
36.srt	00:36:04.249 --> 00:36:15.799	The excess power of errors caused by the leakage is proportional to what we call it as 1 minus v whole divided by mu into the power square.
36.srt	00:36:16.419 --> 00:36:24.719	So, 1 minus v should be kept smaller than mu in order to maintain an acceptable level of performance.
36.srt	00:36:26.539 --> 00:36:28.289	This is adaptive.
36.srt	00:36:28.619 --> 00:36:29.519	FIF filter objects.
36.srt	00:36:29.729 --> 00:36:38.069	If you refer to the book here the book is cove with the reference is going to be given.
36.srt	00:36:38.519 --> 00:36:50.899	So, you will be seeing that adaptive field dot LMS, these are the functions one can use for adaptive filter that is direct form leak LMS algorithm.
36.srt	00:36:50.899 --> 00:36:53.369	So, different methods have been given.
36.srt	00:36:53.369 --> 00:37:01.669	One has to keep it in mind that this adaptive field dot LMS has been removed in the latest version of.
36.srt	00:37:02.279 --> 00:37:04.859	MATLAB that is 2020 B.
36.srt	00:37:04.859 --> 00:37:09.239	So, you have to use it as DSP dot LMS filter.
36.srt	00:37:09.239 --> 00:37:20.599	So, and then properly modify the codes and then you have to use it in your assignments or your work when you want to implement these filters.
36.srt	00:37:21.109 --> 00:37:33.969	So, the code what it is given that is you will be having the random seed what it is generated and then you have been given the coefficients of.
36.srt	00:37:34.519 --> 00:37:46.760	So, you will be filtering the signal and then you are assigning your mu value as 0.05 and then call this function which has to be modified.
36.srt	00:37:46.760 --> 00:37:55.260	So, we will see how we are going to modify these to the 2020 B MATLAB and then use this filter to filter the things.
36.srt	00:37:55.260 --> 00:37:56.980	So, these are the steps.
36.srt	00:37:57.010 --> 00:38:02.519	So, when you observe that this is the desired signal D of n what it is plotted.
36.srt	00:38:06.030 --> 00:38:17.119	And, then you will be seeing that error signal which was very high which is shown in red which is going to slow down and then you will be what is it almost minimized here.
36.srt	00:38:17.119 --> 00:38:24.670	So, this is what your output signal y of n is going to look like and error signal.
36.srt	00:38:24.710 --> 00:38:32.159	So, initially you will be seeing that our output signal has little bit of noise and other things.
36.srt	00:38:32.159 --> 00:38:35.519	So, when error is minimized so, it will be following the.
36.srt	00:38:40.529 --> 00:38:42.269	or input signal.
36.srt	00:38:43.139 --> 00:38:48.650	So, in the next class we will be seeing our adaptive filter applications.
36.srt	00:38:49.139 --> 00:38:53.619	So, thank you for listening to this lecture.
37.srt	00:00:01.219 --> 00:00:25.899	Welcome back to real time digital signal processing lab.
37.srt	00:00:26.239 --> 00:00:32.140	So, today we will see that how we are going to find the contour basically.
37.srt	00:00:32.440 --> 00:00:38.859	error surface and error contours and then see that how adaptive filter is going to work.
37.srt	00:00:39.250 --> 00:00:51.090	The examples what we have taken is from the book as you will be seeing that it is from real time digital signal processing fundamentals implementation and application.
37.srt	00:00:51.469 --> 00:00:58.530	This is the third edition book that is from Saint-Cobb-Bowbley and then this thing publisher is John Willey and Sons.
37.srt	00:00:58.530 --> 00:01:03.770	So, here you will be seeing that compute and plot the.
37.srt	00:01:04.659 --> 00:01:08.480	3 dimensional error surface for L is equal to 2.
37.srt	00:01:08.829 --> 00:01:10.890	So, how it is going to do the thing?
37.srt	00:01:11.359 --> 00:01:36.439	You will be seeing that w 0 and w 1 L is equal to 2 coefficients what it is being chosen and then you will be considering the mesh grid given by this define w 0 and w 1 arrays or 3D plots what you are giving it and error is given with the equation 0.34 minus.
37.srt	00:01:37.600 --> 00:01:48.010	0.6 into w 0 minus w 1 plus w 0 into this thing w 0 plus w 1 into w 1.
37.srt	00:01:48.010 --> 00:01:56.090	So, we know that this is the error signal what we wanted to plot what we have considered in the class also.
37.srt	00:01:56.200 --> 00:02:10.540	So, you will be doing that mesh w 0 and w 1 with error that is what it says plot the mesh using where color is proportional to mesh height add major grid.
37.srt	00:02:13.060 --> 00:02:14.629	lines what it says.
37.srt	00:02:14.909 --> 00:02:34.159	So, you will be adding on the grid and title is error surface what he has given and then label x label x axis is represented with w 0 and y label is w 1 and then the z label we have is MSE that is mean square error what it is going to put.
37.srt	00:02:34.509 --> 00:02:41.819	So, we will run this code and then see that how it is going to look like.
37.srt	00:02:43.629 --> 00:03:07.169	So, So, you can see that this is x axis is w 0, y axis is w 1 and then mean square error what you have given it on the z axis.
37.srt	00:03:14.939 --> 00:03:16.679	So, you will be seeing that whatever we saw in the theory, so you will be seeing the x points y and then z.
37.srt	00:03:17.039 --> 00:03:22.529	So, this is the mesh on the grid what you have plotted.
37.srt	00:03:23.129 --> 00:03:32.789	So, as we have increased the resolution.
37.srt	00:03:33.189 --> 00:03:35.249	So, we have to delete from here.
37.srt	00:03:35.859 --> 00:03:38.429	Next one is how the contours looks like.
37.srt	00:03:39.099 --> 00:03:48.119	Error contours of mean square error whatever given in the example we have taken the same example same from the same book.
37.srt	00:03:48.549 --> 00:04:12.889	So, you will be seeing that it is instead of as you have seen the thing here it is mesh grid with this and then this you will be finding out the contour of this error that is weights basically w0 and w1 with error and then we said for the 15 is the iteration what we will be fixing it.
37.srt	00:04:13.259 --> 00:04:16.219	So, this also we will run it and then see.
37.srt	00:04:17.319 --> 00:04:19.989	So, you will be seeing the you will be seeing 15.
37.srt	00:04:21.069 --> 00:04:23.129	what is it concentric circle.
37.srt	00:04:23.909 --> 00:04:38.169	This is how you will be implementing to see that your weight vectors what it is given if it is more then you can get your contour and then surface basically using this function.
37.srt	00:04:38.829 --> 00:04:48.199	So, now the book we have seen in the last lab that is students how they write their codes and other things.
37.srt	00:04:48.199 --> 00:04:52.399	So, we will see that how the book is going to give adaptive filter.
37.srt	00:04:53.279 --> 00:04:58.719	Because, I have this is from the Welch book what I have taken the thing.
37.srt	00:04:58.829 --> 00:05:17.809	So, you will be seeing that different books have been referred for different applications or for any of the solutions you can refer to different books and then you can get the code and then, but you have to understand how they have been implemented and what is the thing happening.
37.srt	00:05:17.809 --> 00:05:21.449	So, here you will be seeing that.
37.srt	00:05:24.009 --> 00:05:37.659	you are taking the order of the filter is 20 that is number of adaptive filter coefficients what you are assuming it and mu step size is selected as 0.01 that is the convergence of factor.
37.srt	00:05:37.659 --> 00:05:51.309	So, and then f naught is 1000 here it is going to generate a chirp start frequency and f 1 is 5000 chirp stop frequency.
37.srt	00:05:56.849 --> 00:06:00.259	So, chirp is basically like you can birds chirp what we call it.
37.srt	00:06:00.259 --> 00:06:15.749	So, they will be having different tones what they will be creating it same way between 1000 and 5000 hertz you can create in steps of it using this function.
37.srt	00:06:16.399 --> 00:06:22.619	And then our step whatever stop is 20 that is time for the chirp to be at f1 what it says.
37.srt	00:06:29.349 --> 00:06:34.089	So, that is you will be having steps of 20 with varying thing from 1000 to 5000.
37.srt	00:06:34.669 --> 00:06:43.870	So, what you are going to give is your voice with the sampling frequency what you will be taking it from this voice recording dot wave.
37.srt	00:06:43.899 --> 00:06:49.349	So, you can record your own voice and then store it as a dot wave and then you can use it.
37.srt	00:06:49.349 --> 00:06:58.789	Then we will be using the audio read function in the latest MATLAB.
37.srt	00:06:59.060 --> 00:07:05.069	versions and then you will be convert the column to a row vector in this case.
37.srt	00:07:05.750 --> 00:07:08.370	The output is going to be in column format.
37.srt	00:07:08.370 --> 00:07:10.009	So, you are doing the transpose.
37.srt	00:07:10.009 --> 00:07:13.939	So, you will be getting it as in the row format.
37.srt	00:07:14.370 --> 00:07:15.439	Then what happens?
37.srt	00:07:15.849 --> 00:07:19.370	M is the length of the voice what you are taking it.
37.srt	00:07:19.759 --> 00:07:33.289	So, how what was the duration of voice you will take that length that is number of samples to be simulated and t is the time which is going to go that is create a time vector for the chirp command.
37.srt	00:07:33.849 --> 00:07:46.349	So, you will be creating 1 to m divided by f s. So, noise is what you are going to have it as a chirp which is t f naught t stop comma f 1.
37.srt	00:07:46.810 --> 00:07:51.049	So, you will have 20 points that is creating a chirp signal here.
37.srt	00:07:51.269 --> 00:07:55.859	The function in MATLAB what it is called ok in as chirp.
37.srt	00:07:55.859 --> 00:08:04.349	And then what you will be doing you are create the noise storage array.
37.srt	00:08:04.979 --> 00:08:18.370	x is going from 2 to n, noise of whatever n minus 1, previous 1 minus 1 you will be down sampling and then 1 this is the step size what you will be taking it.
37.srt	00:08:18.769 --> 00:08:28.289	Then initially your weight vector is going to be 0s, 1 to n the length of the filter that is what it says initialize the adaptive filter coefficients.
37.srt	00:08:28.849 --> 00:08:36.519	Then you will be doing the storage of your voice plus noise, create the signal.
37.srt	00:08:36.879 --> 00:08:54.279	plus noise in this case and then you will be what is it you are going to normalize the storage how we are going to do it that is divided by maximum of absolute of D storage what you are taking it.
37.srt	00:08:54.720 --> 00:09:06.420	So, that is the positive highest value dividing by that what you are going to do it then your Y storage will have 1 to M 0s.
37.srt	00:09:06.810 --> 00:09:15.550	that is storage array for filtered noise and e storage is going to be your errors you can make I think you would have got the hint of it.
37.srt	00:09:15.980 --> 00:09:23.420	So, which are going to be 0s 1 to m that is storage array for the cleaned up signal what you are going to have it.
37.srt	00:09:23.890 --> 00:09:26.200	So, what is the algorithm for filtering?
37.srt	00:09:26.930 --> 00:09:37.540	So, you will be doing J is defined n to m what you are going to do in this case that is interrupt service routine simulation starts here.
37.srt	00:09:37.899 --> 00:09:59.170	input the 2 channels of data that is x of l noise j what you are going to have it, interference of noise signal and d will be the desired signal from d storage of j that is voice signal plus interference what you will be taking it as the desired signal.
37.srt	00:09:59.830 --> 00:10:04.620	Now, you are going to have adaptively filter the interference signal.
37.srt	00:10:05.279 --> 00:10:10.910	So, you will be making it y is equal to 0, the length of the filter what you will go n minus 1.
37.srt	00:10:11.460 --> 00:10:22.210	y will be y plus you can see the weight i plus 1 what will be considering it multiplied by x of n minus i.
37.srt	00:10:23.050 --> 00:10:29.000	So, then end the thing and your error function is e is given by d minus y.
37.srt	00:10:29.690 --> 00:10:32.509	So, then update the filter coefficients.
37.srt	00:10:32.879 --> 00:10:41.540	So, you will be seeing that w of i is updated as w of i instead of calling.
37.srt	00:10:43.259 --> 00:10:47.389	So, we can update in the present state itself.
37.srt	00:10:47.800 --> 00:11:02.200	So, that our storage is going to be reduced W of i star 2 into mu star are error x of n minus i plus 1 what will be taking it.
37.srt	00:11:02.629 --> 00:11:09.620	So, this is the loop it will go and next is prepare the x array for the next input sample.
37.srt	00:11:10.240 --> 00:11:15.720	So, we will be taking the next sample from this and then we will be working on it.
37.srt	00:11:16.230 --> 00:11:25.780	And, then the interrupt service rotation simulation is going to end here and you will be doing a storage after the post simulation.
37.srt	00:11:26.220 --> 00:11:42.430	So, you will be putting y storage of j will be y whatever the output after finishing your up to filter length and e storage of j is going to give you error e. Then you will be listening to the results basically.
37.srt	00:11:42.770 --> 00:11:46.740	So, with the original voice what you will see it voice comma fs.
37.srt	00:11:48.620 --> 00:12:01.159	signal with interference you will be pausing for 24 seconds and then a de-storage which is added with noise you will be seeing with the same sampling frequency.
37.srt	00:12:01.250 --> 00:12:14.700	Then you will be hearing the adaptive filters output that is where it has stored e-storage will give you the filtered adaptive filter output there.
37.srt	00:12:15.000 --> 00:12:19.000	So, these are the plots what you will be seeing it normalized one.
37.srt	00:12:20.900 --> 00:12:27.540	how the original voice and then the record by signal they are overlapped and then you will be seeing the output.
37.srt	00:12:27.830 --> 00:12:34.300	So, we will run the code because we have understood how it is adaptive filter is going to work.
37.srt	00:12:34.750 --> 00:12:36.180	So, we will run it.
37.srt	00:12:38.550 --> 00:12:42.200	Testing 1, 2, 3, 4, 5.
37.srt	00:12:42.880 --> 00:12:44.090	Why do you need this book?
37.srt	00:12:44.500 --> 00:12:54.550	If you want to learn about real time digital signal processing, DSP, this book can save you many hours of frustration and help you avoid countless dead ends.
37.srt	00:12:55.330 --> 00:12:56.540	Why do you need this book?
37.srt	00:12:56.950 --> 00:13:12.050	If you want to learn about real time digital signal processing DSP, this book can save you many hours of frustration and help you avoid countless dead ends 1, 2, 3, 4, 5 and stop.
37.srt	00:13:13.300 --> 00:13:22.570	So, you have word first was the original voice, second one was with the added chirp signal.
37.srt	00:13:22.570 --> 00:13:27.350	So, you saw that how the chirp signal is generated.
37.srt	00:13:27.940 --> 00:13:51.280	it had a varying frequencies and then later on after adaptive filter you have seen that how the noise is eliminated almost what you can put it because we would not be able to go up to 0 what we said the error cannot be completely 0.
37.srt	00:13:51.540 --> 00:13:59.400	So, you are seeing this is the audio signal overlapped with chirp signal what you are seeing it.
37.srt	00:13:59.450 --> 00:14:00.820	So, if you want to see.
37.srt	00:14:01.820 --> 00:14:02.790	portion of it.
37.srt	00:14:03.610 --> 00:14:23.930	So, I can increase I think I may have to go back to original resolution because we try to increase so that we you can see the thing.
37.srt	00:14:24.440 --> 00:14:30.110	So, the filter thing is plot is going little up.
37.srt	00:14:32.170 --> 00:14:41.240	in any case you can see yourself by that is expanding the thing how the chirp signal is going to look like.
37.srt	00:14:41.540 --> 00:14:44.830	So, now, we will see the input and output.
37.srt	00:14:45.230 --> 00:14:52.920	So, you will be seeing blue is the input signal and then red is going to be the recovered signal.
37.srt	00:14:53.210 --> 00:14:58.940	So, some places you will be seeing that red is little normalized both of them.
37.srt	00:14:59.420 --> 00:15:02.110	So, you will be seeing that it is little low.
37.srt	00:15:02.460 --> 00:15:07.840	So, can you guess what will be delay of our output in this case?
37.srt	00:15:09.600 --> 00:15:13.450	The order of the filter is 20 ok.
37.srt	00:15:13.750 --> 00:15:21.430	So, there will be 20 samples delay in the case of adaptive filter to start our output.
37.srt	00:15:21.430 --> 00:15:28.170	So, you can see initial stages what delay we are going to get it.
37.srt	00:15:28.570 --> 00:15:33.960	So, this as you can see it is marked recovered voice signal.
37.srt	00:15:34.450 --> 00:15:35.360	from the thing.
37.srt	00:15:35.400 --> 00:15:45.300	So, you will be seeing that some of it is whatever you will see the thing the magnitude is lessened in some places.
37.srt	00:15:45.700 --> 00:15:55.980	So, this is the output what you will get it and then, but most of the cases we were able to recover from the noise signal or output.
37.srt	00:15:56.780 --> 00:16:05.520	So, in the next class we will be seeing how to implement the same thing in code composer studio.
37.srt	00:16:05.890 --> 00:16:14.510	And, few more applications what we will be taking up using adaptive filter both in MATLAB and then code composer studio.
37.srt	00:16:14.990 --> 00:16:15.360	Thank you.
23.srt	00:00:00.730 --> 00:00:26.679	Namaskara, welcome back to real time digital signal processing lab course basically.
23.srt	00:00:26.800 --> 00:00:29.190	So last class we had seen some of the.
23.srt	00:00:32.820 --> 00:00:36.320	FFT, how it is going to run in MATLAB.
23.srt	00:00:36.320 --> 00:00:47.480	So, today we will see how we can implement the same thing in our code composer studio that is on the hardware DSP processor.
23.srt	00:00:48.090 --> 00:00:56.520	So, the first thing what we have here is a C code what it is written for FFT.
23.srt	00:00:56.910 --> 00:01:02.810	So, you will be seeing that we will maximize this so that.
23.srt	00:01:03.650 --> 00:01:05.990	You can see the thing the code.
23.srt	00:01:06.560 --> 00:01:08.080	So, what is it?
23.srt	00:01:08.400 --> 00:01:16.700	So, we define the math function because extensively we will be using the sign and then cos functions in this case.
23.srt	00:01:16.700 --> 00:01:22.150	Otherwise, we have to derive it in hardware using series expansion.
23.srt	00:01:22.150 --> 00:01:28.480	So, here number of points DFT points what it is defined is 64.
23.srt	00:01:29.210 --> 00:01:33.050	We call it as FFT or DFT interchangeably.
23.srt	00:01:33.450 --> 00:01:42.530	So, you have to know about that and then in this case I said in matlab we had defined pi as it is, but here we have to specify the value of it.
23.srt	00:01:42.950 --> 00:01:53.510	So, it depends on what is the length you want to define it either 3.1415 usually we stop it and then if you want more accurate value you can take it up to this.
23.srt	00:01:53.890 --> 00:02:00.920	And then the structure what defined is float real and imaginary is defined which is a complex variable.
23.srt	00:02:03.819 --> 00:02:09.370	And, then it is going to call FFT function in this case.
23.srt	00:02:09.769 --> 00:02:20.409	So, the prototype whatever return basically and then I O buffer is going to take the input and then both output buffer.
23.srt	00:02:20.870 --> 00:02:27.659	So, it takes the input values and then output is also going to the buffer that is the reason why it is called I O buffer.
23.srt	00:02:28.509 --> 00:02:32.459	And then your intermediate buffer is also float.
23.srt	00:02:32.939 --> 00:02:37.550	We are seeing that some of them are defined as float, some of them are short values.
23.srt	00:02:38.069 --> 00:02:48.299	So, the index variable i is defined as short and then buffer count is also initially it is made 0 the samples in the I-O buffer.
23.srt	00:02:48.299 --> 00:02:55.969	And then the flag what you are going to set 1 by interrupt service routine when I-O buffer is going to be full.
23.srt	00:02:56.139 --> 00:03:10.309	So, then you have to use the complex that is w points basically you have defined points 64 in this case we have it twiddle constant stored in w.
23.srt	00:03:11.439 --> 00:03:17.689	The next one is samples that is primary working buffer in this case that is also of length this.
23.srt	00:03:18.379 --> 00:03:24.389	And the frequency what will be generating is 10 hertz in this case.
23.srt	00:03:24.889 --> 00:03:41.679	So, we will be computing twiddle factors using cos and then sine function that is what one is the real part of it what we have twiddle constants and imaginary this thing twiddle constants are computed with this.
23.srt	00:03:41.679 --> 00:03:43.319	Now using this.
23.srt	00:03:45.919 --> 00:03:54.379	You will be what is it generating the I-O buffer of I with sine function with 10 hertz.
23.srt	00:03:54.379 --> 00:04:03.659	So, that is frequency what it is given and then 64 is the sampling frequency what you have chosen in this case.
23.srt	00:04:03.659 --> 00:04:08.889	So, you will be initializing the samples initially to 0.
23.srt	00:04:08.889 --> 00:04:16.309	Then you will be calling the buffers basically to swap them.
23.srt	00:04:17.219 --> 00:04:20.419	with new data and that and then later data.
23.srt	00:04:20.749 --> 00:04:29.319	So, you will be going up to 64 that is 0 to 64 you will be computing your FFT.
23.srt	00:04:29.739 --> 00:04:42.419	So, first is imaginary component you are making it 0 and then you are calling the FFT function by sending samples, points in this case it is 64.
23.srt	00:04:42.899 --> 00:04:48.359	So, samples are also going to be 64 in this case.
23.srt	00:04:48.609 --> 00:04:51.209	call function fft.c in this case.
23.srt	00:04:51.879 --> 00:04:58.599	And then once you have called the thing, so you will be getting both real and imaginary values as written.
23.srt	00:04:58.599 --> 00:05:05.149	So, you will be doing i is equal to 0 to i less than points compute the magnitude of it.
23.srt	00:05:05.149 --> 00:05:06.859	So, how you are going to calculate the magnitude?
23.srt	00:05:06.859 --> 00:05:16.349	So, x1 of i is nothing but square root of samples i dot real with real squared basically.
23.srt	00:05:19.779 --> 00:05:24.160	plus samples of imaginary dot imaginary.
23.srt	00:05:24.160 --> 00:05:29.529	So, both the squared under square root what you will be calculating.
23.srt	00:05:30.269 --> 00:05:38.689	And then you will be incrementing your p with p plus 1 and then this will be ending our main function.
23.srt	00:05:39.170 --> 00:05:42.160	So, we will go to this thing.
23.srt	00:05:46.230 --> 00:05:48.579	So, it will be in line with it.
23.srt	00:05:48.829 --> 00:05:52.259	So, we as usual we will be calling the project.
23.srt	00:05:52.980 --> 00:05:56.030	as I said one of the student who has done the thing.
23.srt	00:05:56.400 --> 00:06:02.590	So, we will do the first compilation.
23.srt	00:06:03.620 --> 00:06:16.350	So, you will be seeing that it is intact here it is using the inbuilt FFT function which is being called with whatever samples you have it.
23.srt	00:06:16.660 --> 00:06:20.550	So, you have the sorry FFT function we did not see the thing.
23.srt	00:06:20.949 --> 00:06:23.110	So, we will see it with the thing.
23.srt	00:06:23.449 --> 00:06:43.180	Here also it is points is 64 and structure is your float and then complex basically and then you will be defining this complex you are calling it as extern because you will be passing from between function and then your main function and then FFT function.
23.srt	00:06:43.500 --> 00:06:53.870	So, you are calling this as a FFT function which is complex y is the output and int is our length of.
23.srt	00:06:54.219 --> 00:06:55.219	are FFT.
23.srt	00:06:55.829 --> 00:07:00.060	So, input sample array and number of points as you are seeing it.
23.srt	00:07:00.500 --> 00:07:17.029	So, these are the temporary storage variables and these are the loop counters and then we have to calculate upper leg and then lower leg are calculated separately that is even and then odd part of it are computed of the butterfly separately.
23.srt	00:07:17.389 --> 00:07:24.879	So, then difference between the upper and lower leg what you will be calculating and you will be defining number of stages.
23.srt	00:07:25.379 --> 00:07:40.129	So, that is to have the interaction and then you will be defining some of the step through twiddle constant and then i is equal to log base 2 of n points that is number of stages what you will be doing it.
23.srt	00:07:40.449 --> 00:07:45.719	So, you will be doing up to number of stages plus equal to 1.
23.srt	00:07:46.339 --> 00:07:57.560	So, i will be i to the power of i is 2 times i what you will be doing it and defining your while function this way.
23.srt	00:07:57.949 --> 00:08:08.969	So, you will be calculating the leg difference that is difference between upper and lower legs step between values in twiddle dot hedge what you will be doing it and then for n point A 50.
23.srt	00:08:08.969 --> 00:08:09.569	So, this is the end point.
23.srt	00:08:09.939 --> 00:08:22.639	You are calculating i is equal to 0 to number of stages what you have it and then initially index will be 0 and then the other loop is going to be j is equal to 0 to less than leg difference.
23.srt	00:08:22.969 --> 00:08:35.799	So, you will be computing it and then here it is the upper leg what you will be calculating it some of the temporary variables you will be seeing it and then y is calculated in this fashion.
23.srt	00:08:36.840 --> 00:08:43.139	And you will be indexing is going to be incremented depending on the step size.
23.srt	00:08:43.730 --> 00:08:52.020	And, then the leg difference is going to be leg difference by 2 and then step is going to be multiplied with 2.
23.srt	00:08:52.120 --> 00:09:04.970	So, again j is equal to 0 you will be doing the as we know that bit reversal has to be done for our c calculation which is done using this computation.
23.srt	00:09:05.370 --> 00:09:08.480	So, you will be seeing that hardware is not being used.
23.srt	00:09:08.480 --> 00:09:15.580	So, if you are writing in assembly as I have been telling in the thing you can use the hardware to do the bit reversal.
23.srt	00:09:15.780 --> 00:09:16.940	Here it has to be done.
23.srt	00:09:17.460 --> 00:09:21.230	manually as you can see the thing using the code.
23.srt	00:09:21.550 --> 00:09:35.680	So, this is how you will be calculating your this thing imaginary and real part are arranged for your FFT and then you will be coming back from this FFT function fine.
23.srt	00:09:36.000 --> 00:09:42.420	So, we will run this and then see what is the magnitude squared function what we have got it.
23.srt	00:09:42.740 --> 00:09:46.250	So, this is we are debugging our DFT.
23.srt	00:09:52.320 --> 00:10:04.150	So, we are seeing that build has finished, you are seeing that it is connecting it to the board basically.
23.srt	00:10:04.580 --> 00:10:18.830	So, you will be seeing that where the target has been connected and memory map whatever there is going to be cleared and it will be set up for this function and it will be.
23.srt	00:10:19.110 --> 00:10:24.580	calling the memory is DDR2 in it at 150 megahertz is going to be done.
23.srt	00:10:24.580 --> 00:10:27.750	So, this processor is running at 150 megahertz at present.
23.srt	00:10:27.750 --> 00:10:31.890	So, it goes and loads the code basically.
23.srt	00:10:31.890 --> 00:10:34.770	So, we have to see the debug.
23.srt	00:10:35.060 --> 00:10:46.190	So, you can see that the debug window has got opened.
23.srt	00:10:46.190 --> 00:10:56.810	So, it has gone and loaded in the this is the entry point basically main function where it starts the thing.
23.srt	00:10:56.850 --> 00:10:59.610	This is the entry point of the code in our board.
23.srt	00:11:00.630 --> 00:11:06.090	And then you will be seeing that here the pointer is pointing to the main basically.
23.srt	00:11:06.090 --> 00:11:07.830	So, it is ready to execute.
23.srt	00:11:07.830 --> 00:11:19.450	So, as we have seen in the last class when I took up the demo of the code composer studio either you can continuously run put a breakpoint and run.
23.srt	00:11:19.820 --> 00:11:23.660	So, here there is a breakpoint as you can see which is been set.
23.srt	00:11:24.040 --> 00:11:25.980	So, we will run the code continuously.
23.srt	00:11:25.980 --> 00:11:30.400	If you want to do this there is any error if you find then you can go with.
23.srt	00:11:30.870 --> 00:11:32.150	So, we will run the code.
23.srt	00:11:32.590 --> 00:11:43.910	So, as you have there was a little this thing memory map issue with the thing.
23.srt	00:11:43.940 --> 00:11:57.100	So, we will set the debugger again and then I can either do a debugging or I can because it is already debug has been done we can go and then.
23.srt	00:12:01.770 --> 00:12:12.110	From the run command, so here I can you will be seeing a lot of variations will be available.
23.srt	00:12:12.490 --> 00:12:14.750	So, you can go and load your program.
23.srt	00:12:15.240 --> 00:12:33.930	So, if it is already finished the debug and you have not modified anything and then if you want to run a resume from the run stage you can do that or if you want to terminate or if you want to go to main or if you want to reset the processor, whether you want to do the CPU reset or system reset.
23.srt	00:12:34.470 --> 00:12:39.320	reset the emulator basically whatever is running on the thing you can do it.
23.srt	00:12:39.640 --> 00:12:51.780	And then if you want you can restart or you can step into or step over that function if it is loop then I do not want to see every step of it I can do the step over in that.
23.srt	00:12:52.380 --> 00:12:56.010	And then if I want to do assembly step into I can do the thing.
23.srt	00:12:56.490 --> 00:12:58.900	So, these are the functions what you have it.
23.srt	00:13:04.800 --> 00:13:06.950	Now what we will do is we will have a run here either from here or here I can give the I will give the run from here ok.
23.srt	00:13:07.190 --> 00:13:14.440	So, because this is not finding the exit dot c that is why what it is little bit cribbing on the thing.
23.srt	00:13:14.840 --> 00:13:18.300	So, we will see that what is our this thing output basically.
23.srt	00:13:18.710 --> 00:13:23.650	So, what I have to see is my magnitude square function.
23.srt	00:13:23.650 --> 00:13:37.170	So, we will we can go to tools, we will go to graph, we will find it a single time and then we have said that it is 64 point FFT what we have run.
23.srt	00:13:37.550 --> 00:13:44.670	So, input data will be 64 and then this is a floating point what we are running the thing.
23.srt	00:13:45.050 --> 00:14:03.230	So, I can define it as 32 bit floating point number and then the start address in this case is x 1 is our output where we are calculating our magnitude and even the display data size I will change it to 64 and then we will say ok.
23.srt	00:14:04.570 --> 00:14:10.920	So, you will be seeing that what was our input frequency it was 10 hertz ok.
23.srt	00:14:11.250 --> 00:14:12.290	So, you will be seeing.
23.srt	00:14:12.640 --> 00:14:25.930	computing FFT from your thing which approximately gives you peak exactly if you want to look at the thing it is somewhere around 10 ok.
23.srt	00:14:26.250 --> 00:14:29.690	So, you can see that your code is running fine.
23.srt	00:14:30.080 --> 00:14:41.320	So, how to check this whether you have got your frequency correctly or not, what we can do is our samples what we have generated here.
23.srt	00:14:41.800 --> 00:14:42.880	We will be seeing that.
23.srt	00:14:43.160 --> 00:14:45.980	I O buffer is going to give a sine function.
23.srt	00:14:46.420 --> 00:14:52.740	So, we will see that whether that also has 10 hertz as a sampling frequency.
23.srt	00:14:52.740 --> 00:14:54.340	So, we will go to graph again.
23.srt	00:14:54.970 --> 00:15:01.250	So, sorry I will cancel it because single time for we will see single time and then come back.
23.srt	00:15:01.720 --> 00:15:12.870	So, I can give 64 and then this is again a floating point number 32 bit floating point number and then the start address in this is going to be R.
23.srt	00:15:13.310 --> 00:15:15.020	I O buffer ok.
23.srt	00:15:15.530 --> 00:15:25.840	So, I O buffer what I can give the thing and then even display points will be 64 because we have not gone beyond it.
23.srt	00:15:25.840 --> 00:15:26.830	So, we can give the thing.
23.srt	00:15:27.580 --> 00:15:43.950	So, you can see the sine function how it has with 64 point it is not a.
23.srt	00:15:44.410 --> 00:15:53.320	complete pure sine wave you will be seeing some of the points here has a problem, but it is approximately going with the thing.
23.srt	00:15:53.800 --> 00:15:59.010	So, now, what we will do is we will see FFT of this.
23.srt	00:15:59.440 --> 00:16:07.790	So, again I will go to tools and then I will go to my graph in this we will calculate FFT magnitude.
23.srt	00:16:08.440 --> 00:16:14.390	So, this is 64 points what I have it 64.
23.srt	00:16:14.890 --> 00:16:18.230	64 which is going to give you 60 hertz.
23.srt	00:16:18.470 --> 00:16:46.010	So, if you are unable to see this what we will do is we will again do go to tools and then graph we will do FFT magnitude and then this is 64 and then this is my this thing 32 bit floating point and here sampling frequency what I have to give is 64 and then start address is Ivo buffer.
23.srt	00:16:48.840 --> 00:16:54.210	And, then this is our thing is 64 what we wanted.
23.srt	00:16:55.050 --> 00:16:57.620	So, we will give this and we will plot.
23.srt	00:16:57.860 --> 00:17:06.400	So, you will be seeing that it is showing 10 hertz is the input frequency computed from the built in function.
23.srt	00:17:06.450 --> 00:17:11.390	So, what calculated you will be seeing that in the single time.
23.srt	00:17:11.700 --> 00:17:17.790	So, you will be seeing that by writing your own FFT code so, you are generating the.
23.srt	00:17:18.150 --> 00:17:25.280	10 hertz signal what you have computed without knowing what is the frequency component of the input signal.
23.srt	00:17:25.540 --> 00:17:32.100	Here we know the thing in normal cases we may not know what kind of signal we are going to get it.
23.srt	00:17:32.380 --> 00:17:52.030	So, once I find the frequency spectrum, so what are the frequencies present, but I should know how many what is the sampling frequency at least used most of the cases as I have mentioned in my theory class that speech if it is a narrowband speech we use 8 kilohertz as the sampling frequency.
23.srt	00:17:52.460 --> 00:18:01.269	And if it is a wideband speech it is going to be 16 kilohertz and then we know the rest of the thing audio and then video thing.
23.srt	00:18:01.590 --> 00:18:03.560	So, those are the sampling frequencies.
23.srt	00:18:03.560 --> 00:18:23.009	So, from that what you should be able to find out that whether what signal you want to keep it and then eliminate by doing filtering one of the application using from the frequency domain you will know what are the frequencies present which you want to keep it and which you want to eliminate also you can see.
23.srt	00:18:23.360 --> 00:18:35.090	Most of the ECG signals as you will be knowing that line frequency in India is 50 hertz whereas in US it is 60 hertz that will be present in the ECG signal.
23.srt	00:18:35.130 --> 00:18:37.870	So, first thing what you will be doing is.
23.srt	00:18:38.370 --> 00:18:41.740	eliminate that frequency using filters.
23.srt	00:18:41.740 --> 00:18:48.410	So, this is one of the example of FFT in using our board basically.
23.srt	00:18:48.410 --> 00:19:00.470	So, now, we will see we have seen the overlap add and save method using what I will call it as MATLAB we had seen in the last class.
23.srt	00:19:01.550 --> 00:19:07.900	So, we will see how we are going to do.
23.srt	00:19:08.440 --> 00:19:13.630	using our C code in hardware.
23.srt	00:19:13.839 --> 00:19:34.680	So, here we will be defining number of points there it was 64 points we had defined here it is 512 points and the length of it is 512 and you will be seeing that our filter length is gone to 351 and then input signal length is 3000 length and then our signal block length is 162.
23.srt	00:19:40.569 --> 00:19:54.890	So, this is again pi is defined and then you will be defining variables just like the previous FFT case and then what you will be having is you are going to contain the filter coefficients in column dot dat.
23.srt	00:19:55.460 --> 00:19:58.769	So, there you are generating your filter coefficient.
23.srt	00:19:59.190 --> 00:20:04.120	So, here you can compute and keep it in your data as the file.
23.srt	00:20:04.180 --> 00:20:15.680	So, you will be seeing that filter coefficient is called this is the 351 using MATLAB what it has been taken and then put it in.
23.srt	00:20:16.740 --> 00:20:18.210	file as that file.
23.srt	00:20:18.650 --> 00:20:26.850	So, the other one is you will be calling fft.c function here this thing it is a 512 points.
23.srt	00:20:27.070 --> 00:20:39.500	So, we have seen this fft with what is the thing bit reversal also which contains the thing there it was 64 bit here it is going to be 512 bits what we will be doing it.
23.srt	00:20:39.530 --> 00:20:42.350	So, coming to the main.c what is it?
23.srt	00:20:42.350 --> 00:20:45.450	So, we have to compute our this thing.
23.srt	00:20:46.930 --> 00:20:51.090	Input signal, what are the frequencies that are generated here?
23.srt	00:20:51.440 --> 00:20:58.230	It is 200 hertz just like in MATLAB what we seen the example for these frequencies.
23.srt	00:20:58.540 --> 00:21:04.030	Same thing what will be implemented in C code also on the board.
23.srt	00:21:04.360 --> 00:21:13.120	So, 200 hertz, 267 and then 400 hertz has been generated using sine function in this case.
23.srt	00:21:13.510 --> 00:21:16.580	So, you must be thinking why sine is used.
23.srt	00:21:17.450 --> 00:21:25.330	So, it will take time either you can use the IR filter in oscillatory mode to generate our sine wave or we can use this.
23.srt	00:21:25.780 --> 00:21:32.440	So, taking the FFT of this one and then saving it.
23.srt	00:21:32.840 --> 00:21:43.340	So, we can compute our this thing you will be seeing that it is using the convolution using a overlap save method fine.
23.srt	00:21:43.680 --> 00:21:47.769	So, that is how you will be calculating your.
23.srt	00:21:48.309 --> 00:21:57.500	So, you will be calling the FFT and then you will be taking your this thing you will be computing IA50 using the new twiddle factor array.
23.srt	00:21:57.500 --> 00:22:12.069	So, and then IA50 is just do FFT in this case by providing your twiddle factors with the complex conjugate.
23.srt	00:22:12.500 --> 00:22:16.539	And then you will be doing a stage Y in this case.
23.srt	00:22:18.970 --> 00:22:41.180	for k is equal to 2 and then you are doing all this computation and then later on k is equal to 3 and then k is equal to 4 to that is floor of length s divided by s length that is in this case what it is taken as 64 because you have done already 3 of them.
23.srt	00:22:41.210 --> 00:22:47.549	So, 64 is the length of your FFT what you are do using it in overlap save mode.
23.srt	00:22:50.100 --> 00:22:54.789	for computing the length of your data.
23.srt	00:22:55.220 --> 00:23:03.029	So, you will be doing it and the last one the 62nd one you will be repeating it by providing what is the k value of it.
23.srt	00:23:03.080 --> 00:23:06.750	So, you can see the length of the code what it is running here.
23.srt	00:23:07.069 --> 00:23:12.529	So, again we will put a break point and then see whether there is any error in the thing.
23.srt	00:23:12.640 --> 00:23:19.410	So, it says it is up to date because we have checked it earlier and then brought it.
23.srt	00:23:19.870 --> 00:23:23.299	And then so, we will be doing the debugging as usual.
23.srt	00:23:23.789 --> 00:23:29.430	So, one of the thing one has to remember is what we have to look for here in this case.
23.srt	00:23:29.950 --> 00:23:32.769	So, what is it?
23.srt	00:23:32.769 --> 00:23:37.730	Here it is out s what we are going to look at it.
23.srt	00:23:39.730 --> 00:23:45.269	So, it has gone and then loaded onto the board and then it is pointing at the main.
23.srt	00:23:45.730 --> 00:23:51.049	So, the breakpoint what we have provided is here.
23.srt	00:23:51.600 --> 00:24:06.340	So, this is out s is what we have to look at it I do not think there is a calculation for our magnitude squared.
23.srt	00:24:22.640 --> 00:24:27.610	So, one has to remember or to see that which one I want to monitor ok.
23.srt	00:24:28.180 --> 00:24:37.870	So here what is my input output if I know the thing then I will be able to see that what is my output.
23.srt	00:24:37.870 --> 00:24:52.530	So here what has been declared is product of FFTs and IFFT in the out temp that is what I have to look at the thing.
23.srt	00:24:52.560 --> 00:24:56.110	So anyway we will run the code if there is any difference.
23.srt	00:24:56.539 --> 00:24:59.299	So, we will find out with the thing.
23.srt	00:24:59.670 --> 00:25:06.130	So, now, again as I said because it is unable to see exit dot c sometimes in c function.
23.srt	00:25:06.590 --> 00:25:11.240	So, that is why the code has gone beyond and then it is looking for the thing.
23.srt	00:25:11.640 --> 00:25:15.850	So, anyway we will look at what is our single time graph.
23.srt	00:25:16.240 --> 00:25:19.539	So, we said that it is o temp is our thing.
23.srt	00:25:20.029 --> 00:25:26.230	So, we can give it as our acquisition buffer of 3000 what we have it.
23.srt	00:25:26.859 --> 00:25:28.930	And, then it is a floating point.
23.srt	00:25:29.460 --> 00:25:46.619	So, I can give it as 32 bit floating point and then the sampling rate I will not mention, start address what I will mention it as out s ok, we will try to map the thing.
23.srt	00:25:49.339 --> 00:25:56.529	So, you will be seeing that ok, so something I made a mistake.
23.srt	00:25:56.900 --> 00:26:06.910	Here anybody can look at it what I made the mistake was only 200 samples are getting mapped.
23.srt	00:26:07.319 --> 00:26:16.720	So, but my length is 3000 what I have given the thing this is the sine wave because you have done the IA50 also in this case.
23.srt	00:26:17.080 --> 00:26:27.670	So, we can see what is the frequency we have it 32 bit floating point and then start address is out as sorry vote.
23.srt	00:26:29.060 --> 00:26:40.050	temp where my output are there and then here acquisition also I have to make it that is display data size for 3000.
23.srt	00:26:40.450 --> 00:26:44.530	Now something you will notice I want you to look at the thing.
23.srt	00:26:45.620 --> 00:26:59.710	So for 3000 samples what we have done the thing so what I will do is I will we will make it.
23.srt	00:26:59.900 --> 00:27:00.890	full scale.
23.srt	00:27:09.340 --> 00:27:30.880	So, you are seeing you are this thing what is the frequency here somewhere around 260 hertz what you are retaining it.
23.srt	00:27:31.470 --> 00:27:33.670	filtering out the other two frequencies.
23.srt	00:27:33.670 --> 00:27:39.039	So, there were three frequencies what were present others have been eliminated.
23.srt	00:27:39.420 --> 00:27:57.619	So, one of the thing what we can do is we can see in the other points basically.
23.srt	00:27:58.049 --> 00:28:00.170	So, I can see samples ok.
23.srt	00:28:00.940 --> 00:28:03.539	So, what it is going to give you?
23.srt	00:28:04.259 --> 00:28:06.289	It should give me my inputs.
23.srt	00:28:32.900 --> 00:28:33.759	So you can see my .
23.srt	00:28:34.130 --> 00:28:37.069	some of the samples what it looks like this ok.
23.srt	00:28:37.519 --> 00:28:39.569	This is not the complete sine wave.
23.srt	00:28:39.930 --> 00:29:03.839	So, this is not the input, my input is going to be somewhere generating it as SI only the problem is here I would not be able to see this SI, why is it going to strike something to you because this is SI is a local variable.
23.srt	00:29:04.870 --> 00:29:11.050	So, for me to plot it I had to declare it as a global variable and then I can do the plotting.
23.srt	00:29:11.370 --> 00:29:14.910	So, this exercise you can take it up and then look at it.
23.srt	00:29:15.310 --> 00:29:22.460	So, like this you can go and then run your codes and then see whether your FFT code is working.
23.srt	00:29:22.460 --> 00:29:30.230	One more is DFT code what it has is this is from the book.
23.srt	00:29:36.220 --> 00:29:40.850	So, if you are able to download the code book and then run your code.
23.srt	00:29:40.850 --> 00:29:48.000	So, you will be seeing that it is from the real time digital signal processing fundamentals implementation and application.
23.srt	00:29:48.000 --> 00:30:01.230	This is the third edition most of the time I will be using it also which has the C code to complete compute your float FFT test dot C. So, even MATLAB codes are there.
23.srt	00:30:01.230 --> 00:30:09.530	So, you people can use the thing and then some of the functions that is floating point complex header files is created.
23.srt	00:30:10.310 --> 00:30:19.650	And, then fft dot h and then data file input also is going to be you can declare and then you will be using it.
23.srt	00:30:19.650 --> 00:30:25.040	So, if you say that your input f dot data you will be seeing it as.
23.srt	00:30:27.600 --> 00:30:35.070	So, this is your input data what you have it input 7 f floating point data for experiments ok.
23.srt	00:30:35.519 --> 00:30:41.170	So, you can look at running these book codes.
23.srt	00:30:41.660 --> 00:30:43.809	So, just we will run the thing.
23.srt	00:30:44.269 --> 00:30:48.630	So, we will see that how it is going to run in our board.
23.srt	00:30:50.029 --> 00:30:58.630	One has to keep it in mind that it because I have already checked the things there are no errors.
23.srt	00:30:58.920 --> 00:31:04.120	So, that it can go and then load on to our this thing board and then it is going to run.
23.srt	00:31:04.519 --> 00:31:07.440	As you can see the thing it is pointing here.
23.srt	00:31:07.799 --> 00:31:12.309	So, I can put a breakpoint here in the printf statement.
23.srt	00:31:13.019 --> 00:31:16.220	So, and then I can run the code.
23.srt	00:31:18.140 --> 00:31:31.140	So, he will be running FFT frames basically, there are 13 frames run in this case and which are the ones running and what will be the value of it you will be seeing it.
23.srt	00:31:31.140 --> 00:31:34.610	So, it will take a little time and then you can observe it.
23.srt	00:31:34.610 --> 00:31:37.830	So, you can see that.
23.srt	00:31:48.150 --> 00:31:51.900	experiment is completed at the 13 frames basically.
23.srt	00:31:52.180 --> 00:31:54.910	Frame wise computation what it is happening.
23.srt	00:31:55.390 --> 00:32:04.910	So, that means, to say that either you can sample wise what you can do it or the complete frame you can run and then have a look at it.
23.srt	00:32:05.240 --> 00:32:11.120	So, here output is going to be present in the spectrum of i.
23.srt	00:32:11.430 --> 00:32:13.730	So, we will display that basically.
23.srt	00:32:14.200 --> 00:32:18.550	So, tools go to your graph single time.
23.srt	00:32:18.950 --> 00:32:35.860	So, this has a 64 sample thing and we will call this as 32 bit floating point and start address is spectrum and even the display we have to have it as 64 because that is what what we will be getting it.
23.srt	00:32:36.340 --> 00:32:39.360	So, you will be seeing that I will magnify the thing.
23.srt	00:32:40.100 --> 00:32:51.240	So, you will be seeing that this is what somewhere around 12, 7 hertz or whatever 6 or 6.9 to 7 hertz is the frequency what it is getting generated.
23.srt	00:32:52.250 --> 00:33:05.450	through this ok. With that we will close the FFT computation on the DSP processor board and then we will look at the other applications in the next lab session.
23.srt	00:33:05.819 --> 00:33:06.190	Thank you.
35.srt	00:00:00.340 --> 00:00:27.530	Namaste, welcome back to real time digital signal processing lab this time.
35.srt	00:00:27.969 --> 00:00:30.089	So, we will see that.
35.srt	00:00:30.379 --> 00:00:39.469	how we will be implementing least mean square algorithm that is LMS algorithm in MATLAB today we will look at it.
35.srt	00:00:40.010 --> 00:00:49.879	So, this is the as I will be mentioning usually we will be taking asking the students to implement it.
35.srt	00:00:50.269 --> 00:00:52.780	So, this is one of the student who has implemented.
35.srt	00:00:52.780 --> 00:00:55.980	So, which I am taking it for your presentation.
35.srt	00:00:56.030 --> 00:00:59.939	So, here this is going to call a GUI function basically.
35.srt	00:01:01.780 --> 00:01:06.409	as it is easier to run with different input signals.
35.srt	00:01:07.320 --> 00:01:11.750	So, we will see how our LMS algorithm is going to work.
35.srt	00:01:12.210 --> 00:01:18.390	So, we are going to some of the name and structure you will be seeing it GUI definition.
35.srt	00:01:18.730 --> 00:01:23.810	So, those who are interested in writing their own GUI you can refer to this example.
35.srt	00:01:24.270 --> 00:01:31.500	So, we are interested in seeing that how our LMS algorithm is going to work.
35.srt	00:01:32.280 --> 00:01:55.929	So, we are going to call the variables here as you can see we have the declaration because for parameters changing they have to be declared global here also x y and then y out have been declared as global and the order of the filter is 20 in this case.
35.srt	00:01:56.280 --> 00:02:02.159	So, you can vary this order and then see how your LMS algorithm is going to.
35.srt	00:02:02.760 --> 00:02:05.810	So, now, what you have to do it.
35.srt	00:02:06.319 --> 00:02:12.300	So, you are going to weight function w initially you are making them 0s.
35.srt	00:02:13.680 --> 00:02:21.990	And then in this case mu is selected as that is time step is selected as 0.006.
35.srt	00:02:22.129 --> 00:02:33.289	So, we will see first we will see what happens with the 0.006 and then later on we can see by modifying it step size varying it if you have not calculated it properly.
35.srt	00:02:34.369 --> 00:02:36.079	what is the thing is going to happen.
35.srt	00:02:36.939 --> 00:02:51.179	And then for the length of this thing filter minus the order what will be taking it that is n plus l minus 1 what we have it.
35.srt	00:02:51.609 --> 00:02:54.839	So, buffer is going to be configured.
35.srt	00:03:07.319 --> 00:03:14.949	So, this is going to be order i plus order minus 1 because you are starting from 1 and then you will be taking the transpose basically and then y out of I is nothing, but so, you have buffer star w star 2 what you will be calling it.
35.srt	00:03:15.590 --> 00:03:24.800	Then error I is going to be y I minus buffer of w whatever value is the thing.
35.srt	00:03:24.800 --> 00:03:38.939	So, this is the updated what we are going to have it as error and then our weight function w here it is not represented as n plus 1 w is equal to the current value of w plus.
35.srt	00:03:39.389 --> 00:03:57.079	You will be calculating, you will be seeing that whatever the value here into mu into error of i which you will be taking it as transpose that is update the weights basically and then you will be ending the code.
35.srt	00:03:57.479 --> 00:03:59.240	So, then you will be plotting it.
35.srt	00:03:59.479 --> 00:04:12.599	So, we will run it has all the 3 algorithms that is NLMS that is normalized least mean square algorithm and RLS algorithm is also there.
35.srt	00:04:12.629 --> 00:04:15.289	So, I have considered here only LMS.
35.srt	00:04:15.890 --> 00:04:16.949	for this class.
35.srt	00:04:16.949 --> 00:04:35.189	So, we will see NLMS and then RLS how the function is going to be used and we will as I mentioned in the class we will not be deriving the equations for it those who are interested can run the code and then check it ok.
35.srt	00:04:35.430 --> 00:04:46.899	So, we will run this code you will be seeing that LMS algorithm is going to come up as I.
35.srt	00:04:47.579 --> 00:04:53.840	So, some of the laptops will have resolution problem.
35.srt	00:04:53.840 --> 00:05:02.850	So, we will see that we will be running this code as LMS algorithm first and then we will see the thing.
35.srt	00:05:02.850 --> 00:05:15.439	So, we will run the code this is going to give us as you are seeing it adaptive filters both LMS and LMS and as well as RLS has been.
35.srt	00:05:21.590 --> 00:05:27.920	integrated in this and in the next class we will see separately how we are going to design the thing.
35.srt	00:05:28.310 --> 00:05:31.200	First is I will be loading my noisy signal.
35.srt	00:05:32.250 --> 00:05:43.330	So, this is my noisy signal what I will be loading on to the system and then what desired signal I want to in this case I know both of them.
35.srt	00:05:43.870 --> 00:05:45.340	So, I will be loading it.
35.srt	00:05:46.230 --> 00:05:51.020	So, open it and then we can run our LMS algorithm.
35.srt	00:05:51.740 --> 00:05:52.960	So, both I have loaded.
35.srt	00:05:53.370 --> 00:06:12.230	So, this is the original signal and this is the noisy signal what you are seeing it and using the least mean square algorithm with mu set to 0.006 that is the optimum what usually found out by trial and error you can do it or you can exactly calculate.
35.srt	00:06:12.230 --> 00:06:17.280	So, we will see in the class how we are going to calculate that.
35.srt	00:06:22.670 --> 00:06:30.290	So, we will be getting back approximately our original signal as you can see although amplitude has got a little bit modified compared to the original one.
35.srt	00:06:30.699 --> 00:06:36.370	So, this is what we have taken is input is the signal.
35.srt	00:06:36.629 --> 00:06:44.800	Remember the force will be with you always.
35.srt	00:06:44.829 --> 00:06:51.800	Something must be striking in your mind we use the same input for our FIR and IR filter.
35.srt	00:06:54.680 --> 00:06:56.170	So, same thing we are using for our LMS algorithm also.
35.srt	00:06:56.220 --> 00:07:05.509	So, we will see the noise here whatever noise was added in using the MATLAB which was stored as the noisy signal in this case.
35.srt	00:07:11.580 --> 00:07:14.470	As you can see single frequency tone was added.
35.srt	00:07:14.470 --> 00:07:26.160	So, if you want you can add any noise and then if you have your desired signal you can this is after running our LMS algorithm that is filter output.
35.srt	00:07:28.329 --> 00:07:29.550	So, we can play.
35.srt	00:07:30.199 --> 00:07:34.709	Remember the force will be with you always.
35.srt	00:07:34.709 --> 00:07:39.100	So, you can see that your noise got eliminated.
35.srt	00:07:39.600 --> 00:07:48.170	So, this is how one can run the thing with whatever mu selection what we have done.
35.srt	00:07:48.490 --> 00:07:57.970	So, we will see that if mu is equal to 1 what is the thing is going to happen.
35.srt	00:07:59.210 --> 00:08:11.950	So, we will run this case and we will see whether we are going to get back the signal or it is going to have some noisy signal present in the thing.
35.srt	00:08:13.020 --> 00:08:24.520	This is the desired signal what I have to load it and then run the LMS algorithm.
35.srt	00:08:24.520 --> 00:08:29.360	You can see that my input step size is 1.
35.srt	00:08:29.920 --> 00:08:36.659	So, you are seeing that if you play the thing nothing what you are going to get it.
35.srt	00:08:36.659 --> 00:08:43.879	So, you will be seeing how the steepest algorithm is going to work.
35.srt	00:08:43.879 --> 00:08:49.070	Now we will go back and then change our thing and then re-run.
35.srt	00:08:49.129 --> 00:08:52.220	So, this was the maximum one I have taken the thing.
35.srt	00:08:52.220 --> 00:08:59.409	So, we will start from point 1 and what is the minimum what we are going to get we will see.
35.srt	00:09:00.370 --> 00:09:27.509	So, if it is going to work for 0.1 this is the trial and error method what I am using it, but how we are going to calculate as we have mentioned that the calculation of mu has to be using the if you are calculating on the go then we have to do the inverse of the matrix or I can calculate using the are coefficients basically you have to do matrix inversion.
35.srt	00:09:31.799 --> 00:09:33.289	This is a noisy signal.
35.srt	00:09:33.479 --> 00:09:39.589	So, we will be loading the desired signal again and then I can run the LMS algorithm.
35.srt	00:09:40.619 --> 00:09:45.569	So, you will be seeing that most of the thing you have got back with point.
35.srt	00:09:45.619 --> 00:09:53.689	Remember the force will be with you always.
35.srt	00:09:53.689 --> 00:09:57.259	How your steps size has to be one has to calculate.
35.srt	00:09:57.259 --> 00:10:00.939	So, it depends on how much iterative algorithm you are going to run.
35.srt	00:10:06.759 --> 00:10:09.589	And, then we will run our LMS algorithm.
35.srt	00:10:11.719 --> 00:10:17.459	So, you will be seeing that my step size is too low in this case.
35.srt	00:10:17.969 --> 00:10:34.069	So, this is what the your plot gives you and then if I play what you will hear you can you guess it?
35.srt	00:10:34.639 --> 00:10:50.499	So, your what is it audio is completely reduced or the speech has got very I do not know whether you heard it or not here we can hear it very minute value under that amplitude what we are hearing.
35.srt	00:10:50.499 --> 00:10:54.439	So, there is a single tone sine wave also which is going.
35.srt	00:10:54.799 --> 00:11:01.529	So, you have to compute your mu what should what is going to give you.
35.srt	00:11:04.669 --> 00:11:06.819	your minimum value.
35.srt	00:11:07.529 --> 00:11:14.629	So, if you want to plot your weight function, so you can plot them also.
35.srt	00:11:34.570 --> 00:11:39.019	So, we will see by, we will see plot w because I am in this thing what is it GUI I may get error.
35.srt	00:11:39.620 --> 00:11:40.330	So, we will load it again.
35.srt	00:11:40.559 --> 00:11:42.179	I think.
35.srt	00:12:06.590 --> 00:12:08.789	So, my plot is outside.
35.srt	00:12:09.169 --> 00:12:12.070	So, that is why it is not shown with the thing.
35.srt	00:12:12.529 --> 00:12:17.100	Let me see by taking it inside whether it will be giving me the thing.
35.srt	00:12:17.370 --> 00:12:23.639	Otherwise just without GUI we will run in the next class our LMS algorithm ok.
35.srt	00:12:39.050 --> 00:12:56.149	So, there will be error in the thing because if I come out of it, it is going to it is not plotting basically and if I am inside you can see that it is going for the plot and then it is not coming out of the handle.
35.srt	00:12:56.690 --> 00:13:06.769	So, we can reduce to 0.001 and then look at it how this is going to have the impact on our output.
35.srt	00:13:07.259 --> 00:13:12.730	There was error in opening the GUI.
35.srt	00:13:13.440 --> 00:13:15.120	It took long time to open it.
35.srt	00:13:15.570 --> 00:13:22.960	So, we will clear all and we will open the function again.
35.srt	00:13:29.910 --> 00:13:30.730	We will run the thing.
35.srt	00:13:31.350 --> 00:13:44.600	So, our load noise is signal and then we load the desired signal and then we will run our LMS algorithm.
35.srt	00:13:44.650 --> 00:13:45.670	So, you will be seeing that.
35.srt	00:13:46.620 --> 00:13:49.600	compared to the original with 0.001.
35.srt	00:13:49.600 --> 00:13:54.730	So, you will be seeing that there are attenuation happening with the thing.
35.srt	00:13:54.730 --> 00:13:55.860	So, when you play the sound.
35.srt	00:13:55.860 --> 00:13:58.300	Then the force will be with you always.
35.srt	00:13:58.810 --> 00:14:03.690	Then the force will be with you always.
35.srt	00:14:04.190 --> 00:14:08.770	So, it is a little bit working on the thing.
35.srt	00:14:08.770 --> 00:14:14.870	So, what usually you have to find out what is optimum you what you can run with the thing.
35.srt	00:14:14.870 --> 00:14:16.490	So, thank you.
35.srt	00:14:16.490 --> 00:14:22.780	We will see separately running and then how the weight function is going to adapt itself in the.
35.srt	00:14:23.530 --> 00:14:24.690	next class.
35.srt	00:14:25.070 --> 00:14:25.500	Thank you.
21.srt	00:00:01.219 --> 00:00:25.629	Welcome back to real time digital signal processing lab.
21.srt	00:00:32.280 --> 00:00:32.950	So here in the previous class we saw how the MATLAB is going to run our filters.
21.srt	00:00:33.710 --> 00:00:50.689	Today now we will see that how our board is going to respond to whatever the same corruptive voice what it is going to be given to our board also and we will be designing the filter and we will see that what will be the response ok.
21.srt	00:00:50.810 --> 00:00:56.179	So, as we have been telling that it is the C code what we will be writing.
21.srt	00:00:56.609 --> 00:01:01.689	So, which is going to be ANSI C and you will be using the.
21.srt	00:01:04.109 --> 00:01:12.909	AEC 3106 is the codec chip on the L138 board here we are using C6748 board.
21.srt	00:01:13.060 --> 00:01:22.549	So, which uses this and then we are including the cof file here I have given it as 200 order.
21.srt	00:01:22.780 --> 00:01:32.629	So, you will be seeing that this is the what I will call it as I have given number of coefficients basically although.
21.srt	00:01:35.280 --> 00:01:46.710	It is the same frequency whatever component what it has been taken in FIR filter in the MATLAB same components what you will be seeing it.
21.srt	00:01:47.109 --> 00:01:51.290	So, you are seeing that H of n this is defined continuously.
21.srt	00:01:51.570 --> 00:01:54.420	So, if you want to put it in this format.
21.srt	00:01:54.710 --> 00:01:59.200	So, you can refer to any of the real time signal processing book.
21.srt	00:01:59.200 --> 00:02:02.849	So, they will be giving how to convert from single line to this.
21.srt	00:02:03.140 --> 00:02:08.009	Otherwise, it will be if you have given a return it will take it as a next line.
21.srt	00:02:08.389 --> 00:02:10.750	So, we want to arrange it in this way.
21.srt	00:02:11.050 --> 00:02:13.009	So, that we are not going to lose the thing.
21.srt	00:02:13.009 --> 00:02:18.330	So, either I can we can have the here it is 55th order.
21.srt	00:02:18.659 --> 00:02:22.509	how it can be represented the coefficients what it is the shown.
21.srt	00:02:22.900 --> 00:02:36.629	So, one way of doing it either we can create a dot h file and then put all the filter coefficients here and then or we can provide in our main dot c itself the value of it.
21.srt	00:02:36.710 --> 00:02:39.060	So, you will be seeing both the ways being used.
21.srt	00:02:39.539 --> 00:02:51.579	Now what we will be telling is the initialization of it that is codec has to be initialized so, here we are using the polling technique.
21.srt	00:02:51.950 --> 00:02:58.770	There are 2 ways actually 3 ways of it today we will see 2 ways of doing the same thing.
21.srt	00:02:59.100 --> 00:03:05.689	One is using the polling technique as I have mentioned in my theory class in the architecture.
21.srt	00:03:06.110 --> 00:03:16.610	The polling method CPU will be going and then checking whether there is a new data which is present that is how it will be working on it.
21.srt	00:03:16.610 --> 00:03:24.300	So, it will go and then check if there is any data in our LCDK line input that is codec input.
21.srt	00:03:24.800 --> 00:03:29.940	will be using that and we can specify the sampling frequency what I am going to use it.
21.srt	00:03:30.260 --> 00:03:36.330	In this case we have designed all our thing is in 8000, 8 kilohertz.
21.srt	00:03:36.330 --> 00:03:51.270	So, we will be using FS8000 and we will be looping continuously here because I will be getting the data and then I will be working on my filter and I will be sending the out on to the codec chip.
21.srt	00:03:51.540 --> 00:03:58.650	So, you have to initialize y of n is my output which is going to be initially 0.
21.srt	00:03:59.130 --> 00:04:11.190	So, you will be getting the first sample x of 0 is always I will be taking the first sample from my input data that is whatever is connected.
21.srt	00:04:11.520 --> 00:04:25.180	So, this is input sample that is from ADC what I am going to take it and then I will be looping it you will be computing filter output basically and this is delaying our data in circular manner.
21.srt	00:04:25.180 --> 00:04:29.060	So, for i is equal to 0 i less than.
21.srt	00:04:29.340 --> 00:04:40.870	you are n actually will be doing i plus plus and then you will be computing h of i is the coefficient into x of i whatever data is coming in.
21.srt	00:04:42.470 --> 00:04:59.030	And then you will be shifting i is equal to n minus 1, i greater than 0, i minus minus your x of i will get x of i minus 1 and then the output y n will be whatever you have stored in x of 0 what you have computed.
21.srt	00:05:00.450 --> 00:05:08.660	So, that is how we will be computing for every sample until the order of the filter.
21.srt	00:05:09.200 --> 00:05:22.560	So, then what we are going to do is we will be we can directly output left sample because we have taken in from the left sample audio in has both left sample and then right sample.
21.srt	00:05:22.879 --> 00:05:32.120	Here we have taken only one input sample data from left channel and then we are processing and then putting out on the left channel itself.
21.srt	00:05:32.509 --> 00:05:41.030	So, I can call it as this thing uninitialized interrupt 16 basically y of n what I will be going to output DAC.
21.srt	00:05:41.570 --> 00:05:50.360	Since the volume is going to be little feeble so, what we have done is we have shifted it by 4 basically to increase the output.
21.srt	00:05:50.960 --> 00:05:53.800	amplitude of the signal.
21.srt	00:05:53.879 --> 00:05:58.590	So, we will be putting it to output DAC this value ok.
21.srt	00:05:58.810 --> 00:06:02.000	So, this is how we will run our FIR filter.
21.srt	00:06:02.439 --> 00:06:20.840	So, we will as we know first I can do build debug for project this is going to take surrogam APA itself as input like MATLAB and then you are seeing that it is up to date because I have already run it if there are any errors.
21.srt	00:06:22.230 --> 00:06:25.340	So, you have to take care of them.
21.srt	00:06:25.740 --> 00:06:29.480	So, now I can go and then build this project.
21.srt	00:06:29.860 --> 00:06:46.830	So, we have created the project and we need the codec initialization and then it is H file also and then linkerdsp.cmd will be specifying what how the memory mapping is going to happen just to give a flavor of it.
21.srt	00:06:46.830 --> 00:06:49.800	So, you will be seeing linkerdsp.cmd.
21.srt	00:06:49.800 --> 00:06:53.870	So, you are specifying stack.
21.srt	00:06:55.730 --> 00:06:57.660	heap and then memory.
21.srt	00:06:57.950 --> 00:07:11.440	So, I have a RAM and then there is some shared RAM and then some external RAM also the their length and their origin is given in hex basically in this case.
21.srt	00:07:11.480 --> 00:07:34.610	And what are the sections I will be using is some of it is dot text wherever it appears you have described your comment and other things text has to lie and constant if you have declared that define it will be lying here and this is the BSS section basically where the.
21.srt	00:07:35.050 --> 00:07:37.460	entry point and other things is going to have.
21.srt	00:07:37.800 --> 00:07:45.260	And dot for will be some memory which is away from the thing which is going to be stored in this DSP 12 RAM.
21.srt	00:07:45.810 --> 00:08:04.040	And then you will be seeing even the stack and then switching and even dot data it is getting stored here ok. And initialization part of it we call it as where the entry point to our program is going to be that we call it as initial unit thing which is here.
21.srt	00:08:04.150 --> 00:08:07.480	So, if there are system memory is also in this.
21.srt	00:08:07.930 --> 00:08:17.560	And then you will be having I O whatever also the location is in that and then vectors also whether it is polling or interim driven.
21.srt	00:08:17.560 --> 00:08:27.120	So, the vectors have to be specified where it is going to lie this is the memory and then you will be calling that external RAM as your external RAM.
21.srt	00:08:27.530 --> 00:08:32.919	So, this is how your memory storage is going to be in your DSP processor.
21.srt	00:08:33.350 --> 00:08:38.269	So, we will see that how the thing is going to run in our.
21.srt	00:08:39.620 --> 00:08:43.830	So, you will be seeing that it is doing the debug.
21.srt	00:08:44.230 --> 00:08:48.530	So, you are seeing that it is going and then loading on to the board.
21.srt	00:08:48.900 --> 00:08:53.320	So, it has finished and you will be seeing that this is ready to run.
21.srt	00:08:53.770 --> 00:08:57.390	Either I can do single stepping or I can run continuously.
21.srt	00:08:57.390 --> 00:09:10.090	Since if it is not codec based, you can do single stepping and then see each step what is the value which is getting computed.
21.srt	00:09:10.600 --> 00:09:27.730	So, here you have seen that it has come down to entry point here, int main is our entry point and you will be seeing h and x values where they have been defined and our h value is already it is a float which has been taken in this case.
21.srt	00:09:27.730 --> 00:09:31.650	If you are taking it as quantized one you can go and then take them.
21.srt	00:09:31.650 --> 00:09:41.440	So, these are the values of our coefficients basically and these are the input initially what.
21.srt	00:09:41.850 --> 00:09:48.860	So, what we will do is here it is a sarigama with noise what I will be putting it.
21.srt	00:09:49.290 --> 00:10:04.020	So, we can run this from here which is the input that is through the output of laptop jack you can connect it to the input of the board and then the output we are connecting it to the speaker for you to hear the thing.
21.srt	00:10:04.390 --> 00:10:06.240	So, this is running continuously.
21.srt	00:10:06.560 --> 00:10:13.800	Now we will see what is the thing is going to happen when I run my board ok.
21.srt	00:10:14.060 --> 00:10:27.110	So, what it says is if you are not going to hear anything you have to go back and then reset the board and then you have to restart it.
21.srt	00:10:27.140 --> 00:10:29.400	So, you are unable to hear any of it.
21.srt	00:10:29.810 --> 00:10:43.100	So, we will see again do the debug whether we can hear something we will see.
21.srt	00:10:59.460 --> 00:11:02.920	You will be seeing that.
21.srt	00:11:03.330 --> 00:11:20.470	Even after stopping it the board is running because we have given it as it is a while loop 1 ok, until I reset my board the code will be running on the board.
21.srt	00:11:20.780 --> 00:11:30.130	So, you will be seeing the complete FIR filter, you are hearing the noise because even in the passband we have little noise.
21.srt	00:11:30.130 --> 00:11:33.960	So, as I mentioned in while running my MATLAB code.
21.srt	00:11:34.320 --> 00:11:36.190	So, this is how.
21.srt	00:11:36.670 --> 00:11:41.230	there will be little noise also which is going to be amplified in our boards.
21.srt	00:11:41.430 --> 00:12:07.640	So, I have to go for very high order filter here although it shows it is 200 order FAR filter still I may have to increase, but most of the time as when we took up the stability of the filter for FAR although we said it is stable, but at least up to 256 order it may remain same, but beyond that it may become.
21.srt	00:12:08.180 --> 00:12:23.480	So, better to design all your filter orders for FIR in for the board less than or equal to 200 what I say my students not to go beyond that somewhere around 120 to 150 what we do it.
21.srt	00:12:23.740 --> 00:12:33.670	So, that is how what you saw that little noise is left out ok. Now, we will see the same thing whether I can use the interrupt driven.
21.srt	00:12:33.710 --> 00:12:39.190	So, what is the different between polling and then interrupt driven we will see in a while.
21.srt	00:12:39.650 --> 00:12:42.200	It is the same code what I will be having it.
21.srt	00:12:42.620 --> 00:13:02.390	So, you will be seeing that same surrogama F i F i r dot c. So, you are using the I can use the LP 55 coefficient I have not renamed it or I can use this as renaming for both the coefficients are there I can try on both the things.
21.srt	00:13:02.390 --> 00:13:09.500	So, or I will be taking this itself 200 dot coefficient whichever previous one what we have run.
21.srt	00:13:09.890 --> 00:13:13.290	So, you will know that there is no difference between polling and then.
21.srt	00:13:14.230 --> 00:13:25.110	So, here what it says same thing will be initializing the codec, but what is it I have to write the interrupt service routine here.
21.srt	00:13:25.580 --> 00:13:40.420	Because I am going to interrupt the CPU whenever there is a new sample which is coming again then what the CPU is going to do is there is a location where it is specified here it is interrupt 4 is the one being used.
21.srt	00:13:40.810 --> 00:13:44.190	So, you will be seeing that there is a assembly file.
21.srt	00:13:44.520 --> 00:13:47.550	for vectors interrupt dot ASM.
21.srt	00:13:47.550 --> 00:14:14.070	So, you will be seeing that it is calling all vectors I have the entry point is underscores underscore int 00 where your main basically will be entering it here and then there are predefined vectors here 1, 2, 3 which is not accessible to the user and then the interrupt 4 is accessible to the user and rest of it is not accessible to the user.
21.srt	00:14:14.450 --> 00:14:22.480	So, you will be seeing that this is the entry point and where they will be branching you will be seeing that this is the entry point.
21.srt	00:14:22.990 --> 00:14:29.890	then how it is going to branch this is a assembly code sample in TI processor what you will be seeing it.
21.srt	00:14:29.890 --> 00:14:46.250	This is store word basically B0 in B15 this becomes a stack basically and then you will be moving constant here from this B0 lower portion of it and then a higher.
21.srt	00:14:46.660 --> 00:14:58.350	All the registers are 32 bit so we will be loading the address 16 bit lower version and then higher here and then you will be branching wherever this is pointing.
21.srt	00:14:58.600 --> 00:14:58.800	2.
21.srt	00:14:59.180 --> 00:15:28.180	This is the pointer what it is given and then this is our usually we as I said W15 represents our stack pointer where the entry point has been given ok. And then you will be loading back whatever wherever you have stored the where was the entry point that back so that it can return to its safer place ok. And you will be seeing that there will be some knobs to account for the delay.
21.srt	00:15:32.400 --> 00:15:40.280	So, those who are interested in assembly programming So, if type permits I will show one of it how I can exactly count how much clock cycle it is going to take.
21.srt	00:15:41.240 --> 00:16:02.680	So, this is how your entry points are going to be where it is it says it is reset as you can see that entry vector, vector 1 is non-maskable interrupt I think there should be some trigger in your background what is happening and then these two are reserved and this is a interrupt service routine what we have it.
21.srt	00:16:02.680 --> 00:16:05.060	So, the others are kept it as dummy ok.
21.srt	00:16:05.120 --> 00:16:08.920	So, this is where our interrupt routine is going to start.
21.srt	00:16:09.930 --> 00:16:15.530	So, the CPU will jump and see whether there is any data and then it will take it and then process it.
21.srt	00:16:16.000 --> 00:16:24.520	So, what we are going to do is we will be writing our FIR filter code in the interrupt service routine.
21.srt	00:16:25.100 --> 00:16:40.470	So, X0 what we will be taking the sample from the this thing codec chip and then we are going to process it just like polling and then we will be doing the delay lines assignment circular buffer what we have to call it.
21.srt	00:16:41.000 --> 00:16:50.450	We are doing that and then we will be outputting the sample same way as the previous one right shifted by 4 bits basically.
21.srt	00:16:50.870 --> 00:17:05.690	And then here also we are using the sampling frequency is 8 kilohertz and these are the ADC and DAC gain basically we keep it as 0 dB and then LCDK line input is the codec input and output and we will be looping forever.
21.srt	00:17:06.070 --> 00:17:11.170	So, we will see that thus how it is going to behave.
21.srt	00:17:11.330 --> 00:17:16.300	So, this is how one is with the polling and with the interrupt what we have run the thing.
21.srt	00:17:16.630 --> 00:17:20.050	So, now, we will move on to our IR filter.
21.srt	00:17:20.160 --> 00:17:26.910	So, here it is a notch filter what it has been designed like the previous one.
21.srt	00:17:27.360 --> 00:17:34.240	So, we will see that how this we call it as a interrupt driven only what it has been taken.
21.srt	00:17:34.660 --> 00:17:42.590	So, if you want to run polling you can very well use this as a sample this thing the first one.
21.srt	00:17:43.090 --> 00:17:45.420	there you can go and then put the code.
21.srt	00:17:45.930 --> 00:17:51.450	So, you will be seeing that this is my this thing LCDK initialization.
21.srt	00:17:51.920 --> 00:17:58.370	Next I am going to define my constant it is here int coefficient what it has been taken.
21.srt	00:17:58.840 --> 00:18:08.140	So, for 900 hertz to remove that these are this coefficients what it has been given ok.
21.srt	00:18:13.950 --> 00:18:17.030	So, you will be seeing that and then for the 2700 hertz what I have to remove it.
21.srt	00:18:17.460 --> 00:18:24.520	These are the coefficients values which have been designed in MATLAB and then we have taken the coefficients.
21.srt	00:18:24.910 --> 00:18:29.840	And then we have to this thing sections what we will be having.
21.srt	00:18:30.270 --> 00:18:36.350	So, x of 1 because it is the sixth order filter.
21.srt	00:18:36.430 --> 00:18:45.100	So, you will be seeing that x 1 2, x 6 what you are calling it as signed integer.
21.srt	00:18:45.340 --> 00:18:50.400	So, you are seeing not a float here it is running in integer format.
21.srt	00:18:50.810 --> 00:18:54.230	So, this is how you will be generating the thing.
21.srt	00:18:54.230 --> 00:19:08.110	So, and then our y1 to y6 also has to be defined for both numerator and then denominator you are initializing them separately.
21.srt	00:19:08.600 --> 00:19:13.780	Now since it is the interrupt driven, so you will be see service routine has to be written.
21.srt	00:19:13.820 --> 00:19:21.440	So, some of the variables what we need it for IR filter what it is shown here.
21.srt	00:19:21.980 --> 00:19:27.150	So, output there are temporary files what it has been created.
21.srt	00:19:27.790 --> 00:19:33.560	So, you will be seeing that for 900 coefficient 900 comma input.
21.srt	00:19:34.190 --> 00:19:48.440	So, and then our input in this case is the sample which is coming from my codec that is ADC basically for sample what I take it in input and I will be passing it.
21.srt	00:19:48.860 --> 00:19:53.070	So, next one we will be passing it as you can see that.
21.srt	00:19:53.550 --> 00:20:04.770	output what we have to pass it to temp 1, you are doing the filter IR you are going to pass it through that, that is the second stage of it.
21.srt	00:20:05.210 --> 00:20:11.080	This is the first section, this is the second section which is running and this is the third section.
21.srt	00:20:11.510 --> 00:20:18.340	So, after that because it is a sixth order filter what you have it as I mentioned earlier.
21.srt	00:20:18.630 --> 00:20:28.140	So, the other for the 2700 hertz what you will be doing you will be taking this from the input of this section you will be feeding into this.
21.srt	00:20:29.330 --> 00:20:40.660	This is in what we call it as series what we have fed in the thing then from this output will be feeding to this one fine.
21.srt	00:20:40.920 --> 00:20:54.230	Output of temp 3 goes to our temp 4 which is eliminating my this thing 2700 hertz sine wave what is we call it as a noise.
21.srt	00:20:54.549 --> 00:21:01.490	So, this is finally the output temp is going to have the last stage output.
21.srt	00:21:01.809 --> 00:21:13.269	Then we will be doing output left sample to that is codec DAC output will get from the temp that is left sample what it is going to be.
21.srt	00:21:13.750 --> 00:21:20.100	So, now, will be after that will return from the service routine this is my main function.
21.srt	00:21:20.480 --> 00:21:23.769	So, which is also running at 8000 and then line in.
21.srt	00:21:24.190 --> 00:21:31.529	Now, we have to see that what is my IR filter is going to do because I have I am calling how many times.
21.srt	00:21:31.930 --> 00:21:35.299	3 plus 3, 6 times I am calling the filter.
21.srt	00:21:35.680 --> 00:21:39.889	I have to pass what are the values and then it has to run the thing.
21.srt	00:21:40.180 --> 00:21:57.139	So, you will be calling with star x star y it is their locations what you are giving and then constant sign int even the star h and then integer x 1 what you will be giving it.
21.srt	00:21:57.519 --> 00:22:03.659	So, now, we are initializing here also this is a local variable as you can see temp is 0.
21.srt	00:22:05.459 --> 00:22:15.659	And, then it will be taking x 1 as the input that is copy input to this memory and x of 0 is going to be you are assigning this value.
21.srt	00:22:16.229 --> 00:22:22.899	And, then temp will be calculated that is h 0 into your x of 0.
21.srt	00:22:23.129 --> 00:22:32.459	So, h 0 is int you are pre defining the thing input and then x of 0 is already int.
21.srt	00:22:32.459 --> 00:22:34.789	So, you are doing the integer multiplication.
21.srt	00:22:35.589 --> 00:22:41.449	And, then you will be what is it adding it to temp.
21.srt	00:22:41.959 --> 00:22:43.789	So, h 1 into x 1.
21.srt	00:22:44.269 --> 00:22:48.379	So, you will be continuing up to h 6 into x of 6.
21.srt	00:22:48.479 --> 00:22:52.619	So, you can see that sequentially what the computation is happening.
21.srt	00:23:07.099 --> 00:23:07.819	This is for the first stage of this thing 0 basically and this is going to happen for your poles that is divide temp by coefficients a 0 what you are going to do that.
21.srt	00:23:08.099 --> 00:23:22.809	So, you will be so, if you want to normalize the thing then you have to divide by that otherwise you are passing it through your y1 to y6 here.
21.srt	00:23:23.279 --> 00:23:25.419	So, then what you are going to do?
21.srt	00:23:25.829 --> 00:23:35.949	You are going to because as we know that multiplication and addition is going to result in 32 bit.
21.srt	00:23:36.379 --> 00:23:37.479	So, we have to.
21.srt	00:23:38.209 --> 00:23:47.769	So, else if temp is less than this thing minus 32767, this is this is overflow what you are avoiding it, here you are avoiding the underflow.
21.srt	00:23:47.769 --> 00:23:53.269	If it is less than this, you will be making it maximum as minus 1.
21.srt	00:23:53.339 --> 00:24:04.489	So, the thing is varying between minus 1 to plus 1 that is what we are restricting and then we are putting as y 0 as temp value.
21.srt	00:24:04.999 --> 00:24:09.119	So, you can shuffle the values for the next stage.
21.srt	00:24:09.439 --> 00:24:17.929	because, it has to take y6 should be taking the value from y5, y of n minus 1.
21.srt	00:24:17.929 --> 00:24:27.189	So, you will be and even x of n should take it from x of n minus 1 do this and then you will be returning the temp value.
21.srt	00:24:27.859 --> 00:24:30.149	So, this is how the code is going to run.
21.srt	00:24:30.549 --> 00:24:33.639	So, we will take a demo of it ok.
21.srt	00:24:40.339 --> 00:24:44.499	So, here my input is going to be correct voice with this is the Surigama what we are running.
21.srt	00:24:44.879 --> 00:24:51.169	So, we will take the corrupt voice what we have run it with the MATLAB.
21.srt	00:24:51.679 --> 00:24:53.879	So, sample files we have it.
21.srt	00:24:53.879 --> 00:24:58.509	So, this will be IR corrupt voice what I will be feeding into my system.
21.srt	00:24:58.899 --> 00:25:05.699	So, this is running let it be running by the time we will run our code on the board we will see the thing.
21.srt	00:25:05.779 --> 00:25:07.189	So, I will be doing the debugging.
21.srt	00:25:07.539 --> 00:25:15.879	First what you have to do is compile it see for any errors since as I have been telling you that.
21.srt	00:25:16.240 --> 00:25:26.059	I will be usually running it first and then because time shortage and other things it will take little more time to figure out the errors and then do the debugging.
21.srt	00:25:26.789 --> 00:25:32.230	Usually everything is corrected and once it is running what I will be putting it for the demo ok.
21.srt	00:25:32.259 --> 00:25:33.799	So, we will run the thing now.
21.srt	00:25:35.919 --> 00:25:45.899	Remember the force will be with you always.
21.srt	00:25:47.180 --> 00:25:53.899	always remember the force will be with you always.
21.srt	00:25:54.109 --> 00:25:56.359	As usual output is still remaining.
21.srt	00:25:57.039 --> 00:26:11.149	So, you have seen that both the whatever frequency that is 900 hertz and then 2700 have been removed and you are hearing the clear voice from it.
21.srt	00:26:11.539 --> 00:26:18.720	So, if you want to hear the corruptive voice what I will do is the connection what we have given it to the pod I will remove it.
21.srt	00:26:18.980 --> 00:26:20.359	So, you will hear that.
21.srt	00:26:20.739 --> 00:26:23.499	2 tones as you heard in MATLAB.
21.srt	00:26:33.509 --> 00:26:42.309	So, now, I am connecting back to my board and then if I rerun the thing I can here I need not have to run debug every time.
21.srt	00:26:42.859 --> 00:26:51.849	I can go to the project, I can what I will say I can go to run, I can load the project now whichever because all have been compiled.
21.srt	00:26:51.849 --> 00:26:55.839	So, I need not have to read a debug it again.
21.srt	00:26:57.989 --> 00:27:06.599	If I go and then click on them, it will be running loading on to the board and then we can run it directly.
21.srt	00:27:07.539 --> 00:27:09.309	So, it will take.
21.srt	00:27:13.019 --> 00:27:20.109	So, you have heard the clean speech now coming out of it.
21.srt	00:27:20.109 --> 00:27:25.919	So, once I reset the thing it stops.
21.srt	00:27:26.449 --> 00:27:27.949	So, you will not be.
21.srt	00:27:28.039 --> 00:27:30.769	hearing the thing it is running.
21.srt	00:27:30.769 --> 00:27:42.609	So, usually it goes and loads after the only for debugging purpose what we have to use our laptop once all the code has been running on the board.
21.srt	00:27:43.049 --> 00:27:45.089	So, till you remove the power supply.
21.srt	00:27:45.299 --> 00:27:48.239	So, it will be continuously running on the board.
21.srt	00:27:48.699 --> 00:27:57.659	So, if there is any power failure then you may have to that is go and load into the board and then run it.
21.srt	00:27:58.969 --> 00:28:08.359	So, this completes our demo of FIR and IR filter both in MATLAB and then in hardware.
21.srt	00:28:08.749 --> 00:28:17.849	Anyway we have seen that resonating frequency, how we are generated using the C code is shown in the previous class.
21.srt	00:28:17.849 --> 00:28:22.889	So, if you want to make this a real time that is you can either write a polling driven.
21.srt	00:28:29.369 --> 00:28:31.239	or interim driven.
21.srt	00:28:31.599 --> 00:28:37.879	So, one of this can go as an assignment for you to run this in your hardware.
21.srt	00:28:38.059 --> 00:28:46.739	So, that how I can generate my tone and how multiple frequencies I can generate using the sine wave.
21.srt	00:28:47.089 --> 00:29:01.009	So, that within just as you can see that with y 0, y 1 and y 2 and then x 0, I will be able to generate my required frequency component.
21.srt	00:29:01.639 --> 00:29:05.169	using IR filter in resonatory mode.
21.srt	00:29:05.969 --> 00:29:11.079	So, thank you and then all the best in your labs.
20.srt	00:00:01.219 --> 00:00:25.350	Welcome back to real time digital signal processing lab.
20.srt	00:00:25.620 --> 00:00:28.820	So today we will be discussing about.
20.srt	00:00:31.320 --> 00:00:32.939	the filters in detail.
20.srt	00:00:33.600 --> 00:00:49.400	So, you will be seeing that first we will discuss the MATLAB and then we will go to the code composer studio how we will be verifying whatever result we are going to get from MATLAB which is going to match with our hardware implementation.
20.srt	00:00:49.840 --> 00:01:00.799	So, you are going to see that the same thing Saragamappa what it we generated sine wave that is has been taken as a input or FIR filter.
20.srt	00:01:03.099 --> 00:01:08.500	So, you will be seeing that all the 8 nodes getting generated using the sine function here.
20.srt	00:01:08.899 --> 00:01:15.659	And then you will be concatenating just like last time what we had taken the thing and then we will be sounding all nodes.
20.srt	00:01:16.159 --> 00:01:29.870	And then if you are hearing the nodes before adding noise and then you can check that after noise what is going to happen, what is the noise here we are going to add in this case.
20.srt	00:01:30.299 --> 00:01:32.739	So, you are adding the for all nodes.
20.srt	00:01:34.660 --> 00:01:41.630	you are adding 0.3 times the random number generated with size of all nodes.
20.srt	00:01:41.630 --> 00:01:46.850	So, we will play this after adding the noise what we are going to hear.
20.srt	00:01:46.850 --> 00:01:48.570	Then what happens?
20.srt	00:02:05.660 --> 00:02:13.009	So, we know that anything beyond in this case what is the maximum frequency we have taken is basically 5 times that of the You will be seeing that is 5 times star FSA what it is been taken divided by 6.
20.srt	00:02:13.390 --> 00:02:14.469	So, what is this?
20.srt	00:02:14.469 --> 00:02:23.400	This is 440 FSA and then we will be going up to 880 hertz in this case and sampling frequency chosen is 8000.
20.srt	00:02:24.090 --> 00:02:31.400	So, after 880 hertz, so you are going to eliminate the noise present in the thing.
20.srt	00:02:32.210 --> 00:02:36.370	So, for that the coefficient has been designed in this way.
20.srt	00:02:36.870 --> 00:02:46.099	So, you have to go to FDA toolbox which we saw in the last class and design the FIR filter to remove the noise.
20.srt	00:02:46.099 --> 00:02:50.030	So, you can have two different ways of having it.
20.srt	00:02:50.259 --> 00:02:53.360	So, we will see both the ways how it is going to look like.
20.srt	00:02:53.860 --> 00:03:04.950	Then what you are going to call it as filter out initially you will be calling them as zeros and then concatenate and then you will be going from thus up to 56000.
20.srt	00:03:05.379 --> 00:03:09.340	So, the order of the filter is 121 in this case.
20.srt	00:03:09.750 --> 00:03:11.909	So, you will be going 1 to 121.
20.srt	00:03:12.360 --> 00:03:19.199	So, you will be calculating that is count coefficient j all nodes i minus j plus 1.
20.srt	00:03:19.840 --> 00:03:27.280	So, you will be shifting them get the first sample and then rest of them you have assigned them 0s.
20.srt	00:03:27.750 --> 00:03:35.920	So, you will be seeing that filter out of i is nothing, but filter out of i plus the count initially count is 0.
20.srt	00:03:43.639 --> 00:03:47.439	So, you will be increasing it and then once all the samples have been field you will be getting the filter output.
20.srt	00:03:47.799 --> 00:03:56.750	So, then you will be playing this note filter out actually and then you can do the plotting also.
20.srt	00:03:57.280 --> 00:04:10.029	So, you will be doing that is next power of 2 from length of y what it will be taking it n FFT or normal FFT it will be padding zeros and then it is taking it.
20.srt	00:04:10.389 --> 00:04:15.199	So, the length of it L what you will be taking it FFT is chosen as 8000.
20.srt	00:04:15.689 --> 00:04:30.110	and then original what happens notes and then that is original FFT of the notes after adding the noise what you will be looking at and after filtering what is the note will be getting it ok.
20.srt	00:04:30.459 --> 00:04:38.870	So, this it is going to be displayed using our plots basically we will be having subplots.
20.srt	00:04:39.439 --> 00:04:45.120	So, we will run this and then see that how it is going to look like.
20.srt	00:04:53.550 --> 00:04:57.600	This is the original note what we have generated using sign generation.
20.srt	00:04:57.979 --> 00:05:00.919	So, that is what is getting played here now.
20.srt	00:05:01.279 --> 00:05:06.079	Now, what we are going to do is it says press any key to listen to the noisy notes.
20.srt	00:05:06.489 --> 00:05:07.979	So, you will be hearing it.
20.srt	00:05:15.870 --> 00:05:24.129	This is the noisy note that is random number 0.3 times the value of that is magnitude of it what you have added to all the notes.
20.srt	00:05:24.129 --> 00:05:28.839	So, still you are able to hear the notes because only little bit of it what it is added.
20.srt	00:05:28.839 --> 00:05:32.039	Now, we will see how our FIR filter is going to work.
20.srt	00:05:40.180 --> 00:05:43.870	Still there is a little noise present, why?
20.srt	00:05:44.199 --> 00:05:52.120	Because you have added in the complete region the noise in the domain of input.
20.srt	00:05:52.310 --> 00:05:57.389	So, you can see that there is little noise left out in the even in the passband region.
20.srt	00:05:57.389 --> 00:06:02.009	So, that is what it is seen and anything beyond the passband region.
20.srt	00:06:02.009 --> 00:06:04.879	So, you are seeing that it is a flat response.
20.srt	00:06:05.250 --> 00:06:07.659	So, I will be closing this, this is the output.
20.srt	00:06:08.009 --> 00:06:16.329	magnitude plot original this thing signal and then you will be seeing plot noisy plot.
20.srt	00:06:16.329 --> 00:06:33.069	So, you are seeing the noise in the passband region and then here also you will be seeing the noise and then the filtered noise you are seeing that it is getting eliminated and then little noise you will be seeing to the original which is being left out.
20.srt	00:06:33.399 --> 00:06:37.139	So, this is what the we will say using.
20.srt	00:06:38.769 --> 00:06:43.599	or FIR filter in MATLAB what we have done that.
20.srt	00:06:44.240 --> 00:06:57.319	So, now what we can do is we can run our IAR filter here and then we will go to demo of filters in board basically hardware.
20.srt	00:06:57.519 --> 00:07:04.219	So, we will run this IAR dot m.
20.srt	00:07:09.139 --> 00:07:26.240	So, in this case you will be seeing that your input and then f is so, you are going to read a file that is corruptive dot wave form what you are going to read using audio read.
20.srt	00:07:27.060 --> 00:07:36.689	So, this is how your wave read has to be changed to audio read in the latest version earlier versions have wave read.
20.srt	00:07:37.019 --> 00:07:38.959	So, you will be sounding thus.
20.srt	00:07:39.370 --> 00:07:43.920	And, then you can print f whether we are same thing what we are going to do.
20.srt	00:07:44.500 --> 00:08:07.470	So, now, what is the thing you have to design your IR filter using MATLAB and then you will be seeing that you will be calling numerator is a floating point values what you are going to have it and then denominator values for the f 1 represent the first section.
20.srt	00:08:09.649 --> 00:08:26.649	So, you will be getting the denominator always a0 will be 1 and then you will be having the rest of the this thing values a0, a1, a2, a3, a4 what you are seeing the thing.
20.srt	00:08:26.990 --> 00:08:34.590	So, the second section what it has is it is f2 and denominator we represent it as 2.
20.srt	00:08:35.120 --> 00:08:41.279	So, the same thing here it is instead of a bicoid it is a fourth order what you have been.
20.srt	00:08:42.559 --> 00:08:48.149	reason you will be having the scaling factor that is present in this.
20.srt	00:08:48.529 --> 00:08:58.149	So, now you will be going that is you will be initializing it and then you will be having 4 counts what you are going to have it.
20.srt	00:08:58.659 --> 00:09:08.899	So, you will be going with numerator f1 with 2 size of it what you are going to take it and then you will be counting them basically.
20.srt	00:09:09.329 --> 00:09:15.250	So, that is based on your numerator f1 of i into.
20.srt	00:09:15.899 --> 00:09:29.370	x of i minus j plus 1 and then count 1 what you are keeping it for the first structure and then you will be checking the count 4 that is denominator f1.
20.srt	00:09:29.859 --> 00:09:40.959	So, you will be adding it and then adding count 3 for that and then you will be making all the counts equal in this case.
20.srt	00:09:41.309 --> 00:09:44.870	So, that you will be able to move forward.
20.srt	00:09:45.269 --> 00:09:47.620	So, you will be calling filter output.
20.srt	00:09:49.089 --> 00:10:16.109	1 of i will be giving using this count 2 minus count 4 divided by denominator f11 and then your filter out initially you will be making them 0s and then you will be seeing that count 2 is numerator 2 into j, j is varying from 1 to size of numerator f1, 2.
20.srt	00:10:16.689 --> 00:10:19.719	So, you will be computing count 2.
20.srt	00:10:20.159 --> 00:10:28.799	And, if it is i is greater than g, so you have to count in this way and then count 4 is denominator what you are counting it.
20.srt	00:10:29.219 --> 00:10:45.829	So, you will be getting again you are making it count 1 count 2 that is if the order of because we are doing it continuously we have to come back to our filter that is circular buffering what we should have it.
20.srt	00:10:46.219 --> 00:10:50.839	So, that is how you will be computing the second section also.
20.srt	00:10:51.169 --> 00:10:59.179	But what is it there is an error in the audio read that is corruptive voice dot wave.
20.srt	00:10:59.649 --> 00:11:10.370	So, what we have to do is I have to give the path for it which is not available in the current folder.
20.srt	00:11:10.819 --> 00:11:18.490	So, one of the way of doing it is I can push that corruptive voice dot wave here and then we can run it.
20.srt	00:11:18.879 --> 00:11:23.850	So, what I will do is it is present in my sample files here.
20.srt	00:11:24.359 --> 00:11:28.529	Or I can give that complete path I can give it and then run from there.
20.srt	00:11:29.039 --> 00:11:42.869	So, I can do the copy and then we will go up to the MATLAB portion of it and I will be putting my this thing I will be pasting it here.
20.srt	00:11:43.559 --> 00:11:49.619	Now I can do as all of you know CLC will be clearing all the thing.
20.srt	00:11:50.139 --> 00:11:53.879	So, I can go back and then rerun the thing.
20.srt	00:11:58.949 --> 00:11:59.949	So, what we have.
20.srt	00:12:00.209 --> 00:12:11.349	added here is a one single tone sine wave frequency what it is getting added to your speech signal that is what you are hearing it continuously.
20.srt	00:12:11.409 --> 00:12:15.069	So, now, what I will do is I will press the thing.
20.srt	00:12:18.799 --> 00:12:22.829	So you can see that it got eliminated.
20.srt	00:12:23.429 --> 00:12:30.859	So, what is the thing here it is there are two frequencies sorry in this it is 900, it hurts one peak.
20.srt	00:12:31.449 --> 00:12:34.029	And then the other one is 2700 peak.
20.srt	00:12:34.629 --> 00:12:43.929	So, which was added to the input speech to check that whether we are going to get the output correctly.
20.srt	00:12:43.929 --> 00:12:53.739	So, you have seen that initially there was this thing filtered output you will be seeing that only my speech signal is present in this.
20.srt	00:12:53.739 --> 00:12:57.639	So, you will be seeing these two peaks have got eliminated.
20.srt	00:12:57.939 --> 00:13:02.729	So, what I will be designing is a notch filter from.
20.srt	00:13:03.759 --> 00:13:08.919	So, for my application, so how I can design the notch filter.
20.srt	00:13:09.399 --> 00:13:20.309	So, again we may have to go back to our FDA tool and then if you remember the portion of it.
20.srt	00:13:20.309 --> 00:13:28.949	So, we will see that how to design the notch filter or a bind stop filter what we called it ok.
20.srt	00:13:28.979 --> 00:13:35.699	So, notch is the single frequency what we will be eliminating it.
20.srt	00:13:36.119 --> 00:13:40.789	So, this is my filter design.
20.srt	00:13:41.239 --> 00:13:51.849	So, here as we said that either we can design the frequency component which I want to eliminate.
20.srt	00:13:52.089 --> 00:13:55.369	So, I will be taking IR filter.
20.srt	00:13:55.419 --> 00:14:01.699	So, either I can take Butterworth elliptic 1 or 2 one of the thing.
20.srt	00:14:02.589 --> 00:14:07.449	So, in this case what I want to design is a.
20.srt	00:14:07.789 --> 00:14:11.639	notching what I am going to select in this case.
20.srt	00:14:12.339 --> 00:14:17.429	So, then it says it is the comb filter what it is designing here.
20.srt	00:14:38.999 --> 00:14:40.599	So, if you do not want this single notch what I can eliminate one at a time or both together I can comb filter if I provide two frequencies what I can eliminate it that is why what you are seeing is there is the 4 this thing 0s and poles what you will be seeing it.
20.srt	00:14:40.849 --> 00:14:45.219	So, if I give a single notch only one frequency what I can eliminate.
20.srt	00:14:45.579 --> 00:14:56.359	So, I can specify the order or I can do the minimum this thing, hertz is here fs is 8000 hertz.
20.srt	00:14:56.799 --> 00:15:01.619	So, the notch what I want to eliminate is 900 hertz first time ok.
20.srt	00:15:02.109 --> 00:15:04.539	So, we will see what is the thing is going to happen.
20.srt	00:15:04.969 --> 00:15:10.389	So, the bandwidth what it is asking me bandwidth I will keep it.
20.srt	00:15:10.659 --> 00:15:14.029	as 100 hertz here ok.
20.srt	00:15:14.059 --> 00:15:23.959	So, Q factor what we want is 45 and units in dB pass band what I want is 1 dB ripple.
20.srt	00:15:24.469 --> 00:15:26.219	So, I can design the filter.
20.srt	00:15:33.839 --> 00:15:41.149	So, you are seeing that this is the pass band and it comes and then removes the 900 hertz here.
20.srt	00:15:42.089 --> 00:15:49.009	So, you will be seeing that the magnitude and phase together what it is showing here.
20.srt	00:15:49.009 --> 00:15:59.009	So, if I want to see the if I want to see the group delay.
20.srt	00:15:59.009 --> 00:16:13.169	So, you will be saying that although it is a second order filter the maximum delay what I am going to get is almost 50 samples.
20.srt	00:16:14.010 --> 00:16:19.470	So, in the case of FIR filter we can count how much delay that is what we saw it last time.
20.srt	00:16:19.800 --> 00:16:27.390	If it is the 50th order filter the delay if I use the linear phase which is going to be 25.
20.srt	00:16:27.390 --> 00:16:33.170	If I do not use the linear phase concept then the delay of that filter is going to be 50.
20.srt	00:16:34.090 --> 00:16:42.580	But whereas, although this is a second order filter so, you will be seeing the group delay is almost approximately going up to 50 samples in this.
20.srt	00:16:43.000 --> 00:16:44.930	So, and then if you want to.
20.srt	00:17:18.640 --> 00:17:19.890	Select the target, code composer studio what I will be selecting it here and then one part one has to remember in this case it is a 16th order filter basically and 16 bits are there as we did the in theory that minimum of 2 bits required for my integer part to represent my filter coefficients.
20.srt	00:17:20.210 --> 00:17:36.390	So, hence the what will be using here is if I want sin 32 bit integer I can do it or I can say that sin 16 bit integer what I can generate from it.
20.srt	00:17:36.860 --> 00:17:48.230	So, then we will see that will generate the filter and then it will be saved as fd always it is going to store it as.
20.srt	00:17:48.940 --> 00:17:55.860	So, we will be storing it in this itself and then we will see what we are going to get from that.
20.srt	00:17:58.340 --> 00:18:02.600	Since we have not specified the debugger again the error will come.
20.srt	00:18:03.020 --> 00:18:06.830	So, this is our MATLAB code what we will see it.
20.srt	00:18:07.170 --> 00:18:09.690	So, we have stored the FDA coefficients here.
20.srt	00:18:10.220 --> 00:18:21.800	So, you will be seeing that it is a discrete time IR filter what it has designed and direct form 2 what it is designing and then or it said the length of it is 2.
20.srt	00:18:22.060 --> 00:18:25.900	So, order of the filter will be a length plus 1.
20.srt	00:18:26.510 --> 00:18:30.530	3 basically and denominator length also in this case 3.
20.srt	00:18:31.430 --> 00:18:34.330	So, you will be seeing the values how it is generated.
20.srt	00:18:34.760 --> 00:18:38.530	So, this is numerator length 3 what it has.
20.srt	00:18:38.860 --> 00:18:41.120	So, you will be seeing 3 of them.
20.srt	00:18:41.810 --> 00:18:53.940	If you want you can do it in floating point you can run the code and the denominator all the 3 samples sorry 3 poles what you are seeing it here ok.
20.srt	00:18:54.210 --> 00:18:57.190	This is how your FTA coefficients will be coming out.
20.srt	00:18:57.490 --> 00:19:00.090	So, this is what it was stored in our.
20.srt	00:19:01.470 --> 00:19:03.660	demo of it as you are seeing it here.
20.srt	00:19:03.660 --> 00:19:05.060	So, it is the fourth order.
20.srt	00:19:05.580 --> 00:19:15.880	So, there are one for your this thing one of the filter that is 900 hertz the other one is designed for 2700 hertz.
20.srt	00:19:15.930 --> 00:19:23.770	So, we will see that whether we can give it as a comb filter and then we can specify two frequencies here.
20.srt	00:19:23.860 --> 00:19:27.260	So, instead of single notch I can select it as a comb filter.
20.srt	00:19:35.940 --> 00:19:43.280	And, then order I can specify it as basically fourth order let us see how it is going to look like.
20.srt	00:19:43.280 --> 00:19:57.300	And then I have want the 8000 hertz and bandwidth still I will be giving it as what I will give let us see 900 and 2700 whether it is going to accept it ok.
20.srt	00:19:57.550 --> 00:20:01.440	So, it should be single.
20.srt	00:20:01.820 --> 00:20:10.830	So, we will give it as 900 hertz.
20.srt	00:20:11.610 --> 00:20:17.910	So, what is the thing happening here?
20.srt	00:20:18.680 --> 00:20:27.840	So, you can see that so, even the approximately 900 into 3 is going to be a 27.
20.srt	00:20:28.360 --> 00:20:40.340	So, I can design this and then this is my pass band region what I will be selecting it and there is going to be notch here and stop band what it is happening here.
20.srt	00:20:40.780 --> 00:20:42.220	So, I can use this.
20.srt	00:20:42.740 --> 00:20:47.050	to take my filter coefficients and then run it also fine.
20.srt	00:20:47.690 --> 00:20:51.370	So, or you can take individually and put both together.
20.srt	00:20:51.840 --> 00:20:56.190	So, one after the other filter what you are will be running it fine.
20.srt	00:20:56.570 --> 00:21:13.600	So, this gives the little bit inside of how to use the FDA tools in our and one more thing as you see or seen in the thing I can go back and then store this.
20.srt	00:21:17.080 --> 00:21:34.750	filter descriptor to know that what filter I have designed, how I have taken and then I am using it in my sorry it is asking me I have to give that I need not have to store this ok.
20.srt	00:21:35.240 --> 00:21:36.440	So, it came out of it.
20.srt	00:21:36.790 --> 00:21:46.410	This is to remove our 900 hertz sine wave what it has and the other one is to remove our 2700 fine.
20.srt	00:21:51.950 --> 00:22:03.750	So, this is how we design and then cross verify it and then go back and then run this design filter coefficients whatever we have done the thing and then check in our hardware.
20.srt	00:22:04.230 --> 00:22:11.370	So, we have one more this thing filter dot m if you want to design the thing.
20.srt	00:22:12.110 --> 00:22:17.860	So, that is FIR filter you can direct method if you want to run it.
20.srt	00:22:18.260 --> 00:22:23.410	So, you can design the thing each one will have their own way of.
20.srt	00:22:24.000 --> 00:22:24.800	putting the thing.
20.srt	00:22:25.190 --> 00:22:33.600	So, the books gives that is that is what it says is sinusoidal noise components from a corrupted speech signal.
20.srt	00:22:34.100 --> 00:22:42.200	Here it is 2 bandpass filter with rejection frequency of 900 hertz and 2700 hertz are used ok.
20.srt	00:22:42.660 --> 00:22:53.740	So, this should be band stop filter not a bandpass or you will be having a 2 bandpass filter to eliminate this 900 hertz.
20.srt	00:22:54.170 --> 00:22:56.280	and then 2700 hertz.
20.srt	00:22:56.680 --> 00:23:01.230	So, here also you can different ways of writing code what I am showing you.
20.srt	00:23:01.680 --> 00:23:14.740	So, you will be directly what you are going to do is b 1 comma a 1, b 1 is our 0s basically and a 1 is my poles basic what we will be designing it.
20.srt	00:23:15.080 --> 00:23:26.040	So, we will take Butterworth what it is being used you are giving the WP 1 and then WP 2 that is pass band what you are giving.
20.srt	00:23:26.660 --> 00:23:31.060	800 to 1000 hertz what we want is the stop band frequency.
20.srt	00:23:31.620 --> 00:23:45.340	So, that is we are eliminating the frequency from 800 to 1000 and then I can do the quantization here that is basically fixed point implementation what I wanted.
20.srt	00:23:45.800 --> 00:23:57.530	So, then what is the bits I am going to give 16 bits in that coefficients represented with 13 bits that is Q13 format.
20.srt	00:23:57.720 --> 00:24:03.260	I have been mentioning because coefficients need 2 integer bits.
20.srt	00:24:03.260 --> 00:24:16.930	So, that is why we will be designing Q 13 bits and you will be seeing b 1 quantize Q comma b 1 and then a 1 also you quantize that and you will be seeing that how the poles position is going to be.
20.srt	00:24:16.930 --> 00:24:30.570	Then we can do filter that is eliminate only one portion of it and then we can say that how I am going to here one frequency after removal.
20.srt	00:24:31.110 --> 00:24:39.010	and both together and second time I will be running it and then I can see that the last one how does it look like.
20.srt	00:24:39.010 --> 00:24:47.580	So, we will start from the thing actually the first one what we have is you will be hearing the original corruptive voice.
20.srt	00:24:47.680 --> 00:24:49.830	So, we will run this code.
20.srt	00:24:49.830 --> 00:25:02.350	You have heard the corruptive voice.
20.srt	00:25:02.770 --> 00:25:07.290	So, how to find out what are the frequency component present in it.
20.srt	00:25:07.640 --> 00:25:14.500	So, this is the this is FFT of the voice it is not the clean voice.
20.srt	00:25:14.860 --> 00:25:25.800	So, it is gone to present the last one after removing the frequency component, that is sine waves from that.
20.srt	00:25:25.800 --> 00:25:31.060	So, you will be seeing that 2 poles and then 2 zeros what you have it here.
20.srt	00:25:36.420 --> 00:25:53.720	This way coordinates and then you will be seeing that these are the complex conjugate poles and 0s what you will be presenting it in the z plane and you will be seeing this is my audio over that what we have put in here the 2 frequencies are somewhere around 2, 7 and then 5, 3 or something like that.
20.srt	00:25:53.720 --> 00:26:08.440	So, each one have a individual way of putting their own frequency and then try to eliminate that and then you will be seeing that real part how does it look like these are the 2 poles and these are the 2 0s.
20.srt	00:26:09.080 --> 00:26:10.960	of the R filter.
20.srt	00:26:11.620 --> 00:26:23.960	And then you will be seeing that the mirror image of the frequencies both together that is this is what you have is approximately 900 hertz basically what we have it.
20.srt	00:26:24.540 --> 00:26:36.860	The other one is 2700 hertz you will be seeing that approximately you will be getting it as 2692 or whatever it is got generated 962700 hertz.
20.srt	00:26:36.950 --> 00:26:42.190	So, now, I will what I will do is because all of them if they are run.
20.srt	00:26:42.560 --> 00:26:46.470	So, it will be causing an overlap.
20.srt	00:26:46.840 --> 00:26:48.620	So, you will not understand the thing.
20.srt	00:26:48.910 --> 00:26:51.560	So, you have heard the corruptive voice now.
20.srt	00:26:52.040 --> 00:26:56.030	So, to comment in MATLAB we use this percentage sign.
20.srt	00:26:56.380 --> 00:27:12.410	So, coming to the next one I will remove one of the thing and we can eliminate one frequency and then first is the 900 frequency what you are eliminating and you will be hearing the 2700 hertz here.
20.srt	00:27:12.820 --> 00:27:15.090	So, we will run this again.
20.srt	00:27:23.840 --> 00:27:26.040	Same thing you will be looking at.
20.srt	00:27:26.630 --> 00:27:37.340	Only you have seen that 900 hertz is eliminated and only this frequency is present after the first round of it ok.
20.srt	00:27:37.800 --> 00:27:42.790	Initially was these 2 frequencies present in the voice signal, one got eliminated.
20.srt	00:27:43.140 --> 00:27:45.930	Now what we will do is we will comment on it.
20.srt	00:27:46.710 --> 00:27:51.400	So that we can uncomment the last one.
20.srt	00:27:52.880 --> 00:27:57.220	So it goes through biquite section and then.
20.srt	00:27:59.000 --> 00:28:18.720	So, we will be hearing whether both have got removed or not.
20.srt	00:28:18.750 --> 00:28:23.530	Remember, the force will be with you.
20.srt	00:28:23.530 --> 00:28:28.230	So, you are hearing the clean voice that is what the clean voice what it is shown here.
20.srt	00:28:28.700 --> 00:28:48.030	So, the original voice and this should have the same thing and these are the what will you will call it as the second order section of the second filter and you will be seeing after the first one there was one component left out which was removed by those two poles and zeros.
20.srt	00:28:59.840 --> 00:29:03.370	So, the I am going in the reverse direction these two poles and zeros have removed the whatever present are 900 hertz thing.
20.srt	00:29:03.840 --> 00:29:06.600	So, this is how we run our MATLAB code.
20.srt	00:29:06.980 --> 00:29:17.170	So, you can have your own imagination add your own sine wave or any noise to this and see how you are going to eliminate those noises.
20.srt	00:29:17.440 --> 00:29:21.910	So, we will stop for this class with the MATLAB demo.
20.srt	00:29:22.220 --> 00:29:28.720	So, in the next class we will take up completely our DSP processor board demo.
20.srt	00:29:28.720 --> 00:29:33.700	So, that you will see that how little bit of.
20.srt	00:29:34.240 --> 00:29:45.910	noise whatever left out in the passband is going to emphasize in the port we will be looking at it although we have designed the same kind of filter in that.
20.srt	00:29:46.470 --> 00:29:46.880	Thank you.
34.srt	00:00:00.330 --> 00:00:26.260	So, welcome back to real time digital signal processing course.
34.srt	00:00:26.699 --> 00:00:30.760	So, we will cover today little on adaptive filter.
34.srt	00:00:31.379 --> 00:00:36.009	So, to give you as you can see this is a module 3 what you would be covering.
34.srt	00:00:36.570 --> 00:00:42.539	So, what are the two modules we covered in the previous classes is listed here.
34.srt	00:00:43.089 --> 00:00:47.820	That is we covered in module 1 basic architectures and some number system.
34.srt	00:00:48.599 --> 00:00:54.439	And then in the second one we discussed about filters both FIR and IIR filters.
34.srt	00:00:55.070 --> 00:01:02.209	And then we went on to see frequency domain algorithms discrete Fourier transform.
34.srt	00:01:02.619 --> 00:01:07.480	and how this can be made faster using Fourier transforms.
34.srt	00:01:08.090 --> 00:01:19.950	So, in the last class we little bit discussed about random process and then we will be taking up today continuing on that.
34.srt	00:01:20.409 --> 00:01:27.879	So, before that we will discuss about in module 3 what are the subjects we will be covering.
34.srt	00:01:28.509 --> 00:01:34.310	So, first one is adaptive filters, so we will be taking least square mean square algorithm.
34.srt	00:01:35.109 --> 00:01:53.570	algorithm and its applications and then we will just say a normalized LMS and then even the RL is we will just discuss we will not go on to derive the thing, but more derivative we will be doing it on the least mean square LMS algorithm.
34.srt	00:01:54.400 --> 00:02:06.850	So, later on we will cover basics of image processing basically we will be covering discrete cosine transform with little bit of introduction to our image processing.
34.srt	00:02:07.280 --> 00:02:16.039	and how we will be implementing in the hardware which is going to give us the full site just like our FFT algorithm.
34.srt	00:02:17.629 --> 00:02:21.460	So, coming to continuation of the random process.
34.srt	00:02:21.460 --> 00:02:25.349	So, little bit of theory in the last class we have covered.
34.srt	00:02:38.239 --> 00:02:55.079	Today we will discuss about little on the autocorrelation function of the random process f of n defined as Rx is of n comma k which is given by expected value of x of n with respect to x of k. So, we say random process is stationary if it is a statistic do not change with time.
34.srt	00:02:55.799 --> 00:03:07.519	So, the most useful and relaxed form stationary is the wide sense stationary what we call it which is named as WSS.
34.srt	00:03:09.719 --> 00:03:12.989	So, process that satisfies the following two conditions.
34.srt	00:03:13.679 --> 00:03:17.609	So, that is we call it as wide sense stationary.
34.srt	00:03:18.639 --> 00:03:30.319	The mean of the process is independent of time in this case what it is given as expected value of X of n is given as mx.
34.srt	00:03:30.909 --> 00:03:38.369	So, we say thus mx is constant that is what we see it is independent of time.
34.srt	00:03:38.919 --> 00:03:41.159	Then the autocorrelation function.
34.srt	00:03:41.500 --> 00:04:05.339	function, it is going to depend only on the time difference which is given by Rxx of k which is autocorrelation function given by expected value of x of n plus k into x of k. So, we say k is the time length in digital domain.
34.srt	00:04:06.199 --> 00:04:15.069	The two important properties of our autocorrelation function Rxx of k with respect to our WSS process is defined.
34.srt	00:04:15.559 --> 00:04:16.299	in this way.
34.srt	00:04:16.699 --> 00:04:18.509	First is the even function.
34.srt	00:04:19.060 --> 00:04:20.939	So, what do we mean by that?
34.srt	00:04:21.250 --> 00:04:46.149	So, Rx 6 of minus of k is nothing, but equal to Rx 6 of k which is this the other property is it is bounded by giving that that is the magnitude of Rx 6 of k is less than or equal to Rx 6 of 0.
34.srt	00:04:46.699 --> 00:05:16.689	So, here we call Rx, x of 0 as the expected value of square of the input signal x of n. So, we call it as mean square value or the other name is power of random process x of n. So, if x of n is 0 mean random process, then what we have is expected value of x squared of n is nothing but a standard deviation sigma x squared.
34.srt	00:05:17.590 --> 00:05:46.870	So, continuing with the thing consider the sinusoidal signal as an example which is given by X of n is equal to a times cos omega naught n. So, we have to find its mean and then autocorrelation for of the X of n. So, for the mean what we substitute is mx which is nothing, but amplitude a times expected value of cos omega naught n.
34.srt	00:05:47.910 --> 00:05:53.769	So, which is going to be 0 this is mx equal to.
34.srt	00:05:54.149 --> 00:05:56.970	So, we know that our cos function is given by.
34.srt	00:05:59.610 --> 00:06:06.540	So, you are taking the expected value of this cos omega naught n over the thing.
34.srt	00:06:06.540 --> 00:06:09.910	So, when you add them up you will be getting 0.
34.srt	00:06:10.509 --> 00:06:13.189	So, for the autocorrelation function.
34.srt	00:06:13.649 --> 00:06:18.589	So, how we are going to calculate the thing which is nothing but Rxx of k which is given by 0.
34.srt	00:06:19.139 --> 00:06:39.759	expected value of x of n plus k into x of n. So, here we have taken x of n here which is nothing, but a squared into cos omega naught n plus omega k into cos omega naught n this is the function what we have to solve.
34.srt	00:06:40.300 --> 00:06:49.569	So, when we solve with respect to cos omega naught n plus omega plus omega k into cos omega naught n when you expand the thing.
34.srt	00:06:50.009 --> 00:07:16.339	Then, it becomes as we know that it is a squared by 2 into expected value of cos 2 omega naught n plus omega naught k plus a squared by 2 cos omega naught k which is equivalent to a squared by 2 into cos omega naught k. So, that is what is left out from that other the terms are going to get cancelled.
34.srt	00:07:16.610 --> 00:07:19.259	So, you can expand it and then look at them.
34.srt	00:07:21.899 --> 00:07:31.129	So, And that what is the thing that autocorrelation function of a cosine wave is the cosine function of the same frequency omega naught.
34.srt	00:07:31.939 --> 00:07:40.919	So, as we started with cos omega naught n. So, we will be seeing that it is a function of omega naught itself.
34.srt	00:07:41.669 --> 00:07:48.979	So, coming with how we are going to calculate power spectrum and then cross correlation next function we will see the thing.
34.srt	00:07:49.729 --> 00:07:55.069	So, we are using the widely used random signal for many applications.
34.srt	00:07:55.529 --> 00:08:03.709	which is we said it is white noise what we will be considering V of n with 0 and variance as sigma V squared.
34.srt	00:08:04.219 --> 00:08:26.529	Then its autocorrelation function is given by r V V of k is equal to sigma V squared into delta of k. So, is we know that delta of k is a delta function with amplitude what we call it as sigma V squared at lag k is equal to 0 and its power spectrum is given by.
34.srt	00:08:27.169 --> 00:08:32.849	PVV of W which is nothing, but sigma V squared into magnitude of omega.
34.srt	00:08:33.399 --> 00:08:40.629	This is less than or in this case what we consider magnitude of omega is less than or equal to pi.
34.srt	00:08:41.469 --> 00:08:49.899	So, this shows that the power of the random signal is uniformly distributed over the entire frequency range.
34.srt	00:08:50.799 --> 00:08:57.610	So, now defining the cross correlation function between two wide sense stationary process.
34.srt	00:08:57.929 --> 00:09:26.439	x of n and y of n which is defined by Rxy of k which is given by expected value of x of n plus k into y of n. So, this function has the property that is Rxy of k is nothing but R yx of minus k. So, what we said here it is a even function.
34.srt	00:09:26.439 --> 00:09:28.829	So, even the cross correlation is a.
34.srt	00:09:29.269 --> 00:09:31.899	even function what you can look at it.
34.srt	00:09:32.569 --> 00:10:02.269	So, then what happens to R y x of k is simply the folded version of what we call it as R x y of k. So, now take an example to see that what will be the cross correlation of FIR filter with input output equation what it is given by equal to y of n equal to x of n plus a x of n minus 1 plus b into x of n.
34.srt	00:10:02.549 --> 00:10:03.599	n minus 2.
34.srt	00:10:03.969 --> 00:10:07.589	So, you can assume this is small y of n equal to.
34.srt	00:10:08.179 --> 00:10:30.709	So, we assume the white noise with 0 mean and variance sigma x squared in this case as the input signal x of n. Find the mean that is m y and the autocorrelation function Rxy of k of the filter output y of n what we have to do it fine.
34.srt	00:10:38.789 --> 00:10:41.699	So, for the mean what we are going to substitute m y is equal to expected value of y of n what we are going to take it which is nothing, we will be putting it on the right hand side.
34.srt	00:10:42.099 --> 00:10:54.919	Expected value of x of n plus a times expected value of x of n minus 1 plus b times expected value of x of n minus 2 which we will be substituting it as 0.
34.srt	00:10:55.969 --> 00:11:01.289	Now, the autocorrelation function, so what happens to the thing.
34.srt	00:11:01.619 --> 00:11:11.009	So, we will be seeing 1 plus a squared plus b squared whole into Rx of k we are considering the autocorrelation as you can see plus.
34.srt	00:11:11.409 --> 00:11:25.849	a plus a b into r x x of k minus 1 plus a plus a b into r x x of k plus 1 and then so on we will be substituting for these functions.
34.srt	00:11:25.849 --> 00:11:30.849	So, which is given by what is the thing.
34.srt	00:11:31.259 --> 00:11:43.119	So, 1 plus a square plus b square into sigma x square if k is equal to 0 and it is going to be a plus a b into sigma x square if k is equal to plus or minus 1.
34.srt	00:11:43.289 --> 00:12:01.849	what we have is we call it as mx tilde equal to the average value of it what we will be taking 1 by n, n is equal to 0 to n minus 1 x of n. So, where n is the number of samples available for the short time analysis.
34.srt	00:12:02.459 --> 00:12:07.229	So, this is the mean is defined with respect to this equation.
34.srt	00:12:07.339 --> 00:12:14.599	And then how we are going to take for the same sample what will be the autocorrelation function.
34.srt	00:12:15.079 --> 00:12:32.969	which is defined as Rxx of k is nothing but 1 by n minus k into n is equal to 0 to n minus k minus 1, x of n plus k into x of n and k will be varying between 0 to n minus 1.
34.srt	00:12:33.829 --> 00:12:45.159	So, the next is we will take up an example for to see that what will be our mean and autocorrelation and cross correlation with respect to finite length signal.
34.srt	00:12:45.629 --> 00:13:13.359	Here we have assumed x of n is equal to a cos omega naught n plus v of n. So, the mean of this corrupted we call it as v of n is the error signal what we have put the thing is signal is given by mx is equal to a times expected value of cos omega naught n plus expected value of v of n which should be equal to 0.
34.srt	00:13:13.969 --> 00:13:16.669	So, from the previous example.
34.srt	00:13:17.049 --> 00:13:30.599	We know that for cos omega naught n it is nothing, but a square by 2 into cos omega naught k plus this one will be sigma v square delta of k that is our autocorrelation.
34.srt	00:13:31.089 --> 00:13:42.879	So, what happens to its power basically P x is of omega it is nothing, but a square by 2 into delta of omega naught plus sigma v square.
34.srt	00:13:43.329 --> 00:13:46.649	So, this one should be magnitude of omega should be less than.
34.srt	00:13:47.159 --> 00:13:50.009	pi in this case right.
34.srt	00:13:50.399 --> 00:13:56.049	So, now we will see how to look at the adaptive noise cancellation.
34.srt	00:13:56.879 --> 00:13:59.730	So, what is that adaptive noise cancellation?
34.srt	00:13:59.730 --> 00:14:05.970	We will first derive it and then we will see that how we can do the cancellation of it.
34.srt	00:14:06.509 --> 00:14:18.409	So, the adaptive noise cancellation is nothing, but this is an effective method to remove additive noises from the contaminated signals.
34.srt	00:14:18.990 --> 00:14:27.450	When do we say that it is additive along with the input sequence you have the noise that is what we consider we often hear.
34.srt	00:14:27.450 --> 00:14:36.009	So, with the desired signal if there is a noise then we call in the added fashion we call it as a additive noise.
34.srt	00:14:36.159 --> 00:14:50.409	So, it has been widely used in the fields of what are the applications in telecommunication.
34.srt	00:14:51.169 --> 00:14:53.519	Radar and sonar signal processing.
34.srt	00:14:54.120 --> 00:15:00.490	So, telecommunication we know that communication channel basically has the noise.
34.srt	00:15:00.490 --> 00:15:05.570	So, it depends on which channel you will be using it.
34.srt	00:15:05.570 --> 00:15:17.279	So, how to eliminate or cancel the noise we know about it and we have looked in the little bit of examples of radar and sonar I discussed in the previous classes.
34.srt	00:15:17.679 --> 00:15:20.830	So, radar when it is sending the signal.
34.srt	00:15:21.710 --> 00:15:22.840	when it comes back.
34.srt	00:15:22.840 --> 00:15:25.019	So, you know the medium may affect the signal.
34.srt	00:15:25.330 --> 00:15:38.379	So, how we are going to adapt to the different noises that is what it is going to be and even in the sonar we know that it is in the sea.
34.srt	00:15:38.570 --> 00:15:43.799	So, there will be different signals which is going to be refractive in nature.
34.srt	00:15:44.230 --> 00:15:52.379	So, those how you will be getting it and then from along with the rest of the noises how you will be separating it.
34.srt	00:15:52.779 --> 00:16:00.649	So, we have to cancel the noise and then take the signal that is what we call it as it is going to happen in adaptive way.
34.srt	00:16:01.179 --> 00:16:10.409	So, we say that one more example is most of you use ear earphones and then headphones.
34.srt	00:16:11.120 --> 00:16:22.970	So, what it says is your earphone and then headphone if they fit perfectly then what you say is you are unable to hear any outside noise.
34.srt	00:16:23.769 --> 00:16:34.549	So, they have to be filtered out and then you will say that high frequency noise is coming from your co-worker which has to be cancelled out.
34.srt	00:16:34.549 --> 00:16:38.850	So, you call them as chatty co-worker, I do not want to listen to them.
34.srt	00:16:38.850 --> 00:16:46.179	Then if nothing is going to come when you are wearing your earphone or headphone, then you say that you have cancelled the noise perfectly.
34.srt	00:16:46.919 --> 00:16:50.960	So, this we call it as active noise cancellation.
34.srt	00:16:55.239 --> 00:17:04.849	So, in this case it can be there are two noises what we call it one is passive noise and the other one is the active noise.
34.srt	00:17:05.159 --> 00:17:10.659	Here we call it as if you are unable to hear from outside as a passive noise.
34.srt	00:17:11.099 --> 00:17:16.789	So, we will define it in a while basically and then in the active noise cancellation.
34.srt	00:17:17.369 --> 00:17:23.679	So, what is the thing is going to happen your headphones are here, but neutralize the ambient noise.
34.srt	00:17:24.209 --> 00:17:25.659	So, you will be seeing that.
34.srt	00:17:25.870 --> 00:17:32.610	But in an aeroplane this thing engine noise or in a car engine noise is going to cause.
34.srt	00:17:32.980 --> 00:17:49.870	So if you are outside noise when you are driving or whatever may be the thing if you want to cancel it out you can use the noise cancelling technology basically, but still you will be left out with noise not completely gone.
34.srt	00:17:50.160 --> 00:17:52.690	So this we call it as a active noise.
34.srt	00:17:53.160 --> 00:17:54.490	So what is it?
34.srt	00:17:54.519 --> 00:17:57.049	Active noise work by incorporating.
34.srt	00:17:57.380 --> 00:18:09.860	microphones into your headphones which listen to the outside noise and generate a phase inverted sound that effectively cancel out your ambient noise before it reaches your ears.
34.srt	00:18:10.160 --> 00:18:15.000	So, exactly we want to cancel it which is may not be possible.
34.srt	00:18:15.029 --> 00:18:25.610	So, that is the reason why in the active noise cancellation you may hear little bit of noise present it most of it is suppressed.
34.srt	00:18:27.830 --> 00:18:39.330	That is what it says in other words your adaptive noise cancellation or active noise cancels noise by creating equal, but opposite noise.
34.srt	00:18:39.930 --> 00:18:51.029	So, when it will be desirable not desirable one can look at the literature and then work out what you want to design that is what it is going to depend on.
34.srt	00:18:51.880 --> 00:18:59.230	So, in the active noise cancellation it is best suited for real time implementations because.
34.srt	00:18:59.630 --> 00:19:12.380	When you are using the microphone recording some of the open air what you will call it as speech or music or whatever may be the thing.
34.srt	00:19:12.759 --> 00:19:23.470	So, if you can take with the one more mic the surrounding noise and use it as a noise and you want to suppress that you can do that.
34.srt	00:19:23.580 --> 00:19:25.500	This is how real time is going to work.
34.srt	00:19:25.500 --> 00:19:29.730	So, we will see some examples how we will be doing this cancellation.
34.srt	00:19:30.390 --> 00:19:45.130	So, we will ask the question whether the which has better sound quality whether whatever you have used the earphones and then earbuds are when you do the active noise cancellation which one will be good.
34.srt	00:19:45.530 --> 00:19:55.380	So, we will see two sets of earbuds ok, when you will say quality I have to compare two sets basically of earbuds.
34.srt	00:19:55.910 --> 00:19:59.860	So, in this case we will say it is from the similar build.
34.srt	00:20:00.400 --> 00:20:17.990	And, tuning quality what we have it is also similar and then the earbud with better passive noise isolation will be sounding better than the ones that rely on active noise cancellation to block out ambient noise.
34.srt	00:20:18.400 --> 00:20:24.570	So, you will be seeing that sometimes passive noise cancellation is better compared to active noise.
34.srt	00:20:31.049 --> 00:20:41.069	So, passive noise cancellation what we call it as PNC or isolation is when you are in headphones, earbuds or earphones or your monitors in ear monitors naturally block outside noise.
34.srt	00:20:41.460 --> 00:21:02.099	So, in other words in your earbuds are isolating you from ambient noise instead of actively using technology to cancel it out that is why you will hear this technique called both passive noise isolation and passive noise cancellation.
34.srt	00:21:02.710 --> 00:21:09.910	So, that is what the name given to it when you are fully disconnected from the external noises.
34.srt	00:21:10.580 --> 00:21:14.680	So, now we will see why we need adaptive filters.
34.srt	00:21:15.420 --> 00:21:17.860	So, we have discussed about the linear filters.
34.srt	00:21:17.860 --> 00:21:28.190	So, it should be triggering in your mind that both FIR and IR filters we used in the previous classes we have a.
34.srt	00:21:32.569 --> 00:21:39.299	They are called linear filters, it is not linear phase filters, they are linear filters.
34.srt	00:21:39.779 --> 00:21:43.170	Output is linear function of the filter input.
34.srt	00:21:44.009 --> 00:21:47.109	So, what are the design methods that are available?
34.srt	00:21:47.450 --> 00:21:57.390	So, we will see the classic approach, one is we can use the frequency selective filters such as we can use low pass, band pass or notch filters.
34.srt	00:21:58.049 --> 00:22:03.140	As you know low pass if I want to eliminate higher frequencies.
34.srt	00:22:03.590 --> 00:22:19.780	Band pass is only the frequency of interest what I want to pass it and notch filters you know certain single tone or multi tone you know the this thing frequency of them you can use the notch filters to suppress that.
34.srt	00:22:20.040 --> 00:22:29.280	As an example we had taken it as a line this thing frequency that is our electric lines 50 hertz what it is.
34.srt	00:22:29.519 --> 00:22:32.560	So, we can use the notch filter to eliminate it.
34.srt	00:22:33.090 --> 00:22:37.530	The other one is what we can design is the optimal filter basically.
34.srt	00:22:38.330 --> 00:22:48.810	So, how we are going to use this we will see it in a while and then this is mostly based on minimizing the mean square value of the error signal.
34.srt	00:22:49.430 --> 00:23:03.690	So, from the desired signal so, will be this thing subtracting from the original signal and see how much error is left out whether we can try to minimize that error what we will look at it and then design in.
34.srt	00:23:07.880 --> 00:23:09.910	optimal kind of filter.
34.srt	00:23:10.810 --> 00:23:17.340	So, there are 4 aspects involved with our adaptive filters which are they.
34.srt	00:23:17.890 --> 00:23:21.890	The first one is the signals being processed by the filter.
34.srt	00:23:22.890 --> 00:23:28.330	So, whatever input signal you are going to feed it how the filter structure is going to behave with it.
34.srt	00:23:29.480 --> 00:23:37.920	The other one is the structure to design this filter defines how the output signal of the filter is computed from it.
34.srt	00:23:38.230 --> 00:23:39.190	input signal.
34.srt	00:23:40.530 --> 00:23:49.950	The third one is the parameters within the structure that can be iteratively changed to alter the filters input output relationship.
34.srt	00:23:50.950 --> 00:24:00.430	So, usually we call this as weights by modifying the weights whether my input and output structure can be changed that is what we will be looking at it.
34.srt	00:24:01.090 --> 00:24:08.450	So, the next one is the adaptive algorithm that describes how the parameters are adjusted from.
34.srt	00:24:09.000 --> 00:24:12.020	1 time instant to the next times.
34.srt	00:24:12.730 --> 00:24:16.850	So, these are the 4 aspects of definition what we are going to follow.
34.srt	00:24:17.550 --> 00:24:21.020	So, now, we will compare with the real world signals basically.
34.srt	00:24:21.020 --> 00:24:39.890	What we want we are looking at is it is desired to extract a certain component of we call it D of n as the desired signal from the y of n whatever we have the output from that we want to extract our desired signal.
34.srt	00:24:40.680 --> 00:25:05.550	So, that this was contained in our input signal what we call it x of n or it may be to isolate a component of d of n within the error e of n that is not contained in x of n. So, whatever error which was introduced in between whether we can minimize that or isolated from that desired signal what we are looking at.
34.srt	00:25:12.060 --> 00:25:17.500	So, what does it look like here it is input is contaminated with noise.
34.srt	00:25:17.850 --> 00:25:20.590	So, we are trying to extract the desired signal.
34.srt	00:25:21.080 --> 00:25:27.790	The other one is if we know the error then we can model it and then get the thing.
34.srt	00:25:27.790 --> 00:25:40.720	Here what is it from the it is not contaminate input is not contaminated with the noise, but the channel make have a noise just like your communication channel is going to introduce the noise.
34.srt	00:25:41.120 --> 00:25:43.250	Any of that for that matter.
34.srt	00:25:43.620 --> 00:25:48.610	So, whether we know the thing whether we can extract from that the desired signal.
34.srt	00:25:49.200 --> 00:26:07.549	So, then what happens to get these things only we may vary the weights W of n and we may not be interested in what is my input, what is my output or even desired this thing input what I am going to have or a function.
34.srt	00:26:07.970 --> 00:26:16.090	So, I want to see the weights so that if I can match X of n and Y of n I know that what I want to have it as a result.
34.srt	00:26:16.920 --> 00:26:18.830	So, there are situation which.
34.srt	00:26:19.030 --> 00:26:25.480	in which what we say in the real time D of n is not available at all basically.
34.srt	00:26:25.950 --> 00:26:39.960	So, then what is the what you are looking at is also one of the important thing if you do not know what you have to look for it in such situations adaptation typically occurs only when D of n is available.
34.srt	00:26:40.519 --> 00:26:49.430	So, if you know only D of n or you pinpoint something what why I want to look at it then I can apply adaptive algorithm.
34.srt	00:26:49.980 --> 00:26:56.230	So, when d of n is unavailable then how we are going to deal with this kind of signal.
34.srt	00:26:56.750 --> 00:27:16.660	We typically use our most recent parameter estimates to compare our y of n in an attempt to estimate the desired response signal d of n. So, I know in the previous case I have got this output y of n and this output similarly looks like the previous one.
34.srt	00:27:17.130 --> 00:27:20.109	So, then I will try to see that.
34.srt	00:27:20.480 --> 00:27:25.870	this is what I wanted to have because in the previous one I had the desired signal basically.
34.srt	00:27:26.350 --> 00:27:31.310	So then I will be looking in the present situation this is what I am looking at.
34.srt	00:27:32.040 --> 00:27:35.730	So in some more real world situations what is it?
34.srt	00:27:35.730 --> 00:27:39.880	D of n is never available there it was not available it will be never available.
34.srt	00:27:52.220 --> 00:28:02.750	In such cases use your hypothetical blind that is predefined statistical behavior or amplitude characteristics to form suitable estimates of your d of n from the signals available to the adaptive filter.
34.srt	00:28:03.460 --> 00:28:08.220	So, such methods are collectively called blind adaptation algorithm.
34.srt	00:28:08.690 --> 00:28:12.190	Already I have told you hypothetical basically blind.
34.srt	00:28:12.590 --> 00:28:15.980	So, that is what you will be applying to get the desired signal.
34.srt	00:28:16.470 --> 00:28:22.230	So, these algorithms there are two varieties, one is the steeped descent algorithm.
34.srt	00:28:24.290 --> 00:28:28.920	The other one is the maximum likelihood of optimization.
34.srt	00:28:29.370 --> 00:28:33.970	In this present situation we will be covering steepest descent algorithm.
34.srt	00:28:33.970 --> 00:28:45.090	Those who are interested can look into the literature for maximum likelihood optimization algorithm to get the signal from the real world.
34.srt	00:28:45.930 --> 00:28:50.690	So, we will see now what is the generic block diagram for adaptive filter.
34.srt	00:28:51.430 --> 00:28:55.970	So, the signal along with noise.
34.srt	00:28:56.190 --> 00:29:08.890	or without noise characteristics are often non-stationary and the statistical parameters vary with time that is what we define our signal basically.
34.srt	00:29:08.890 --> 00:29:19.800	And then adaptive filter has an adaptation algorithm that is meant to monitor the environment and vary the filter transfer function accordingly.
34.srt	00:29:20.130 --> 00:29:26.700	So, based on the actual signals received, so what we are going to do?
34.srt	00:29:26.700 --> 00:29:30.660	Attempts to find the optimum filter design is going to be considered.
34.srt	00:29:32.180 --> 00:29:38.300	So, you are given the generic block diagram of an adaptive filter here, what does it contain?
34.srt	00:29:38.750 --> 00:29:50.430	X of n is an input and then what we have is the digital filter here, how these weights are going to be altered is from the adaptive algorithm.
34.srt	00:29:50.900 --> 00:29:56.480	As you can see dotted line which is going to change the weights of this filters.
34.srt	00:29:57.190 --> 00:30:02.020	Based on what this algorithm is going to work on, it is going to take the input.
34.srt	00:30:02.670 --> 00:30:22.150	And, then it is going to take we know in this case desired signal is known and then we will be subtracting our output from the filter and then the desired signal which we call it as error E of n. These are the two inputs to our adaptive algorithm.
34.srt	00:30:22.700 --> 00:30:31.050	So, based on the thing so, we will be minimize the error by varying our weights.
34.srt	00:30:31.410 --> 00:30:35.390	So, that is what error minimization here what we are going to do it.
34.srt	00:30:37.420 --> 00:30:46.560	So, how we are going to apply this adaptive filter for our FIR filter as an example we will see it.
34.srt	00:30:46.890 --> 00:30:51.090	So, this is our block diagram of FIR filter.
34.srt	00:30:51.190 --> 00:31:04.690	So, our data flow diagram what you can call it x of n is the input and earlier in a FIR sequence we had taken it as B0 n, B0 1 and then B L-1 of n.
34.srt	00:31:06.690 --> 00:31:22.900	So, L length filter what we have considered here we will call them as weight function because we are going to vary these weights w0, w1 and wL-1 and our input z-1 we know that in the z domain it is going to delay our input.
34.srt	00:31:22.900 --> 00:31:30.120	So, we will be delaying x of n as x of n-1 and then last one will be x of n-L plus 1.
34.srt	00:31:30.120 --> 00:31:32.400	So, this is the L length filter.
34.srt	00:31:32.430 --> 00:31:37.240	So, we know that convolution theorem y of n is given by.
34.srt	00:31:38.450 --> 00:31:58.550	L is equal to 0 to L minus 1, WL of n into S of n minus L. So, instead of giving X is input this is our source signal what we call it S of n minus L and WL will be weight of the filter what we will call it.
34.srt	00:31:58.840 --> 00:32:09.770	Now, represent this in terms of equation what we call it as a vector basically notation.
34.srt	00:32:10.110 --> 00:32:18.190	So, which is given by x of n will be x of n, x of n-1, x of n-l plus 1 transpose what we will have it.
34.srt	00:32:18.190 --> 00:32:37.800	So, and the coefficients vector also represented in this format, w of n is equal to w0n, w1, wl-1, l length coefficients what we are taking it, they transpose what we will be looking at.
34.srt	00:32:38.280 --> 00:32:38.980	So, now.
34.srt	00:32:40.280 --> 00:33:01.660	So, how we are going to represent now our y of n is nothing but w transpose of n into x of n or x transpose of n into w of n. So, you can see our summation in terms of vector multiplication is going to be represented in this fashion.
34.srt	00:33:02.370 --> 00:33:10.840	So, the filter output y of n is compared to the desired signal d of n to obtain the error signal.
34.srt	00:33:11.310 --> 00:33:36.490	So, we said from this equation we know that E of n is given by or y of n will be equal to what is it error function is nothing but desired signal d of n minus y of n. So, which is equal to d of n by substituting y of n with this it is going to be W transpose n into x of n then what we call it as error as.
34.srt	00:33:41.430 --> 00:33:56.750	in terms of our this thing random variable eta of n what we call it as error function which is equivalent to our expectation of e squared of n basically what we represent.
34.srt	00:33:57.180 --> 00:34:09.450	Then what is the thing here our eta of n is given by so expected value of we are taking the square error squared what we want to minimize basically.
34.srt	00:34:09.809 --> 00:34:12.570	So, we are taking the square on both sides of.
34.srt	00:34:13.160 --> 00:34:14.890	these 2 sides.
34.srt	00:34:14.890 --> 00:34:43.070	So, it will be eta of n is nothing, but expected value of d square of n. So, it is nothing, but what I am putting from here is we are calculating E square of n which is nothing, but d of n minus y of n whole square what we will be taking it by substituting y of n.
34.srt	00:34:43.250 --> 00:34:47.280	expanding it, so you will be getting this equation.
34.srt	00:34:47.470 --> 00:34:48.470	So, what is it?
34.srt	00:34:48.920 --> 00:35:14.360	Expected value of d squared of n minus will come to this because why we have called it as P transpose W of n plus W transpose of n into R into W of n. So, expand this where P is the cross correlation vector defined as expected value of d of n into X of n.
34.srt	00:35:15.740 --> 00:35:27.840	which is nothing, but the sequences Rdx of 0, Rdx of 1 etcetera and then Rdx of l minus 1 transpose what we will have it.
34.srt	00:35:28.620 --> 00:35:48.500	And then Rdx of k is nothing, but expected value of d of n plus k into x of n and then R is our autocorrelation matrix which is given by expected value of x of n into x transpose of n.
34.srt	00:35:50.330 --> 00:36:08.860	So, when you equate it here you will be seeing that d of n minus W transpose x of W transpose of n into x of n whole squared.
34.srt	00:36:09.470 --> 00:36:16.380	So, which comes down to you will be seeing that equal to d squared of n.
34.srt	00:36:22.230 --> 00:36:38.260	minus 2 into d of n into our w transpose of n into x of n and then what is the thing?
34.srt	00:36:39.030 --> 00:36:47.940	W squared function you will be getting it transpose x squared n.
34.srt	00:36:52.220 --> 00:37:05.050	when you take the expectation on both the sides, we have represented e squared of n as the expected value of e squared of n as the eta of n. So, you will be substituting it here in this equation.
34.srt	00:37:05.440 --> 00:37:21.440	So, you are seeing that Rdx is nothing, but expected value of d of n plus k into x of n that is our desired and then n what will be taking combining with the thing ok.
34.srt	00:37:21.820 --> 00:37:23.120	So, that will be our.
34.srt	00:37:23.920 --> 00:37:55.070	desired signal and then R is the autocorrelation matrix which is given by you will be seeing that which is nothing but expected value of X of n into X transpose of n. So, which is given by Rxx of 0, Rxx of 1 and then Rxx of L minus 1 is the filter length up to here and you will be seeing that Rxx of L.
34.srt	00:37:55.720 --> 00:37:58.200	and then 0 L minus 2.
34.srt	00:37:58.200 --> 00:38:03.000	So, you will be filling up this matrix in this way this is Rx is 0.
34.srt	00:38:03.280 --> 00:38:04.980	So, what is this matrix?
34.srt	00:38:05.340 --> 00:38:13.280	We call this is a symmetric matrix and Topolitz matrix since all the elements on the main diagonal are equal.
34.srt	00:38:13.280 --> 00:38:29.060	So, you will be seeing that all the things are equal here also you will be seeing that they will be equal ok. Then, consider the optimum filter with a fixed coefficient W1.
34.srt	00:38:29.390 --> 00:38:35.610	as which was illustrated in figure which will be shown here.
34.srt	00:38:36.180 --> 00:39:03.850	So, we say W0 is equal to 1 and W1 is the weight of the filter that is what shown in this figure we are assuming that and if the given signals x of n and d of n have characteristics given by this that is expected value of R x squared of n is equal to 1 and then expected value of x of n and x of n minus 1 is given as 0.5.
34.srt	00:39:05.010 --> 00:39:28.870	And then expected value of our desired signal d squared of n is given as 4 and then the cross correlation d of 1 and x of n is given as minus 1 and this thing what we call it as expected value of x of n with the delayed of its signal x of n minus 1 is also given as 1.
34.srt	00:39:29.440 --> 00:39:34.840	Then what is the problem to solve find the minimum square error.
34.srt	00:39:35.380 --> 00:39:38.989	function eta based on the fixed coefficient vector.
34.srt	00:39:39.590 --> 00:39:42.829	So, what are the coefficient vector we are going to have it.
34.srt	00:39:43.360 --> 00:39:51.960	So, in this case R has to be Rxx0, Rxx1 and then Rxxs1 and Rxx0.
34.srt	00:39:52.699 --> 00:40:03.690	So, which is given as 1 is 1 the other one is going to be 0.5 as you can see the thing x of n and x of n-1 is 0.5.
34.srt	00:40:06.079 --> 00:40:13.650	expected value of x square of n is 1 substitute this in the as a matrix form.
34.srt	00:40:13.679 --> 00:40:28.440	So this is 1, 0.5, 0.5 and 1 and your cross correlation matrix as you will be seeing it what is given as your rdx0, rdx1 that is what we are going to have it.
34.srt	00:40:28.440 --> 00:40:35.980	So what after substituting it is going to be minus 1 and then 1.
34.srt	00:40:37.119 --> 00:40:53.219	And, then eta is given by expected value of this equation d squared of n minus 2 P transpose W plus W transpose into R into W. So, substitute all the values.
34.srt	00:40:53.519 --> 00:41:11.380	So, we have been given expected value of d squared that desired signal is 4 and then minus 2 into this transpose minus 1 and 1 and then W is the vector what we have W naught is 1 and W1 has been given to you.
34.srt	00:41:11.809 --> 00:41:22.009	1 and w1 plus what we have minus 1 and w1 basically whole into your transpose what you are taking the thing.
34.srt	00:41:22.689 --> 00:41:29.829	So, it is 1.5.5 1 and then 1 and then w1.
34.srt	00:41:29.829 --> 00:41:39.559	So, now substitute the optimum the equation boils down to w1 squared minus w1 plus 7.
34.srt	00:41:39.599 --> 00:41:44.589	How we are going to calculate optimum filter we call the name as w0 basically.
34.srt	00:41:46.780 --> 00:41:57.469	Minimizes the mean square error function this eta of n that is by substituting r w not equal to p basically.
34.srt	00:41:57.869 --> 00:42:09.530	So, we will say that it is expected value of sorry eta of d squared of n r not into minimum of it what we have to compute fine.
34.srt	00:42:09.530 --> 00:42:15.389	Thus the optimum filter can be computed as.
34.srt	00:42:18.680 --> 00:42:27.740	W naught will be equal to this is what we will be substituting is R inverse P from this equation.
34.srt	00:42:28.480 --> 00:42:31.800	So, something is going to trigger in your mind.
34.srt	00:42:32.160 --> 00:42:37.010	So, we have to calculate the inverse of a matrix in this case.
34.srt	00:42:37.010 --> 00:42:42.890	So, you know the challenges will be facing in hardware implementation.
34.srt	00:42:43.519 --> 00:42:49.740	To give an example for the optimum filter, so we are going to consider.
34.srt	00:42:50.160 --> 00:43:17.980	an FIR filter with 2 coefficients w0 and then w1 the desired signal d of n is given by root 2 into sin omega 0 n for n greater than or equal to 0 and the reference signal x of n equal to your d of n minus 1 delayed function of it find w0 and then eta minimum what it is been given.
34.srt	00:43:27.310 --> 00:43:55.860	So, as we calculated with the previous example Rxx of 2 is given by expected value of x squared of n. So, which is given as expected value of d squared of n which is nothing but 1 and Rxx of 1 is equal to cos omega naught in this case and then Rxx of 2 is given by cos 2 omega naught and Rdx is 0 that is cross correlation and then which is equivalent to Rxx of 1.
34.srt	00:43:56.380 --> 00:44:01.200	Rdx of 1 is nothing but Rxx of 2.
34.srt	00:44:01.680 --> 00:44:19.550	So, by substituting these values, so we know that W0 is equal to R inverse of P, this is nothing but 1 and cos omega naught cos omega naught 1 and then minus 1 and then you will substitute your other parameters.
34.srt	00:44:19.550 --> 00:44:25.050	So, then by simplifying it, so what you will be getting is.
34.srt	00:44:26.710 --> 00:44:31.280	Eta is going to be with this function minimum what you have to calculate.
34.srt	00:44:31.910 --> 00:44:44.050	So, in practical applications what we call it as the computation of the optimum filter requires continuous estimation of our R and P when the signal is non stationary.
34.srt	00:44:44.880 --> 00:44:56.980	So, in addition if the filter length L is very large the dimension of the autocorrelation matrix that is L cross L is large thus the calculation of inverse matrix.
34.srt	00:44:57.470 --> 00:45:03.680	is going to come it becomes a bottleneck which requires intensive computation.
34.srt	00:45:04.400 --> 00:45:20.630	So, coming with the other example, so if the length of the filter if it L is assumed as 2, the error surface forms a 3 dimensional space called an elliptic paraboloid.
34.srt	00:45:21.460 --> 00:45:29.300	So, now if we cut the paraboloid with planes above eta minimum.
34.srt	00:45:29.790 --> 00:45:32.700	that are parallel to w naught minus 1 plane.
34.srt	00:45:33.790 --> 00:45:39.960	We have obtained concentric ellipses of constant mean square errors values.
34.srt	00:45:40.360 --> 00:45:49.100	To give you a flavor of it this is how it will be when you cut into the thing you will be getting the concentric circles what you can see it.
34.srt	00:45:49.720 --> 00:45:55.710	So, then these ellipses are called the error contours.
34.srt	00:45:56.270 --> 00:46:04.710	So, that is what was written there also and then we are going to consider an FIR filter with coefficient 2 coefficient w naught and w1.
34.srt	00:46:05.320 --> 00:46:09.960	And, the reference signal x of n is the 0 mean white noise with unit variance.
34.srt	00:46:10.280 --> 00:46:17.450	So, we have derived the thing this is our desired signal b0 x of n plus b1 into x of n minus 1.
34.srt	00:46:17.810 --> 00:46:21.310	So, the coefficient b0 and b1 have been given as 0.3 and 0.5.
34.srt	00:46:21.310 --> 00:46:30.560	So, you have to calculate the error surface and error contours basically using this equation as the derived signal.
34.srt	00:46:30.560 --> 00:46:38.180	So, you will be because it is a second order with the previous example and this example combined actually you are.
34.srt	00:46:39.130 --> 00:46:52.080	autocorrelation matrix is going to become 1 0 and 0 1 and then your p vector is going to be b0 and b1 and we have this is the error function eta what we are going to calculate.
34.srt	00:46:52.470 --> 00:47:14.350	So, put it in this equation and then substitute all the values then you will be combining b0 square plus b1 squared minus 2 b0 into w0 and minus 2 b1 w1 plus w0 square plus w1 square and substitute b0 is equal to 0.3 and b1 is equal to 0.5 then your eta is going to be.
34.srt	00:47:15.740 --> 00:47:21.640	0.34 minus 0.6 W naught minus W1 plus W naught square plus W1 squared.
34.srt	00:47:21.640 --> 00:47:46.640	So, the error function is given as this fine and if you calculate the contour for that using Matlab function defining giving these are your W naught are the 2 coefficients and then W other one coefficient what you will give it and error for 15 that is W1.
34.srt	00:47:47.670 --> 00:47:56.500	your 15 contours what you want to have it and then you calculate right plot the surface function.
34.srt	00:47:57.010 --> 00:48:03.800	So, using the steepest descent algorithm what you will be putting the thing ok.
34.srt	00:48:04.060 --> 00:48:20.030	So, when you calculate using the MATLAB what is it descent method is an iterative recursive technique that is starts from some arbitrary initial weight vector W of 0 and it is going to descends to the bottom of the bowl.
34.srt	00:48:20.570 --> 00:48:32.360	So, somewhere here you will be selecting it and you will be moving on the error surface basically in the direction of the negative gradient what you are going to go down.
34.srt	00:48:32.840 --> 00:48:38.130	So, that is estimated at that particular point and then go down.
34.srt	00:48:38.650 --> 00:48:45.930	So, examples of the error surface and error contours for L is equal to 2 what it is shown fine.
34.srt	00:48:46.250 --> 00:48:52.580	So, we will consider the what is it W of n plus 1 is the future.
34.srt	00:48:52.960 --> 00:48:57.460	weight vector is going to be computed by this equation.
34.srt	00:48:57.690 --> 00:49:08.310	How we are going to derive and then how we are going to calculate the steepest decent algorithm technique we will see in the next class.
34.srt	00:49:08.790 --> 00:49:17.150	So, we will be deriving the least mean squared error algorithm also using this technique.
34.srt	00:49:17.530 --> 00:49:20.430	So, happy learning and thank you.
34.srt	00:49:21.420 --> 00:49:23.040	We will meet you in the next class.
18.srt	00:00:01.050 --> 00:00:26.379	We come back to real time digital signal processing lab part of it.
18.srt	00:00:26.809 --> 00:00:33.979	So, we will see last class we have seen FIR sign generation, how we can use them in resonator.
18.srt	00:00:34.380 --> 00:00:39.810	and how the sign table can be used to generate a audio wave.
18.srt	00:00:40.149 --> 00:00:47.010	So, today we will see how the filter can be designed and then how it can be stored in different ways.
18.srt	00:00:47.010 --> 00:00:59.420	So, we will go back to our MATLAB and here again I will be using FDA toolbox to generate my filter coefficients from MATLAB.
18.srt	00:01:00.790 --> 00:01:06.569	So, you will be seeing that as I have been mentioning it will be using the filter designer in the next.
18.srt	00:01:06.759 --> 00:01:07.969	versions and other things.
18.srt	00:01:08.449 --> 00:01:11.739	So, still it accepts FDA tool at present.
18.srt	00:01:12.250 --> 00:01:21.849	So, we are going to design a low pass filter, I can make it full screen and then we can design the FIR filter.
18.srt	00:01:22.489 --> 00:01:28.239	So, here we will use the window technique and then I can specify the order here.
18.srt	00:01:28.569 --> 00:01:30.379	So, we will specify it as 30.
18.srt	00:01:30.530 --> 00:01:38.079	So, I will be getting n plus 1, it is going to be 30, 31 coefficients what it is going to generate.
18.srt	00:01:38.359 --> 00:01:42.039	So, window I can give it as Hanning window.
18.srt	00:01:42.769 --> 00:01:53.750	And, then the sampling frequency what we can give is 800 hertz and then we will see that cutoff frequency is 1000 hertz what I will give it.
18.srt	00:01:54.139 --> 00:01:56.799	So, then design the filter.
18.srt	00:01:58.609 --> 00:02:02.619	So, you will be seeing the magnitude response in this way.
18.srt	00:02:02.929 --> 00:02:08.939	So, you will be seeing that the cutoff frequency Hanning window is somewhere around between minus 40 and then 60.
18.srt	00:02:09.349 --> 00:02:14.229	So, you will be seeing the attenuation after 1 kilohertz it is dropped down.
18.srt	00:02:14.769 --> 00:02:23.109	1 at 1 kilohertz it will be minus 3 dB that is 0.7307 what it is going to come down and then it will be coming down fully.
18.srt	00:02:23.109 --> 00:02:34.590	So, you will be seeing that the response that is this has a linear response that is what we have been telling FIR filter in the pass band region as you can see it here.
18.srt	00:02:34.590 --> 00:02:42.000	Now, as last time we will be importing this coefficients to our this thing file dot h file what we can use it.
18.srt	00:02:48.840 --> 00:02:56.630	So, if you want what it suggests is double precision floating point, but since we are using in our processor.
18.srt	00:02:57.060 --> 00:03:04.700	So, I can specify that it can be 16 bit signed integer what I want to generate it.
18.srt	00:03:05.020 --> 00:03:16.900	So, if you want to give the processor board you can give here, if you specify here I am going to specify it as 6478.
18.srt	00:03:17.680 --> 00:03:20.590	So, this is going to select the target.
18.srt	00:03:21.180 --> 00:03:27.940	And, then we will generate the file basically as you will be seeing that variable name in the header.
18.srt	00:03:28.360 --> 00:03:30.900	So, what I am generating is fda coefficients.
18.srt	00:03:30.900 --> 00:03:39.380	So, we will go back and then put it in the document file at present I am storing it as you can see it is already there.
18.srt	00:03:39.380 --> 00:03:49.570	So, I can give it as fda coefficients 1 dot you are seeing the header file is generated is dot h file.
18.srt	00:03:50.360 --> 00:03:53.080	So, it says the board is not available.
18.srt	00:03:53.510 --> 00:03:55.890	But, still it is fine with us.
18.srt	00:03:55.960 --> 00:03:59.570	So, we will go and then check in our documents file.
18.srt	00:03:59.630 --> 00:04:04.250	So, you will be seeing FDA coefficients 1 here.
18.srt	00:04:04.860 --> 00:04:08.580	So, one of the way of doing get I will come in a while.
18.srt	00:04:08.890 --> 00:04:20.750	So, you will be seeing that the filter length is 31 and we have the direct form FIR representation and linear phase what it has designed and then type 1 filter what it has used it.
18.srt	00:04:21.170 --> 00:04:28.020	And then you will be seeing that it is stored in T and W types dot H basically in this.
18.srt	00:04:28.570 --> 00:04:32.590	file if you want to directly include it in your processor.
18.srt	00:04:32.910 --> 00:04:36.180	Since it has not taken it gives the warning.
18.srt	00:04:36.510 --> 00:04:42.260	So, we know the length is 31 and then it is in 16 what we have given the thing.
18.srt	00:04:42.630 --> 00:04:56.130	So, what I one of the way of doing it is I can take this coefficients and then go and paste it in my filter basically.
18.srt	00:04:59.569 --> 00:05:03.500	Here you are seeing that FIR is in the range of interrupt driven is there I will come to that in a while.
18.srt	00:05:03.790 --> 00:05:16.689	So, here I have one more FIR 1 kilohertz what it shows the thing I will be there are so, many main dot c. So, if you want you can call by this name.
18.srt	00:05:16.689 --> 00:05:19.189	So, that will not have any confusion.
18.srt	00:05:19.490 --> 00:05:24.080	So, you will be seeing that here in this case it is declared as float here.
18.srt	00:05:24.500 --> 00:05:30.670	So, what is the problem with R thing is I have declared it as.
18.srt	00:05:31.180 --> 00:05:33.800	int 16 underscore t in the thing.
18.srt	00:05:34.150 --> 00:05:39.480	So, whether we are going to go back and then declare it as float we will see it now.
18.srt	00:05:40.000 --> 00:05:50.620	So, we can go back and then I can call it as single precision which is going to be 32 bit float what I will be creating it and then I can generate it.
18.srt	00:05:50.980 --> 00:05:53.689	So, I will be overwriting on the same thing.
18.srt	00:05:53.970 --> 00:05:56.730	So, I want to overwrite this ok.
18.srt	00:05:57.290 --> 00:06:01.699	So, and then if I go and then open this one.
18.srt	00:06:02.220 --> 00:06:05.710	So, these are the values what you will be seeing in the floating point.
18.srt	00:06:05.710 --> 00:06:28.920	So, I can take this values control c what I can do and then go into my CCS studio and then I can paste it.
18.srt	00:06:36.350 --> 00:06:38.030	lot of it which has got opened.
18.srt	00:06:38.030 --> 00:06:39.710	So, that is why it was hiding in the thing.
18.srt	00:06:40.189 --> 00:06:48.080	Now, what I can here because I thought I will not change this n that is the reason why I gave even 31st order.
18.srt	00:06:48.420 --> 00:06:51.680	So, if I want I can go and then paste here ok.
18.srt	00:06:52.220 --> 00:06:58.220	So, the what was the cutoff frequency used in this case is 1 kilohertz.
18.srt	00:06:58.550 --> 00:07:02.460	So, that is a name what it gives is FIR 1 kilohertz.
18.srt	00:07:02.820 --> 00:07:05.480	So, what we will do is we will do.
18.srt	00:07:09.870 --> 00:07:11.620	debug this code.
18.srt	00:07:19.040 --> 00:07:31.000	So, you can see that it is building the console and then it is now written on to the board and then we have got the code ok.
18.srt	00:07:31.070 --> 00:07:36.810	So, what I will do is I will select the frequency here.
18.srt	00:07:39.780 --> 00:07:42.060	component what I have to run ok.
18.srt	00:07:42.350 --> 00:07:45.670	So, we will select this as 800 hertz.
18.srt	00:07:45.780 --> 00:07:49.280	So, which it should be able to play on our output.
18.srt	00:07:50.010 --> 00:07:53.160	So, I will run the thing here my code.
18.srt	00:07:53.190 --> 00:07:56.050	So, and then play the 800 hertz sine wave.
18.srt	00:08:07.750 --> 00:08:08.540	So, you will be hearing a tone coming out of this.
18.srt	00:08:37.290 --> 00:08:39.300	Hope you are able to hear the tone.
18.srt	00:08:39.650 --> 00:08:47.380	Otherwise, you can try it on your own and then you will be hearing that tone of 800 hertz to come out.
18.srt	00:08:47.590 --> 00:09:02.300	So, sorry I will what I want to show again is that when we are playing one little more than the 1 kilohertz.
18.srt	00:09:02.680 --> 00:09:06.080	So, you will not be hearing the tone.
18.srt	00:09:06.120 --> 00:09:09.820	So, we will change the tone here so that it becomes.
18.srt	00:09:10.800 --> 00:09:18.970	I can go and then search in the directory.
18.srt	00:09:19.000 --> 00:09:23.100	So, we have tones generated lot of them.
18.srt	00:09:23.100 --> 00:09:27.400	So, if I press 2000 hertz it should have got attenuated.
18.srt	00:09:27.400 --> 00:09:30.160	So, you will be hearing blank in this case.
18.srt	00:09:30.190 --> 00:09:31.380	So, I will play this.
18.srt	00:09:31.860 --> 00:09:33.930	As you can see that.
18.srt	00:09:45.510 --> 00:09:50.210	is attenuating anything above 1 kilohertz in this case.
18.srt	00:09:50.550 --> 00:09:52.580	So, that is the one of the example.
18.srt	00:09:52.910 --> 00:09:58.250	Now how to store our coefficients in a different way we will see it.
18.srt	00:09:58.670 --> 00:10:02.950	So, in this case what we did was we cut and pasted within the code.
18.srt	00:10:02.950 --> 00:10:15.110	The other way of doing it is as you can see that in this I call it as FIR interrupt driven basically.
18.srt	00:10:15.440 --> 00:10:21.270	So, you see that your main FIR filter is here and then you can include the file lp55.h.
18.srt	00:10:21.970 --> 00:10:35.470	So, you are seeing that as a include file whatever generated from MATLAB as you can see that this is the 11th order filter what you have it here generated.
18.srt	00:10:35.470 --> 00:10:45.210	So, you will be seeing this one completely as a dot h file directly you can store it in the thing.
18.srt	00:10:47.080 --> 00:10:54.710	In this case how this FIA filter is working, we will just see the code once.
18.srt	00:10:55.160 --> 00:11:02.340	So, what we say is as I have been mentioning this is a interrupt driven, here interrupt 4 is going to be accessed.
18.srt	00:11:02.720 --> 00:11:14.780	So, what happens to this, we are calling our i is the continuous counting length what we are going to have it and then you are initializing your output to 0.
18.srt	00:11:15.540 --> 00:11:16.880	And then you are getting the.
18.srt	00:11:17.120 --> 00:11:19.810	input x of 0 is the first input.
18.srt	00:11:20.170 --> 00:11:30.240	So, we know that it is a float and then we get from the right sample from input from ADC compute your filter output.
18.srt	00:11:30.570 --> 00:11:42.350	Then what you are going to do for i is equal to 0 to i less than n. So, you should be calculating your y n plus this is the length of the filter what I have it.
18.srt	00:11:42.800 --> 00:11:47.180	So, from here you will be computing your.
18.srt	00:11:47.640 --> 00:11:54.090	y n plus equal to your h of i multiplied with x of i.
18.srt	00:11:54.690 --> 00:11:59.040	So, how you are going to update your weights in the filter.
18.srt	00:11:59.410 --> 00:12:05.600	So, for i is equal to n minus 1, i greater than 0, i minus minus.
18.srt	00:12:05.930 --> 00:12:10.380	So, your updation has to happen in the reverse.
18.srt	00:12:10.860 --> 00:12:20.210	So, the last what we call it as h of n has to be thrown out and then the rest of them has to be moved into here.
18.srt	00:12:23.170 --> 00:12:31.400	So, that this axis circular buffer basically and x of i is going to be x of i minus 1 value what you will be storing it.
18.srt	00:12:31.860 --> 00:12:38.050	So, that and then x of 0 first one what you will be taking it later.
18.srt	00:12:38.530 --> 00:12:48.510	Output channel so, which is multiplied by 32000 basically we have that is a maximum value as we discussed in the last class also.
18.srt	00:12:48.820 --> 00:13:01.430	So, it goes to our DAC and then return and then as usual in the previous demo we have seen that it is initially it is interrupt driven what we have taken it.
18.srt	00:13:01.820 --> 00:13:05.350	and then 8000 hertz what we are running.
18.srt	00:13:05.790 --> 00:13:16.440	So, both ADC and DAC gain we have made it as 0 and then we will be taking it from the line input of the board and this will run for continuously.
18.srt	00:13:16.690 --> 00:13:31.270	So, if I stop here also the code will be running unless I reset the processor from the board or you will be recompiling and then putting one more code on to the thing.
18.srt	00:13:32.680 --> 00:13:35.280	So, that is what is going to happen.
18.srt	00:13:35.610 --> 00:13:46.390	So, this is how will be what will I will call it as MATLAB and then code composer will go in hand in hand for designing your FIR filter.
18.srt	00:13:46.840 --> 00:13:47.710	So, coming to IR filter.
18.srt	00:13:48.110 --> 00:13:56.220	So, demo we will see in the next class, but we can do the MATLAB design here.
18.srt	00:13:56.220 --> 00:14:06.430	So, I will be showing you the demo also although we have seen it in the last class I do not know how much you have given attention to that.
18.srt	00:14:06.850 --> 00:14:09.130	So, I will give that as IR filter.
18.srt	00:14:09.550 --> 00:14:12.360	So, whether I want Butterworth filter or Chebyshev.
18.srt	00:14:12.640 --> 00:14:17.050	So, we will see their responses as I have been mentioning get.
18.srt	00:14:17.050 --> 00:14:21.890	So, we will go for the minimum order design in this case.
18.srt	00:14:22.320 --> 00:14:31.270	So, we have to what we are going to match exactly whether I want to match stop band criteria or the pass band criteria.
18.srt	00:14:31.780 --> 00:14:37.070	So, if you are not sure it is better to select stop band criteria because.
18.srt	00:14:37.500 --> 00:14:44.150	are what we call it as aliasing is not going to happens.
18.srt	00:14:44.480 --> 00:14:48.810	So, it is better to choose top band criteria to meet the thing.
18.srt	00:14:49.230 --> 00:14:52.050	Based on it the order of the filter is going to be designed.
18.srt	00:15:08.160 --> 00:15:13.770	So, what I will design is here 8000 hertz and then my pass band I can keep it as this thing 3 dB what I want to come for 1000 hertz and then I want 1200 what I can choose it as my stop band.
18.srt	00:15:14.090 --> 00:15:17.740	So, and I have to specify in IR filter.
18.srt	00:15:18.230 --> 00:15:21.980	So, what is my pass band ripple usually we keep it at 1.
18.srt	00:15:22.060 --> 00:15:25.640	So, if you want 0.5 we can select the thing it depends on your application.
18.srt	00:15:25.640 --> 00:15:33.470	And in the stop band whether I want to go down 80 dB or 90 dB or 60 dB what we have to specify.
18.srt	00:15:33.470 --> 00:15:38.580	So, we will see that we will at present we will give this and then design the filter.
18.srt	00:15:39.960 --> 00:15:51.380	So, you will be seeing that your filter is getting designed and you can see that the order has gone to 48th order fine.
18.srt	00:15:51.680 --> 00:16:06.010	If I have not given any specification for the order, it has gone to 48th and number of sections as we know we will be using the second order sections it is 24.
18.srt	00:16:06.840 --> 00:16:10.200	In the theory class what I mentioned was.
18.srt	00:16:10.500 --> 00:16:17.860	not to go beyond 12th order filter what I said the thing otherwise we may have the oscillation.
18.srt	00:16:18.190 --> 00:16:23.750	But MATLAB has the capability whether it can design a stable filter.
18.srt	00:16:24.170 --> 00:16:30.260	As you will be seeing that if it gives it is a stable filter still you can go with this order filter.
18.srt	00:16:31.080 --> 00:16:42.470	And then how will you will be seeing the response as you can see the thing and we will see its phase response.
18.srt	00:16:42.970 --> 00:16:48.540	As we are telling that it is not going to maintain its this thing phase.
18.srt	00:16:50.850 --> 00:16:53.790	So, this is together what I am plotting the thing.
18.srt	00:16:54.290 --> 00:17:00.410	So, this is my frequency response and then this is my phase.
18.srt	00:17:00.410 --> 00:17:12.690	So, if you want to see only the phase magnitude response is this way and then this is my in dB what it is going to show me the magnitude response up to 1 kilohertz.
18.srt	00:17:13.060 --> 00:17:17.560	it is almost 0 after that it is start coming down ok.
18.srt	00:17:17.960 --> 00:17:24.000	So, this is just the phase response.
18.srt	00:17:24.340 --> 00:17:34.110	So, you will be seeing that pass band is 1 kilohertz what we have given the thing like FIR filter it does not have a linear phase.
18.srt	00:17:34.450 --> 00:17:43.970	So, for every frequency you will be seeing that there is a change in the thing that is why we call it as non-linear phase.
18.srt	00:17:45.150 --> 00:17:46.960	IR filter ok.
18.srt	00:17:47.280 --> 00:17:53.090	So, what I want to do is how I can order of the filter I can come down ok.
18.srt	00:17:53.530 --> 00:17:56.130	So, I do not want to design so much better order.
18.srt	00:17:56.550 --> 00:17:57.890	There are two ways of it.
18.srt	00:17:57.890 --> 00:18:08.660	One is I can increase my transition band and say that then with the same Butterworth filter I can go down in the order.
18.srt	00:18:09.120 --> 00:18:15.170	The other one is either I can select the Chebyshev or Elliptic actually.
18.srt	00:18:15.410 --> 00:18:18.900	So, we will see Chebyshev type 2 what is the thing is going to happen.
18.srt	00:18:18.900 --> 00:18:20.350	So, we will design the filter.
18.srt	00:18:21.280 --> 00:18:30.330	So, my you will be seeing that your what is it phase response is not going to be linear even in this case.
18.srt	00:18:30.670 --> 00:18:39.240	So, you are seeing that from 24th order it has dropped down to 16 using my Chebyshev design.
18.srt	00:18:39.790 --> 00:18:45.130	So, then what we are going to do is we will see what happens with the elliptic.
18.srt	00:18:45.130 --> 00:18:47.750	So, you will be seeing the magnitude response sorry.
18.srt	00:18:48.110 --> 00:18:49.860	this is the magnitude response.
18.srt	00:18:50.140 --> 00:18:58.330	So, you will be seeing in Chebyshev 2 you have the oscillation in the stop band and it is going to give you a flat response in the pass band.
18.srt	00:18:58.780 --> 00:19:20.910	So, if you do not can allow oscillations in the pass band and then you want a flat response because I do not want any other frequency that is higher order frequencies aliased into my system then what I can do is I can go for Chebyshev type 1 and then I can design the filter.
18.srt	00:19:21.540 --> 00:19:28.620	So, you will be seeing that your magnitude it is I have to increase the thing.
18.srt	00:19:28.930 --> 00:19:33.010	So, in the stop band you will be seeing no oscillations are formed.
18.srt	00:19:33.700 --> 00:19:40.300	So, I want the lowest order then what happens I can go with the elliptic design.
18.srt	00:19:40.650 --> 00:19:45.230	So, you will be having match exactly both of it I will be designing it.
18.srt	00:19:45.510 --> 00:19:48.760	So, you will be seeing how much order it is going to come down.
18.srt	00:19:49.050 --> 00:19:51.970	So, you are seeing that order has.
18.srt	00:19:52.440 --> 00:19:57.070	come down to 9th order and number of sections have to be 5.
18.srt	00:19:57.600 --> 00:20:05.990	So, the last section will not have the it will be a first order section instead of second order because it should be multiple of 2.
18.srt	00:20:06.480 --> 00:20:11.390	So, the fifth section will have only the single order filter.
18.srt	00:20:11.590 --> 00:20:13.920	So, we will see the coefficients in a while.
18.srt	00:20:14.310 --> 00:20:18.700	So, as you can see you have a ripple in the pass band as well as in the stop band.
18.srt	00:20:19.290 --> 00:20:21.840	So, if I want to save this.
18.srt	00:20:23.810 --> 00:20:26.700	So, this is what the filter specification you have given.
18.srt	00:20:26.780 --> 00:20:29.950	So, I can give the same target as my code composer studio.
18.srt	00:20:30.380 --> 00:20:37.680	So, you will be seeing now from the FIR filter you have got both numerator and then denominator coming in.
18.srt	00:20:38.130 --> 00:20:43.970	So, IR filter as we know it is a feedback concept what it is going to use.
18.srt	00:20:43.970 --> 00:20:46.480	So, it will be having both numerator and denominator.
18.srt	00:20:46.670 --> 00:20:52.880	So, I will be still keeping it as single precision float.
18.srt	00:20:55.770 --> 00:21:03.230	And, then I can generate this and then we will call it as FDA coefficients 2 ok.
18.srt	00:21:03.710 --> 00:21:09.840	So, I can save this and then go and then check the thing.
18.srt	00:21:09.840 --> 00:21:21.850	So, as you can see how much order which has come down from 31 order to 9th order using our elliptic filter using the IR filter.
18.srt	00:21:22.300 --> 00:21:26.000	So, you will be seeing that what it says is it is a real.
18.srt	00:21:28.720 --> 00:21:34.610	And, then number of sections is going to be 5 and then whether it is a stable filter or not what it will give you.
18.srt	00:21:34.610 --> 00:21:45.590	So, it says yes and then how the coefficients are going to be represented in this because I need both what we call it as numerator and denominator.
18.srt	00:21:46.030 --> 00:21:55.090	So, it will be shown as this is the scaling factor what we discussed in the last class today also we will be seeing it.
18.srt	00:21:55.450 --> 00:21:57.060	Why we have to go for the scaling?
18.srt	00:21:57.580 --> 00:22:00.540	Static scaling for each sections.
18.srt	00:22:00.910 --> 00:22:04.170	what MATLAB is going to give out ok.
18.srt	00:22:04.590 --> 00:22:29.830	So, it will be this is my this thing coefficients what I have it in the because these are 2 are 0s, this is my a 1 is 1 always you will be seeing it, this is my a 2 coefficient minus 1.2315 and sorry this is a 0, this is a 1.
18.srt	00:22:31.870 --> 00:22:36.930	and this is a2 ok. And then you will be seeing 0s here.
18.srt	00:22:37.900 --> 00:22:42.220	So, that is how the scaling function.
18.srt	00:22:42.220 --> 00:22:52.150	So, and then the second section what you will be seeing it here and then all what it says is it has 3 values what it will be giving you the thing.
18.srt	00:22:52.150 --> 00:22:59.150	So, we will discuss our scaling and then come back and then see the thing.
18.srt	00:23:02.330 --> 00:23:06.440	how many sections I am going to have it you will be seeing it.
18.srt	00:23:06.440 --> 00:23:11.470	So, there are 5 sections in this case fine.
18.srt	00:23:12.750 --> 00:23:15.350	What output you will be getting?
18.srt	00:23:15.350 --> 00:23:18.250	The last one will have only 2 of them.
18.srt	00:23:18.420 --> 00:23:27.279	So, this is how you are if you want to see the pole positions you will be seeing it in your MATLAB.
18.srt	00:23:41.120 --> 00:23:44.530	So, you will be seeing second order section filters what you will be seeing the thing ok.
18.srt	00:23:50.330 --> 00:23:54.600	So, you have the pole 0 positions based on it.
18.srt	00:23:54.980 --> 00:24:11.550	So, you are seeing that circles are represented with 0s and then what you are seeing this cross are your poles, how they are located what you are seeing that this is a complex conjugate what you are going to.
18.srt	00:24:11.790 --> 00:24:17.690	have it and then the grouping it is going to do automatically using MATLAB.
18.srt	00:24:18.120 --> 00:24:22.670	So, just if you want to see the values of them.
18.srt	00:24:22.670 --> 00:24:24.560	So, what it is going to give?
18.srt	00:24:24.600 --> 00:24:48.730	So, you will be seeing that numerator is 1 and then this is b naught is 1 and b 1 b 2 is 1 and this is b 1 value and denominator value this is a 0 a 1 and then a 2 and gain of that section what it is giving the section first and then after that you will be going with section 2.
18.srt	00:24:49.170 --> 00:24:53.980	So, this is how you will be getting the values as your output from the MATLAB.
18.srt	00:24:53.980 --> 00:24:58.340	So, we will see the demo and then come back.
18.srt	00:24:58.340 --> 00:25:04.660	You will be seeing how IAR filter code is going to be written.
18.srt	00:25:04.710 --> 00:25:06.420	So, this is with DSK6713.
18.srt	00:25:06.740 --> 00:25:19.270	So, you will see signed integer and then how this is order of the filter is what it is shown filter coefficients this is how band stop filter for.
18.srt	00:25:22.170 --> 00:25:28.460	900 hertz what it has been designed and then this is for a 2700 hertz.
18.srt	00:25:28.920 --> 00:25:34.030	So, we will see the demo of this in the next class.
18.srt	00:25:34.300 --> 00:25:42.180	So, this is how you will be writing the code in C, the more detail of it what I will come back and then discuss.
18.srt	00:25:42.390 --> 00:25:49.730	So, we will see this thing MATLAB code how it has been written.
18.srt	00:25:59.210 --> 00:26:06.080	I have to change the folder ok.
18.srt	00:26:06.500 --> 00:26:13.860	So, one of the issue with this is what will be reading is the corruptive voice dot wave in this.
18.srt	00:26:14.200 --> 00:26:24.820	So, what wave read has been removed and then in the latest version it is the audio read basically.
18.srt	00:26:24.930 --> 00:26:26.450	So, these are the ones.
18.srt	00:26:27.810 --> 00:26:37.740	So, one has to change it to as you can see it is telling it is error ok in the line 8 if you go with the thing.
18.srt	00:26:38.090 --> 00:26:56.280	So, it says that it has to be audio read instead of wave read sorry I have given let us see whether it is going to run or not otherwise whatever still I have a error ok.
18.srt	00:26:56.630 --> 00:26:57.620	So, this is.
18.srt	00:26:58.140 --> 00:27:03.120	also here which has to be replaced with audio read basically.
18.srt	00:27:03.890 --> 00:27:22.490	So, it needs these are the errors file name range and then data type what it has an error in the case which has to be fixed and then we have to correct it and then come back fine.
18.srt	00:27:23.110 --> 00:27:27.620	So, this is how you will be.
18.srt	00:27:28.200 --> 00:27:38.200	from one version this was implemented in 2016 B basically version and now what I am using is 2020 B.
18.srt	00:27:38.560 --> 00:27:41.670	So, we will see the corrected one in the next class.
18.srt	00:27:42.080 --> 00:27:44.250	So, thank you for listening.
18.srt	00:27:44.840 --> 00:27:47.920	So, we will come back in the next class for the demo.
30.srt	00:00:01.219 --> 00:00:25.690	Welcome back to real time digital signal processing course.
30.srt	00:00:25.929 --> 00:00:29.550	Today we will discuss about continue with our FFT.
30.srt	00:00:30.059 --> 00:00:35.770	So, in the last class we discussed about FFT for fast computation.
30.srt	00:00:36.170 --> 00:00:54.820	how it is going to help us in speeding up our computation from DFT and then we saw that what are the quantization effects of our FFT in computation and then how we are going to do the scaling.
30.srt	00:00:55.270 --> 00:01:06.079	So, today we will talk about little bit on computation aspects of DFT and then FFT with examples.
30.srt	00:01:06.560 --> 00:01:13.800	So, we call discrete Fourier transform pair as analysis and synthesis equations.
30.srt	00:01:14.109 --> 00:01:25.860	So, analysis equation is given by x of k is equal to n is equal to 0 to x of n e power minus j 2 pi n by n where k is going 0 to n minus 1.
30.srt	00:01:25.860 --> 00:01:37.400	So, we can represent this with the piddle factors and inverse DFT as we know it is IDFT which is given by x of n we have the scaling function 1 by.
30.srt	00:01:37.629 --> 00:01:51.210	n for k is equal to 0 to n minus 1 x of k into W n k. Here it is W n k, here it is going to be W n minus n k what we will be taking it according to the twiddle factors.
30.srt	00:01:51.659 --> 00:02:03.319	To derive this x of n what we can do is we can substitute our x of k with this equation and then derive the thing.
30.srt	00:02:03.319 --> 00:02:07.159	So, for this derivation that x of n becomes x of n.
30.srt	00:02:07.640 --> 00:02:14.750	And why we have the 1 by n scaling function also you can refer to any of the digital signal processing book.
30.srt	00:02:15.020 --> 00:02:22.439	So, which will give you how to derive our that is analysis substitution in synthesis get our x of n back.
30.srt	00:02:22.439 --> 00:02:24.069	So, now we will see with few examples.
30.srt	00:02:24.099 --> 00:02:33.829	So, we first will determine the endpoint DFT of the following sequence for n greater than or equal to our length l what we call it.
30.srt	00:02:33.829 --> 00:02:38.319	So, x of n is equal to 1 in the 0 to n.
30.srt	00:02:43.090 --> 00:02:49.410	than or equal to n less than or equal to l minus 1 and which is going to be 0 otherwise.
30.srt	00:02:49.770 --> 00:02:55.610	So then we can represent our DFT of x of n up to length l minus 1.
30.srt	00:02:56.060 --> 00:03:12.810	So that is x of omega or x of k what we can take it which is going to be in this case we are assuming x of omega that is DTFT discrete time Fourier transform.
30.srt	00:03:13.220 --> 00:03:15.890	Here the amplitudes are discrete.
30.srt	00:03:16.490 --> 00:03:25.060	And, then our frequency is continuous that is the reason why omega is there which omega is going to vary 0 to 2 pi basically.
30.srt	00:03:25.400 --> 00:03:36.480	Then DTFT is given as x of n into e power minus j omega n and then when we substitute that we have got x of n is equal to all 1's.
30.srt	00:03:36.870 --> 00:03:52.520	So, then what happens to that n is equal to 0 to l minus 1 e power minus j omega n. So, this what will be representing with sin omega l by 2 divided by sin omega by 2 into e power minus j omega l minus 1.
30.srt	00:03:53.090 --> 00:03:54.140	divided by 2.
30.srt	00:03:54.490 --> 00:03:57.470	So, what happens to our x of omega?
30.srt	00:03:57.920 --> 00:04:08.270	So, this is what our equation is I think something it must be boggling in your mind basically we call this as a sinc function.
30.srt	00:04:08.880 --> 00:04:17.460	So, x of k if we calculate that in the DFT domain this was in the DTFT.
30.srt	00:04:17.880 --> 00:04:27.800	So, then what happens to this equation sin 2 pi k by n l divided by 2 and then here also sin 2 pi k by n.
30.srt	00:04:28.300 --> 00:04:35.760	divided by 2 and then this e power minus j 2 pi k by n into l minus 1 divided by 2.
30.srt	00:04:36.200 --> 00:04:54.160	So, this is what we will be getting it if our x of n is we call it as unity step function basically here u of n basically n is in this case l minus 1 length.
30.srt	00:04:55.000 --> 00:05:00.730	So, then we will take a simple example to see that how we are going to compute.
30.srt	00:05:01.170 --> 00:05:05.410	are DFT from small example.
30.srt	00:05:05.410 --> 00:05:22.890	So, what it says is we have to do the plot and calculate the magnitude phase spec plot the magnitude and phase spectrum of the sample data sequence it is just 2001 ok, 4 point what we have to calculate.
30.srt	00:05:23.230 --> 00:05:34.480	So, which was obtained using a sampling frequency of 20 kilohertz and verify the DFT result using IDFT also whatever DFT values we have got it.
30.srt	00:05:34.829 --> 00:05:35.829	how to verify it.
30.srt	00:05:35.829 --> 00:05:39.139	So, we have to do IDFT then we have to get back the signal.
30.srt	00:05:39.590 --> 00:05:44.770	So, we will see with the because it is the small value what we have taken the thing 4 bit.
30.srt	00:05:45.110 --> 00:05:48.340	So, our x 0 what we will calculate first.
30.srt	00:05:48.660 --> 00:05:59.280	So, for that n is equal to 0 to 3 x of n because our k is equal to 0 in this case correct.
30.srt	00:05:59.569 --> 00:06:01.629	So, e power minus j will be 1.
30.srt	00:06:01.629 --> 00:06:13.530	So, it is x of n. So, it is nothing, but 2 plus 0 plus 0 plus 1 which is equal to 3 which is magnitude is 3 and then it is at an angle of 0 degrees.
30.srt	00:06:13.949 --> 00:06:22.509	And then we will calculate x of x1 basically, n is equal to 0 to 3 and then x of n e power minus j.
30.srt	00:06:22.939 --> 00:06:34.000	So, which is equal to what is it x of n into e power minus j pi by 2 because it is n capital n is equal to 4.
30.srt	00:06:34.000 --> 00:06:39.129	So, which comes down to minus j pi by 2 into n basically.
30.srt	00:06:39.509 --> 00:06:48.610	So, when you substitute the values for expand your summation it is going to be a first one is x of 0 is 2.
30.srt	00:06:48.800 --> 00:06:49.039	2.
30.srt	00:06:49.479 --> 00:06:58.899	So, it is going to be 2 and the other 2 values what we have taken for simplicity is 0 and then the last one is 1 when n is equal to 3.
30.srt	00:06:59.209 --> 00:07:02.300	So, this becomes e power minus j 3 pi by 1.
30.srt	00:07:02.839 --> 00:07:11.459	So, if you substitute for e power minus j in cos and sin you will be seeing 2 plus cos 3 pi by 2 minus j sin 3 pi by 2.
30.srt	00:07:11.829 --> 00:07:16.360	So, you will be getting this as 2 plus j.
30.srt	00:07:17.029 --> 00:07:19.409	So, this is 0.
30.srt	00:07:19.670 --> 00:07:21.300	and this is minus 1.
30.srt	00:07:21.649 --> 00:07:24.310	So, it will be plus j 2 plus j.
30.srt	00:07:24.600 --> 00:07:30.410	So, when you calculate your magnitude it is going to be 2.236 at an angle of 26.57 degrees.
30.srt	00:07:30.410 --> 00:07:37.329	So, magnitude is computed with square root of real squared plus imaginary squared ok.
30.srt	00:07:37.329 --> 00:07:47.680	So, that is the value you will get it and then the angle will be tan inverse what you can see imaginary divided by your real.
30.srt	00:07:47.680 --> 00:07:51.980	So now, calculate the x 2 next stage.
30.srt	00:07:53.269 --> 00:08:00.110	So, here also you will be seeing that 3 components are left out it is going to be e power minus j 3 pi.
30.srt	00:08:00.220 --> 00:08:06.660	So, it is going to be cos 3 pi minus j sin 3 pi.
30.srt	00:08:07.079 --> 00:08:19.389	So, this comes out as you can see that it is going to be minus 1 and this j term is 0.
30.srt	00:08:19.990 --> 00:08:26.519	So, it becomes 2 minus 1 which is equal to 1 it is also 1 at an angle of 0 degrees.
30.srt	00:08:26.889 --> 00:08:29.819	There are 2 ways of computing your x 3.
30.srt	00:08:30.189 --> 00:08:33.779	So, one is here what is shown is direct computation.
30.srt	00:08:34.149 --> 00:08:37.690	So, what you arrive at is 2 minus j.
30.srt	00:08:38.029 --> 00:08:42.050	So, this is at a 2.236 at an angle of minus 26.57 degrees.
30.srt	00:08:42.050 --> 00:08:43.940	This is one method.
30.srt	00:08:43.940 --> 00:08:54.740	The other one is you can use the periodicity property basically and we know that x3 is equivalent to x1 conjugate.
30.srt	00:08:54.940 --> 00:09:00.490	So, then what happens I will be taking 2 and minus j.
30.srt	00:09:01.720 --> 00:09:05.870	So, this is the way what you will be substituting.
30.srt	00:09:06.439 --> 00:09:11.379	So, now we will see how the magnitude and phase response is going to look like.
30.srt	00:09:11.659 --> 00:09:19.370	So, we have been given the sampling frequency fs as 20 kilohertz and then our n is 4.
30.srt	00:09:19.699 --> 00:09:23.970	So, if I substitute fs by n is nothing, but 5 kilohertz.
30.srt	00:09:24.269 --> 00:09:33.589	So, we will be seeing that f in the this thing x axis will have points of 0, 5, 10 and then 15.
30.srt	00:09:34.340 --> 00:09:36.279	are the sampling frequencies.
30.srt	00:09:36.279 --> 00:09:38.909	So, 4 points what we have to have our magnitude.
30.srt	00:09:39.259 --> 00:09:49.740	Magnitude of our X r is going to be we know that first one is 3 what we have got it and second one is 2.236, 1 and then 2.236.
30.srt	00:09:49.740 --> 00:09:56.769	And then we have calculated our angle also at these frequencies what you will be putting the angle.
30.srt	00:09:56.769 --> 00:10:03.009	So, first one is at 0 is 0 and here we have a 26.37 degrees and then the.
30.srt	00:10:04.190 --> 00:10:11.549	at 10 kilo hertz we have 0 and at 15 kilo hertz it has minus 26.57 degrees.
30.srt	00:10:11.549 --> 00:10:14.639	This is how manually you can do the thing.
30.srt	00:10:14.639 --> 00:10:29.600	So, we will seeing in the lab that how we can compute our magnitude and phase spectrum using either matlab or code composer studio in using C language.
30.srt	00:10:29.840 --> 00:10:35.340	So, now comes the thing so we have to verify whatever DFT values we have got it.
30.srt	00:10:35.879 --> 00:10:40.179	using the IDFT that is inverse discrete Fourier transform we are going to get back.
30.srt	00:10:40.600 --> 00:10:44.120	So, we saw our analysis and synthesis equation.
30.srt	00:10:44.379 --> 00:10:51.450	So, we will be making use of our synthesis equation which is 1 by n is nothing, but 1 by 4 in this case.
30.srt	00:10:51.799 --> 00:10:57.029	So, our r will be varying between 0 to 3 x r what I have to put the thing.
30.srt	00:10:57.370 --> 00:11:05.240	So, 1 by 4 into 3 plus 2 plus j plus 1 plus 2 minus j.
30.srt	00:11:05.940 --> 00:11:06.860	So, you are.
30.srt	00:11:07.580 --> 00:11:12.990	Already seeing that we have got back our original signal 2 that is first signal.
30.srt	00:11:13.580 --> 00:11:23.789	So, this is going to be 3 plus 1, 4 divided by 4 is sorry 3 plus 1 plus 4 plus what is the thing?
30.srt	00:11:24.470 --> 00:11:30.629	We have it here you can see that this is 2 plus 2 is 4.
30.srt	00:11:30.629 --> 00:11:42.700	So, 4 plus 4 is 8 what we have it 8 by 4 is nothing, but 2 plus j and minus j are getting cancelled in this case.
30.srt	00:11:43.149 --> 00:11:45.399	So, now we will see x of 1.
30.srt	00:11:45.789 --> 00:12:03.929	So, this is 1 by 4 r is equal to 0 to 3 r x r e power j 3 pi by 4 into r r. So, which by expanding we are going to get it as that is we will be getting it 1 by 4.
30.srt	00:12:04.329 --> 00:12:14.709	So, we have to apply whatever DFT equation what we have got it values for them 3 plus 2 plus j is the.
30.srt	00:12:15.099 --> 00:12:28.799	x1 and then this is e power j pi by 2 plus e power j pi plus 2 minus j into e power j 3 pi by 2 in this case.
30.srt	00:12:28.799 --> 00:12:33.129	So, when we expand this so we are going to get it as 0.
30.srt	00:12:33.659 --> 00:12:39.109	So, you can simplify this and you can see that the output is 0.
30.srt	00:12:39.109 --> 00:12:46.049	So, how about x of 2 now same way what we have to work it out substitute all the values.
30.srt	00:12:46.509 --> 00:12:50.209	And, then you will be seeing that that also comes in 0.
30.srt	00:12:50.709 --> 00:13:02.359	So, we know that using the symmetry property we can calculate x of 3 or manually by calculating to verify that you are going to get it 1 what you can see it.
30.srt	00:13:02.679 --> 00:13:11.019	This case we may not be able to compute the other value because it is 2 0 0 1 is our value.
30.srt	00:13:11.319 --> 00:13:18.379	So, we have to go with manual computation and you will be seeing the last stage what you have it is these are the values.
30.srt	00:13:18.809 --> 00:13:20.749	by simplifying you get it as 1.
30.srt	00:13:21.079 --> 00:13:32.229	So, you will be seeing that what was original case 2 0 0 here and 1 is the output.
30.srt	00:13:32.289 --> 00:13:39.219	So, you will be seeing that DFT and then is analysis equation and IDFT is your synthesis.
30.srt	00:13:39.599 --> 00:13:44.899	So, whatever value you have sent it you are getting it back basically.
30.srt	00:13:45.279 --> 00:13:48.959	So, no compression is happening.
30.srt	00:13:49.339 --> 00:14:01.519	So, why I am calling it as compression sometimes we use our DFT for compression also we can eliminate some of the low values and use in compression.
30.srt	00:14:02.049 --> 00:14:16.229	Now we will see that how we can use the previous one was decimation in time what we have used it using the FFT that is fast Fourier transform using the butterfly structure.
30.srt	00:14:16.659 --> 00:14:24.649	So, we have x of 0 and next one is x of 2, x of 1 and x of 3 are the 4 inputs what we have to give it.
30.srt	00:14:25.039 --> 00:14:27.809	So, this you will be seeing that this is 2.
30.srt	00:14:28.409 --> 00:14:34.279	x of 2 is 0 and x of 1 is 0 and then 1 is x of 3.
30.srt	00:14:34.329 --> 00:14:39.999	So, it does not make the order reverse in this case because both of them we have 0.
30.srt	00:14:40.719 --> 00:14:46.519	Then we have to calculate our this thing twiddle factors since n is equal to 4.
30.srt	00:14:46.519 --> 00:15:00.569	So, our w r what we call it or w k which of the 1 we are conversant will be using notations it may little bit vary from 1 to 1.
30.srt	00:15:01.799 --> 00:15:03.989	So, we you can have one notation to use the thing.
30.srt	00:15:03.989 --> 00:15:28.879	So, it becomes e power minus j 2 pi by n into r. So, which will be equivalent to it is 2 pi by 4 r. So, which is nothing, but e power minus j pi by 2 into r. So, we will see that w 0 always we know that it is 1, what is w 1 is nothing, but putting r equal to 1 it is going to be e power minus j pi by 2.
30.srt	00:15:29.149 --> 00:15:33.309	So, which is nothing, but cos pi by 2 minus j sin pi by 2.
30.srt	00:15:33.649 --> 00:15:37.359	So, we know cos pi by 2 is 0 and sin pi by 2 is 1.
30.srt	00:15:37.539 --> 00:15:39.829	So, we are going to end up with minus j.
30.srt	00:15:40.249 --> 00:15:44.619	So, these are the only twiddle factors what we need in computation.
30.srt	00:15:44.889 --> 00:15:46.519	So, you will be putting this is 1.
30.srt	00:15:46.899 --> 00:15:49.489	and this is minus j here.
30.srt	00:15:49.949 --> 00:15:54.689	So, now, do the simple multiplication and addition.
30.srt	00:15:55.099 --> 00:16:05.079	So, what is my E 0 is nothing, but x of 0 plus x of 2 ok, because we assume that this is 1.
30.srt	00:16:19.370 --> 00:16:22.789	So, this is first one is x of 0 plus x of 2 which is nothing, but 2 plus 0 is equal to 2 and then same way we will calculate E 1 here which is nothing, but x of 0 minus x of 2.
30.srt	00:16:23.469 --> 00:16:35.519	So, you can see that how we are going with the thing 2 minus 0 is equal to 2 and compute your o 0 and then o 1 this is a even part what it is and this is the odd part.
30.srt	00:16:35.949 --> 00:16:39.809	So, what you will be getting 1 and then minus 1 in this case.
30.srt	00:16:40.109 --> 00:16:42.729	So, these are the e 0 e 1 o 0 o 1.
30.srt	00:16:43.039 --> 00:16:49.349	Now, we have to calculate because it is in this thing in order output x 0 x 1 x 2 x 3.
30.srt	00:16:49.539 --> 00:16:51.250	3 what we have it.
30.srt	00:16:51.559 --> 00:16:53.429	So, what is x 0?
30.srt	00:16:53.840 --> 00:17:01.240	So, you will be seeing that x 0 is E 0 plus r x 1.
30.srt	00:17:02.590 --> 00:17:20.819	So, it is 2 plus 1 is equal to 3 in this case and then r x 1 is nothing, but what is what we have E 1 fine and then next minus j into O 1.
30.srt	00:17:22.160 --> 00:17:24.100	So, that is what it is written.
30.srt	00:17:24.460 --> 00:17:35.960	So, it is nothing, but E1 what we have is 2 plus minus j into 1 is our thing is minus 1.
30.srt	00:17:36.390 --> 00:17:46.050	So, this we will be getting it as 2 plus j and you will be seeing the last what if you substitute the thing you will get it as 2 minus j.
30.srt	00:17:46.640 --> 00:17:47.670	So, x 3.
30.srt	00:17:47.670 --> 00:17:50.730	So, whatever DFT you have seen that.
30.srt	00:17:51.279 --> 00:17:58.670	how difficult is to calculate here using the butterfly structure that is fast Fourier transform.
30.srt	00:17:59.120 --> 00:18:09.360	We were able to do it in two steps to compute this values and one weight factor what we have to calculate and then put it in our butterfly structure.
30.srt	00:18:09.960 --> 00:18:15.080	Now we have to see that whether we are going to get back the results using FFT.
30.srt	00:18:15.569 --> 00:18:16.870	So, what is it?
30.srt	00:18:17.279 --> 00:18:31.440	Here x0, x1, x2, x3 are in sequence and our output will be out of order x0 that is bit reversed output what we will be getting it x of 0, x of 2, x of 1 and x of 3.
30.srt	00:18:31.830 --> 00:18:34.769	This we call it as decimation in frequency.
30.srt	00:18:35.019 --> 00:18:57.490	So, you will be seeing that we use this decimation in frequency which is nothing but 1 by n, 1 by 4 what we have to put scale all of them and then we have the butterfly whatever we use for DFT which is going to be reversed in this case as you can see the thing.
30.srt	00:18:58.159 --> 00:19:07.299	And you will be marking this as A naught, A1, B naught and B1 and you are this thing it is 1 coefficient.
30.srt	00:19:07.440 --> 00:19:12.279	Here minus j conjugate you will be getting it as plus j in this case.
30.srt	00:19:12.799 --> 00:19:29.529	So, and then rest of the butterfly you will be multiplying with minus 1 at the second part of it the top one is going to have plus 1 as you can see the thing here plus 1 and here also plus 1.
30.srt	00:19:30.079 --> 00:19:36.970	So, to this computation you will be seeing that you have to get back your output.
30.srt	00:19:38.390 --> 00:19:48.349	So, we have a 0 a 1 b 0 b 1 first computed and in the next case you will be calculating x of 0 x of 1 x of 2 x of 3.
30.srt	00:19:48.349 --> 00:19:55.670	So, you are seeing that you are getting back 2 0 0 1 as your output.
30.srt	00:19:55.670 --> 00:20:04.819	This is how both of them decimation in time and decimation in frequency work for your analysis and synthesis equivalent of DFT.
30.srt	00:20:06.440 --> 00:20:10.990	Now, some of the important DFT properties we are seeing in this slide.
30.srt	00:20:11.619 --> 00:20:25.819	So, the properties of DFT are different from those typical what we use it for discrete time Fourier series and discrete time Fourier transform because they are circular in nature.
30.srt	00:20:26.589 --> 00:20:30.680	So, that is they apply to the periodic repetition of the signal.
30.srt	00:20:30.769 --> 00:20:42.319	Here you can have DTFS or DTFT, it can be this thing continuous signal minus infinity to infinity whereas, this uses a circular property.
30.srt	00:20:42.759 --> 00:20:55.900	So, the first one is your notation what is it time domain is represented as x of n and frequency domain we represent it as x of k. So, the first one is the periodicity.
30.srt	00:20:56.269 --> 00:21:06.089	So, x of n is equal to x of n plus capital N is nothing, but this thing what will be getting it x of n itself.
30.srt	00:21:06.390 --> 00:21:13.869	So, which is equivalent to x of k plus x of n plus n in the frequency domain.
30.srt	00:21:14.390 --> 00:21:16.980	And, what is our linearity property?
30.srt	00:21:17.369 --> 00:21:46.059	So, if x1 is multiplied by any coefficient a1 and x2 multiplied by a2 and if you add them the result in frequency domain also it should be pre multiplied by a1 with respect to your frequency domain conversion that is x1 of k plus a2 into x2 of k. So, you can have the time reversal in your time domain.
30.srt	00:21:46.470 --> 00:21:52.259	So, here it is going to be in the frequency domain it is with respect to k what you are going to get the.
30.srt	00:21:52.799 --> 00:21:53.879	time reversal.
30.srt	00:21:54.180 --> 00:22:27.899	And then you can have the circular time shift with respect to n. So, which is going to be reflected in your frequency domain as x of k into e power minus j 2 pi k L divided by n ok. And complex conjugate x conjugate of n is nothing, but x conjugate of delayed function that is n minus k. And if we do the circular convolution in the time domain, it is circular multiplication as you will be seeing x 1 of k into x of k.
30.srt	00:22:28.450 --> 00:22:40.880	x2 of k. So, with respect to multiplication here it becomes the convolution circular convolution divided by scaling factor 1 by n. So, we know the Percival's theorem.
30.srt	00:22:41.109 --> 00:22:46.430	So, it is x1 of n into y conjugate of n in the time domain.
30.srt	00:22:46.430 --> 00:22:58.009	So, which is represented as 1 by n times k is equal to 0 to n minus 1 x of k into y conjugate of k.
30.srt	00:22:59.329 --> 00:23:11.379	So, now we will see that how our hardware complexity using DFT and FFT in processor is going to reflect.
30.srt	00:23:11.689 --> 00:23:26.819	So, as an example DSP system is based on a floating point processor we have considered and we say that it is capable of performing multiply and add instruction in one machine cycle which is going to take 15 nanosecond.
30.srt	00:23:27.159 --> 00:23:31.809	So, we have ignored in this case all I O operations.
30.srt	00:23:32.000 --> 00:23:38.039	So, only we are looking into the computation aspects of our hardware.
30.srt	00:23:38.409 --> 00:23:55.730	So, and we have a next one what this it is defined is that is suppose that the system is used to implement the DFT directly and is required to output the DFT of 512 input sample points within an interval of 64 samples.
30.srt	00:23:56.069 --> 00:23:56.779	That is Chang's.
30.srt	00:23:56.779 --> 00:23:58.959	So, this is the case of 64 samples are going to.
30.srt	00:23:59.299 --> 00:24:11.449	come out and then what we have to do it that is estimate the maximum sampling frequency if sine and cosine function are pre computed and stored in a lookup table.
30.srt	00:24:11.789 --> 00:24:15.669	So, we are not going to use the library function.
30.srt	00:24:15.669 --> 00:24:17.269	So, we are saving little time.
30.srt	00:24:17.269 --> 00:24:24.469	So, we will be calculating for 512 points both sine and cos is computed and then kept in the table.
30.srt	00:24:24.469 --> 00:24:29.599	So, we are using that to compute our DFT values.
30.srt	00:24:29.909 --> 00:24:31.019	So, what is it?
30.srt	00:24:31.839 --> 00:25:01.049	Using the DFT means we know that are either x of k or x r what we can give it, n is equal to 0 to n minus 1 is phi 11, x of n into cos 2 pi by phi 12 R n minus j times n is equal to 0 to phi 11 x of n into sine of function 2 pi by phi 12 into R n. That is we have split our e minus j into cos and sine function.
30.srt	00:25:01.429 --> 00:25:03.019	So, we can see that.
30.srt	00:25:03.409 --> 00:25:06.480	This involves what is it?
30.srt	00:25:06.960 --> 00:25:12.149	512 possible sine values and 512 possible cosine values are pre-computed.
30.srt	00:25:12.149 --> 00:25:20.669	So, we are not taking the computation time of it because we have kept it in the look up table and then what happens to this now.
30.srt	00:25:20.669 --> 00:25:32.200	So, frequency point requires 512 multiplications what we need it here and then we need 511 additions as you I think something it should be coming.
30.srt	00:25:32.200 --> 00:25:38.940	Then in n multiplications and n minus 1 additions what we need it for real and then.
30.srt	00:25:39.690 --> 00:25:55.139	imaginary parts separately what we have to do it, then it is order of n if I take it 2 into 512 times what we wanted, but what we have is k or r is going to go between 0 to 511.
30.srt	00:25:55.480 --> 00:26:04.990	So, then what happens to this it is 2 into 512 squared is our computation time to do our n point DFT.
30.srt	00:26:04.990 --> 00:26:08.389	So, and then we have been given.
30.srt	00:26:10.500 --> 00:26:17.539	We are ignoring because multiplication and addition we are combining it which is order of n squared.
30.srt	00:26:17.950 --> 00:26:22.029	So, which takes 15 nanosecond what we have been given with.
30.srt	00:26:22.589 --> 00:26:31.759	So, then this comes to about 26.21 millisecond and we have been given that 64 samples of chunks are going at a time.
30.srt	00:26:42.529 --> 00:26:57.019	So, we will divide this 26.21 by 64 which gives us 0.4095 millisecond to do DFT for And we know that maximum frequency what we can operate this circuit with is 1 by 4095 millisecond which comes to about 2442 hertz or 2.442 kilohertz.
30.srt	00:26:57.299 --> 00:27:00.180	So, this is what with the DFT.
30.srt	00:27:00.180 --> 00:27:04.369	So, we will see with the FFT how we are going to compute it.
30.srt	00:27:04.369 --> 00:27:09.230	Except for stage 1 which is going to have only additions.
30.srt	00:27:09.349 --> 00:27:11.900	So, each stage we have to do.
30.srt	00:27:13.339 --> 00:27:28.149	N by 2 complex multiplications that is 256 complex multiplications and we have discussed in the last class that each complex multiplication is going to take 4 real or ordinary multiplication.
30.srt	00:27:28.149 --> 00:27:39.709	So, it becomes 4 into 256 multiplications and we said addition is going to causes 2 into 256 addition or subtractions fine.
30.srt	00:27:40.049 --> 00:27:43.359	So, each complex addition is going to take 2 additions.
30.srt	00:27:43.359 --> 00:27:45.939	So, that is the reason why 2 into 256.
30.srt	00:27:46.359 --> 00:27:49.589	number of additions for the rest of the stages what we needed.
30.srt	00:27:50.119 --> 00:28:15.849	So, if each complex multiplication is implemented by executing the multiply and add instructions, four times the number of multiply and add instructions required to execute at each stage that is 4 into 256 what we wanted, it has to be executed ok.
30.srt	00:28:17.419 --> 00:28:27.789	Complex additions at each stage except stage 1 also require an addition of 2 into 512 times we said additions.
30.srt	00:28:28.129 --> 00:28:43.289	So, what happens the total number of computation stage is log 2 512 which is nothing, but 9 stages what we have it and we said stage 1 we do not need any complex multiplication in the thing.
30.srt	00:28:43.289 --> 00:28:47.469	So, we only we need 512 additions in this case.
30.srt	00:28:47.879 --> 00:28:55.919	So, if the execution time of addition instruction is assumed to be same as the multiply and add instruction.
30.srt	00:28:56.249 --> 00:29:04.039	So, although we know that multiply may take little more time, but we are assuming at present it is going to have addition also same time.
30.srt	00:29:04.429 --> 00:29:09.009	Then the computation time required for 512.850 what we are putting it.
30.srt	00:29:09.009 --> 00:29:16.769	So, this is 4 into 256 plus 2 into 512.
30.srt	00:29:18.559 --> 00:29:33.349	what we have it or additions as you can see the thing complex additions is nothing, but 2 into 512 into because the first stage we are having only additions which is assumed here 512 stages.
30.srt	00:29:33.699 --> 00:29:37.769	So, n minus 1 stages here 9 minus 1 is going to be 8.
30.srt	00:29:38.249 --> 00:29:47.029	So, these are the ones which are causing our complex multiplication and then complex addition which is separately taken into account.
30.srt	00:29:47.479 --> 00:29:53.639	And then whatever complex addition with multiplication is coming we are assuming that it is consumed in this.
30.srt	00:29:53.979 --> 00:29:57.239	This is the other additions what we are showing it here.
30.srt	00:29:57.679 --> 00:30:02.279	So, into 15 nanoseconds is going to give us 0.8448 millisecond.
30.srt	00:30:03.949 --> 00:30:10.059	And, then we said that it is 64 samples in this time period what we are outputting it.
30.srt	00:30:10.379 --> 00:30:14.399	So, divide by that will give us 13.0 microsecond.
30.srt	00:30:14.459 --> 00:30:21.699	And the maximum sampling frequency is going to be 1 by this which is going to be 75.757 kilohertz.
30.srt	00:30:21.859 --> 00:30:28.079	As you can see at 2 point some kilohertz in using DFT.
30.srt	00:30:28.079 --> 00:30:31.389	Using A50 we are going to have 75.757 kilohertz.
30.srt	00:30:35.409 --> 00:30:36.749	75 kilohertz.
30.srt	00:30:37.149 --> 00:30:39.449	So, that is the comparison.
30.srt	00:30:39.449 --> 00:30:45.029	So, you will be seeing that it is equal into 31 fold increase in the computation speed.
30.srt	00:30:45.619 --> 00:30:50.809	So, now we will see that how we can implement FIR filter using FFT.
30.srt	00:30:51.179 --> 00:31:05.059	So, we will be taking the DFT of our input signal and DFT of our coefficient and then we have to do complex multiplication here XR into HR and then we are going to take IDFT.
30.srt	00:31:05.329 --> 00:31:09.479	So, this is what our circular convolution which is going to happen.
30.srt	00:31:09.819 --> 00:31:12.099	So, how we are going to calculate this?
30.srt	00:31:12.479 --> 00:31:28.429	If we are taking a 4 point then we know that 4 squared is 16 what we are going to get the thing and then multiplication and 4 into 4 minus 1, 12 additions why in the direct circular convolution for 4 point.
30.srt	00:31:28.759 --> 00:31:36.919	Now we are assuming the same thing and then trying to see that whether we are going to have 5, 12 multiplications.
30.srt	00:31:37.279 --> 00:31:42.189	So here we will require 5, 12 multiplications and.
30.srt	00:31:42.569 --> 00:31:48.689	512 into 512 minus 1 whatever we said that additions for direct using DFT.
30.srt	00:31:49.069 --> 00:32:03.919	So, we will be seeing that add instruction we can do it as 512 squared basically what we are going to have it as it is seen 512 squared here it is 512 squared.
30.srt	00:32:04.389 --> 00:32:08.769	So, what we say is 512 squared into 15 nanosecond.
30.srt	00:32:08.769 --> 00:32:11.669	So, it is going to be 13.11 millisecond what we needed.
30.srt	00:32:14.929 --> 00:32:21.389	So, now we will see using FFT although I am going to take it DFT and this thing.
30.srt	00:32:21.689 --> 00:32:38.739	So, previously we calculated our each FFT needs 0.8448 millisecond and then how many times I have to do it here 1, 2 and then 3 of them what I have to do it because even IDFT is equivalent to DFT.
30.srt	00:32:38.739 --> 00:32:42.699	So, we can compute it as 3 into 0.8448 millisecond plus.
30.srt	00:32:45.689 --> 00:32:49.849	we have to do this complex multiplication here.
30.srt	00:32:50.239 --> 00:32:58.249	So, each complex multiplication as we know we have it as 4 normal multiplication 4 into 512 into 50.
30.srt	00:32:58.689 --> 00:33:00.079	So, this is the additional.
30.srt	00:33:00.349 --> 00:33:11.819	So, which runs at 2.6368 millisecond and then we are calculating that is 3.11 millisecond in the thing.
30.srt	00:33:11.869 --> 00:33:14.979	So, here it is 2.6368 millisecond.
30.srt	00:33:14.979 --> 00:33:24.819	So, we are still using all this complex method or FFT method is still 4.97 faster than that.
30.srt	00:33:27.989 --> 00:33:29.209	direct DFT.
30.srt	00:33:29.709 --> 00:33:37.089	And one more thing one can keep in mind that I because this is a predefined coefficients basically.
30.srt	00:33:37.359 --> 00:33:42.669	So, I would not be recomputing every time only our input signal is which is coming continuously.
30.srt	00:33:43.079 --> 00:33:49.219	So, if we apply a DFT and keep it precomputed values here.
30.srt	00:33:49.509 --> 00:33:54.019	So, we can avoid one of the DFT online.
30.srt	00:33:54.399 --> 00:33:57.329	So, then it becomes this one 2 into 0.448.
30.srt	00:33:57.329 --> 00:33:59.189	So, which reduces to 1.7.
30.srt	00:34:00.679 --> 00:34:04.789	to millisecond compared to our 2.6368 millisecond.
30.srt	00:34:04.869 --> 00:34:07.649	So, still we will be gaining with the thing.
30.srt	00:34:07.649 --> 00:34:19.229	So, we will see in the next class because we say that our x of n is continuous how we will use the overlap add or save method to compute our FFT.
30.srt	00:34:19.229 --> 00:34:21.159	Thank you.
24.srt	00:00:01.219 --> 00:00:24.179	Welcome back to real time digital signal processing course.
24.srt	00:00:24.179 --> 00:00:29.620	So last class we discussed about the discrete Fourier transform.
24.srt	00:00:30.170 --> 00:00:33.840	In this today's class we will see the complexity of filtering.
24.srt	00:00:34.259 --> 00:00:37.659	and then how FFT is going to be derived.
24.srt	00:00:38.179 --> 00:00:51.359	So, that so, what is how we represent our digital filtering we know that the equation for our FIR filter for a simplicity what we will take it here.
24.srt	00:00:51.769 --> 00:01:03.409	So, X of n is our input and H of n is our H of n be real signals that is.
24.srt	00:01:06.159 --> 00:01:17.049	2 signals if you want to take it or the impulse response of the filter what we will consider it as h of n. So, if we assume the coefficients it becomes b of n in FIR filter.
24.srt	00:01:17.509 --> 00:01:22.259	So, x of n is we are representing it as 0 to n minus 1.
24.srt	00:01:22.659 --> 00:01:31.030	Then we have to compute our y of n using the as we can see here the star indicates the linear convolution.
24.srt	00:01:31.530 --> 00:01:36.140	So, how we can represent k will be varying between minus infinity to infinity.
24.srt	00:01:36.620 --> 00:01:47.600	x of k into h of n minus k or we can represent k is equal to 0 to n minus 1 because this is what our length of sequence input sequence.
24.srt	00:01:48.040 --> 00:01:58.939	Then what we will show is x of k into h of n minus k or we can as you know that since this is a LTI system.
24.srt	00:01:59.360 --> 00:02:08.099	So, we can have x of n minus k for my x and then h of k for my coefficients what we have seen in our.
24.srt	00:02:08.599 --> 00:02:10.889	DSP implementation.
24.srt	00:02:11.400 --> 00:02:13.669	So, both the ways are correct.
24.srt	00:02:13.669 --> 00:02:20.360	Here we will be assuming at present to derive x of k into h of n minus k. So, what is it?
24.srt	00:02:20.909 --> 00:02:27.170	So, we have to say that what is the complexity of computation of this linear convolution.
24.srt	00:02:28.120 --> 00:02:33.740	To make it simpler instead of convolution we will assume it as a multiplication at present.
24.srt	00:02:34.189 --> 00:02:47.199	k will be varying between 0 to n minus 1 and then x of k into h of n minus k. So, how many real multiplications I am going to do it because it is 0 to n minus 1, n real multiplications.
24.srt	00:02:47.759 --> 00:03:00.169	and with x of k into h of n minus k and then we have to have the summation which is going to be 1 less we will be assuming it n minus 1 real additions are required.
24.srt	00:03:00.710 --> 00:03:19.389	For all n varying between 0 to n minus 1 then if we assume that my n is also length of 0 to n minus 1 then total number of multiplications for our filtering required is.
24.srt	00:03:19.870 --> 00:03:26.239	n into n that is n squared we say order of n squared real multiplications are required.
24.srt	00:03:26.969 --> 00:03:36.879	And then addition we know n into n minus 1 additions which is nothing, but this also results in order of n squared real additions.
24.srt	00:03:37.289 --> 00:03:46.439	So, total number of multiplications and additions are required is order of n squared which we consider it as very high ok.
24.srt	00:03:46.840 --> 00:03:52.959	So, how we can do filtering in the frequency domain which can reduce our complexity.
24.srt	00:03:53.169 --> 00:03:56.099	what we will be looking in few slides.
24.srt	00:03:56.699 --> 00:03:57.900	So, what is it?
24.srt	00:03:58.409 --> 00:04:00.830	We will say discrete Fourier transform.
24.srt	00:04:00.830 --> 00:04:04.580	We say it is a frequency analysis of discrete time signal.
24.srt	00:04:05.219 --> 00:04:11.110	It is how we can perform it on the DSP that is what we will be looking at.
24.srt	00:04:11.490 --> 00:04:18.300	So, both time domain and frequency domain in the signals must be in the discrete format.
24.srt	00:04:18.329 --> 00:04:24.870	So, x of t is our analog input after sampling I will be getting x of n in the.
24.srt	00:04:25.439 --> 00:04:56.230	digital domain and x of omega which is omega is continuous after sampling it we will be getting x of 2 pi k by n or we call it as x of k. So, we will be representing 2 pi k by n as k in this case that is capital K. So, we will be see some of the duality of the Fourier's domain thing one is in the time domain what it is represented in the frequency domain if it is a sinc function.
24.srt	00:04:56.780 --> 00:05:01.280	in time domain which is going to be rectangle in frequency domain.
24.srt	00:05:01.639 --> 00:05:09.230	So, if it is rectangle in our the sync time domain it becomes a sync function in our frequency domain.
24.srt	00:05:09.530 --> 00:05:17.490	So, if I think some of you would have heard sync squared function it becomes triangle in frequency domain vice versa.
24.srt	00:05:18.139 --> 00:05:25.930	And we will be seeing that it becomes a ringing in case of time domain then it becomes a truncation in the frequency.
24.srt	00:05:25.930 --> 00:05:27.069	So, the other way round.
24.srt	00:05:27.620 --> 00:05:39.310	So, if it is discrete in time domain which becomes periodic in our frequency domain and if the input signal is periodic then it becomes discrete in our frequency domain.
24.srt	00:05:39.640 --> 00:05:54.900	So, if it is continuous it becomes aperiodic in frequency and if it is aperiodic in time domain it will be continuous and then you can have many more like this in the duality what you can consider.
24.srt	00:05:54.900 --> 00:05:59.530	So, few of it which is required for our derivation what we will be using it here.
24.srt	00:06:00.210 --> 00:06:01.800	So, coming to DFT.
24.srt	00:06:02.200 --> 00:06:12.250	So, we know that if the signal is aperiodic plus discrete in time domain, then if I take the Fourier transform of this.
24.srt	00:06:12.379 --> 00:06:29.450	So, that means, to say if x of n is aperiodic and my h of n is discrete in time domain, what I will be getting the result is continuous time signal in Fourier domain plus periodic in frequency what I will get it.
24.srt	00:06:29.450 --> 00:06:30.689	So, by doing the sampling.
24.srt	00:06:34.230 --> 00:06:49.730	I can reach this discrete signal what I can get plus periodic in frequency what I can achieve from this stage or I can have a periodic signal in the time domain plus DST in this thing discrete time signal here.
24.srt	00:06:49.730 --> 00:07:00.699	Then I can get discrete plus periodic in frequency when I do the Fourier transform or if the signal is periodic plus discrete.
24.srt	00:07:05.620 --> 00:07:14.610	Then, if I take the discrete time Fourier series basically if I convert it then the output is going to be periodic plus discrete.
24.srt	00:07:15.009 --> 00:07:24.199	So, we will be seeing that one period of our discrete sample DFT I will be getting one period of discrete samples here.
24.srt	00:07:24.490 --> 00:07:34.009	So, here n is equal to 0 to n minus 1 in this case we will be having k will be varying between 0 to n minus 1.
24.srt	00:07:34.610 --> 00:07:40.660	So, now, how to represent it both in time and frequency domain relation what it is shown here.
24.srt	00:07:41.139 --> 00:07:47.720	So, you will be seeing that this is a periodic plus discrete time sample what it is taken in the time domain.
24.srt	00:07:48.100 --> 00:07:51.449	So, you are seeing that this is my x of n.
24.srt	00:07:51.900 --> 00:07:57.650	And, then when I take the DFT, so I will be getting x of k here.
24.srt	00:07:57.680 --> 00:08:07.510	If I take the discrete time Fourier series, then what you will be seeing is periodic plus discrete in this thing time domain.
24.srt	00:08:07.510 --> 00:08:12.120	So, this is how the samples have been represented in that.
24.srt	00:08:12.189 --> 00:08:22.270	So, this will be x axis will be k and then our y axis will be representing periodic plus DST in frequency domain.
24.srt	00:08:22.879 --> 00:08:29.860	So, coming with the thing how we are going to do the frequency domain sampling what we are going to achieve.
24.srt	00:08:30.410 --> 00:08:39.180	So, that is we have already said sampling in time domain we said it is going to result in periodic repetition in frequency.
24.srt	00:08:39.529 --> 00:08:54.370	So, when I represent x of n. So, we say that it is a repetition of it x a of t we represent t is equal to n t then take the Fourier transform we result in x of omega.
24.srt	00:08:54.799 --> 00:09:01.299	which is nothing, but 1 by t into k sigma k is equal to minus infinity to infinity.
24.srt	00:09:01.329 --> 00:09:16.199	This is the this thing periodic signal x a into omega plus 2 pi by t into k. So, similarly sampling in frequency results in periodic repetition in time.
24.srt	00:09:16.199 --> 00:09:24.279	What we will be seeing it that is this is the periodic signal what we are representing.
24.srt	00:09:24.639 --> 00:09:53.049	as x p of n in the time domain then it is going to result i is equal to minus infinity to infinity x of n plus i n and then I will be taking the Fourier transform which is equivalent to x of k which is nothing but x of omega in this case omega is represented by 2 pi by n into k. So, now we will see the thing how the sampling is going to happen.
24.srt	00:09:53.459 --> 00:09:58.490	So, we know that n is proportional to omega that is sampling rate.
24.srt	00:09:58.929 --> 00:10:08.479	So, that is n samples per 2 pi what we are going to have it in this region is the 0 to 2 pi we will have n samples.
24.srt	00:10:08.829 --> 00:10:14.709	So, we know that x of n when we take the Fourier transform we will be getting x of omega.
24.srt	00:10:15.169 --> 00:10:25.449	So, the periodic representation x p of n if we take it Fourier transform we will be getting x of k in this case.
24.srt	00:10:25.779 --> 00:10:29.459	So, we are seeing that is samples of x of omega.
24.srt	00:10:29.970 --> 00:10:41.379	used in the reconstruction of x p of n and from x p of n we can get x of n can be reconstructed in this fashion.
24.srt	00:10:41.730 --> 00:10:55.440	So, we will be seeing that this is what we are varying 0 to n minus 1 next one will be the n sample k is going here and this is our omega x axis.
24.srt	00:10:55.799 --> 00:11:00.409	So, here it is you are seeing when n is equal to 2 pi this is the axis.
24.srt	00:11:01.169 --> 00:11:13.120	And, then n minus 1 point will be 2 pi minus 2 pi by n. So, this is the resolution what we will be calling depending on our n samples.
24.srt	00:11:13.779 --> 00:11:25.389	So, coming to the how we can do the reconstruction because we have gone from time domain to frequency domain, but my output I want it in the time domain.
24.srt	00:11:25.740 --> 00:11:27.990	So, how we can do the reconstruction?
24.srt	00:11:28.250 --> 00:11:32.399	So, this is shown with n is equal to 4 in this case.
24.srt	00:11:32.730 --> 00:11:35.649	So, you can see that this is my x of n.
24.srt	00:11:36.040 --> 00:11:53.330	which has 4 samples the magnitude you will be seeing that this is 0 1 0 1 what you have taken rest of them are 0s both the sides negative and then positive side this is my n basically.
24.srt	00:11:53.930 --> 00:11:59.740	And then we will see that we are assuming because I have n is equal to 4.
24.srt	00:12:00.180 --> 00:12:04.700	So, we do not have any temporal aliasing in this case.
24.srt	00:12:07.379 --> 00:12:10.710	So, this is my X of basically this is the periodicity what I have taken.
24.srt	00:12:10.980 --> 00:12:22.409	So, you will be seeing that the magnitude sorry at x is 0 it is 2 and then x is equal to 1 it is 1 and then x is equal to 2 it is 0 and then this is 1.
24.srt	00:12:22.779 --> 00:12:27.509	So, you will be replicating them on both the sides as you can see it.
24.srt	00:12:27.919 --> 00:12:35.090	So, these 4 samples you will be seeing that it becomes 2 1 0 1 2 again.
24.srt	00:12:35.399 --> 00:12:37.870	So, on the negative axis also what you will be?
24.srt	00:12:38.149 --> 00:12:39.079	doing the repetition.
24.srt	00:12:39.079 --> 00:12:43.740	So, we do not have any aliasing because they are distinct in nature.
24.srt	00:12:44.199 --> 00:12:53.500	So, you will be seeing that x of n is a unit step response all of them are 1, then what happens in the time domain.
24.srt	00:12:53.899 --> 00:13:00.039	So, we said that if it is a rectangular window it should result in your sinc function.
24.srt	00:13:00.429 --> 00:13:08.429	So, here you can see that what is the happening is in the periodic if I take the thing.
24.srt	00:13:08.940 --> 00:13:33.240	Then, you will be seeing that these two are 1s and then that is magnitude is 2 and then 1 and then which is not equivalent to my x of n. So, the sampling rate if you have n is equal to 4 you have to kept it, but x of n is what you have given more than n. So, I would not be able to reconstruct the signal.
24.srt	00:13:33.240 --> 00:13:40.419	So, you are seeing that aliasing happening instead of one magnitude of what I have supposed to get it.
24.srt	00:13:40.750 --> 00:13:44.809	So, two of the samples which have got aliased and then which has gone to peak.
24.srt	00:13:45.190 --> 00:13:47.220	magnitude 2 in this case.
24.srt	00:13:47.960 --> 00:13:54.040	So, what is sampling and then reconstruction how they are related in the frequency domain we will see it.
24.srt	00:13:54.580 --> 00:14:04.269	So, x of n can be recovered from our periodic x p of n if there is no overlap when taking the periodic repetition.
24.srt	00:14:16.500 --> 00:14:33.590	So, if x of n is finite duration and then non-zero in the interval 0 to l minus 1 then what we say is x of n is equal to xp of n in this domain 0 to n minus 1 when n is greater than or equal to l. So, if it is less than then we know that aliasing is going to happen for the periodic signal.
24.srt	00:14:34.110 --> 00:14:46.939	So, if n is less than l that is what it says cannot be recovered from our periodic xp of n. Also x of omega cannot be recovered from its samples that is x of omega.
24.srt	00:14:47.409 --> 00:14:53.259	2 pi by n into k due to time domain aliasing what has happened.
24.srt	00:14:53.750 --> 00:15:01.509	As the previous slide shows that what was the initial thing, but here all of them are 1.
24.srt	00:15:01.700 --> 00:15:05.980	So, we are not getting back in this case ok.
24.srt	00:15:06.350 --> 00:15:12.009	So, now, what is the relation between our DTFT, DTFS and then DFT.
24.srt	00:15:12.490 --> 00:15:19.430	So, x of n for all n if I take the DTFT then it becomes x of omega for all omega.
24.srt	00:15:19.910 --> 00:15:50.200	and then the periodic signal in the time domain x p of n for all n and if you take a discrete time Fourier series then it is going to become x of k for all k. So, we say that x tilde of n that is periodic DFT if I take it results in the periodic x of k. So, here x of n periodic what we are represented instead of x p of n.
24.srt	00:15:50.750 --> 00:16:05.850	So, for n is equal to 0 to n minus 1 it will be 0 otherwise and then what happens in the frequency domain x hat of k will be x of k in this 0 to n minus 1 other thing is 0.
24.srt	00:16:07.730 --> 00:16:11.590	So, what are the we have seen the DTFT pair.
24.srt	00:16:11.950 --> 00:16:13.860	So, now, we will see the DFT pair.
24.srt	00:16:14.519 --> 00:16:18.840	So, that is we have taken the example and we took the IDFT.
24.srt	00:16:19.159 --> 00:16:20.980	So, we call them as pair.
24.srt	00:16:21.399 --> 00:16:25.240	So, this is the analysis function and this is the synthesis what we call it.
24.srt	00:16:25.460 --> 00:16:42.700	that is capital X of k is given by n is equal to 0 to n minus 1, X of n into e power minus d 2 pi by n into k or k n by n by n whatever way you represent it, k will be varying between 0 to n minus 1.
24.srt	00:16:43.140 --> 00:16:56.660	The inverse what we have seen it is X of n is the nothing but 1 by n. So, k is equal to 0 to n minus 1, X of k into e power pi same thing instead of negative here it becomes positive.
24.srt	00:16:57.360 --> 00:17:00.760	In this case n will be varying between 0 to n minus 1.
24.srt	00:17:01.930 --> 00:17:06.380	So what is the complexity of DFT what we have seen the thing.
24.srt	00:17:06.750 --> 00:17:14.330	So with respect to our signal processing hardware we will see what is the complexity of our DFT.
24.srt	00:17:14.890 --> 00:17:22.180	Complexity of filter what we have seen the thing we have to see the complexity of our Fourier transform discrete Fourier transform.
24.srt	00:17:22.690 --> 00:17:24.820	n is equal to 0 to n minus 1.
24.srt	00:17:25.320 --> 00:17:30.310	So we know that X of into W and k and k will be varying between 0 to n minus 1.
24.srt	00:17:30.760 --> 00:17:38.760	So we know that straightforward implementation of DFT to compute X of k for k is equal to 0 to n minus 1.
24.srt	00:17:39.130 --> 00:17:49.660	requires just like our filter order of n squared here it is not real multiplications it is going to be complex multiplications.
24.srt	00:17:49.960 --> 00:18:00.599	Because x of n has to be multiplied with cos and x of n has to be separately multiplied with our sine which is imaginary part and they have kept separately.
24.srt	00:18:00.890 --> 00:18:05.119	So, that is why it needs complex multiplications in this case.
24.srt	00:18:05.470 --> 00:18:11.289	And then we need one complex multiplication is equivalent to what we call it as.
24.srt	00:18:11.590 --> 00:18:16.840	AR plus JAI into BR plus JBI if I do it this is what I am doing.
24.srt	00:18:16.970 --> 00:18:27.769	So, both Xn and then my coefficients are we call it as complex Xn is also complex I have we have assumed.
24.srt	00:18:28.180 --> 00:18:39.750	When we do this multiplication you will be seeing that it is nothing but AR into BR minus AI into BI plus J times AR into BI plus AI into BR.
24.srt	00:18:42.350 --> 00:18:49.180	So, what does it show 1, 2, 3 and then 4 real multiplications.
24.srt	00:18:49.509 --> 00:19:04.000	So, one complex multiplication is equal to 4 multiplication plus I have to have even we take it as subtraction as addition because we do in 2's complement if you call back your number system.
24.srt	00:19:04.340 --> 00:19:08.220	So, we have 2 additions real additions.
24.srt	00:19:08.620 --> 00:19:15.630	So, what happens to our total computation time which is equivalent to 4 into.
24.srt	00:19:16.140 --> 00:19:22.560	n squared which is nothing, but order of n square real multiplications what we needed.
24.srt	00:19:23.030 --> 00:19:27.780	So, which is same as that of our filtering.
24.srt	00:19:28.430 --> 00:19:35.730	So, we will see that how we can reduce or take that forward.
24.srt	00:19:35.930 --> 00:19:41.280	So, in this case we said only multiplication we covered the thing.
24.srt	00:19:41.600 --> 00:19:45.140	Now, we have to see from the addition point of view.
24.srt	00:19:45.450 --> 00:19:55.509	So, what is it our filtering was needing n into n minus 1 real time additions, but in this case it is going to be n into n minus 1 complex additions.
24.srt	00:19:55.870 --> 00:19:58.170	How do we represent one complex addition?
24.srt	00:19:58.539 --> 00:20:05.350	that is AR plus JI this is what we say is plus BR plus JBI.
24.srt	00:20:05.870 --> 00:20:11.100	So, this is my equation AR plus JAI plus BR plus JBI.
24.srt	00:20:11.100 --> 00:20:16.819	So, it will be AR plus BR plus J times AI plus BI.
24.srt	00:20:17.130 --> 00:20:21.730	So, that is how we will be resulting in two real additions and then.
24.srt	00:20:29.460 --> 00:20:38.390	When I want to do the total complex multiplication and then we take that 2n into n minus 1.
24.srt	00:20:38.610 --> 00:20:42.400	So, we will be deriving it once again when we take up the problem.
24.srt	00:20:42.400 --> 00:20:54.770	So, it will be coming it as 2n into n minus 1 plus 2n squared that is which is arriving from my complex multiplication.
24.srt	00:20:55.270 --> 00:20:57.970	So, some of the additions taken from there.
24.srt	00:21:00.430 --> 00:21:02.650	So, this many number of So, what I need is real additions.
24.srt	00:21:03.050 --> 00:21:05.060	So, what does it mean?
24.srt	00:21:05.440 --> 00:21:07.310	So, this is the complex addition.
24.srt	00:21:07.310 --> 00:21:12.660	So, 2 times because each complex multiplication we are taking it as 2 real addition.
24.srt	00:21:13.040 --> 00:21:24.090	So, which results in 2 into n into n minus 1 from this stage and then we know that from the complex multiplication we have addition which is resulting.
24.srt	00:21:24.090 --> 00:21:25.930	So, which comes to 2 n squared.
24.srt	00:21:26.330 --> 00:21:32.550	So, that is what it is rendered from complex multiplication I have to take this also into account.
24.srt	00:21:32.810 --> 00:21:38.450	So, this is what our total number of additions required for computing my DFT.
24.srt	00:21:38.700 --> 00:21:39.900	So, in that case.
24.srt	00:21:40.270 --> 00:21:46.800	the maximum is 2 n into n minus 1 if I take it if we absorb this also inside.
24.srt	00:21:47.160 --> 00:21:59.570	So, additions also what we need is order of n squared that is the complexity of DFT both real multiplication and real additions are order of n squared.
24.srt	00:22:00.090 --> 00:22:05.760	So, we know that already we have pointed out in the filtering it is too high.
24.srt	00:22:11.200 --> 00:22:14.520	So, linear increase in the length of the DFT increases the complexity by a power of 2 basically.
24.srt	00:22:15.060 --> 00:22:33.990	And if you are given them this thing what is it magnitude of applications that is number of them where Fourier analysis is employed that is we will call it as linear filtering or correlation analysis which will be taking it up little later.
24.srt	00:22:34.290 --> 00:22:41.850	And then do the spectral analysis what are the intention of our applications then we will say that.
24.srt	00:22:44.490 --> 00:22:52.730	How many this thing what is the complexity of it that is efficient computation is required.
24.srt	00:22:53.600 --> 00:23:01.830	So, that is reduce the complexity by exploring the symmetry property of our complex exponential.
24.srt	00:23:02.250 --> 00:23:04.009	So, how we can do that?
24.srt	00:23:04.440 --> 00:23:05.960	We have the twiddle factor.
24.srt	00:23:06.460 --> 00:23:13.960	We saw that W n k plus n by 2 is equivalent to minus W.
24.srt	00:23:14.400 --> 00:23:45.819	So, we will see the left hand side is nothing, but W n k plus n by 2 is equal to e power minus j 2 pi substituting k with k plus n by 2 k plus n by 2 by n which is nothing, but e power minus j 2 pi k by n into e power minus j 2 pi n by 2 by n. So, this results in minus 1 that is what it is shown here e power minus j 2 pi k.
24.srt	00:23:46.670 --> 00:24:09.810	k by n into e power minus j pi which is nothing but this cos minus pi plus j sin minus pi when we expand e power minus j pi and then we know that cos minus pi is minus 1 and sin pi is going to be 0, pi or minus pi is 0.
24.srt	00:24:10.130 --> 00:24:11.810	So, which will be minus 1.
24.srt	00:24:12.210 --> 00:24:17.060	So, when we represent this is nothing but minus.
24.srt	00:24:17.710 --> 00:24:24.110	So, that is how the derivation between the two has been arrived at.
24.srt	00:24:24.220 --> 00:24:25.990	So, LHS is equal to RHS.
24.srt	00:24:25.990 --> 00:24:30.070	So, whatever we are representing that is symmetry properties true.
24.srt	00:24:30.500 --> 00:24:48.960	So, now, how we can extend this usually we call it as decimation in time basically that is x of k is equal to n is equal to 0 to n minus 1 x of n W n k and this is our normal DFT equation k will be varying between 0 to n minus 1.
24.srt	00:24:49.490 --> 00:24:51.520	So, now what happens?
24.srt	00:24:51.880 --> 00:25:04.160	So, if n is even then n is equal to 0 what we will be taking it x of n plus w n k plus that is we are considering even and then odd parts.
24.srt	00:25:20.480 --> 00:25:29.240	Next n is odd x of n w n k. So, here it is going to be we are changing the little bit of notation from n actually m is equal to 0 to n by 2 minus 1 x of 2 m because it is a E 1 and W n k times 2 m, n is substituted with m in this case.
24.srt	00:25:29.640 --> 00:25:41.430	And this is our art part m is equal to 0 to n by 2 minus 1 x of 2 m plus 1 W n k times 2 m plus 1.
24.srt	00:25:42.220 --> 00:25:51.110	So, this is how we can split our DFT equation into even and then art parts.
24.srt	00:25:51.430 --> 00:25:53.890	So, when you can see that.
24.srt	00:25:54.340 --> 00:26:25.880	We represent x of 2 m as f 1 of m and we are seeing that this is become already W n 2 k m and then this we call x of 2 m plus 1 as f 2 of m equivalent to and then this is W n 2 k m into W n k. So, we are going to split like this, this mission in time and then we know that W n 2 is nothing but by substituting k is equal to 2.
24.srt	00:26:26.140 --> 00:26:30.019	e power minus j 2 pi by n into 2.
24.srt	00:26:30.390 --> 00:26:36.789	So, which is nothing, but e power minus j 2 pi by n by 2 what I can take it.
24.srt	00:26:36.789 --> 00:26:40.859	So, the twiddle factor it is going to be W n by 2.
24.srt	00:26:41.819 --> 00:26:57.859	So, then we will represent x of k is equal to what we have is f 1 m and then f 2 m. So, by putting substituting this f 1 of m and then we are substituting our W n.
24.srt	00:26:58.079 --> 00:27:28.589	2 actually with respect to this it becomes W n by 2 into k m plus we know that W n k is independent of n. So, which will be taking it out W n k and this is our sigma for the f 2 f m W n by 2 into k m. So, you will be seeing that this is n by 2 d f t of f 2 of m that is what we have it.
24.srt	00:27:28.970 --> 00:27:48.819	Then, if we represent this as this is n by 2 DFT of f 1 of m, if we substitute that as capital F 1 of k plus this is going to be W n k f 2 of k, k will be varying between 0 to n minus 1.
24.srt	00:27:50.639 --> 00:27:55.529	And then we know that f 1 k and f 2 k are n by 2 DFTs.
24.srt	00:27:56.190 --> 00:27:59.720	So, you will be seeing that f 1 of k plus n by 2.
24.srt	00:28:00.180 --> 00:28:22.490	and f2 of k plus n by 2 and x of k is going to be that is DFT of fit will be f1 of k plus w n k into f2 of k. So, now, what we are going to represent that k also will be taking the symmetry property will do it as k plus n by 2.
24.srt	00:28:22.950 --> 00:28:31.539	So, we can have it as f2 k plus n by 2 plus w n k plus n by 2 into f2 of k plus n by 2.
24.srt	00:28:32.049 --> 00:28:34.939	k plus n by 2.
24.srt	00:28:43.599 --> 00:28:53.990	So, here it is f 1 of k plus n by 2 plus w and k plus n by 2 into f 2 of k plus n by 2.
24.srt	00:28:54.509 --> 00:29:01.969	So, which is nothing but f 1 of k minus w and k into f 2 of k.
24.srt	00:29:02.539 --> 00:29:20.179	So, how this has come you will be seeing that W n k plus n by 2 what we have to solve the thing which is nothing but e power minus j 2 pi by n k plus n by 2 which you solve the thing.
24.srt	00:29:20.459 --> 00:29:26.269	So, which is nothing but e power minus j 2 pi by n into k into minus 1.
24.srt	00:29:26.629 --> 00:29:32.980	So, this is our W n k. So, you can see that.
24.srt	00:29:33.279 --> 00:29:36.929	k plus n by 2 results in W n cube.
24.srt	00:29:37.789 --> 00:29:42.980	So, we can split this decimation in time further.
24.srt	00:29:43.509 --> 00:30:04.139	So, that is x of k is nothing, but f 1 of k plus W n k f 2 of k, k also will be going between 0 to 1 to n by 2 minus 1 and then x of k plus n by 2 is given by this equation as we have already computed minus W n k into f 2 of k.
24.srt	00:30:04.619 --> 00:30:06.379	0 to n by 2 minus 1.
24.srt	00:30:07.459 --> 00:30:20.369	Now, this is what we call it as Radix II FFT that is n decimation in time what is happening step by step till we go up to last stage is 2.
24.srt	00:30:21.369 --> 00:30:34.289	So, you will be seeing that repeating decimation in time f 1 of n and f 2 of n. So, we will be obtaining f 1 of 2 n and f 1 of 2 n plus 1 we call it as v 1 1 and v 1 2.
24.srt	00:30:34.709 --> 00:30:38.799	So, you will be going n is equal to 0 to n by 4 minus 1 next stage.
24.srt	00:30:39.309 --> 00:30:46.599	and then v 2 1 of n is nothing, but f 2 of 2 n and then f 2 of 2 n plus 1.
24.srt	00:30:46.939 --> 00:30:54.189	So, which will be going by n by 4 minus 1 when k is equal to divided by 2 further.
24.srt	00:30:54.669 --> 00:31:11.289	So, that is how you will be continuously going on splitting the thing that is f 1 of k is nothing, but v 1 1 of k plus w n by 2 k v 1 2 of k. So, which is going between this then f 1 of k plus n by 4 if you take the thing.
24.srt	00:31:11.769 --> 00:31:18.599	this is what you will be resulted and then that is the next f to what is split into this.
24.srt	00:31:19.059 --> 00:31:24.209	So, which has n by 4 DFTs in this case.
24.srt	00:31:25.319 --> 00:31:29.159	How we can represent in decimation in time?
24.srt	00:31:29.549 --> 00:31:35.849	This is my for n is equal to 8 it is a simple one to consider we have considered it.
24.srt	00:31:36.169 --> 00:31:42.129	So, the first one is x of 0 the next value is what we need is x of 4.
24.srt	00:31:42.539 --> 00:31:44.929	So, we will be doing the 2 point DFT.
24.srt	00:31:45.339 --> 00:31:54.669	And then x of 2 and x of 6 will be doing the 2 point DFT which is going to be combined with 2 point DFTs here.
24.srt	00:31:55.299 --> 00:32:09.409	And then the other 2 odd part what you can see it x 1 of 1 and x of 5, x of 3 and x of 7 other 2 point DFT what you can do it and then combine them.
24.srt	00:32:09.879 --> 00:32:13.839	And then finally you will be combining as a 4 point DFT.
24.srt	00:32:15.729 --> 00:32:18.889	So, you will be getting output as x of 0 to x of 7.
24.srt	00:32:19.249 --> 00:32:34.279	So, you can see that input is bit reversed what we have considered in the number system and DSP architecture we said we need input in the bit reversed format output will be in order.
24.srt	00:32:34.599 --> 00:32:40.599	So, we have seen the example how to generate the bit reversed also using hardware adder.
24.srt	00:32:41.199 --> 00:32:48.339	So, when we represent this as the from the previous thing.
24.srt	00:32:48.809 --> 00:32:52.219	In terms of what we call it as this is the butterfly structure.
24.srt	00:32:52.669 --> 00:32:55.679	So, this is my x of 0 and x of 4.
24.srt	00:32:56.149 --> 00:33:12.149	So, this will be my weight W80 and this is minus WNK what we have it here it is going to be minus 1 and then we will be combining these two and which goes to the stage 2.
24.srt	00:33:12.759 --> 00:33:18.909	This is stage 1, this is stage 2, this is stage 3 where all the things are combined.
24.srt	00:33:19.229 --> 00:33:26.209	Whereas, in the second stage my twiddle factors what I need is W80 and W82.
24.srt	00:33:26.209 --> 00:33:33.059	So, in both the cases and we know that W80 is 1 ok, I have to compute only this twiddle factor W82.
24.srt	00:33:33.669 --> 00:33:47.139	Whereas, in the last stage we need 3 twiddle factors that is W81, W82 and W83 has to be computed and then as usual W80 is 1.
24.srt	00:33:47.519 --> 00:33:49.589	So, we will be getting the output in.
24.srt	00:33:50.249 --> 00:33:50.709	order.
24.srt	00:33:51.059 --> 00:34:04.419	So, to do FFT computation for n is equal to 8, we know that log 2 of n 8 is nothing but 3, we need 3 stages.
24.srt	00:34:04.819 --> 00:34:11.710	So, we will be seeing that how we are going to reduce the thing computation.
24.srt	00:34:12.019 --> 00:34:19.779	So, we will be seeing that with respect to this what we have given computational efficiency of n point FFT we will see it.
24.srt	00:34:20.119 --> 00:34:25.659	We know that it is n squared complex multiplication and addition what we needed and FFT.
24.srt	00:34:26.380 --> 00:34:32.299	So, we we need n by 2 log 2 n. So, we said that for 8 point it was 3 stages.
24.srt	00:34:32.299 --> 00:34:44.909	So, if it is n point then we need log 2 n and we can use a symmetry property it is going to be n by 2 complex multiplications what we needed using FFT.
24.srt	00:34:45.150 --> 00:34:58.279	So, you will be seeing some n points and then what is the DFT multiplication and FFT multiplications with respect to n. So, if it is 256 we see that 65536 here what we need is 1024.
24.srt	00:34:58.619 --> 00:35:06.440	So, FFT efficiency we compute it as 64 is to 1 for our DFT.
24.srt	00:35:06.759 --> 00:35:09.339	So, as and when our n point increases.
24.srt	00:35:09.389 --> 00:35:12.539	So, you will be seeing that computation of DFT.
24.srt	00:35:13.269 --> 00:35:24.950	increasing very much and then FFT you will be seeing low and you will be seeing that 68 683 is to 1 is the ratio for 4096.
24.srt	00:35:24.950 --> 00:35:31.470	So, this is how we do the computation of FFT.
24.srt	00:35:31.470 --> 00:35:44.039	So, in the next class we will be seeing quantization of FFT, how it is going to affect our world length and then even the coefficient has to be quantized.
24.srt	00:35:44.430 --> 00:35:46.610	So, number of stages is going to increase.
24.srt	00:35:46.610 --> 00:35:49.730	So, it is pipeline structure what we are going to have it.
24.srt	00:35:50.130 --> 00:35:54.980	So, we will see what are the quantization effects in FFT in the next class.
24.srt	00:35:55.420 --> 00:35:55.880	Thank you.
25.srt	00:00:01.219 --> 00:00:18.809	Welcome back to real time digital signal processing lab.
25.srt	00:00:22.160 --> 00:00:29.710	So, in the previous lab we have saw how we can do the DFT and FFT in.
25.srt	00:00:31.789 --> 00:00:33.350	using MATLAB.
25.srt	00:00:34.119 --> 00:00:42.719	Today we will see how we can use our code composer studio to run our DFT and FFT code.
25.srt	00:00:43.210 --> 00:00:47.980	So, you would have seen such a simple calling FFT function in MATLAB.
25.srt	00:00:48.620 --> 00:00:55.539	Here we have to write our own routine here in C language and we will be running it.
25.srt	00:00:55.840 --> 00:00:57.079	So, welcome.
25.srt	00:00:57.390 --> 00:00:59.489	So, we will see the code actually.
25.srt	00:01:00.320 --> 00:01:05.709	So, the first one is the simulator code what it has been written.
25.srt	00:01:06.129 --> 00:01:16.400	So, number of points here it is selected as 512 FFT points and FFT length is also 512 chosen.
25.srt	00:01:16.400 --> 00:01:18.969	So, if it has to be modified we can modify it.
25.srt	00:01:19.289 --> 00:01:37.879	So, that is what it says both are same just defining 2 for convenience sake basically and define FFT length is 351 that is filter length what it is chosen and then the define length is that is signal length is chosen as 3000.
25.srt	00:01:38.819 --> 00:01:48.969	And, signal block length so, you will be seeing that here it is going to be overlap method is going to be used to compute our FFT.
25.srt	00:01:49.530 --> 00:02:00.329	So, signal length is signal block length what it is chosen is 162 and we have to define pi here unlike MATLAB where pi can be directly taken into the thing.
25.srt	00:02:00.879 --> 00:02:03.340	So, we have to define some structure.
25.srt	00:02:03.750 --> 00:02:08.650	So, here you will be defining float real and imaginary.
25.srt	00:02:09.710 --> 00:02:12.580	And, we are calling it as complex ok.
25.srt	00:02:12.969 --> 00:02:18.939	So, you will be calling the function fft, I will be showing you fft dot c what it is going to do.
25.srt	00:02:19.439 --> 00:02:32.710	So, you are passing your y and then n is the your number of points what you will be passing it that is fft prototype.
25.srt	00:02:33.350 --> 00:02:39.830	And then we call the function complex, we are going to do the complex multiplication.
25.srt	00:02:40.260 --> 00:02:58.260	So, x and then y separately and then you have to define some of the terms as you can see the thing and then your flag is going to be set that is interrupt service routine when I-W buffer is full that is what it is going to be set.
25.srt	00:02:58.260 --> 00:03:12.130	And then we have w points is the twiddle constant stored in a w and then complex what we have samples points primary this thing working buffer.
25.srt	00:03:13.550 --> 00:03:21.600	And, then we will be calling it FFT H number of points and then out temporary are the complex what we have defined ok.
25.srt	00:03:22.020 --> 00:03:28.360	So, the include is the data file this is the filter coefficients what we have it.
25.srt	00:03:28.360 --> 00:03:30.110	So, we will try to open this.
25.srt	00:03:30.520 --> 00:03:42.210	So, you can see that these are the filter coefficient values 351 of them have been pre computed using MATLAB and then stored in this file.
25.srt	00:03:44.610 --> 00:03:46.950	So, are the twiggle factors.
25.srt	00:03:46.950 --> 00:03:52.400	So, you will be going into the main and then you will be doing to the length of your signal.
25.srt	00:03:52.500 --> 00:04:02.470	So, you will be generating your sign basically that is 200 into i and then you have a 267 and then 400.
25.srt	00:04:03.200 --> 00:04:06.540	This is the input what you are generating at ok.
25.srt	00:04:06.540 --> 00:04:12.840	So, you will be taking a 50 that is using the coefficients.
25.srt	00:04:16.370 --> 00:04:20.449	So, you will be calculating w i of real and w i of imaginary.
25.srt	00:04:20.449 --> 00:04:23.980	So, these are the cause and then this is the sign function.
25.srt	00:04:23.980 --> 00:04:32.720	So, real component of twiddle constants and these are the imaginary constants what we have it.
25.srt	00:04:33.110 --> 00:04:41.449	So, then you will be computing f of t that is h of i that is real part of it.
25.srt	00:04:41.800 --> 00:04:48.330	So, you will be assigning it and then you will be with the new data what you will be calculating this.
25.srt	00:04:48.830 --> 00:04:54.439	So, how you will be calculating your imaginary components initially you will be setting it to 0.
25.srt	00:04:54.930 --> 00:05:04.470	and then call the fft function with fft hedge as you have computed here with number of points ok.
25.srt	00:05:04.889 --> 00:05:10.470	So, the bottom one will be showing you convolution with overlap.
25.srt	00:05:10.470 --> 00:05:18.129	So, we can here also we can set the break point and then see whether we are going to run only fft of it.
25.srt	00:05:18.629 --> 00:05:22.910	So, the thing is what we have seen the data file.
25.srt	00:05:23.019 --> 00:05:28.710	So, we will see the how the fft dot c function is written here.
25.srt	00:05:29.290 --> 00:06:00.970	So, this is again number of points what it has been defined and you will be seeing that that is whatever you call it as upper leg, lower leg, index of upper and lower butterfly leg what you are going to implement it and then you should have a loop counters and difference between upper and lower leg what you will be having it and then how many steps you are going to have it.
25.srt	00:06:01.390 --> 00:06:07.020	twiddle constant and then number of stages what you have to do it.
25.srt	00:06:07.410 --> 00:06:12.770	So, using butterfly structure will be computing our FFT.
25.srt	00:06:12.770 --> 00:06:21.900	So, as we know that number of stages is going to be locked to n. So, for that what will be computing our thing.
25.srt	00:06:21.900 --> 00:06:30.250	So, the code will be shown in this way step is step between values in twiddle what you will be taking it.
25.srt	00:06:30.670 --> 00:06:31.970	How you are going to calculate?
25.srt	00:06:32.240 --> 00:06:37.090	So, you will be calculating your lower like and then temporary files what you needed to store them.
25.srt	00:06:38.710 --> 00:06:47.230	And then you will be calculating y1 y of lower leg and then upper leg separately that is real and imaginary separately is computed.
25.srt	00:06:47.330 --> 00:06:54.360	And then you will be setting your index t is equal to how many steps what we have taken into.
25.srt	00:06:54.840 --> 00:07:01.970	And then you will be calculating the leg difference by 2 and then you will be setting your step to 2.
25.srt	00:07:02.980 --> 00:07:09.470	So, we will be starting this one more loop for i is equal to 1, 2.
25.srt	00:07:10.030 --> 00:07:12.870	less n less n minus 1.
25.srt	00:07:13.260 --> 00:07:22.790	So, bit reversal for what is it arranging our data in the bit reversed manner.
25.srt	00:07:22.790 --> 00:07:32.370	So, you will be seeing that how you will be putting them in your input ok, bit reversal in see what it is done.
25.srt	00:07:32.780 --> 00:07:41.280	So, whereas, in the case of if we use the assembly program then we can directly access our bit reversal.
25.srt	00:07:41.839 --> 00:07:47.189	module what we discussed in the architecture in our DSP processor.
25.srt	00:07:47.639 --> 00:07:52.899	So, you will be calculating the complex multiplication what you will calling the function.
25.srt	00:07:53.300 --> 00:08:04.009	So, you will be doing the real you are seeing it real come multiplied and imaginary multiplication and then imaginary part separately.
25.srt	00:08:04.300 --> 00:08:13.930	So, you are seeing 4 multiplications and 2 additions are happening in R 1 complex multiplication ok.
25.srt	00:08:14.870 --> 00:08:18.060	Then you will be returning the z and then it will be continuing.
25.srt	00:08:18.430 --> 00:08:25.889	So, what we will do is we will just chosen this is the active debugger what we have to choose it.
25.srt	00:08:26.350 --> 00:08:30.830	First what we will do is we will compile the thing for any error in the thing.
25.srt	00:08:31.139 --> 00:08:37.919	So, it is simulator as it shows dot out is up to date because I have pre compiled and then done the thing.
25.srt	00:08:38.289 --> 00:08:42.259	If there is any modification is done so, it will be doing the recompilation.
25.srt	00:08:42.649 --> 00:08:45.430	So, now what we will do is go to the debug mode.
25.srt	00:09:18.250 --> 00:09:21.139	So, we will be seeing that our output will be in we have the So, the As you can see we have put the break point here.
25.srt	00:09:21.659 --> 00:09:26.379	This will show our using overlap save method has been implemented here.
25.srt	00:09:26.769 --> 00:09:29.200	In the MATLAB you saw overlap add method.
25.srt	00:09:29.580 --> 00:09:32.970	So, we can run the code ok.
25.srt	00:09:33.080 --> 00:09:42.990	So, what is happened is it is unable to find the break point.
25.srt	00:09:42.990 --> 00:09:48.720	What I can redo is one way of doing it is I can go and then check.
25.srt	00:09:51.459 --> 00:10:09.719	work on the graph that is single time what was our variable some it was 512 was the samples and then I can because we have called it floating point we can represent in full floating point.
25.srt	00:10:09.750 --> 00:10:17.769	So, sampling frequency at present we will keep it at this and then I can give it as let us let me see samples is declared here.
25.srt	00:10:24.039 --> 00:10:27.799	So, you will be seeing I can make it full.
25.srt	00:10:31.230 --> 00:10:34.309	So, you are seeing some garbage in the thing.
25.srt	00:10:34.740 --> 00:10:42.659	So, what we will do is we will minimize this.
25.srt	00:11:03.769 --> 00:11:05.360	So, this is.
25.srt	00:11:05.610 --> 00:11:10.029	I can close this and you will be seeing some memory map.
25.srt	00:11:10.480 --> 00:11:15.050	why it got this thing that is it gone till the end of it.
25.srt	00:11:15.240 --> 00:11:20.860	So, that is why disassembly will be having a problem because it is unable to come back.
25.srt	00:11:20.860 --> 00:11:23.320	We will start computing on the board.
25.srt	00:11:23.320 --> 00:11:26.639	So, you will be seeing that there was error.
25.srt	00:11:27.019 --> 00:11:34.940	So, what we will put the thing main dot c as you can see that the breakpoint was removed.
25.srt	00:11:34.940 --> 00:11:38.330	Otherwise in the end what you have to.
25.srt	00:11:41.440 --> 00:11:42.950	put the break point.
25.srt	00:11:49.890 --> 00:11:58.490	So, we will decompile the thing, it is loading on to the board.
25.srt	00:12:03.920 --> 00:12:12.050	So, you have seen in the main it has entered the main function, you will be seeing the pointer program pointer is here.
25.srt	00:12:12.610 --> 00:12:24.150	So, we will see whether I have the breakpoint hopefully it will come up to this breakpoint we will look at it when I run the thing ok.
25.srt	00:12:24.930 --> 00:12:32.090	There is some abortion is happening it is unable to detect this breakpoint.
25.srt	00:12:32.510 --> 00:12:43.200	So, we will come back to this program little later we will start stop the thing and then we will go back to the.
25.srt	00:12:43.760 --> 00:12:46.490	other demo what I have it ok.
25.srt	00:12:46.940 --> 00:12:56.610	So, this is one of the student who has developed the FFT basically here it is for the 64 point.
25.srt	00:12:57.010 --> 00:13:04.530	So, you will be seeing that even the it is in the same way what the simulator has it has been developed.
25.srt	00:13:04.850 --> 00:13:14.370	So, you will be seeing that because I have put the break point here to see that because n means sometimes it will be.
25.srt	00:13:14.770 --> 00:13:17.640	going the handle is given somewhere.
25.srt	00:13:17.940 --> 00:13:21.230	So, whether it it would not be able to stop the thing.
25.srt	00:13:21.690 --> 00:13:32.110	So, we will see that whether the A 50 is using this method that is 64 point will be going through ok.
25.srt	00:13:32.390 --> 00:13:37.180	So, I will give the run command ok.
25.srt	00:13:37.370 --> 00:13:43.310	So, we can see that that is graph single time.
25.srt	00:13:47.540 --> 00:13:49.150	So, W is the thing.
25.srt	00:13:49.150 --> 00:13:54.790	So, with we will see what has been declared because this will be floating.
25.srt	00:13:54.840 --> 00:14:09.570	So, we will be declaring it as 32 bit floating point and start address will be W. Here also it is samples what it has been selected, we will select the thing and we will display it.
25.srt	00:14:23.370 --> 00:14:29.130	So, what you are seeing in the You will be seeing that there will be an error because the processor has got reset.
25.srt	00:14:29.640 --> 00:14:32.900	So, we will be coming back to this.
25.srt	00:14:40.740 --> 00:15:08.860	So, x1 of i will be the magnitude what it is going to be computed.
25.srt	00:15:09.180 --> 00:15:15.700	So, as you can see that there was because I had switched on the board little earlier there was a issue with the thing.
25.srt	00:15:16.100 --> 00:15:20.070	So, now, we are seeing that it has reached the break point.
25.srt	00:15:20.380 --> 00:15:32.620	So, this is how what you have to debug your code whenever there is a problem you can software reset or sometimes what you have to do is unplug the power supply to the board and then reconnect it.
25.srt	00:15:33.010 --> 00:15:37.490	In this case only have a switch actually reset button which I pressed it.
25.srt	00:15:37.890 --> 00:15:40.170	Now, we will do the plotting of it.
25.srt	00:15:40.480 --> 00:15:45.140	So, because it was giving me all garbage values last time.
25.srt	00:15:46.020 --> 00:15:52.130	So, we will be seeing that x of I think 64 points what we have it.
25.srt	00:15:52.580 --> 00:16:13.150	I will go to the this thing 32 bit floating point start address is x what I am interested in and then we will sorry it is x 1 not x that is why it was giving me an error.
25.srt	00:16:13.880 --> 00:16:16.380	So, you will be seeing that the peak.
25.srt	00:16:17.210 --> 00:16:19.020	has got generated.
25.srt	00:16:19.630 --> 00:16:21.300	So, what is the frequency?
25.srt	00:16:21.580 --> 00:16:35.020	You can see that what is the peak value of it what you are getting it sample somewhere around you can see that they have generated it as 10 hertz or something.
25.srt	00:16:35.020 --> 00:16:41.120	So, 9 hertz what will be getting it in this.
25.srt	00:16:41.120 --> 00:16:46.990	So, you will be seeing that this is the frequency we can go back and then check the thing.
25.srt	00:16:47.490 --> 00:17:00.790	This is what is it 64 minus what I am supposed to see 60 minus 7 or something we will cross verify and then come back.
25.srt	00:17:11.860 --> 00:17:17.290	What is the frequency we will see it sorry I forgot to check the thing.
25.srt	00:17:18.080 --> 00:17:21.190	So, what is it 10 hertz basically.
25.srt	00:17:21.190 --> 00:17:34.120	So, you are seeing that there is an little error what it has got generated that is what we want to see the frequency value is 10, it is coming somewhere around 9 or something like that ok.
25.srt	00:17:34.630 --> 00:17:38.050	The error with respect to whatever the computation.
25.srt	00:17:38.380 --> 00:17:41.300	So, this is how it runs on board.
25.srt	00:17:41.510 --> 00:17:46.150	So, we will go back to we will stop this and then.
25.srt	00:17:47.760 --> 00:17:51.040	will see directly whether I can compute my DFT.
25.srt	00:17:51.820 --> 00:17:55.320	So, here I have used the FFT to show the thing.
25.srt	00:17:55.750 --> 00:17:58.870	So, whether we can do directly DFT.
25.srt	00:17:59.210 --> 00:18:05.810	So, here what I have is FFT calculation again.
25.srt	00:18:05.840 --> 00:18:13.670	So, but I can go back to and then see that I can put individual this thing what is it.
25.srt	00:18:13.760 --> 00:18:13.920	.
25.srt	00:18:14.110 --> 00:18:18.930	So, .
25.srt	00:18:19.819 --> 00:18:29.519	So, DFT DFT dot c files to check in the same thing whether I am going to get my DFT and FFT correctly or not ok.
25.srt	00:18:29.920 --> 00:18:47.860	So, we have the this thing first what I will do is we will run this is FFT dot c is there.
25.srt	00:18:53.720 --> 00:19:16.919	So, you will be seeing n is equal to 128 point complex what you have this thing declared them and then you will be calculating just like your twiddle factors cos and then sine functions what you are keeping it and you will be using it and we will call the FFT of samples what you are going to pass it ok.
25.srt	00:19:17.299 --> 00:19:28.349	So, this will be your FFT dot H samples of FFT function taken from the book Rolfs Chasiang basically.
25.srt	00:19:28.829 --> 00:19:32.369	And, then dot h file will be defining all of them.
25.srt	00:19:33.159 --> 00:19:37.749	Let us see whether this is going to run because I have not tested it.
25.srt	00:19:38.219 --> 00:19:39.949	I will be testing in front of you.
25.srt	00:19:40.389 --> 00:19:46.059	So, we know that it has completed its running.
25.srt	00:19:46.179 --> 00:19:51.209	So, that means, to say that there are no errors in the code.
25.srt	00:19:52.499 --> 00:19:57.809	What it says is real input data stored in array samples.
25.srt	00:19:59.009 --> 00:20:01.839	So, you will be calling FFT function.
25.srt	00:20:02.240 --> 00:20:15.779	So, you will be seeing that it is going to give you a printf done and then we have to see these samples whether we have got it or not in our memory.
25.srt	00:20:17.460 --> 00:20:22.139	One is I can plot and then see how we have got the values.
25.srt	00:20:22.639 --> 00:20:27.139	So, you will be seeing that PIDL factors how it has been generated here.
25.srt	00:20:27.690 --> 00:20:28.700	So, you have.
25.srt	00:20:29.079 --> 00:20:32.970	had 0 to 99 and then 100 to 127 what it is showing.
25.srt	00:20:33.500 --> 00:20:40.369	So, in the this thing decimal or octal what you want to display it you can display.
25.srt	00:20:40.369 --> 00:20:49.019	So, one of the sorry fine.
25.srt	00:20:49.339 --> 00:20:59.490	So, it has entered into the main function what we will do is we will put up break point otherwise I will be losing the control on the thing I want to be in the same.
25.srt	00:21:00.569 --> 00:21:01.250	basically.
25.srt	00:21:01.549 --> 00:21:02.619	So, we will run the thing.
25.srt	00:21:02.969 --> 00:21:08.759	So, you will be seeing that input data stored in array samples what it says.
25.srt	00:21:09.089 --> 00:21:26.069	So, we will see thus I can view I can use the memory browser and then I have to enter the locations here.
25.srt	00:21:26.490 --> 00:21:29.219	So, we will give it as samples.
25.srt	00:21:32.679 --> 00:21:36.169	So, you will be seeing the samples in this what is it?
25.srt	00:21:36.169 --> 00:21:38.939	It is representing it as 32 bit hex.
25.srt	00:21:39.519 --> 00:21:41.250	Texas instrument style.
25.srt	00:21:41.660 --> 00:21:47.759	So, if you want to have it as this thing floating point 32 bit floating point.
25.srt	00:21:48.089 --> 00:21:57.880	So, you will be seeing that the samples are stored in this both you will be seeing that dot real and then imaginaries are 0s basically.
25.srt	00:21:58.230 --> 00:22:03.390	So, the real values have been stored in this case fine.
25.srt	00:22:04.089 --> 00:22:09.500	So, this is how you will be implementing and then you can do the IFFT.
25.srt	00:22:10.099 --> 00:22:19.199	So, to see that you have got back your what is the input what you have passed into the system.
25.srt	00:22:19.899 --> 00:22:34.379	So, what it says is test frequency is 800 hertz and then sampling frequency chosen as 800 hertz and then I should be getting here it is magnitude square function is not found out.
25.srt	00:22:34.379 --> 00:22:37.719	So, you can include your code and then check.
25.srt	00:22:40.019 --> 00:22:42.599	we are going to get the results correctly.
25.srt	00:22:42.599 --> 00:22:46.179	Otherwise what you are seeing is this one.
25.srt	00:22:46.179 --> 00:22:52.719	So, one thing what we what I can do is I can put the graph single time we will put it.
25.srt	00:22:53.139 --> 00:23:03.259	So, this is I will put it as I think number of samples I did not check the thing it may be 64 samples what it is generated.
25.srt	00:23:03.629 --> 00:23:15.859	So, we will put it as 32 bit floating point and then start address can be your this thing.
25.srt	00:23:16.519 --> 00:23:18.539	what we have is samples.
25.srt	00:23:20.569 --> 00:23:29.019	And if I want I can specify sampling frequency I know I can put it as 8000 frequency.
25.srt	00:23:29.079 --> 00:23:32.659	So, you will be seeing that the plot is coming.
25.srt	00:23:33.399 --> 00:23:46.199	So, you are seeing that one p cut here what is the value just it has to be little here somewhere around 25 point.
25.srt	00:23:46.559 --> 00:23:50.139	07 what you are seeing the peak ok.
25.srt	00:23:50.549 --> 00:24:01.509	So, this is what you are you will be seeing that if I calculate the magnitude absolute of it alone I will be getting the thing.
25.srt	00:24:01.969 --> 00:24:13.919	So, what we can do is I can generate the FFT of it let us see FFT magnitude alone what I want to have it.
25.srt	00:24:14.389 --> 00:24:18.229	So, I will give it as 6 hopefully it is 64 anyway.
25.srt	00:24:18.649 --> 00:24:22.099	Again I did not check how many points we have chosen the thing.
25.srt	00:24:22.469 --> 00:24:24.689	So, you can look at it.
25.srt	00:24:25.139 --> 00:24:32.429	So, I will be giving my sampling frequency is 8000 and then start address is samples.
25.srt	00:24:32.429 --> 00:24:37.069	You want to find the FFT magnitude of it.
25.srt	00:24:37.489 --> 00:24:45.209	It has taken frame size I will give it as 6 in this case also will put the thing.
25.srt	00:24:45.429 --> 00:24:50.009	So, you will be seeing some garbage output is going to come.
25.srt	00:24:50.489 --> 00:24:54.659	have to plot it basically.
25.srt	00:24:56.009 --> 00:25:01.269	Hopefully, samples dot real is not defined with the thing only I can select the samples.
25.srt	00:25:01.519 --> 00:25:16.879	So, what you can do is magnitude square function what you can calculate for this output of the samples and then see that your magnitude perfectly represented with 800 hertz what we are supposed to get the thing.
25.srt	00:25:17.979 --> 00:25:21.479	Because this is what this test frequency what it has been generated.
25.srt	00:25:21.889 --> 00:25:30.599	So, at what k value of you will be getting 800 hertz is a 1, 1 has to take it up fine.
25.srt	00:25:32.239 --> 00:25:40.929	One more what we can do is I can remove this fft dot c and then include a dft if I am required.
25.srt	00:25:41.079 --> 00:25:44.499	So, I will put it as add files.
25.srt	00:25:44.579 --> 00:25:51.429	So, I am showing you how I can use the same project file to run.
25.srt	00:25:52.889 --> 00:25:56.489	my different programs basically.
25.srt	00:25:56.909 --> 00:26:03.919	So, I have to select where my codes are lying.
25.srt	00:26:03.919 --> 00:26:19.449	So, I will be taking the LCDK book files and then I can versions CC 5 what I have it according to the chapters what you are going to have some of the codes.
25.srt	00:26:28.609 --> 00:26:30.789	You will be seeing that There is a DFT code also.
25.srt	00:26:31.109 --> 00:26:38.279	So, if you want directly you can take it or there are different codes what it is there in this directory.
25.srt	00:26:38.729 --> 00:26:57.479	So, you can use the that is world level DFT what you can use it and then normal DFT is there or FFT you can use or you can use the library which is present in the thing.
25.srt	00:26:57.479 --> 00:27:00.339	So, what we will do is we will include this file.
25.srt	00:27:00.889 --> 00:27:02.199	in the program.
25.srt	00:27:03.779 --> 00:27:04.939	I am copying it.
25.srt	00:27:05.009 --> 00:27:13.129	So, this is my DFTC dot that is L1386748 board what we are using it and then in this n is defined as 100.
25.srt	00:27:13.799 --> 00:27:20.879	Here also sampling frequency is chosen as 800 and 8000.
25.srt	00:27:21.229 --> 00:27:25.339	So, you will be seeing result and then real and imaginary.
25.srt	00:27:25.639 --> 00:27:29.479	So, x of k is going to get result function.
25.srt	00:27:31.359 --> 00:27:41.809	And, then this is your main function what you are passing it you are calling your DFT with samples and then you will be completing it.
25.srt	00:27:42.389 --> 00:28:01.649	One more thing you have to remember in when you are using a code composer studio that most of the variables if you have defined as a global variable just like C, then you will be able to what is that.
25.srt	00:28:01.939 --> 00:28:04.909	view them in the graph.
25.srt	00:28:05.289 --> 00:28:09.699	Otherwise if it is a local variables you may not be able to view them.
25.srt	00:28:10.249 --> 00:28:15.009	So, this is one thing what you have to keep it in mind.
25.srt	00:28:15.299 --> 00:28:19.429	So, you are seeing the complex samples is a global variable.
25.srt	00:28:19.849 --> 00:28:22.829	So, we can still viewing the thing.
25.srt	00:28:22.829 --> 00:28:39.769	So, these are the what is it how you will be calculating your these are my samples real whatever cause functions sampling frequency real my imaginary part is 0 and you will be calling.
25.srt	00:28:40.289 --> 00:28:41.969	DFT of the function.
25.srt	00:28:42.129 --> 00:28:47.109	So, we will do the running of it.
25.srt	00:28:47.269 --> 00:28:56.659	I can put the break point at the return.
25.srt	00:28:56.729 --> 00:29:01.499	So, that I am within the my leg of it.
25.srt	00:29:01.539 --> 00:29:09.619	So, your DFT is declared here as you can see complex comma x and then you will be.
25.srt	00:29:12.109 --> 00:29:16.639	computing directly here real part and then imaginary part separately.
25.srt	00:29:17.199 --> 00:29:21.199	So, you will be adding them up and then to the length of it.
25.srt	00:29:21.619 --> 00:29:27.829	So, your output is going to be in the result which you are giving back to your sample.
25.srt	00:29:27.829 --> 00:29:29.629	So, I can run this code.
25.srt	00:29:31.069 --> 00:29:33.469	So, you are seeing that it is holding on here.
25.srt	00:29:33.909 --> 00:29:43.169	So, what we can one of the way of doing it is I can look at the values here as you have seen the thing when you show in the red.
25.srt	00:29:46.799 --> 00:29:51.919	Those are the modified values what you will be looking at it compared to your FFT and here.
25.srt	00:29:52.399 --> 00:29:56.709	So, these are the little bit modified values what you will be seeing it.
25.srt	00:29:56.709 --> 00:30:09.559	So, that is one way of doing it in 32 bit floating point or if what is it samples is declared as complex and then we have a float basically.
25.srt	00:30:09.559 --> 00:30:13.299	So, I can give it as 32 bit floating point.
25.srt	00:30:13.329 --> 00:30:15.459	So, if you want to.
25.srt	00:30:17.629 --> 00:30:20.119	view the graph.
25.srt	00:30:20.490 --> 00:30:33.559	So, we can go to single time again and the number of samples I can give it as 64 and then it is going to be 32 bit floating point and start address will be samples.
25.srt	00:30:33.559 --> 00:30:48.759	You will be seeing that again your peak is somewhere around because number of points what I have chosen it is approximately 20 hertz what it has.
25.srt	00:30:49.609 --> 00:30:50.629	taken it ok.
25.srt	00:30:51.509 --> 00:31:00.969	So, can you make out what was the thing 800 hertz was my sampling frequency.
25.srt	00:31:01.369 --> 00:31:05.419	So, what was the number of samples what we have taken here is 8000.
25.srt	00:31:05.419 --> 00:31:17.569	So, where you are going to get your peak what you have to look at it fine with that we will stop.
25.srt	00:31:19.879 --> 00:31:27.399	this lab here if there are any doubts I will be open to solve your doubts.
25.srt	00:31:27.559 --> 00:31:28.739	Thank you.
31.srt	00:00:01.219 --> 00:00:24.929	Welcome back to real time digital signal processing course.
31.srt	00:00:25.140 --> 00:00:30.070	So, today we will discuss about overlap add method.
31.srt	00:00:30.350 --> 00:00:35.230	how to use our FFT in for the continuous time signal.
31.srt	00:00:35.760 --> 00:00:38.420	So, coming to the recap of it.
31.srt	00:00:38.500 --> 00:00:51.909	So, we have completed FFT, it is butterfly structure and then we have seen some examples using both DFT and then FFT.
31.srt	00:00:51.909 --> 00:00:57.890	So, how to use FFT in for overlap add method.
31.srt	00:00:58.079 --> 00:01:00.670	So, we will see some of the definitions.
31.srt	00:01:00.670 --> 00:01:07.879	So, we will see modulo indices and how it is going to be used for the periodic repetition.
31.srt	00:01:08.390 --> 00:01:10.079	So, as we can see here.
31.srt	00:01:10.780 --> 00:01:16.830	anything n with capital N is our length of FFT.
31.srt	00:01:17.420 --> 00:01:20.780	So, it is equivalent to N itself.
31.srt	00:01:21.160 --> 00:01:22.189	What does it mean?
31.srt	00:01:22.219 --> 00:01:32.520	That is mod of N is nothing, but remainder of N by N. So, in this case X of N if we have 4 samples.
31.srt	00:01:32.939 --> 00:01:42.310	So, we say that it is periodic with period 4, the repeated pattern will consist of what is it X of 0, X of 1.
31.srt	00:01:42.950 --> 00:01:58.390	x of 2 and then x of 3 and the length is n then we say that the repetition is going to happen after x of n minus 1 samples n is usually we take it power of 2.
31.srt	00:01:58.950 --> 00:02:03.469	So, as we have seen in the example n is equal to 4 what we have taken.
31.srt	00:02:03.469 --> 00:02:06.350	So, we have seen the repetition what it is going to happen.
31.srt	00:02:06.670 --> 00:02:12.689	So, we will see visually here n is going to vary from minus 4 to n.
31.srt	00:02:12.960 --> 00:02:26.370	8 is the long sample what we have taken and then small n which is going to repeat after 4 that is 0, 1, 2, 3 and then later on again 0, 1, 2, 3 and 0, 1, 2, 3 and then the last one is 0.
31.srt	00:02:26.939 --> 00:02:43.680	So, we say that n by n is nothing, but integer plus non-negative integer which is less than n divided by n. As an example, so because we have taken capital N is equal to 4.
31.srt	00:02:43.680 --> 00:02:47.890	So, the fifth sample what we have to take it then what is the thing is going to happen?
31.srt	00:02:47.890 --> 00:02:52.700	This is 5 by 4 which is nothing, but 1 plus 1 by 4.
31.srt	00:02:53.710 --> 00:03:00.010	So, this is what the integer plus non negative integer what we are taking it.
31.srt	00:03:00.380 --> 00:03:11.610	Here if it is minus 2 by 4, then the integer is going to be minus 1 plus 2 by 4, this should be non negative integer what we have to assume.
31.srt	00:03:12.090 --> 00:03:18.490	So, this is how we will be taking the modulo indices and then after that it is going to repeat.
31.srt	00:03:18.950 --> 00:03:23.950	So, what we are going to do with overlap during the periodic repetition.
31.srt	00:03:24.400 --> 00:03:55.949	So, we say that periodic repetition makes an aperiodic signal that is x of n. So, periodic to produce x tilde of n. So, there are two important parameters in this case that is the smallest support length of the signal x of n what we needed and period n used for repetition that determines the period of r x tilde of n. So, we call I.
31.srt	00:03:56.139 --> 00:04:26.660	smallest support length which is greater than period of repetition and repeating the thing i there will be overlap, i will be the smallest support length period of repetition and i there will be no overlap these are the condition there will be overlap and no overlap condition and x of n can be recovered from our periodic signal x tilde of n. So, how do we represent our x tilde of n is equal to i is equal to.
31.srt	00:04:27.899 --> 00:04:37.379	minus infinity to infinity x of n minus i n. So, i will be defined with these parameters.
31.srt	00:04:37.870 --> 00:04:48.519	So, to show that how the periodic repetition is going to be that is if we consider no overlap and then n is taken as 4.
31.srt	00:04:49.370 --> 00:04:55.439	This is our x of n then what happens to our the repeated signal.
31.srt	00:05:00.139 --> 00:05:02.310	at L is equal to 0.
31.srt	00:05:02.829 --> 00:05:19.469	So, we know that we have 4 samples here, then this is our x of n, then at L is equal to 1 it is going to be x of n minus n that is we are repeating the 4 samples.
31.srt	00:05:34.829 --> 00:05:39.430	Same thing at L is equal to 2 will be repeating x of n minus 2 n. So, that is what dot dot what we have it and then what happens on the negative side of it, it is going to be L is minus 1 it is going to be x of n plus n actually.
31.srt	00:05:39.769 --> 00:06:04.589	So, the 4 samples are repeated here same way and then all of them get added and then we will be seeing that there is no overlap the support length what we have taken is 4 is which is equal to n. So, our x tilde of n you will be seeing that this is the x of n and then this is l is equal to 1 and this side l is equal to minus 1.
31.srt	00:06:04.589 --> 00:06:07.889	So, you will be seeing the repetition of it this is the.
31.srt	00:06:08.079 --> 00:06:12.120	periodic repetition what is shown pictorially.
31.srt	00:06:12.660 --> 00:06:20.449	So, coming to if there is a overlap that is periodic repetition how it is going to look what we will see it here.
31.srt	00:06:20.930 --> 00:06:23.790	So, here also taken as n is equal to 4.
31.srt	00:06:24.310 --> 00:06:37.139	So, what we have is our x of n sample has 6 samples in this case and then we are taking n is equal to 4.
31.srt	00:06:37.649 --> 00:06:40.550	So, initially what we have is 6 samples.
31.srt	00:06:40.830 --> 00:06:56.379	at the 0 basically then x of n is put in since it is repetition what we have is n is equal to 4 you will be seeing that there is a overlap on the positive side as well as on the negative side.
31.srt	00:06:56.420 --> 00:07:02.370	So, you are seeing that there are two of them have been repeated on this.
31.srt	00:07:02.460 --> 00:07:08.010	So, you will be seeing that they are overlapping even here it is going to overlap.
31.srt	00:07:08.350 --> 00:07:11.770	Then what happens to our x tilde of n.
31.srt	00:07:12.160 --> 00:07:21.480	So, we say that support length is 6 which is greater than n then we will be seeing that because we are adding them up.
31.srt	00:07:21.770 --> 00:07:28.750	So, you will be seeing in the magnitude which has got increased with these two samples the other two samples remain same.
31.srt	00:07:29.080 --> 00:07:35.800	So, you will be seeing that this repetition is going to happen on the positive side as well as on the negative side.
31.srt	00:07:36.129 --> 00:07:41.960	So, one has to keep it in mind that how the periodic repetition is going to happen.
31.srt	00:07:42.439 --> 00:07:58.500	have a overlap when our length is greater than our n. So, coming to the thing we will see that how we are going to have the periodic repetition once again what you will be seeing the thing.
31.srt	00:07:58.899 --> 00:08:01.259	So, you have x of n here.
31.srt	00:08:01.709 --> 00:08:10.980	So, then what is the thing is going to happen only we are taking the samples here which are length 4.
31.srt	00:08:11.480 --> 00:08:16.930	So, you will be seeing that the magnitude of them is 2101.
31.srt	00:08:17.699 --> 00:08:43.639	And, then x of n has support for n is equal to 0 to n minus 1, then our x of n capital n will be it is n mod n what will be taking it as x tilde n which is given by the equation i is equal to minus infinity to infinity x of n minus i n. So, how this is going to be represented?
31.srt	00:08:43.639 --> 00:08:48.299	So, this is our x of n this is what we have taken the thing.
31.srt	00:08:48.600 --> 00:08:57.149	So, when we do the repetition you will be seeing that modulo of n is going to be 2 1 0 1.
31.srt	00:08:57.600 --> 00:09:09.480	So, because the support size and period size are the same there is no overlap when taking the periodic repetition of our x of n. So, you will be seeing that it is same.
31.srt	00:09:10.079 --> 00:09:20.519	So, now, coming to the this thing modulo indices same thing periodic repetition how it is going to look like what we will be seeing with the thing.
31.srt	00:09:20.809 --> 00:09:22.579	So, you will be seeing that the same.
31.srt	00:09:23.609 --> 00:09:29.599	values have been taken 2 1 0 and 1 and then when we take the module of it.
31.srt	00:09:29.839 --> 00:09:41.049	So, you will be seeing that it is going to go in the 0th here then minus 1 will be this is the way and then 1 next what will going to have the thing.
31.srt	00:09:41.389 --> 00:09:45.989	So, it will be repeating the value at different intervals what it is shown here.
31.srt	00:09:46.369 --> 00:09:50.589	So, which is shown again in this manner.
31.srt	00:09:50.989 --> 00:09:56.029	So, from here to here what will be going from here to here and from there.
31.srt	00:09:56.519 --> 00:10:04.349	we can show it pictorially that this is the way what we are going to represent in the periodic of form.
31.srt	00:10:04.669 --> 00:10:12.749	So, that is x of n modulo n is nothing, but our repetition x tilde of n which is shown there.
31.srt	00:10:13.169 --> 00:10:23.709	So, from here what you can draw your diagram as x and y coordinates repetition of x of n in this manner.
31.srt	00:10:24.509 --> 00:10:28.729	So, now, we have to look in for the circular convolution.
31.srt	00:10:28.729 --> 00:10:37.419	So, you must be remembering we have taken some examples and then we repeated the computation of the circular convolution.
31.srt	00:10:38.999 --> 00:10:42.949	So, there are 2 interpretation the first interpretation what we will see it.
31.srt	00:10:43.319 --> 00:10:50.499	So, we are assuming x 1 and x 2 have support n is equal to 0 to n minus 1.
31.srt	00:10:50.989 --> 00:11:01.219	Then take the periodic decryption of our x 2 of n with period n we are assuming both are of the size n in this case.
31.srt	00:11:01.559 --> 00:11:10.169	Then what happens it is going to be k is equal to 0 to n minus 1 x 1 of k into x 2 of n minus k.
31.srt	00:11:10.549 --> 00:11:20.499	modulo n what we are going to take it or we can write it x 2 of k into this thing modulus of r x of x 1 basically here.
31.srt	00:11:20.499 --> 00:11:21.349	So, both are the same thing.
31.srt	00:11:21.869 --> 00:11:24.339	So, we can use any one of them.
31.srt	00:11:24.339 --> 00:11:37.329	So, conduct a standard linear convolution of x 1 and then x 1 and x 2 tilde n for n is equal to 0 to n minus 1.
31.srt	00:11:37.679 --> 00:11:45.359	So, we remember that circular convolution has the symbol like this x 1 and convolved with x 2 of n.
31.srt	00:11:45.689 --> 00:11:58.629	or the other way round what we will be seeing it x 1 of n convolved with our distinct linear convolution x 2 periodic tilde of n what we can give it which is same.
31.srt	00:11:59.019 --> 00:12:00.739	So, this is the equation.
31.srt	00:12:01.189 --> 00:12:02.689	So, what we have it?
31.srt	00:12:03.029 --> 00:12:06.419	So, we will be seeing that this is minus infinity to infinity.
31.srt	00:12:06.419 --> 00:12:09.769	So, we cannot compute in our hardware.
31.srt	00:12:10.099 --> 00:12:17.789	So, it will be reduced from 0 to n minus 1 x 1 of k into x 2 tilde of n minus k.
31.srt	00:12:18.479 --> 00:12:22.869	So, what happens to the circular convolution of it?
31.srt	00:12:23.279 --> 00:12:33.779	It is going to be 0 for n less than 0 that is what we have assumed and n greater than or equal to n this is what we have given the equation.
31.srt	00:12:34.139 --> 00:12:39.029	So, that is it makes sense that is what we take it.
31.srt	00:12:39.129 --> 00:12:47.049	Since x of n modulo of n is nothing, but our repetition x tilde of.
31.srt	00:12:48.159 --> 00:12:52.379	So, another interpretation is what is it?
31.srt	00:12:52.809 --> 00:12:55.979	So, they have the support of 0 to n minus 1.
31.srt	00:12:56.439 --> 00:13:02.919	So, we are going to take the periodic repetition of x 2 of n with period n in this case.
31.srt	00:13:24.639 --> 00:13:31.819	So, you will be seeing that x 2 of n minus k n and then we conduct the linear convolution instead of circular convolution we will be doing the linear convolution of x 1 and x 2 for n. Then what happens x l is represented as the linear convolution of n is given by X1 of n linearly convolved with X2 of n. So, equation what you are seeing minus infinity to infinity.
31.srt	00:13:32.079 --> 00:13:51.499	So, which is going to be reduced to k is equal to 0 to n minus 1 for the implementation X1 of k into X2 of n minus k. So, compute the periodic repetition of your XL of n and window the results for n is equal to 0 to n minus 1.
31.srt	00:13:52.039 --> 00:13:57.469	So, you will be doing X1 circular convolution is equal to X2 of n.
31.srt	00:13:57.789 --> 00:14:09.249	x 2 of n which is nothing, but are a is equal to minus infinity to infinity x l of n minus i n for n is equal to 0 to n minus 1.
31.srt	00:14:09.729 --> 00:14:11.609	So, what are the two methods?
31.srt	00:14:11.869 --> 00:14:27.269	First we can do the circular convolution by taking the module of one of the signal or we can do the linear convolution of the signal and do the circular convolution at the output that is what it is shown.
31.srt	00:14:28.029 --> 00:14:34.519	So, we know that filtering of long data sequence how we are going to use our FFT.
31.srt	00:14:34.889 --> 00:14:42.859	So, as we have already discussed we have n is equal to 8 and 8 point FFT is given by this butterfly structure.
31.srt	00:14:43.419 --> 00:14:45.429	So, you have seen the thing.
31.srt	00:14:45.469 --> 00:14:50.459	So, if it is 16 you can extend it and 32 and so on.
31.srt	00:14:50.709 --> 00:14:53.149	So, it is easy to write n is equal to 8.
31.srt	00:14:53.199 --> 00:14:55.289	So, which we can use it.
31.srt	00:14:55.699 --> 00:15:00.579	So, how we are going to take care of the long data sequence that we want to filter it.
31.srt	00:15:01.899 --> 00:15:08.369	We say all n input samples are required simultaneously by the FFT operation.
31.srt	00:15:08.909 --> 00:15:15.519	So, complexity of n in FFT is what we have taken n log 2 n basically.
31.srt	00:15:16.039 --> 00:15:41.799	and if we use a symmetry property it will be n by 2 log 2 n. So, if n is too large as for long data sequences then there is a significant delay in processing that is precludes our real time processing that is we are going to have a time constraint on the thing because we do not know the length of the signal which is going to come continuously in real time.
31.srt	00:15:42.229 --> 00:15:46.379	So, how we are going to take care of this we cannot have as long as.
31.srt	00:15:46.589 --> 00:15:47.339	we want.
31.srt	00:15:47.679 --> 00:16:01.329	So, then what we do is we give the input signal here, we get it from the data acquisition delay what we are going to consider and then we will be adding our data processing delay also.
31.srt	00:16:01.329 --> 00:16:06.799	This is acquisition as well as processing, then we will be giving the signal out.
31.srt	00:16:07.149 --> 00:16:11.959	This is our real time processing what it is going to happen.
31.srt	00:16:12.199 --> 00:16:13.939	So, we will see the thing.
31.srt	00:16:13.939 --> 00:16:18.829	So, for the first case today what we will consider is the overlap.
31.srt	00:16:19.009 --> 00:16:19.499	method.
31.srt	00:16:19.619 --> 00:16:24.629	So, the next class we will come consider the overlap save method.
31.srt	00:16:24.929 --> 00:16:26.049	So, what is it?
31.srt	00:16:26.129 --> 00:16:27.299	Overlap add method.
31.srt	00:16:27.839 --> 00:16:33.679	This is going to deal with some of the signal processing principle what it is written here.
31.srt	00:16:34.099 --> 00:16:35.089	So, what is it?
31.srt	00:16:35.429 --> 00:16:50.249	We are going to have the linear convolution of a discrete time signal of length l what we are going to restrict and a discrete type signal of length m where what we are going to get the output is l plus m minus 1.
31.srt	00:16:50.869 --> 00:17:12.609	So, that is we are using the additivity property here x 1 of n plus x 2 of n convolved with our h of n is going to give us x 1 of n convolved with h of n plus x 2 of n convolved with h of n. So, that is what we are looking at it.
31.srt	00:17:13.049 --> 00:17:14.899	So, now we will see the thing.
31.srt	00:17:14.929 --> 00:17:21.809	So, what we have is input x of n is divided into non overlapping blocks basically.
31.srt	00:17:22.299 --> 00:17:28.539	and x m of n each of length l what will be considering in this.
31.srt	00:17:29.049 --> 00:17:41.709	And then each input blocks x m of n is individually filter as it is received to produce the output block y m of n. So, you will be seeing as a picture really here.
31.srt	00:17:42.039 --> 00:17:50.649	So, you are considering l is equal to 1 first that is the length in this case is n is equal to 4 what it has been taken.
31.srt	00:17:51.039 --> 00:17:53.259	So, this is the first length.
31.srt	00:17:53.559 --> 00:18:04.470	which is going to be convolved with h of n. So, the other length what we will be considering is l is equal to 4 sorry l is equal to 2, 3 and then 4.
31.srt	00:18:04.849 --> 00:18:11.319	So, in this whatever x of n signal so, we have 4 l basically.
31.srt	00:18:11.879 --> 00:18:15.710	Now, what we have done the thing so, we have separated according to the length.
31.srt	00:18:15.710 --> 00:18:23.500	So, I have 4 values in this we will do the convolution of it and the next one.
31.srt	00:18:23.709 --> 00:18:34.329	is convolved with H of n is convolved with X 2 of n then later on as you can see it we are adding with the previous one.
31.srt	00:18:34.719 --> 00:18:54.869	So, the next one is getting added with the X 3 of n. So, you will be seeing that these are the 4 samples which is in X 3 of n which is getting convolved and then you will be going on till you finish your input or if it is continuously coming this is the process which is going to be repeated for.
31.srt	00:18:55.339 --> 00:18:59.089	So, what is the filtering stage?
31.srt	00:18:59.089 --> 00:19:18.200	So, we make use of that is N DFT and N IDFT where N is the length of our this thing DFT or FFT length which is going to be L plus M minus 1.
31.srt	00:19:19.069 --> 00:19:25.490	And then we are going to do the zero padding of X of n and H of n so that are of length.
31.srt	00:19:26.279 --> 00:19:31.459	L what we call it, M is less than N is required in this case.
31.srt	00:19:31.829 --> 00:19:45.250	So, the actual implementation of the DFT IDFT will use the as we know that for fast Fourier transform what will be using it and then inverse fast Fourier transfer for computational simplicity.
31.srt	00:19:48.480 --> 00:19:53.000	So, how we are going to use the DFT for linear convolution.
31.srt	00:19:53.509 --> 00:19:56.399	So, first we are going to take XM of N.
31.srt	00:19:56.769 --> 00:20:07.009	which has the length 0 to L minus 1 and H of n is the other length which has the support n is equal to 0 to M minus 1.
31.srt	00:20:07.529 --> 00:20:26.299	So, we set that is in this case one of them is the signal H of n if it is the filter case we will be seeing that if it is a FIR filter we will be having the b coefficients the basically or H of n can represent the coefficients of the filter.
31.srt	00:20:26.690 --> 00:20:30.660	So, this is one length the other one is L length input length.
31.srt	00:20:31.490 --> 00:20:48.819	length, then we set n is greater than or equal to L plus m minus 1 that is the length of linear convolution result and 0 pad are x m n and then h n to have support for n is equal to 0 to n minus 1.
31.srt	00:20:49.240 --> 00:21:01.650	So, in the lab class we have seen that how we can do the 0 padding even two problems what we have taken how by 0 padding we can make it same length.
31.srt	00:21:02.029 --> 00:21:05.930	and then do the FFT on the two signals.
31.srt	00:21:06.380 --> 00:21:09.269	So, then what we are going to do it?
31.srt	00:21:09.319 --> 00:21:19.640	So, we are going to take first N DFT of X of M to give X M of k, k is varying between 0 to N minus 1 in this case.
31.srt	00:21:20.170 --> 00:21:30.740	And then the next one is take N DFT of H of N to give us H of k which is k also will be between 0 and minus 1.
31.srt	00:21:31.160 --> 00:21:37.730	Then we know that in the frequency domain when we have two DFTs it is only the multiplication between the.
31.srt	00:21:38.340 --> 00:21:48.290	2 signals that is y of y m of k is nothing, but x m of k into h of k for k is to 0 to n minus 1.
31.srt	00:21:48.740 --> 00:22:09.970	So, once we have done the multiplication we know that the result is available then we can take the IDFT, n IDFT of y m of k to give our y m of n. So, you must be wondering why we have to do all these things why not sigma.
31.srt	00:22:10.420 --> 00:22:45.850	So, in the last class we have seen that with the 512 points DFT computation cost and then FFT computation cost and what the frequency will be achieving although we are doing this four times basically or three times we call it because NDFT 2 of it and NIDFT cost is same basically and in between we have to do the complex multiplication in spite of the thing our computation time or the.
31.srt	00:22:46.280 --> 00:22:56.110	frequency of operation is higher than the normal DFT and even which is equivalent to our linear convolution.
31.srt	00:22:57.070 --> 00:23:01.900	So, now, we will see how we are going to do this linear convolution by other DFT.
31.srt	00:23:02.740 --> 00:23:07.970	So, length of linear convolution result is equal to length of DFT what we are going to get it.
31.srt	00:23:08.270 --> 00:23:10.630	So, this is our 4 samples.
31.srt	00:23:10.880 --> 00:23:18.360	So, we are repeating the things same 4 samples on both the sides left and then right hand side and we have assumed.
31.srt	00:23:18.620 --> 00:23:41.530	there is no overlap and then we have assumed support length is 4 which is n is equal to 4 and we can see that here x of n what we have is the 4 length and then the repetition on the r x tilde of n. So, now, we will see how we are going to overlap at addition stage.
31.srt	00:23:50.900 --> 00:23:55.000	So, from the additivity property since our x of n is equal to x1 of n plus x2 of n plus x3 of n you can go on.
31.srt	00:23:55.300 --> 00:24:02.710	So, which is nothing, but m is equal to 1 to infinity xm of n. So, this is what we have the convolution.
31.srt	00:24:03.170 --> 00:24:20.660	So, we will be using x of n convolved with h of n which is nothing, but x1 of n plus etcetera total going to be convolved with h of n or because of the our additivity property.
31.srt	00:24:20.870 --> 00:24:22.150	So, we can do them.
31.srt	00:24:22.470 --> 00:24:51.590	So, that is x m of n convolved with h of n, m is varying between 1 to infinity and then what we call it as summation of all of them individually done x m of n. So, we will be adding all y's basically that is n is equal to 1 to infinity y of y m of n will be giving us the complete overlap add output.
31.srt	00:24:52.220 --> 00:24:54.400	So, as we can see the thing here.
31.srt	00:24:54.830 --> 00:25:05.310	So, this is the length what we have it we are going to convolve with H of n and will be generating the linear convolution.
31.srt	00:25:05.310 --> 00:25:11.370	So, we know that it is going to give us L plus M minus 1 length here.
31.srt	00:25:11.710 --> 00:25:24.020	So, that whatever this extra M minus 1 samples that is we call it as which is going to be in connection.
31.srt	00:25:25.790 --> 00:25:35.750	we will be discarding them ok or we can take it to the next one and then use that is add to the next block basically.
31.srt	00:25:36.050 --> 00:25:49.770	So, this is first y 1 of n and then these two are going to be added to the next block and then we will be making it as l is equal to 4 length here as you can see the thing.
31.srt	00:25:50.200 --> 00:25:57.070	So, two samples will be coming from there these two are from m minus 1 which is 2 will be from.
31.srt	00:25:57.430 --> 00:26:25.480	this block what will be coming and then we will be using that to compute our here also y 2 of n and then later on it is y 3 of n. So, you will be adding these two samples as you can see that they are getting repeated in successive that is the m minus 1 samples are repeated in the next blocks for our computation.
31.srt	00:26:26.010 --> 00:26:31.410	So, we call y of n is nothing, but x of n convolved with our h of n.
31.srt	00:26:31.990 --> 00:26:41.110	So, thus support overlap amongst YM blocks must be accounted for that is what the one has to keep it in mind.
31.srt	00:26:41.530 --> 00:26:48.490	So, how the thing is going to happen we have this figure shows in I think that was little small.
31.srt	00:26:48.680 --> 00:26:53.540	So, you will be understanding the thing this is my complete input.
31.srt	00:26:53.860 --> 00:26:58.910	So, we have bifurcated into L chunks of them as you can see it.
31.srt	00:26:59.300 --> 00:27:02.950	We call them as X1 and X2 of n.
31.srt	00:27:03.180 --> 00:27:15.720	So, you are seeing from this m minus 1 what will be adding as 0s in this case and here also will be adding m minus 1 0s.
31.srt	00:27:16.070 --> 00:27:27.180	So, you will be seeing that you are adding m minus 1 0s with x1 of n, x2 of n and then x3 of n. Then what will be our output?
31.srt	00:27:27.570 --> 00:27:34.240	This is y1 of n and add this m minus 1 0s to this one.
31.srt	00:27:35.130 --> 00:27:44.570	that is you will be appending on the y 2 of n and then we have on the other side also m minus 1 0s.
31.srt	00:27:44.850 --> 00:27:54.300	So, this one is going to be added m minus 1 0s with y 3 of n and so on what will be having the output.
31.srt	00:27:55.890 --> 00:28:05.260	So, we have overlap add method how it is going to work what is shown in here algorithm what it has to be written.
31.srt	00:28:05.660 --> 00:28:06.610	So, what is it?
31.srt	00:28:06.680 --> 00:28:23.000	First break the input signal x of n into non-overlapping blacks of x m of n of length l. And then we are going to do the 0 pad h of n to be of length n is equal to l plus m minus 1.
31.srt	00:28:23.100 --> 00:28:35.230	And then we take n DFT of h of n to give our h of n basically k is equal to 0 to n minus 1. h of k here.
31.srt	00:28:36.550 --> 00:28:38.920	for k is equal to 0 to n minus 1.
31.srt	00:28:39.390 --> 00:29:03.160	So, for each block M we are going to 0 pad x m n to be of length n is equal to same thing l plus m minus 1 and then we are going to take n d f t of x m of n to give x m of k here for k is equal to 0 to n minus 1.
31.srt	00:29:03.790 --> 00:29:06.120	So, multiply y m k.
31.srt	00:29:06.320 --> 00:29:38.620	with x m of k what we have got it here with that of h of k. This should be h here, h m of n to give our h m of k. Then these are the two signals what we have taken the DFT and then we will be multiplying it and then take n I DFT of y m of k what we have got it to give y m of n for n will be because n was DFT n will be varying between 0 to.
31.srt	00:29:39.110 --> 00:29:40.010	n minus 1.
31.srt	00:29:40.440 --> 00:29:59.370	So, then the fifth step is form y of n by overlapping the last m minus 1 samples of y of m y m of n with the first m minus 1 samples of y m plus 1 n and adding the result.
31.srt	00:29:59.890 --> 00:30:02.180	So, this is how we will be doing it.
31.srt	00:30:02.710 --> 00:30:10.120	We will take up an example and then show that how we have done the overlap add method.
31.srt	00:30:10.460 --> 00:30:15.640	Thank you and in the next class we will cover overlap save method.
31.srt	00:30:15.970 --> 00:30:18.930	So, both of them should give us the same results.
31.srt	00:30:20.530 --> 00:30:21.010	Thank you.
19.srt	00:00:00.310 --> 00:00:24.539	Back to real time digital signal processing course.
19.srt	00:00:24.859 --> 00:00:30.039	So you can see that we are going to discuss the fourth part of IR filters today.
19.srt	00:00:30.490 --> 00:00:41.520	So, why FIR has not taken so much of time, why IR is taking you will be seeing in a while although we have already seen that quantization how it is going to affect.
19.srt	00:00:41.829 --> 00:00:52.640	So, in today's class we will work out and then see how the center frequency is going to move from with the coefficient quantization from one value to the other one.
19.srt	00:00:53.109 --> 00:01:02.920	So, as a recap so, we have been seeing the theory of IR filters and how to design them and then how the cascade.
19.srt	00:01:03.619 --> 00:01:08.579	filter section is going to aid us to implement in DSP processor.
19.srt	00:01:08.969 --> 00:01:14.900	Just to comment on it so, we know that cascade section is nothing, but it is a multiplication.
19.srt	00:01:15.200 --> 00:01:24.459	So, in DSP processor we have seen in the number system that when we do multiplication of 2 numbers the overflow is not going to happen.
19.srt	00:01:24.829 --> 00:01:30.750	Only if we have to do the addition we have to take care of overflow and then underflow.
19.srt	00:01:31.099 --> 00:01:33.959	So, the parallel section is equivalent to.
19.srt	00:01:34.569 --> 00:01:43.359	So, that is the reason why we will not use parallel structure in case of IR filter design for this hardware units.
19.srt	00:01:43.359 --> 00:01:57.759	So, usually we go with the cascade realization although both cascade and then parallel section have the same effect on the design.
19.srt	00:01:57.909 --> 00:02:05.259	According to the thing so, we will see that how we will be seeing.
19.srt	00:02:06.870 --> 00:02:11.830	So, what happens what is our transfer function is going to look like.
19.srt	00:02:12.180 --> 00:02:26.949	So, we are going to design a bandpass IR filter to be used in our digital clock recovery for a 4.8 kilo bits per second modem what we are using it which is characterized by the following transfer function.
19.srt	00:02:26.949 --> 00:02:36.920	So, you have been given your impulse response h of z is equal to 1 by 1 plus a 1 into z minus 1 plus a 2 into z minus 2.
19.srt	00:02:36.920 --> 00:02:42.629	So, it should be triggering in your mind that this is just a second order design what we are doing it.
19.srt	00:02:42.659 --> 00:02:49.400	So, in this case you have been given the values of a 1 and then a 2, a 1 is given as minus 1.957558.
19.srt	00:02:52.400 --> 00:02:55.700	And, a 2 is given as 0.995813.
19.srt	00:02:55.939 --> 00:03:08.590	So, you this your a 1 and a 2 can be designed from using MATLAB or this value has been computed and then you have been given in this equation.
19.srt	00:03:08.670 --> 00:03:19.210	So, assuming in this case because we are using in the clock recovery sampling frequency of what we are telling is 153.6 kilohertz.
19.srt	00:03:23.990 --> 00:03:31.900	to assess the effects of quantizing the coefficients what we are going to do to 8 bits that also you have to keep it in mind.
19.srt	00:03:31.900 --> 00:03:45.610	So, if you want to increase it to 16 bits you can do it and then verify what will be the centre frequency which is going to remain that is what one of the assignment what I will be putting it for you.
19.srt	00:03:46.150 --> 00:03:54.670	So, then we have to say that how the pole positions is going to affect our this thing centre frequency.
19.srt	00:03:55.110 --> 00:03:56.880	So, we will do that.
19.srt	00:03:57.120 --> 00:04:03.050	So, as we know that we have the equation how to calculate our p 1 and then p 2 value.
19.srt	00:04:03.390 --> 00:04:20.189	So, p 1 is my this thing pole position of the first one which is given r at an angle of theta and then p 2 is given at an angle r at an angle of minus theta because we are designing the complex conjugate poles in this case.
19.srt	00:04:20.569 --> 00:04:25.939	So, we had the equation that r is equal to a to the a 2.
19.srt	00:04:26.290 --> 00:04:32.209	to the power of half and then theta is given by your cos inverse minus a1 by 2r.
19.srt	00:04:32.639 --> 00:04:35.790	So, in this case how do we compute r?
19.srt	00:04:36.089 --> 00:04:51.160	So, we have been given the value of a2 as you can see a2 is given as 0.995813 which we are going to take it as square root of it because that will give me a2 value.
19.srt	00:04:51.160 --> 00:04:57.180	So, we are going to get 0.99795 what I will be.
19.srt	00:04:58.100 --> 00:04:58.990	getting it here.
19.srt	00:04:59.439 --> 00:05:03.050	So, that is r squared is a2.
19.srt	00:05:03.379 --> 00:05:06.700	So, r will be square root of a2 what you are going to have.
19.srt	00:05:07.090 --> 00:05:14.720	So, theta is going to be cos inverse a1 divided by minus a1 by 2r.
19.srt	00:05:15.000 --> 00:05:17.760	So, we know that a1 is negative.
19.srt	00:05:18.070 --> 00:05:23.930	So, that is the reason why you will be seeing positive here this is 1.957558 divided by 2r.
19.srt	00:05:23.930 --> 00:05:28.780	2r is going to be whatever what you have computed here.
19.srt	00:05:28.780 --> 00:05:30.110	So, will be.
19.srt	00:05:31.519 --> 00:05:38.220	into that which gives me in terms of degrees as 11.25 degrees fine.
19.srt	00:05:38.779 --> 00:05:45.449	So, this corresponds to a centre frequency of 4.799 kilo hertz.
19.srt	00:05:45.449 --> 00:05:47.980	So, what do we mean by that?
19.srt	00:05:47.980 --> 00:05:50.009	So, we know that this is my unit circle.
19.srt	00:05:50.009 --> 00:05:52.740	So, this is my centre.
19.srt	00:05:52.740 --> 00:05:55.500	So, we are calculating r here.
19.srt	00:05:55.620 --> 00:06:00.949	So, this is r at an angle of what we call it as zirc.
19.srt	00:06:02.020 --> 00:06:10.180	So, 11.25 degrees you have the pole ok, this is 11.25 degrees.
19.srt	00:06:10.180 --> 00:06:26.490	So, when I calculate center frequency that what we are going to do is this is my sampling frequency what it has been given and I know its degrees 11.25 degrees divided by 360 degree which is going to give me the center frequency.
19.srt	00:06:26.490 --> 00:06:32.370	So, for this it is at 4.799 kilo Hertz is the center frequency.
19.srt	00:06:33.920 --> 00:06:37.340	it is in the original state what we will call it.
19.srt	00:06:37.720 --> 00:06:49.280	Now, what you have been given in the problem is we have to quantize the coefficients to 8 bits that is what our constraint as one of the coefficients is greater than unity.
19.srt	00:06:50.259 --> 00:06:55.410	So, you will be seeing that a1 is minus 1.957558.
19.srt	00:07:04.460 --> 00:07:06.170	So, we need at least one bit to represent my coefficient in the integer format.
19.srt	00:07:06.490 --> 00:07:09.280	So, what will be the representation here?
19.srt	00:07:09.650 --> 00:07:19.189	So, we can in the normal case we say that it is Q15 format is 1.15 format for 16 bits number.
19.srt	00:07:19.189 --> 00:07:22.210	Here you have been given 8 bits basically.
19.srt	00:07:22.629 --> 00:07:37.710	So, normally if we allocate all the 7 bits, 1 is the sign bit and rest of the 7 bits then I will be talking about 1.75 or 1.7 format, but since my integer value is greater than 1.
19.srt	00:07:37.710 --> 00:07:40.240	So, I need 1 bit for my integer.
19.srt	00:07:40.240 --> 00:07:42.200	So, what happens to this?
19.srt	00:07:43.800 --> 00:07:46.510	will be representing it as 2.6 format.
19.srt	00:07:46.510 --> 00:07:50.760	This is the format what I need to represent this value.
19.srt	00:07:50.760 --> 00:07:51.990	Then what happens?
19.srt	00:07:51.990 --> 00:07:58.760	I have 6 bits for my fractional representation which I have to convert it.
19.srt	00:07:58.760 --> 00:08:14.760	So, my coefficient from a1 it is going to be a1 dash what I will be putting it minus 1.957555 into 2 power 6 which is equivalent to I will be rounding off or truncating one of the thing what you can do it.
19.srt	00:08:14.760 --> 00:08:17.780	So, which comes out as minus 1.2 minus 125.
19.srt	00:08:17.940 --> 00:08:22.759	So, if you represent in binary this is the value what you will be representing it.
19.srt	00:08:22.759 --> 00:08:24.900	So, coming to a2 dash.
19.srt	00:08:26.139 --> 00:08:28.970	So, which is given as minus 0.995913.
19.srt	00:08:28.970 --> 00:08:31.660	So, into 2 power 6 which comes out as 63.
19.srt	00:08:31.660 --> 00:08:37.970	So, it may come out as 63.5 or 63.6 exact value you can check the thing.
19.srt	00:08:37.970 --> 00:08:44.600	So, why we are representing this also in 63 I will hold on for a while we will come to that.
19.srt	00:08:44.600 --> 00:08:46.580	This is your binary representation basically fine.
19.srt	00:08:46.629 --> 00:08:55.299	So, now we will go back and then recalculate what are the values we have got it ok.
19.srt	00:08:56.899 --> 00:09:08.240	So, my maximum value what is it 125 for a 1 what I have represented in with 8 bits, then we said that it is 2 power 6 is nothing, but 64.
19.srt	00:09:08.599 --> 00:09:14.750	So, I can re divide the value and calculate what I am going to get it.
19.srt	00:09:15.109 --> 00:09:17.829	So, it becomes 1.953125.
19.srt	00:09:17.829 --> 00:09:21.449	So, what was the original this thing 957558.
19.srt	00:09:21.849 --> 00:09:27.109	So, you will be seeing that there is a quantization which is.
19.srt	00:09:27.590 --> 00:09:28.580	already happened.
19.srt	00:09:28.929 --> 00:09:34.960	Even A2 you can see that we are doing 63 by 64 which comes down to 0.984375.
19.srt	00:09:34.960 --> 00:09:38.399	So, what was the original one was 0.995913.
19.srt	00:09:38.710 --> 00:09:51.440	So, now, with this modified calculate your centre frequency apply the same equations as the previous one we call that as r dash and theta dash what we will be calculating.
19.srt	00:09:51.440 --> 00:09:57.250	So, you are seeing that from 11.54 degrees it has come down to 10.17.
19.srt	00:09:59.329 --> 00:10:03.120	So, if you want to round it off to 2 digits it is going to be that degree.
19.srt	00:10:03.409 --> 00:10:06.799	So, now calculate is your f naught that is the centre frequency.
19.srt	00:10:07.309 --> 00:10:16.129	This is what you will be getting it 10.17 divided by 360 into 153.6 into 10 power 3 because it is in kilohertz.
19.srt	00:10:16.129 --> 00:10:19.259	So, you can see that this is going to be 4.3399 kilohertz.
19.srt	00:10:19.259 --> 00:10:22.769	So, what was our original thing?
19.srt	00:10:22.769 --> 00:10:24.689	It was 4.799 kilohertz.
19.srt	00:10:24.689 --> 00:10:29.769	So, you will be seeing that.
19.srt	00:10:31.129 --> 00:10:40.039	your centre frequency has moved what we call it as centre frequency in this case is where I am dropping down.
19.srt	00:10:40.069 --> 00:10:45.750	This is we usually call it as my cutoff frequency fc ok.
19.srt	00:10:45.970 --> 00:10:54.939	So, you will be seeing that your think from 4.799 it has got moved to 4.3399.
19.srt	00:10:55.120 --> 00:10:59.179	So, you will be seeing that.
19.srt	00:11:04.799 --> 00:11:07.590	your thing has moved to left.
19.srt	00:11:07.789 --> 00:11:13.820	So, you are allowing more whatever we call it as in the stop band region.
19.srt	00:11:14.230 --> 00:11:17.809	So, that if there are going to be some aliasing.
19.srt	00:11:18.120 --> 00:11:20.080	So, it may creep into the thing.
19.srt	00:11:20.799 --> 00:11:26.620	So, this is the effect of moving quantization basically.
19.srt	00:11:26.899 --> 00:11:32.450	So, now I said I can take R is equal to 1 ok. What happens in that case?
19.srt	00:11:34.730 --> 00:11:38.129	So, we recalculate So, we have calculated and only we are giving the final thing.
19.srt	00:11:38.420 --> 00:11:51.840	So, you will be seeing that what happens to your theta dash it becomes 12.43 degrees and f naught becomes 5.303 kilohertz actually in this case fine.
19.srt	00:11:51.840 --> 00:11:55.899	So, what happens?
19.srt	00:11:55.899 --> 00:12:02.290	This is f c, this is I call it as f c dash and this I can call it as f c double dash.
19.srt	00:12:02.290 --> 00:12:04.220	So, this will be coming to.
19.srt	00:12:05.319 --> 00:12:10.870	5.303 kilo Hertz here if it is represented in kilo Hertz fine.
19.srt	00:12:12.069 --> 00:12:15.069	So, my fc double dash.
19.srt	00:12:15.069 --> 00:12:25.699	So, you will be seeing that more frequency will be coming into your input and then you will have a problem.
19.srt	00:12:25.769 --> 00:12:39.649	Here you are going to reduce the thing if there are any frequency component present in this thing is going to be cut off whereas, here more frequency has come in.
19.srt	00:12:39.649 --> 00:12:41.769	So, you will be having the aliasing effect.
19.srt	00:12:41.769 --> 00:12:43.720	So, that is the reason why.
19.srt	00:12:44.310 --> 00:12:48.060	We choose r is equal to 63 in this case.
19.srt	00:12:48.060 --> 00:12:55.009	So, which is almost nearer to our 4.799 compared to going beyond the frequency.
19.srt	00:12:55.320 --> 00:13:02.330	So, this shows that how your number of bits is going to affect.
19.srt	00:13:02.330 --> 00:13:05.159	So, now, you can calculate n is equal to 16.
19.srt	00:13:05.159 --> 00:13:07.710	So, what is the frequency?
19.srt	00:13:07.710 --> 00:13:10.360	How much difference you can get it?
19.srt	00:13:10.360 --> 00:13:13.879	You can calculate and then give the result ok.
19.srt	00:13:14.930 --> 00:13:16.190	Continuing with the thing.
19.srt	00:13:16.920 --> 00:13:26.389	How the next one is what is the word length requirement for stability and desired frequency response what we have to say.
19.srt	00:13:27.070 --> 00:13:37.879	So, our stability discussions will be restricted to second order filter sections because each individually if they are stable then we say the complete IR filter is stable.
19.srt	00:13:38.340 --> 00:13:48.950	Since these are the basic building blocks of any filter and consider our second order section characterized by the familiar equation what you are seeing it here.
19.srt	00:13:49.330 --> 00:14:02.820	That is h of z is given by b naught plus b 1 z minus 1 plus b 2 z minus 2 which represents our 0s divided by 1 plus a 1 z minus 1 plus a 2 into z minus 2.
19.srt	00:14:03.379 --> 00:14:06.460	So, a 1 a 2 are pole positions.
19.srt	00:14:06.460 --> 00:14:12.509	So, in the equation what you will be getting is y of n is k is equal to 0 to 2.
19.srt	00:14:13.009 --> 00:14:19.169	So, b k into x of n minus k this is our 0 representation minus.
19.srt	00:14:19.370 --> 00:14:25.409	are pole position that is feed this is the feed forward section and this is the feed backward section.
19.srt	00:14:25.859 --> 00:14:45.759	So, we know that poles are the roots of the denominator are located at what we call it as p 1 is equal to half minus a 1 plus a 1 squared minus 4 a 2 to the power of half or square root of a 1 squared minus a 2 and p 2 will be the complex conjugate.
19.srt	00:14:46.169 --> 00:14:50.409	So, of p 1 what will be representing it.
19.srt	00:14:51.690 --> 00:14:53.750	So, what happens in this case?
19.srt	00:14:54.240 --> 00:15:17.970	A digital we will take up an example, a digital filter required to that is satisfy the following frequency response specifications, determine a suitable transfer function for the filter and then determine a suitable coefficient word length to maintain stability and satisfy the frequency response specification.
19.srt	00:15:24.079 --> 00:15:32.149	So, you will be taking obtain and plot the frequency response of the unquantized filter Those of quantized filters corresponding to this part basically, how you will be number of bits what you will be considering.
19.srt	00:15:32.419 --> 00:15:34.730	So, what is the specification what we have?
19.srt	00:15:35.179 --> 00:15:41.949	Pass band region is given by 20.5 to 23.5 kilohertz and then stop band is given.
19.srt	00:15:41.949 --> 00:15:45.730	So, you will be seeing this is a band pass filter basically.
19.srt	00:15:45.730 --> 00:15:47.610	So, how it is represented?
19.srt	00:15:47.610 --> 00:15:49.480	This is the way I represent it.
19.srt	00:15:49.480 --> 00:15:53.579	And then this is given as 20.5 to 23.5 kilohertz.
19.srt	00:15:55.379 --> 00:16:02.429	Till pi by 2 it is going to be your stop band region in this case 25 to 50 kilohertz.
19.srt	00:16:03.039 --> 00:16:12.809	And then ripple what you want is less than or equal to 0.25 dB and then stop band attenuation what I want is greater than 45 dB.
19.srt	00:16:12.809 --> 00:16:24.169	So, as you know that it is better to design this filter using MATLAB and then get the values of your coefficients basically.
19.srt	00:16:25.259 --> 00:16:29.999	So, when you do that this is from the book I have taken the example.
19.srt	00:16:30.309 --> 00:16:37.449	So, you can refer to the book and then see CD of the book is going to give you this example.
19.srt	00:16:37.449 --> 00:16:45.069	This is basically from if Iker what I have taken the thing real digital signal processing book.
19.srt	00:16:45.469 --> 00:16:56.609	So, in this case what happens it generates as in the lab we will be seeing it that how many sections it is going to create.
19.srt	00:17:03.219 --> 00:17:11.179	So, here there are 4 second order sections which has been created and then using their and then poles you will be representing your impulse response like this h 1, h 2, h 3 and the h 4.
19.srt	00:17:11.629 --> 00:17:16.069	So, you will be seeing that this is in a cascade form basically.
19.srt	00:17:16.679 --> 00:17:21.889	There will be 4 sections what I am going to have.
19.srt	00:17:22.689 --> 00:17:29.819	This is my h 1 of z, h 2 of z and then this is h 4 of z.
19.srt	00:17:31.149 --> 00:17:33.769	So, these are the values what you will get it.
19.srt	00:17:34.659 --> 00:17:46.470	So, you have to take each second order section and then see whether there is going to be overflow or underflow or what is the number of bits what you needed.
19.srt	00:17:46.799 --> 00:17:52.359	So, that you are going to have the stable filter as you can see in this case.
19.srt	00:17:52.710 --> 00:18:05.589	So, you will be varying your number of bits that is 2 to 2 comma 3 like that you can keep on changing and then you can go up to 29 bits.
19.srt	00:18:06.180 --> 00:18:11.710	So, that is what the theory gives basically.
19.srt	00:18:11.710 --> 00:18:16.420	So, we will work out for H1 of z.
19.srt	00:18:16.420 --> 00:18:21.910	So, what is the number of b bits we will assume because even in the previous example we had taken 8 bits.
19.srt	00:18:22.279 --> 00:18:25.000	We will see whether it is going to give us a stable filter.
19.srt	00:18:25.470 --> 00:18:31.640	So, you will be seeing that A1 will be because all the coefficients are less than 1.
19.srt	00:18:32.039 --> 00:18:35.130	Now, what I can represent this as a 1.7 format.
19.srt	00:18:35.130 --> 00:18:44.930	That is why you will be seeing multiplication by 2 power 7 is happening and then we are doing the rounding that is the reason why we are adding 0.5 to that.
19.srt	00:18:44.930 --> 00:18:51.349	So, the value is going to be minus 22.8104 after that we will be truncating the value.
19.srt	00:18:53.259 --> 00:18:57.490	So, which is going to give us minus 22, same thing we will calculate a 2.
19.srt	00:18:57.819 --> 00:19:01.509	So, it will be giving us 124.1736.
19.srt	00:19:01.509 --> 00:19:06.210	So, you will be truncating here which is going to give us 124.
19.srt	00:19:06.210 --> 00:19:15.109	So, the fractional notation the coefficients are nothing, but minus 22 divided by 128.
19.srt	00:19:15.250 --> 00:19:18.440	So, this is in decimal value.
19.srt	00:19:18.440 --> 00:19:23.339	So, when I represent it in fraction, so it will be giving out as minus 0.1718.
19.srt	00:19:25.130 --> 00:19:30.500	So, you have seen I think something triggering in your mind.
19.srt	00:19:30.820 --> 00:19:42.550	So, the coefficient quantization has already happened with 8 bits, 1 point 0.1742, 0.171 what it has got reduced in this case.
19.srt	00:19:42.550 --> 00:19:44.630	So, A2 will be becoming 0.96875.
19.srt	00:19:44.630 --> 00:19:48.320	So, original was 0.9662.
19.srt	00:19:48.320 --> 00:19:57.540	So, you have seen that it has got because we have taken a round off it has got 0.96875.
19.srt	00:19:58.920 --> 00:20:03.160	little bit increased compared to the original one.
19.srt	00:20:03.549 --> 00:20:20.569	So, with this you can go back and then calculate your r and theta value and see that what we are going to get is 84.99 degrees what we are getting it.
19.srt	00:20:20.569 --> 00:20:30.330	So, what it says is the all quantized coefficients and polar coordinates were computed using an analysis program.
19.srt	00:20:31.540 --> 00:20:45.070	And, if for any coefficient word length the pole radial distance of a filter section is equal to or greater than unity, then there is potential instability that is what the literature gives.
19.srt	00:20:45.620 --> 00:20:56.200	And then it was found that all the filter sections as few as b is equal to 5 bits are required to maintain our stability.
19.srt	00:21:03.660 --> 00:21:08.740	So, in general if the pole of an unquantized second order section is at radius less than So, is more used in this case ok.
19.srt	00:21:09.039 --> 00:21:16.720	So, to see that B coefficient of second order section where each quantized to various word lengths.
19.srt	00:21:16.960 --> 00:21:31.710	So, you have to use your MATLAB code to do these things and then you can vary your word length 5 to 16 bits and then how they are going to be represented is given in the table here.
19.srt	00:21:32.059 --> 00:21:33.710	So, this is my poles.
19.srt	00:21:33.990 --> 00:21:56.899	that is a coefficients and this represent 0s that is b coefficients for 5 bits what we want is ideal is this one and then with 16 bits how almost closer what we are as you can see that most of the 16 bit is closer to the original one what we say it.
19.srt	00:22:10.799 --> 00:22:11.480	So, this is how we will be calculating and then fixing our number of bits that is the something should be triggering in our your mind all DSP processor most of them are 16 defined.
19.srt	00:22:12.309 --> 00:22:22.829	And then we have to this is one of the this thing quantization of our coefficients how it is going to vary the thing.
19.srt	00:22:23.220 --> 00:22:30.559	Next is we have to take care of overflow errors and their effects based on it what we have to decide on it.
19.srt	00:22:30.819 --> 00:22:39.200	So, we know that in two's complement arithmetic the addition of two large numbers of a similar sign may produce an overflow.
19.srt	00:22:39.569 --> 00:22:42.890	If it is beyond our representation we are going to have a overflow.
19.srt	00:22:43.420 --> 00:22:54.910	So, that it exceeds the permissible word length and then very large negative number if you are adding them negative numbers you may have a underflow in that.
19.srt	00:22:55.099 --> 00:23:03.420	So, these are the two things what you have to look at it, what is that we will see in the figure what is the thing happened.
19.srt	00:23:03.420 --> 00:23:14.069	So, the value is getting added here from here to here it has gone to the positive value we will assume.
19.srt	00:23:14.700 --> 00:23:16.080	And, then what happens?
19.srt	00:23:16.380 --> 00:23:22.730	So, when my number of bits are not sufficient immediately drops down to the negative value.
19.srt	00:23:23.430 --> 00:23:29.610	And, then again it start building up once it reach the peak value it is going to drop down.
19.srt	00:23:30.180 --> 00:23:41.569	So, this is how it will be oscillating between minus 1 and then 1 if this overflow or underflow is not taken care of.
19.srt	00:23:41.960 --> 00:23:43.690	So, what it says is.
19.srt	00:23:44.319 --> 00:23:59.559	Large scale overflow occurs at the outputs of the adders and may be prevented by scaling the inputs to the adders in such a way that outputs are kept low, but this is at the expense of reduced signal to noise ratio.
19.srt	00:24:00.059 --> 00:24:10.910	Because you are bringing down your amplitude of the signal then my signal to noise rate ratio is going to have a effect on it.
19.srt	00:24:17.180 --> 00:24:21.780	So, that is how it is important to select scale factors to prevent overflow while at same time maintaining my largest possible signal to noise ratio.
19.srt	00:24:22.110 --> 00:24:27.810	So, coming to the thing you will be seeing that overflow illustration is shown in this figure.
19.srt	00:24:27.810 --> 00:24:35.710	So, you have b naught, b 1, b 2 are the forward coefficients and then a 1 and a 2 are the feedback coefficients.
19.srt	00:24:36.080 --> 00:24:42.150	So, those both minus a 1 and then a 2 and what is the scaling factor we will be providing it.
19.srt	00:24:50.590 --> 00:25:09.519	So, this section if I am correct taking it up it is going to be scaled by 1 by s 1 at There are different places where you can do the scaling whether at the input or at the output or if you are providing any of these sections you have to integrate into all the arms basically to take care of that you have scaled everything fine.
19.srt	00:25:09.970 --> 00:25:17.610	So, as you will be seeing using the MATLAB when you are doing it the scale factor is given in the beginning itself.
19.srt	00:25:18.190 --> 00:25:20.650	So, that has to be used and then.
19.srt	00:25:21.059 --> 00:25:22.470	your filter has to be designed.
19.srt	00:25:23.269 --> 00:25:25.909	So, what is the principle of scaling?
19.srt	00:25:25.909 --> 00:25:38.690	So, first we will consider the canonic section because this is the one most widely used in all hardware implementation that is what we are seeing it.
19.srt	00:25:51.480 --> 00:25:54.509	As I said that it is scaled by 1 by S1 and when we want to get back of our Yn either I can scale up here or provide at these legs ok.
19.srt	00:25:55.000 --> 00:26:08.009	So, if I take the scaling factor inside as I was mentioning in the original thing this is going to be b0 by s1 and b1 by s1 and then b2 by s1.
19.srt	00:26:08.359 --> 00:26:21.849	When we are loading our coefficients itself if we want we can scale them if they are power of 2 if they are not then you will be having little computation.
19.srt	00:26:22.339 --> 00:26:28.789	involvement in designing your FIR sorry IAR filter.
19.srt	00:26:29.319 --> 00:26:39.579	So, you will be seeing that in the end what you can do is I can scale the output by S1 value ok.
19.srt	00:26:39.909 --> 00:26:44.409	So, you will be seeing that what are the principles to use the scaling.
19.srt	00:26:44.939 --> 00:26:53.039	So, most of you would have heard of what we have norms basically it can be L1 norm, L2 norm or L3 norm.
19.srt	00:26:53.240 --> 00:26:57.899	L infinity are the 3 norms what we have in literature.
19.srt	00:26:58.309 --> 00:27:03.909	So, what is that first we will see the L1 norm we call it as scaling by as S1.
19.srt	00:27:04.299 --> 00:27:07.309	So, here it says k is equal to 0 to infinity.
19.srt	00:27:07.609 --> 00:27:18.959	So, I am going to take the frequency response of my input and take the magnitude of it and then calculate the summation of all of them.
19.srt	00:27:23.639 --> 00:27:32.229	So, as it says f of K is the impulse response from input to the output of the first adder that is W of n in our figure here.
19.srt	00:27:32.779 --> 00:27:36.789	This is what I will be taking the impulse response of that.
19.srt	00:27:37.309 --> 00:27:45.329	And then in the second method often we usually call it as L2 norm, the scale factor is calculated this way.
19.srt	00:27:45.769 --> 00:27:56.849	So, if you want you can call it as S2 here or you we can have it as S1 is the scaling factor what notation what we are using it.
19.srt	00:27:57.179 --> 00:27:58.549	So, in this case.
19.srt	00:27:58.839 --> 00:28:08.039	You will take the impulse response, but you will be taking the square root of the value what you have sum sum value what you have calculated.
19.srt	00:28:08.639 --> 00:28:16.939	So, that is what it says scale factor may be obtained using contour integration via the relationship.
19.srt	00:28:17.649 --> 00:28:26.629	The last one L infinity norm what you are going to do is k is equal to 0 to infinity what I have to calculate f of k impulse response.
19.srt	00:28:27.119 --> 00:28:29.469	So, which is given as 1 pi.
19.srt	00:29:00.089 --> 00:29:01.180	2 pi j this is the L2 norm what we are doing with the contour integration as you can see it integral of f of z into f z minus 1 this is a complex conjugate what I have taken the thing dz by z where your f of z is that z transform of your f of k impulse response and this is represents our contour integral around the unit circle magnitude of z is equal to 1 basically.
19.srt	00:29:01.750 --> 00:29:05.440	So, evaluating this is much easier.
19.srt	00:29:05.819 --> 00:29:18.990	So, if you want you can go to the book and then refer to the steps involved in deriving this equation final equation in terms of your poles basically what it is calculated.
19.srt	00:29:19.359 --> 00:29:26.559	So, you will be calculating the contour integral of your poles in conjugate form dz by z.
19.srt	00:29:36.670 --> 00:29:39.190	So, if you do the simplification of it what then simplest one you will be getting it is 1 minus a to square minus a1 square into 1 minus a a2 divided by 1 plus a2.
19.srt	00:29:40.059 --> 00:29:46.620	So, this is how one can manually calculate our L2 norm using this.
19.srt	00:29:46.990 --> 00:30:01.870	So, in method 3 we calculate peak amplitude of the frequency response between the input and then W of n that is we will be taking the Fourier transform and then the peak amplitude whatever it has it.
19.srt	00:30:02.299 --> 00:30:05.289	So, we will be giving that as our scaling factor.
19.srt	00:30:05.880 --> 00:30:09.309	So, these are the underlying methods what we have it.
19.srt	00:30:11.650 --> 00:30:34.950	So, you can read the theory compact way of expressing the scale factor what we call it as S1 is our L1 norm what we have it with P. So, you will be seeing that we this is represented as norm and the method what we are going to have it is L1 norm, L2 norm are in L infinity norm.
19.srt	00:30:35.320 --> 00:30:43.000	And then how the scaling factors are going to get themselves aligned or compare what we will be seeing it.
19.srt	00:30:43.510 --> 00:30:53.380	So, L2 norm is the minimum and then next comes the L infinity and then L1 is the maximum what you would have scaled.
19.srt	00:30:54.000 --> 00:30:58.120	So, the value of L2 is less than your L infinity which is less than L1.
19.srt	00:30:58.250 --> 00:31:05.030	So, we will take up an example and then see how we are going to calculate this.
19.srt	00:31:05.300 --> 00:31:14.440	So, in the book it says that the figure whatever in 13.19 is been used.
19.srt	00:31:15.430 --> 00:31:20.860	And then we have this is our second order section for the example.
19.srt	00:31:21.470 --> 00:31:24.010	Then what is the thing is going to happen?
19.srt	00:31:24.370 --> 00:31:38.390	So either using flow diagram what you can flow analysis you can use the thing or you can use the book if you are using the thing CD which is the companion which is going to have it.
19.srt	00:31:38.710 --> 00:31:45.020	So, you will be getting these codes for this program and then you can run it.
19.srt	00:31:45.370 --> 00:31:48.480	So, you can evaluate all the equations.
19.srt	00:31:48.730 --> 00:31:59.160	in your book and then get the scale factors for 3 methods which it is computed and then you will be seeing it.
19.srt	00:31:59.490 --> 00:32:11.520	So, for the L1 norm it is 3.7112 and for L2 norm it is 1.7352 and then L infinity 3.5863 what you will be getting it.
19.srt	00:32:11.520 --> 00:32:18.030	So, one of the thing what we can compute we know that we have the equation to calculate our L2 norm.
19.srt	00:32:19.450 --> 00:32:27.730	So, which is given as S 1 squared is equal to 1 by this your a 1 and then a 2 what you will be substituting and calculate.
19.srt	00:32:28.080 --> 00:32:31.150	So, when you calculate it S 1 is coming as 1.7350.
19.srt	00:32:31.150 --> 00:32:37.400	So, which is closer to whatever the software has calculated the thing.
19.srt	00:32:37.730 --> 00:32:40.299	So, this is how you can do that.
19.srt	00:32:40.299 --> 00:32:54.279	So, the thing is given as your b naught b 1 b 2 and then this is the diagram what you have it for the example there and then see go and then look at them.
19.srt	00:32:55.240 --> 00:33:02.210	So, if you are realizing the scaling factor for cascade realization.
19.srt	00:33:02.690 --> 00:33:16.600	So, you will be seeing that each one has to be calculated and then how you will be rescaling back in the in between what you can see it one of the norms what you can use that fine.
19.srt	00:33:17.100 --> 00:33:19.380	So, this is how you will be selecting it.
19.srt	00:33:19.690 --> 00:33:31.519	So, one of the ways either you can have the division done when you are storing your after multiplication before summation you can scale them and then do the addition that way you will be.
19.srt	00:33:31.980 --> 00:33:37.630	avoiding your overflow instead of adding them and if there is a overflow and then dividing it later.
19.srt	00:33:37.630 --> 00:33:40.840	So, you can provide the scaling factor at this itself.
19.srt	00:33:40.840 --> 00:33:53.910	So, this shows for the sixth order I R filter how you will be doing the scaling part of it and then the final one you will be multiplying only by S3 whatever scaling you have done.
19.srt	00:34:05.000 --> 00:34:15.600	So, you will be accounting for S3 and then you will be sending the output y of n. So, this is what the S2 and S3 for the figures you can So, these are the cascade section H1, H2, H3 using MATLAB you can calculate them and then you can get the thing.
19.srt	00:34:15.900 --> 00:34:26.830	So, if you use your FWS program, so the solution you will be seeing that L1, L2, L infinity for the 3 sections what it is calculated.
19.srt	00:34:27.280 --> 00:34:38.650	This given in the thing L2 is going to give you the minimum this thing scaling factor and then the maximum is L1, L infinity lies in between.
19.srt	00:34:39.010 --> 00:34:41.640	The simplest method to calculate is L2.
19.srt	00:34:41.930 --> 00:34:56.990	So, if your application is going to overflow and then you are going to get results malfunctioning then better to go with one of these norms L1 or L infinity which is going to suit your application.
19.srt	00:34:57.460 --> 00:35:01.350	So, just the last slide to wind up our IR filter.
19.srt	00:35:01.760 --> 00:35:05.640	So, we will be seeing the comparison between our FIR and IR filter.
19.srt	00:35:05.950 --> 00:35:11.980	Few of the parameters what you can see the thing, one or two I will specify and rest of it you can go through.
19.srt	00:35:12.380 --> 00:35:16.160	So, that is sensitivity to filter coefficient quantization.
19.srt	00:35:16.630 --> 00:35:29.280	So, it can be as high it says in Motorola they use the 24 bit coefficients to for high fidelity audio function in their processor.
19.srt	00:35:29.480 --> 00:35:37.310	Otherwise all TI or analog devices they use 16 bit for their number representation.
19.srt	00:35:37.470 --> 00:35:49.070	So, in the case of we know that IFR filter it is very low and it says 16 bit coefficients are safely represented or computed.
19.srt	00:35:49.620 --> 00:35:50.470	using that.
19.srt	00:35:50.950 --> 00:36:10.650	And then probability or overflow it can be very high in this case, which is going to be very low and coming with our linear phase, we do not have IR filter direct method to implement it, but nowadays over the IR filter you can try to impose the linear phase.
19.srt	00:36:11.030 --> 00:36:15.019	So, using software techniques, so you can go through the MATLAB functions.
19.srt	00:36:15.360 --> 00:36:19.780	So, otherwise they do not provide the linearity of the phase, whereas it is guaranteed.
19.srt	00:36:19.890 --> 00:36:29.960	And rest of the thing what you will be seeing it, one of the example will be supporting supports adaptive filtering what it says.
19.srt	00:36:30.350 --> 00:36:33.440	So, I have both of them support adaptive filter.
19.srt	00:36:33.470 --> 00:36:39.400	So, we will be considering it in the next after few classes later.
19.srt	00:36:39.780 --> 00:36:44.370	So, coming to the end of it which finishes our filter design.
19.srt	00:36:44.370 --> 00:36:51.560	So, we will be taking our DFT and then FFT in the next class.
19.srt	00:36:51.900 --> 00:37:00.190	So, thank you for listening to this lecture and then happy learning through this media.
19.srt	00:37:01.300 --> 00:37:01.640	Thank you.
27.srt	00:00:00.320 --> 00:00:22.670	We come back to real time digital signal processing course.
27.srt	00:00:22.670 --> 00:00:25.980	So we have discussed about DFT in the last class.
27.srt	00:00:26.510 --> 00:00:31.589	Today we will try to cover.
27.srt	00:00:31.890 --> 00:00:42.829	So, to have a recap we discussed about discrete Fourier transform in the last class and then how to use that for circular convolution.
27.srt	00:00:43.320 --> 00:00:58.320	To give a flavor of it so, we will see the resolution what we discussed how the interval R resolution in the frequency domain is going to get affected whether it gets affected by padding 0's or not what we will look at it.
27.srt	00:00:58.640 --> 00:01:03.189	So, what we have here is how to check the.
27.srt	00:01:03.899 --> 00:01:08.229	frequency domain resolution.
27.srt	00:01:08.620 --> 00:01:24.729	So, we call f as the resolution which is approximated as 1 divided by n times t. We call this as hertz, t is a sampling period and then n is the number of DFT points what we will be taking it.
27.srt	00:01:24.729 --> 00:01:34.319	So, which we can give it as delta f as the resolution named with f resolution then we will be having n into delta f resolution.
27.srt	00:01:39.799 --> 00:01:44.119	So, this is the time period between two samples.
27.srt	00:01:44.390 --> 00:01:49.149	So, which is nothing but 1 by t which is nothing but FSR hertz.
27.srt	00:01:49.649 --> 00:02:06.009	So, what does it say frequency resolution is determined only by the length of the observation interval that is what we call it as n here whereas, the frequency interval is determined by the length of the sampling interval.
27.srt	00:02:06.719 --> 00:02:09.969	So, increasing the sampling rate.
27.srt	00:02:10.319 --> 00:02:20.689	It means that expand the frequency interval and increase observation time which will help our improving the frequency resolution.
27.srt	00:02:21.240 --> 00:02:25.469	So, zero padding does not alter the frequency resolution.
27.srt	00:02:26.020 --> 00:02:37.139	So, because resolution is going to be determined by the length of the observation interval that is whatever n what we have chosen and zero padding does not increase this length.
27.srt	00:02:37.560 --> 00:02:42.120	So, to show this so one can run MATLAB.
27.srt	00:02:43.049 --> 00:02:49.409	equation to see that how it is going to affect the resolution.
27.srt	00:02:49.409 --> 00:03:02.310	So, we will take two complex signals with close frequencies that one is with 10 hertz and one F 2 with 12 hertz sample with the sampling interval t is equal to 0.02.
27.srt	00:03:02.429 --> 00:03:05.489	So, it is going to be approximately 50 hertz.
27.srt	00:03:05.489 --> 00:03:12.879	So, consider various data length n is equal to 10, 15, 30 and then 100.
27.srt	00:03:13.919 --> 00:03:19.969	and we will pad these n with rest of the values as 0.
27.srt	00:03:20.779 --> 00:03:26.499	So, that it becomes 512 points and then run it in MATLAB.
27.srt	00:03:27.299 --> 00:03:30.509	As you can see for n is equal to 10.
27.srt	00:03:30.849 --> 00:03:38.819	So, which is what is the frequency we are going to have f 2 minus f 1 is what we have is 2 hertz.
27.srt	00:03:39.509 --> 00:03:44.649	So, what is our resolution it is 1 by n t.
27.srt	00:03:45.039 --> 00:03:46.919	which is equivalent to 5 hertz.
27.srt	00:03:47.199 --> 00:03:53.019	So, hence these two signals are not bifurcated as you can see only one is shown.
27.srt	00:03:53.409 --> 00:04:02.009	So, as this thing what it is showing 10 times this basically as a 10 hertz thing.
27.srt	00:04:02.479 --> 00:04:06.079	So, you are seeing it as 100 here in this.
27.srt	00:04:06.689 --> 00:04:14.839	So, coming to the next one when we substitute n is equal to 15 in your algorithm and then run.
27.srt	00:04:15.429 --> 00:04:21.399	Still, if this is not resolved why because our 1 by n t is equal to 3.3 hertz.
27.srt	00:04:21.399 --> 00:04:27.920	So, that is the 2 hertz is less than the interval between the 2 samples.
27.srt	00:04:27.920 --> 00:04:38.519	So, still you represent your 10 and then 12 as approximately 10 hertz itself and coming with n is equal to 30.
27.srt	00:04:38.519 --> 00:04:41.800	So, partly as we can see it is resolved.
27.srt	00:04:41.800 --> 00:04:45.629	So, we are going to see 2 peaks in our.
27.srt	00:04:46.389 --> 00:04:56.089	DFT domain with n 30 samples and then rest of them are 0 padded to make it 512 points.
27.srt	00:04:56.439 --> 00:05:03.429	So, it is what is it our resolution 1 by n t which is equal to 1.7 hertz.
27.srt	00:05:03.499 --> 00:05:07.939	So, you will be which is 2 hertz is greater than this.
27.srt	00:05:07.939 --> 00:05:13.259	So, hence you will be seeing 2 waveforms peaks here which is appearing.
27.srt	00:05:13.259 --> 00:05:16.099	So, when we go to n is equal to 100.
27.srt	00:05:17.109 --> 00:05:20.649	So, you will be clearly seeing them 2 peaks ok.
27.srt	00:05:20.750 --> 00:05:24.310	So, it is dropping down to 0 and then again raising.
27.srt	00:05:24.739 --> 00:05:28.959	So, this will be at 10 hertz and this will be at 12 hertz.
27.srt	00:05:29.219 --> 00:05:34.209	So, what is the resolution here we have it 1 by n t is 0.5 hertz.
27.srt	00:05:34.209 --> 00:05:44.669	So, as you can see that whatever we claimed in the previous slide that is 0 padding is not going to alter the frequency resolution.
27.srt	00:05:44.810 --> 00:05:47.419	That is what shown in the next slide.
27.srt	00:05:48.149 --> 00:05:52.539	So, coming with the next why we have to go for FFT.
27.srt	00:05:53.050 --> 00:05:57.069	So, initially we will take up radix 2 FFT.
27.srt	00:05:57.379 --> 00:06:05.069	So, we will see that how we are going to derive our fast Fourier transform algorithm for our DFT.
27.srt	00:06:05.459 --> 00:06:15.829	As we discussed in the last class the computation of DFT is order of n squared actually that is complex multiplication and addition.
27.srt	00:06:16.189 --> 00:06:19.269	So, we will be seeing that how we can reduce it.
27.srt	00:06:19.649 --> 00:06:21.579	using butterfly structure.
27.srt	00:06:21.919 --> 00:06:25.849	So, we are representing two butterfly ways of representing it.
27.srt	00:06:25.849 --> 00:06:31.879	One is in the decimation in time what we will be looking at it.
27.srt	00:06:32.239 --> 00:06:43.629	So, your twiddle factors W n k is going to be fed here and whereas, in the decimation in frequency it is at the output what you will be feeding it in.
27.srt	00:06:43.629 --> 00:06:49.609	So, both are the same concept and then what is the output here.
27.srt	00:06:50.029 --> 00:06:51.169	So, we know that.
27.srt	00:06:51.589 --> 00:07:07.319	A will have real component plus the imaginary component what we are feeding A is equal to and then B value also will be providing real and imaginary that is inputs are complex in nature.
27.srt	00:07:07.360 --> 00:07:14.649	So, what will be the output we will see in a while which we call it as A dash here.
27.srt	00:07:15.129 --> 00:07:23.240	So, we will be seeing that our twiddle factors W n k is nothing, but e power minus j 2 pi k by n.
27.srt	00:07:23.709 --> 00:07:31.799	So, which is expanded in cos and sin you will be seeing it cos 2 pi k by n minus j sin 2 pi k by n ok.
27.srt	00:07:32.119 --> 00:07:44.429	So, output a dash what we call it when we expand this a with real and then imaginary and b also with real and imaginary and w and k with cos and sin function.
27.srt	00:07:44.789 --> 00:07:55.149	So, this is what we will be getting it that is a real plus b real into cos x plus b i imaginary part into sin x.
27.srt	00:07:57.009 --> 00:08:03.749	plus j times this is the imaginary part, this is the real part and this is the imaginary part of it.
27.srt	00:08:04.119 --> 00:08:11.739	So, you will be seeing that same way even the b dash is going to be represented with real and then imaginary part separately.
27.srt	00:08:12.049 --> 00:08:21.549	So, from this you will be seeing that how many multiplications that is what we have real multiplication and addition what you can count from it.
27.srt	00:08:21.919 --> 00:08:28.559	So, I will be having 1, 2, 3 and then 4 multiplications.
27.srt	00:08:29.089 --> 00:08:44.379	And, then you will be seeing that 1, 2, 3 and then sorry for the real part 2 additions and imaginary part 2 additions taking into account my subtraction also.
27.srt	00:08:44.849 --> 00:08:51.959	So, this is how what you can separate and then B dash also we will be having the same amount.
27.srt	00:08:52.259 --> 00:08:59.389	So, what we say is one complex multiplication leads to 4 real multiplications.
27.srt	00:08:59.750 --> 00:09:04.059	and 2 additions what we are going to have it fine.
27.srt	00:09:04.600 --> 00:09:08.889	So, if we apply the symmetry property.
27.srt	00:09:09.419 --> 00:09:13.529	So, then we will see how we are going to make our twiddle factors look like.
27.srt	00:09:13.710 --> 00:09:27.350	So, W n into n k is given as we know that it is e power minus j to pi n n k divided by n. So, nothing but cos and sin what we have taken the thing.
27.srt	00:09:27.820 --> 00:09:30.279	So, how we represent W 8 0.
27.srt	00:09:31.009 --> 00:09:35.789	So, to show that our butterfly structure we will be taking n is equal to 8.
27.srt	00:09:36.490 --> 00:09:46.019	So, this will be e power minus j 2 pi by 8 into 0 which is nothing, but cos 0 minus j sin 0.
27.srt	00:09:46.370 --> 00:09:48.850	So, we know that sin 0 is 0.
27.srt	00:09:48.850 --> 00:09:50.629	So, cos 0 is plus 1.
27.srt	00:09:50.629 --> 00:09:54.490	So, we will be getting 1 and then w 0 1.
27.srt	00:09:55.000 --> 00:10:01.139	So, what it is going to be cos pi by 4 minus j sin pi by 4.
27.srt	00:10:02.139 --> 00:10:11.179	And, then w a 2 will be represented as this and then it is nothing, but cos pi by 2 minus j sin pi by 2.
27.srt	00:10:11.799 --> 00:10:24.899	So, and then w a 3 what we have is e power minus j 2 pi by 8 into 3 which is nothing, but cos 3 pi by 4 minus j sin 3 pi by 4.
27.srt	00:10:25.459 --> 00:10:31.990	So, how many coefficients we have calculated n by 2 in this case for n is equal to 8.
27.srt	00:10:32.719 --> 00:10:46.509	So, the rest of the thing that is 0 to 3 you can compute, rest of them what you can do is you can calculate it as w 8 4 is nothing, but w 8 0 plus 4.
27.srt	00:10:47.169 --> 00:10:52.099	So, which is nothing, but minus w 8 0 which will be minus 1.
27.srt	00:10:52.939 --> 00:10:59.779	So, you will be using the symmetry property here to get the rest of the coefficients.
27.srt	00:10:59.869 --> 00:11:03.419	Same way w 8 5 and w 8 6 are the same.
27.srt	00:11:04.199 --> 00:11:10.519	calculated and then rw87 remains same ok.
27.srt	00:11:10.879 --> 00:11:20.409	So, to see that how the coefficients are calculated both cos and sin coefficients for n is equal to 8 has been plotted in this case.
27.srt	00:11:20.729 --> 00:11:36.019	So, we know that sin starts from 0 and then how pi by 4 here and then pi by 2 and then next is pi by 2 pi by 3 and then.
27.srt	00:11:36.519 --> 00:11:39.079	how we will be going with values.
27.srt	00:11:39.409 --> 00:11:51.499	And then cos we know that it starts from 1 basically and then how rest of the thing pi by 4 and then pi by 2 what it you are seeing it in this case.
27.srt	00:11:52.049 --> 00:12:08.059	So, these are the 8 coefficients what we will be having it for are 8 point DFT that is discrete Fourier transform which will be deriving it for our fast Fourier time fast Fourier transform basically.
27.srt	00:12:08.269 --> 00:12:10.919	So, we will see first decimation in time.
27.srt	00:12:10.919 --> 00:12:19.199	So, we said there are 2 ways of doing it one is decimation in time the other one is decimation in frequency.
27.srt	00:12:19.569 --> 00:12:21.689	So, first we will take the time part of it.
27.srt	00:12:21.959 --> 00:12:24.559	So, how we are going to bivocate that?
27.srt	00:12:24.649 --> 00:12:31.859	So, x of k is equal to we can take even parts and then the odd parts separately.
27.srt	00:12:31.859 --> 00:12:33.559	So, that is what we name.
27.srt	00:12:34.019 --> 00:12:35.889	So, two summations what will be splitting it into.
27.srt	00:12:36.229 --> 00:12:47.159	So, which is equivalent to or r is equal to 0 to n by 2 minus 1 x of 2r here n is replaced with.
27.srt	00:12:50.579 --> 00:12:59.279	r basically for e1 it is going to be 2r for r part of it is going to be 2r plus 1.
27.srt	00:12:59.939 --> 00:13:11.899	So, this is n by 2 minus 1 and here also it is going to be n by 2 minus 1 and we have substituted r is equal to 2r.
27.srt	00:13:11.899 --> 00:13:21.299	So, this will be w n 2r k and here what we will be having w n 2r plus 1 into k. So, now we will see that.
27.srt	00:13:21.689 --> 00:13:38.809	by combining it that is 2 we are taking it out inside in this equation and r k goes here we have separated it out into w n 2 to the power of r k the other one term is w n k basically.
27.srt	00:13:38.999 --> 00:13:45.639	So, it which is not dependent on r. So, we can take it as a constant then take it outside in this equation.
27.srt	00:13:46.119 --> 00:13:52.429	So, now, we will see what is going to happen with our w n 2 which is nothing but e power minus 2.
27.srt	00:13:52.889 --> 00:14:02.069	2 pi by n which is when you split the thing it is going to be e power minus j 2 pi n by 2.
27.srt	00:14:02.339 --> 00:14:08.129	So, we will name this twiddle factor as w n by 2 fine.
27.srt	00:14:08.379 --> 00:14:24.309	So, when we substitute that so, we will be ending up with x of 2 r w n by 2 r k and w n k the other one is x of 2 r plus 1 w n by 2 r k.
27.srt	00:14:24.849 --> 00:14:41.279	g of k plus w k h of k. So, these are the two terms what we will get it when we split k 2 0 to n by 2 and the other part is n by 2 plus k 2 values what we will be representing it.
27.srt	00:14:41.779 --> 00:14:46.589	So, now, continuing with the thing DIT part of it.
27.srt	00:14:54.939 --> 00:15:09.079	So, we are naming g of k is thus we will give it as g r and w n by 2 to r k and then G of we are going to split this into 2 parts again even and then odd part G of k. So, then we give a new notation that is L actually.
27.srt	00:15:09.469 --> 00:15:15.599	So, this will be 0 to n by 4 minus 1 earlier it was n by 2.
27.srt	00:15:15.599 --> 00:15:17.909	So, we are bifurcating dividing by 2.
27.srt	00:15:25.999 --> 00:15:36.179	So, it is going to be n by 4 minus 1 and then this is going to be G of 2 L into W n by 2 into 2 L k this will be 2 L plus 1 W n by 2 into 2 L plus 1 k. So, same way if we represent the thing g of k now.
27.srt	00:15:36.609 --> 00:15:39.869	So, we can have it as earlier splitting.
27.srt	00:16:00.119 --> 00:16:14.899	So, we will be putting it as W n by 4 L k you have to recall that we named it as W n by 2 R k earlier now it will be L k bottom multiplied by 2 it is going to be n by 4 and then this is W n by 2 into to the power of k and again 2L plus 1 into W n by 4 into L k. So, same way we can split our h of k. So, because we had both g k and then h k here.
27.srt	00:16:15.389 --> 00:16:19.659	So, the first we have bifurcated g k into 2 parts h k we have to bifurcate.
27.srt	00:16:20.519 --> 00:16:31.469	So, when we do that it will be ending up in h of 2L even and then odd part of it n by 4 into L k and then this becomes.
27.srt	00:16:31.859 --> 00:16:37.489	As you can see this is this was W n k then when we split the thing.
27.srt	00:16:37.799 --> 00:16:48.709	So, it will be becoming n by 2 here into k this is the constant what we will have it twiddle factor and this is our normal one.
27.srt	00:16:49.259 --> 00:16:50.649	So, then what happens?
27.srt	00:16:50.649 --> 00:17:02.489	So, how we are going to define are all these coefficients W n by 2 k is nothing, but e power minus j 2 pi k n by 2 which is nothing, but W n 2 k.
27.srt	00:17:02.949 --> 00:17:30.949	And, same way W n by 2 0 is nothing, but W n 0 W n by 2 1 is now is equivalent to W n squared and W n by 2 squared will be equal to W n by 4 which is nothing, but W minus W n 0 and W n by 2 whole cube is nothing, but W n to the power of 6 which is nothing, but minus W n squared.
27.srt	00:17:31.299 --> 00:17:32.759	So, you are seeing that.
27.srt	00:17:33.069 --> 00:17:48.749	This g of k is this n by 4 point DFT and then h of k the odd part of it is shown here and further we will be getting our g 0, g 1, g 2, g 3.
27.srt	00:17:49.059 --> 00:18:01.919	So, you are seeing this is input is x of 0 and then here x of 4 and then x of 2 and then x of 6 for the even part where you are bifurcating g k into.
27.srt	00:18:03.019 --> 00:18:06.199	E1 and then Rd in this case.
27.srt	00:18:06.799 --> 00:18:11.679	So, coming for n is equal to 8 now we will split the thing.
27.srt	00:18:12.239 --> 00:18:31.689	So, what we have is this is my n by 4 point DFT what you have it on the left hand side and then we will be combining our weights in this case and then this is the final output.
27.srt	00:18:31.959 --> 00:18:33.459	So, how we will be feeding it?
27.srt	00:18:33.779 --> 00:18:36.149	So, we had for the two of it.
27.srt	00:18:40.730 --> 00:18:48.359	So, the other h k is the into 2 stages as you can see x of n and x of 5 and then the other one is x of 3 and x of 7.
27.srt	00:18:48.779 --> 00:18:56.759	So, we will be having combining the thing this is our output x 0 to x 7.
27.srt	00:18:57.139 --> 00:19:02.049	So, now what we will do is we have all our inputs here.
27.srt	00:19:02.359 --> 00:19:10.359	So, this we will see n by 4 point is nothing, but only single butterfly in this case.
27.srt	00:19:10.669 --> 00:19:14.909	So, we will replace this with a single butterfly and then put the.
27.srt	00:19:15.339 --> 00:19:16.099	weights here.
27.srt	00:19:16.130 --> 00:19:18.859	So, we know that W n 0 is equal to 1.
27.srt	00:19:19.230 --> 00:19:30.710	So, we can avoid the multiplication here and then we have minus 1 basically that is how did we get the minus 1 here.
27.srt	00:19:31.049 --> 00:19:34.079	So, you can you have to go back and then look into the thing.
27.srt	00:19:34.400 --> 00:19:40.559	So, that is W 8 4 which is equal to minus W 8 0 which is nothing, but minus 1.
27.srt	00:19:40.880 --> 00:19:47.069	So, you will be seeing all of them will have the butterfly at the bottom minus 1 here.
27.srt	00:19:48.549 --> 00:19:56.299	So, what we have is W n k here W n this is n by 2 what we have the thing.
27.srt	00:19:56.659 --> 00:20:05.359	So, when we this needs n log 2 n complex multiplications and complex additions.
27.srt	00:20:05.669 --> 00:20:12.690	When I have the twiddle factors it is in this way that is we are representing y m minus first stage in this manner.
27.srt	00:20:13.299 --> 00:20:17.529	So, now after splitting the thing that is W.
27.srt	00:20:18.059 --> 00:20:24.199	nr n by 2 is nothing but w n to the power of n by 2 into w nr.
27.srt	00:20:24.759 --> 00:20:27.329	So, which is nothing but minus w nr.
27.srt	00:20:27.709 --> 00:20:31.389	So, I can provide the what is it?
27.srt	00:20:31.799 --> 00:20:35.519	So, this is equivalent to minus 1 now.
27.srt	00:20:36.089 --> 00:20:47.669	So, this is minus 1 here and I can shift my w n k to here in the input of one of the input then what happens?
27.srt	00:20:48.789 --> 00:20:51.829	So, our computation is going to reduce to half.
27.srt	00:20:52.140 --> 00:21:00.400	So, then we will be needing n by 2 log 2 n complex multiplications and n log 2 n complex additions.
27.srt	00:21:00.740 --> 00:21:04.809	So, this shows for n is equal to 8 the complete butterfly structures.
27.srt	00:21:05.190 --> 00:21:16.299	In the second stage you will be seeing that we need two coefficients because the other one I have taken it as 1 equal to 1 and here also what you will be needing it is two coefficients.
27.srt	00:21:20.009 --> 00:21:25.700	Whereas, in the last stage what we have is 4 coefficients what is represented, but w 8 0 is going to be 1.
27.srt	00:21:25.980 --> 00:21:29.299	So, we need 3 coefficients in this case.
27.srt	00:21:29.580 --> 00:21:33.630	That way some of the multiplication complex multiplications you can avoid.
27.srt	00:21:33.980 --> 00:21:37.240	So, we will see that the computation complexity in a while.
27.srt	00:21:38.110 --> 00:21:44.390	So, now, we have compared when we discussed about DFT versus FFT.
27.srt	00:21:44.759 --> 00:21:47.559	Now, after doing the FFT splitting of it.
27.srt	00:21:47.559 --> 00:21:50.610	So, we will be seeing that how we have reduced it.
27.srt	00:21:50.840 --> 00:21:56.700	So, we know that we need in DFT n squared complex multiplications and whereas, in FFT.
27.srt	00:21:56.990 --> 00:22:02.290	with the shifting our twiddle factor to the input stage.
27.srt	00:22:02.640 --> 00:22:06.470	So, we have achieved n by 2 log 2 and complex multiplications.
27.srt	00:22:06.759 --> 00:22:12.540	So, with respect to that we know that when n is of the order of power of 2.
27.srt	00:22:12.940 --> 00:22:26.200	So, what will be the computations number of multiplications required by DFT and number of multiplications required by FFT and only with respect to this we will be comparing our efficiency.
27.srt	00:22:26.200 --> 00:22:28.269	So, it goes from 64 is to 12.
27.srt	00:22:28.940 --> 00:22:48.190	683 as the power of computation we have to do increases by base compared to base 2 ok 2 to the power of n. So, as it is increasing so our efficiency is also going to increase.
27.srt	00:22:48.950 --> 00:22:59.560	So, now one of the thing what we have seen is when we are doing this bifurcation what has happened to our here it is going to show us clearly.
27.srt	00:22:59.900 --> 00:23:00.380	So, what.
27.srt	00:23:00.760 --> 00:23:09.070	I have is first is x of 0, next one what I want is x of 4, next I want x of 2 and then x of 6.
27.srt	00:23:09.190 --> 00:23:12.750	So, we have done the bit reversal in this case.
27.srt	00:23:12.920 --> 00:23:18.270	So, as you will be seeing in the equation here.
27.srt	00:23:18.720 --> 00:23:32.440	So, what we want is decimal number 0 to 7 what we have it when n is equal to 8 binary equivalent is as you will be seeing 0 0 to 8.
27.srt	00:23:33.300 --> 00:23:52.660	1 1 1, but input in the order what we want is 0, next is 4 what we wanted which is equal to 1 0 0 and then 0 1 0 and the next is 1 1 0 which is equivalent to 6 so on in the outside part.
27.srt	00:23:53.020 --> 00:23:59.970	So, as we said that in DSP hardware we use the data address generator to do that.
27.srt	00:24:00.330 --> 00:24:05.690	I think if you have to recall your architecture I had given how to do this.
27.srt	00:24:06.110 --> 00:24:07.420	addition in hardware.
27.srt	00:24:07.890 --> 00:24:10.880	As we know n is equal to in this case 8.
27.srt	00:24:11.190 --> 00:24:13.620	So, n by 2 is equal to 4.
27.srt	00:24:14.740 --> 00:24:20.260	So, we know that the first one we are starting with 0 0, then we add 1 0 0.
27.srt	00:24:20.700 --> 00:24:23.540	So, that is from left to right what we will be adding it.
27.srt	00:24:23.540 --> 00:24:27.930	So, which gives me first digit is 0, next one is 4.
27.srt	00:24:28.300 --> 00:24:30.100	Now, I add 1 0 0.
27.srt	00:24:36.360 --> 00:24:40.020	So, I said we will be adding it in this way 1 plus 1 is 0, we will be carrying 1 to here 0 1 0 which will give me 2.
27.srt	00:24:40.350 --> 00:24:43.660	So, you can go on doing that till the end.
27.srt	00:24:43.940 --> 00:24:54.490	So, this is the data address generator which will be incorporating our bit reversal as the input or FFT computation.
27.srt	00:24:54.490 --> 00:25:06.270	So, now, we will see the how complex it is, how many groups we have and then how many butterflies per group what we needed.
27.srt	00:25:09.430 --> 00:25:18.250	So, that is we said input signal must be properly reordered using a bit reversal that is what we wanted in the input.
27.srt	00:25:18.640 --> 00:25:31.690	So, you can say that this is a two point DFT which we can represent it as just a butterfly when it is a two stage point DFT.
27.srt	00:25:32.080 --> 00:25:36.880	So, the next one is combine these two points DFTs from each stage.
27.srt	00:25:37.340 --> 00:25:40.330	We will be having the next stage.
27.srt	00:25:40.769 --> 00:25:52.290	And, then combine these two point DFTs and then finally, we will be combining 4 points here from 8 stage to get my 8 bit output.
27.srt	00:25:52.810 --> 00:26:03.290	So, when we represent n is equal to 8 as you can see the thing this is the first stage, this is the second stage what we have it, this is the third stage.
27.srt	00:26:03.790 --> 00:26:13.420	So, now, we call this thing as if we want to have we can do in place computation.
27.srt	00:26:13.960 --> 00:26:16.700	What do I mean by in place computation?
27.srt	00:26:17.200 --> 00:26:28.730	That means, my these are the inputs I can overwrite with these values with respect to this because I do not need these values in the later stages.
27.srt	00:26:28.730 --> 00:26:32.859	That is why we call it as in place computation.
27.srt	00:26:33.170 --> 00:26:38.549	So, that I need not have to store my input more than 8 bits.
27.srt	00:26:40.180 --> 00:26:43.309	And then next is how many stages we have to do?
27.srt	00:26:43.819 --> 00:26:45.630	We say n is equal to 8.
27.srt	00:26:46.160 --> 00:26:55.120	We have seen that we need 3 stages that is log 2 n. So, which is going to be 3 and stage 1.
27.srt	00:26:55.660 --> 00:27:02.200	So, we know that all the twiddle factors are 1, all are w 8 0.
27.srt	00:27:02.580 --> 00:27:11.110	So, which is 1 in this case and last stage that twiddle factors are in sequential order.
27.srt	00:27:11.730 --> 00:27:17.660	As we can see that here it is w 8 0 and w 8 0.
27.srt	00:27:17.870 --> 00:27:19.020	to what we need it.
27.srt	00:27:19.520 --> 00:27:28.080	Here what we need is W80 1 2 and then 3 that is what the twiddle factors in the last stage is going to be in order.
27.srt	00:27:28.690 --> 00:27:33.480	Now, we will see that some of the parameters with respect to our butterfly structures.
27.srt	00:27:33.960 --> 00:27:36.510	Number of groups how many I am going to have it.
27.srt	00:27:37.010 --> 00:27:42.510	So, here you can see that we call each one as group.
27.srt	00:27:42.660 --> 00:27:46.210	So, each butterfly basically.
27.srt	00:27:46.210 --> 00:27:50.760	So, in the first stage we have n by 2.
27.srt	00:27:51.340 --> 00:27:55.260	As we have taken n is equal to 8, 8 by 2 will be 4.
27.srt	00:27:55.580 --> 00:27:59.970	So, you will be seeing 1, 2, 3, 4 groups are there in this case.
27.srt	00:28:00.400 --> 00:28:11.060	Now, in the next stage I am going to have n by 4 which is nothing but 2 in this case n is equal to 8 you will be seeing this is one group this is the other group.
27.srt	00:28:11.610 --> 00:28:15.500	And in the last stage we will have one group.
27.srt	00:28:15.880 --> 00:28:17.960	So, 8 by 8 is 1.
27.srt	00:28:18.430 --> 00:28:23.690	So, this is you are having only one group in the stage 3 in this case.
27.srt	00:28:24.400 --> 00:28:28.500	Now, we will see how many butterflies per group are going to be there.
27.srt	00:28:29.300 --> 00:28:32.640	In the first stage we have one butterfly.
27.srt	00:28:33.490 --> 00:28:36.500	So, in all the groups we have only one butterfly.
27.srt	00:28:37.220 --> 00:28:46.620	Coming to stage 2, so as you can see this is these are the two groups I have two butterflies in this group and here also we have two butterflies.
27.srt	00:28:47.130 --> 00:28:55.560	When I come to the next stage, stage 3, then we are going to have n how many butterflies?
27.srt	00:28:55.960 --> 00:28:58.760	4 butterflies in the group here.
27.srt	00:28:59.210 --> 00:29:05.630	So, you will be seeing that this is 1 butterfly, second, third and then fourth butterfly.
27.srt	00:29:06.270 --> 00:29:17.290	So, that is what it is going to be and number of stages are more than what we will say in the stage log 2 n we will have n by 2 butterflies.
27.srt	00:29:17.620 --> 00:29:25.940	So, something should be striking if it is n is equal to 16 then it is going to be 8 butterflies in the last stage.
27.srt	00:29:26.510 --> 00:29:28.690	ok. And then what is it?
27.srt	00:29:28.800 --> 00:29:31.020	We call it as dual node spacing.
27.srt	00:29:31.890 --> 00:29:37.990	So, between the 2 nodes what is the spacing I am going to have it?
27.srt	00:29:38.380 --> 00:29:46.730	Here 1 because x 0 and x 4 these are the 2 nodes the spacing is only 1 between them.
27.srt	00:29:47.440 --> 00:29:52.690	When I come to stage 2 we will be seeing that the spacing is going to be 2 nodes.
27.srt	00:29:53.030 --> 00:29:57.470	So, I am taking 1 from here next one is coming from this.
27.srt	00:29:57.800 --> 00:30:03.560	So, there will be 2 node difference what I will be giving it as input with this.
27.srt	00:30:03.890 --> 00:30:13.040	Same way you can calculate everywhere and in the stage 3 I will be having this thing dual node spacing is going to be 4.
27.srt	00:30:13.500 --> 00:30:20.210	I think it should be something striking equivalent your butterflies per group and then node spacing is also same ok.
27.srt	00:30:20.210 --> 00:30:22.810	These 2 columns almost repeated.
27.srt	00:30:23.180 --> 00:30:29.270	So, you will be seeing that this is the first input, the next input the from the fourth one.
27.srt	00:30:29.720 --> 00:30:39.440	So, if I taken this 1, 2, 3, 0, 1, 2, 3 and then the fourth one from here what I will be taking it.
27.srt	00:30:39.470 --> 00:30:44.520	So, there will be spacing of 4 nodes for this.
27.srt	00:30:45.130 --> 00:30:53.010	Now comes the twiddle factor exponents how we are going to put it in each node.
27.srt	00:30:53.520 --> 00:31:00.140	So, we will be having n by 2 into k in this case in the stage.
27.srt	00:31:00.420 --> 00:31:02.490	1 k will be equal to 0.
27.srt	00:31:03.100 --> 00:31:10.960	So, that means to say I will be having 8 W n k's which are all 1 ok.
27.srt	00:31:11.580 --> 00:31:18.970	So, that is the reason why we do not have any we can remove this W 8 0 equal to 1.
27.srt	00:31:19.300 --> 00:31:21.140	So, 8 of them are there.
27.srt	00:31:21.580 --> 00:31:25.680	So, we which is equivalent to 1 in this case.
27.srt	00:31:26.470 --> 00:31:36.960	So, the next one in W n k what we have put it k is equal to 0 that is why it becomes W 8 0 and it which is equivalent to 1.
27.srt	00:31:37.420 --> 00:31:39.260	So, in the second stage.
27.srt	00:31:39.590 --> 00:31:47.130	what we are going to have is n by 4 into k, k will be going between 0 and 1.
27.srt	00:31:47.900 --> 00:32:00.090	So, you will be seeing that this is w 8 0 and then k will be 1 then it is going to be w 8 into 2 in this case.
27.srt	00:32:00.730 --> 00:32:12.410	So, the last stage what it will have our stage 3 in this case is going to be our last stage n by 2 into k 0 1 and then 2 are the values.
27.srt	00:32:12.710 --> 00:32:17.520	So, w 8 0, w 8 1, w 8 2 and w 8 3.
27.srt	00:32:18.590 --> 00:32:29.570	So, we will be having 4 of them here and when we have more than that what will be the thing k will be going between 0 to n by 2 minus 1.
27.srt	00:32:30.340 --> 00:32:34.220	So, you will be seeing here n by 2 is 4, 4 minus 1 is 3.
27.srt	00:32:34.540 --> 00:32:38.110	So, that is why we have k is equal to 0, 1, 2 when n is equal to 8.
27.srt	00:32:38.730 --> 00:32:47.880	So, coming with this thing as we said we can have the computation either in the time domain or in the frequency domain.
27.srt	00:32:48.360 --> 00:32:51.570	So, that is we call it as decimation in frequency.
27.srt	00:32:52.210 --> 00:32:59.300	So, we say that output signal must be properly reordered using a bit reversal algorithm.
27.srt	00:33:00.120 --> 00:33:10.450	That means to say input is in order and output will be in the bit reversal order in then the DIF case.
27.srt	00:33:10.820 --> 00:33:21.800	So, here also it is in place computation compared with your DIT decimation in time and here also number of stages is going to be locked to n.
27.srt	00:33:22.240 --> 00:33:32.990	and what we say stage 1 all the twigal factors are in sequential order and last stage all the twigal factors are going to be 1 in this case.
27.srt	00:33:33.400 --> 00:33:40.960	So, you will be seeing that in the decimation in frequency is equivalent to reverse of your decimation in time.
27.srt	00:33:41.440 --> 00:33:46.070	So, how the number of stages and other things it looks like you will be seeing it.
27.srt	00:33:46.460 --> 00:33:53.060	Number of groups in this case is going to be 1 for n is equal to 8 what it is shown.
27.srt	00:33:53.850 --> 00:34:02.680	And, then number of stage number of groups in stage 2 is going to be 2 and then last stage in this case is 4.
27.srt	00:34:02.680 --> 00:34:10.220	So, it is equivalent to log 2 in stages the stage thing will have n by 2 number of groups.
27.srt	00:34:10.800 --> 00:34:20.039	And, then you will be seeing the butterflies per group will be n by 2, n by 4 and n by 2 and last one will have 1 basically per group.
27.srt	00:34:20.519 --> 00:34:24.930	And, then even your dual node is equivalent to the previous.
27.srt	00:34:25.630 --> 00:34:27.530	case basically this is the one.
27.srt	00:34:27.910 --> 00:34:30.530	Now, only the thing is twiddle factor exponent.
27.srt	00:34:30.530 --> 00:34:57.320	So, you will be seeing that n in this case there it was a k was the variable here it is going to be n, n will be going between 0 to n by 2 minus 1 will be your twiddle factor first stage and in the second stage it is 0 to n by 4 minus 1 and so on what you will have it in the last stage you will be having n is equal to 0 and n by 2 twiddle factors which becomes equivalent to.
27.srt	00:34:57.740 --> 00:35:01.760	1 in this case also as you can see it ok.
27.srt	00:35:02.230 --> 00:35:09.300	So, now we will look at the finite word length effects in FFT.
27.srt	00:35:09.940 --> 00:35:10.510	Thank you.
27.srt	00:35:10.849 --> 00:35:15.880	So, we have seen how to get our FFT using butterfly.
27.srt	00:35:15.880 --> 00:35:22.320	So, in the next class we will look at the finite word length effects in FFT.
27.srt	00:35:22.639 --> 00:35:27.700	How it will be affecting our outputs and what is the care we have to take it.
27.srt	00:35:28.059 --> 00:35:28.469	Thank you.
33.srt	00:00:00.730 --> 00:00:26.750	Namaskara, welcome back to real time digital signal processing course.
33.srt	00:00:26.989 --> 00:00:30.179	So we will discuss today.
33.srt	00:00:30.740 --> 00:00:49.100	To recap in the last class we have covered about overlap save method, both overlap previous to that we had covered overlap add method for continuous input signal, how we can calculate our FFT and then we had seen lab also.
33.srt	00:00:49.100 --> 00:00:54.640	Coming to in today's class we will discuss about correlation.
33.srt	00:01:01.729 --> 00:01:07.750	So, what is the definition of correlation or why do we need it we will look at it.
33.srt	00:01:08.250 --> 00:01:17.319	So, basically a process of comparing two data sequences to obtain a measure of similarity between them.
33.srt	00:01:18.090 --> 00:01:34.990	So, most of you must be knowing that you will be trying to correlate one person with other either in terms of their habits or their look or their appearance that is what you will be looking at.
33.srt	00:01:35.379 --> 00:01:39.490	In this case we will be looking with our signals whatever we are going to get the thing.
33.srt	00:01:39.930 --> 00:01:41.250	So, one of it is.
33.srt	00:01:41.480 --> 00:01:46.760	in the application of voice recognition in audio signal processing.
33.srt	00:01:47.270 --> 00:01:52.050	So, which requires comparison of different speech waveforms.
33.srt	00:01:52.620 --> 00:02:11.030	So, you are want to recognize somebody's voice ok and then you have stored originally and then marked it this is the original person's voice and some of the people their voice is recorded or from the same person.
33.srt	00:02:11.490 --> 00:02:18.909	Then you want to see that whether whatever stored is going to match with that particular person's voice.
33.srt	00:02:19.280 --> 00:02:22.480	So, this is one of the application we need the correlation.
33.srt	00:02:23.000 --> 00:02:30.450	Next in the case of image classification in image processing which requires comparison of different image data.
33.srt	00:02:30.969 --> 00:02:42.870	As I was telling so, you might have taken the image somewhere else and then you want to have a see that the current image whether there is any correlation or.
33.srt	00:02:44.030 --> 00:02:59.980	So, the other application one of the mostly used what we will call it in day to day life is object detection and location in basically sonar and radar systems.
33.srt	00:03:00.530 --> 00:03:08.430	So, which require comparison of the transmitted signal and the signal reflected from the target objects.
33.srt	00:03:08.920 --> 00:03:13.689	So, it you want to all of you know now drone is becoming.
33.srt	00:03:14.830 --> 00:03:15.940	mostly popular.
33.srt	00:03:16.400 --> 00:03:23.440	So, if you want to identify if one of the drone is going to cross our border or whatever maybe the thing.
33.srt	00:03:23.440 --> 00:03:28.290	So, you want to identify it is a foe and then you want to destroy it.
33.srt	00:03:28.340 --> 00:03:35.770	So, lot of work is happening the same way in the sonar area is one of the sea area.
33.srt	00:03:36.110 --> 00:03:37.650	So, submarines and other things.
33.srt	00:03:37.650 --> 00:03:48.850	So, they will be reflecting through signals through radars basically and then they reflected by which comes back you have to process it.
33.srt	00:03:49.260 --> 00:03:56.050	and then see that what correlation it has with the template what we have it.
33.srt	00:03:57.000 --> 00:04:02.160	And even you would be in case of aeroplanes basically.
33.srt	00:04:02.460 --> 00:04:20.750	So, you want to see that what kind of aeroplane which is running whether it is military or civil so, that also reflection you will be catching through the radar and then you will be finding out.
33.srt	00:04:21.000 --> 00:04:23.389	So, you know that correlation is used.
33.srt	00:04:23.680 --> 00:04:41.930	So, the fundamental measure of similarity between the two sequences we call it x of and y of n is the sum of the products of the corresponding base of data values that is sigma x of n into y of n what we represented.
33.srt	00:04:42.550 --> 00:04:53.920	Then what we are going to say so, we say if the is it positively correlated when we are going to say this if there is some kind of.
33.srt	00:04:54.129 --> 00:05:09.290	proportionality relationship between x of n and y of n with positive or negative values generally occurring concurrently in both sequences, then some of the products will be a positive value.
33.srt	00:05:09.790 --> 00:05:18.300	Because even both of them are negative we know that the product is going to give us positive and both of them are positive then it will be giving the positive value.
33.srt	00:05:18.300 --> 00:05:25.589	So, then we will be saying that as a positive correlation, when we call that as negative.
33.srt	00:05:26.029 --> 00:05:47.949	If there is some kind of inverse proportionality relationship between x of n and y of n with positive values in one sequence generally accompanied by negative values in the other sequence then we know that sum of products will be a negative value indicating that is negative correlation between the two sequences.
33.srt	00:05:48.569 --> 00:06:00.169	So, when we say there is no correlation between the two sequences, if the two sequences are independent with positive values and negative values equally.
33.srt	00:06:00.579 --> 00:06:06.839	likely to occur in both actually the sum of products will tend to towards 0.
33.srt	00:06:07.560 --> 00:06:13.219	So, we call it as due to self cancelling of the product terms in summation.
33.srt	00:06:13.789 --> 00:06:16.669	So, then we say that they are not correlated.
33.srt	00:06:17.300 --> 00:06:31.399	So, continuing with the thing so, we say if two sequences x of n and y of n the cross correlation function we call it as C x y of P is defined by this equation.
33.srt	00:07:04.209 --> 00:07:15.310	What do we say cxy of p is equal to limit n tending to infinity 1 by n small n is equal to 0 to n minus 1 x of n into n minus p. So, we say where plus or minus p represent the number of sampling points by which y of n has been delayed or advanced in time with respect to x of n and 1 by n is included as a normalization scaling factor to ensure that The cross correlation of two periodic sequences converge to the same result as more and more sample pairs from two sequences are included in the cross correlation operation.
33.srt	00:07:15.699 --> 00:07:21.620	So, that we are trying to avoid the overflow by scaling it ok.
33.srt	00:07:21.920 --> 00:07:24.579	So, how do we define the autocorrelation?
33.srt	00:07:24.990 --> 00:07:33.620	When y of n equal to x of n, we have a special case whereby the cross correlation function becomes the autocorrelation function.
33.srt	00:07:36.360 --> 00:07:57.320	The equation is given by Cxx of p is equal to limit n tending to infinity, the same scaling factor 1 by n, n will be going from 0 to n minus 1, x of n into y of n minus p in this case the maximum autocorrelation where we are going to get is when p is equal to 0.
33.srt	00:07:57.920 --> 00:08:06.360	Since two identical in phase signals are being compared and the autocorrelation value decreases as p is going to.
33.srt	00:08:06.879 --> 00:08:12.810	So, we will see how we are going to calculate our correlation as an example.
33.srt	00:08:13.339 --> 00:08:33.590	So, what we have it the same example for FFT what we have taken the thing here also we will be taking the same this thing x of n and then h of n. Here it is x of n is 2001 and h of n is given by 4321.
33.srt	00:08:33.700 --> 00:08:35.750	So, now we will write.
33.srt	00:08:36.970 --> 00:08:42.029	compute our cross correlation by writing the table.
33.srt	00:08:42.029 --> 00:08:57.860	So, n will be varying between minus 3, minus 2, minus 1 this is and then 0, 1, 2, 3 greater than equal to 7 we know that it is going to be 0.
33.srt	00:08:57.860 --> 00:09:09.470	Because we know that like linear convolution we call it as linear correlation here the length is going to be L plus M minus 1.
33.srt	00:09:09.850 --> 00:09:12.889	So, that is what we needed even the negative side.
33.srt	00:09:13.250 --> 00:09:17.250	So, x of n we are going to write it as this thing.
33.srt	00:09:17.250 --> 00:09:25.320	So, we know that in the negative region it is 0 and if nothing is mentioned we assume the starts from 0.
33.srt	00:09:25.659 --> 00:09:31.889	Sometimes if you want to say that it is starting from the negative side of it.
33.srt	00:09:31.889 --> 00:09:40.019	So, you may mark with an upper arrow here stating that this is our 0th location basically.
33.srt	00:09:40.500 --> 00:10:07.459	So, it is 2 0 0 1 and then elsewhere it is 0 what we have assumed P ok. And then we will be computing our correlation equation that is Cxh that is cross correlation with respect to P. So, first one is h of n plus 3 because P is equal to minus here basically minus 3 it is going to be n plus 3.
33.srt	00:10:08.159 --> 00:10:12.879	So, it will be 4 3 2 1 what we assume the thing here.
33.srt	00:10:13.490 --> 00:10:15.850	and then rest of them 0s.
33.srt	00:10:16.279 --> 00:10:27.210	So, when you do the multiplication here, so what you are going to get is when p is equal to minus 3.
33.srt	00:10:27.759 --> 00:10:44.070	So, you are doing the multiplication 2 into 1 is 2 rest of them are 0s and we have to scale it by n, capital N is 4 because both the sequences are of length 4 in this case.
33.srt	00:10:44.539 --> 00:10:46.279	by 4 is going to give us 0.5.
33.srt	00:10:46.279 --> 00:10:51.240	So, same way what you have to do is next is n plus 2.
33.srt	00:10:51.360 --> 00:11:03.139	So, you will be shifting H of n sequence right by 1 place and then you will be computing your cross correlation here.
33.srt	00:11:03.139 --> 00:11:13.139	Same way you do the thing when this thing x of n and H of n at 0 will be seeing that is p is equal to 0.
33.srt	00:11:15.340 --> 00:11:30.720	So, both will be coinciding with each other that is 2 0 0 1 and 4 3 2 1 and then you will be seeing that the correlation of value at this is peak it is 2.25.
33.srt	00:11:30.860 --> 00:11:41.309	So, then you will be moving away from the thing p is equal to you will be giving it as 1 2 and then 3 and then 4.
33.srt	00:11:41.419 --> 00:11:44.730	So, this is our output of.
33.srt	00:11:45.700 --> 00:11:47.870	linear cross correlation.
33.srt	00:11:48.250 --> 00:11:51.290	So, what is the difference with respect to our convolution?
33.srt	00:11:51.480 --> 00:11:55.070	So, here H of n is not folded in the correlation process.
33.srt	00:11:55.100 --> 00:12:09.009	So, we fold H of n in the case of convolution, here it goes as it is, it is not folded that is the difference between our convolution and then correlation.
33.srt	00:12:16.320 --> 00:12:17.309	So, coming with continuing with the correlation, So, what is it?
33.srt	00:12:17.620 --> 00:12:32.710	It is often desirable in practice to make the autocorrelation function values independent of the signal scaling by normalizing the autocorrelation function with respect to its maximum value at 0 phase.
33.srt	00:12:33.179 --> 00:12:36.120	So, that it need not have to depend on the thing.
33.srt	00:12:36.629 --> 00:12:45.990	So, what is that normalization results in an autocorrelation coefficient we call it as rho xx whose values always lie in a.
33.srt	00:12:46.310 --> 00:12:48.930	fixed range of plus or minus 1.
33.srt	00:12:49.580 --> 00:12:57.610	So, when we take the autocorrelation rho xx of p, it will be cxx of p divided by cxx of 0.
33.srt	00:12:58.370 --> 00:13:19.060	So, similarly normalizing the cross correlation function results in cross correlation coefficient rho xy which is given by rho xy of p is nothing, but our cxy of p divided by root of cxx of 0 at the 0.
33.srt	00:13:19.340 --> 00:13:30.379	So, autocorrelation value what you will be taking it here for one of the signal and then autocorrelation this thing coefficient c yy of the second signal.
33.srt	00:13:30.620 --> 00:13:36.410	So, and a square root you will be doing it which will normalize our this thing cross correlation function.
33.srt	00:13:36.970 --> 00:13:50.740	So, the note at this places our rho xy lies in the fixed range of plus or minus 1 with plus 1, 0 and minus 1.
33.srt	00:13:51.159 --> 00:14:04.389	indicating 100 percent positive correlation, when it is 0 it is no correlation and 100 percent negative correlation respectively if it falls in this values.
33.srt	00:14:04.769 --> 00:14:16.190	So, what does it say that our cross correlation magnitude of it should be less than or equal to square root of this function basically.
33.srt	00:14:16.570 --> 00:14:19.279	So as an example.
33.srt	00:14:22.269 --> 00:14:30.370	We will take the same sequence x of n and then h of n we have already calculated their cross correlation coefficient.
33.srt	00:14:30.889 --> 00:14:51.350	Now we will see the values of it that is autocorrelation Cxx of 0 is nothing but 1 by 4 into n is equal to 0 to 3 x of n squared what we will be doing it which is nothing but 1 by 4 into 2 square plus 0 square plus 0 square plus 1 square which is equal to 1.25.
33.srt	00:14:53.199 --> 00:15:04.129	autocorrelation of the h signal that is we have it 0 it is equivalent to 1 by 4 into same way n is equal to 0 to 3 h of n squared.
33.srt	00:15:04.129 --> 00:15:09.249	So, when you substitute these values you will be getting 7.5.
33.srt	00:15:09.249 --> 00:15:20.419	Now, we have computed cross correlation Cxh of p in the previous table as you can see it 0.511.5.
33.srt	00:15:25.939 --> 00:15:27.169	So, how we can normalize this using this equation.
33.srt	00:15:27.569 --> 00:15:40.039	So, what is the first value what we have is 0.5 divided by square root of r 1.25 into 7.5 will give us the value 0.16.
33.srt	00:15:40.039 --> 00:15:50.979	Same way for all the autocorrelation values you can calculate are normalizing the thing will give.
33.srt	00:15:58.889 --> 00:16:01.159	these values which have been put into table.
33.srt	00:16:01.509 --> 00:16:07.379	So, you can go and then compute for rest of them whether it is going to match or not fine.
33.srt	00:16:07.779 --> 00:16:12.779	So, now, just like our linear correlation and linear convolution.
33.srt	00:16:12.859 --> 00:16:19.209	So, we have the circular correlation equivalent to circular convolution.
33.srt	00:16:19.629 --> 00:16:23.859	So, how we are going to write our circular correlation in this case?
33.srt	00:16:24.329 --> 00:16:31.779	We call it as C x y of p is nothing but 1 by n, n will be varying between 0 to n minus 1.
33.srt	00:16:32.359 --> 00:16:40.849	x of n into y of n minus p. So, in this case p will also be varying between 0 to n minus 1.
33.srt	00:16:41.559 --> 00:16:51.029	So, when we compute the circular this thing correlation between these two sequences as we had done it with linear correlation.
33.srt	00:16:51.029 --> 00:17:05.169	So, what we have it x of n is we have 2 0 0 1 and h of n is given as 4 3 2 1 and then the capital N in this case is 4.
33.srt	00:17:07.179 --> 00:17:11.219	So, we will be going between 0 to 3 after that it is going to repeat.
33.srt	00:17:11.699 --> 00:17:13.509	So, here when we calculate it.
33.srt	00:17:13.869 --> 00:17:35.989	So, this is nothing but 2 into 4 plus 0 into 3 plus 0 into 2 plus 1 into 1 and then scaled by 4 what we are doing it capital N. Then you will be seeing that it is going to give us 2.25, the next one is 1 and then next one is 1.75 and then the last one in this case is going to be 2.5.
33.srt	00:17:37.629 --> 00:17:39.719	is something going to strike to you.
33.srt	00:17:40.089 --> 00:17:43.939	So, you can see that what was our earlier case.
33.srt	00:17:44.309 --> 00:17:54.219	So, it is 2.25 in the thing it is matching and you will be seeing only one is going to match like a linear convolution.
33.srt	00:17:54.359 --> 00:18:06.679	Here also circular convolution with linear convolution there is only one value which is the at 0 which is going to match rest of them are not going to match.
33.srt	00:18:09.739 --> 00:18:19.139	So, to get again our linear correlation how we are going to implement it.
33.srt	00:18:19.519 --> 00:18:21.309	So, this is one of the questions.
33.srt	00:18:21.309 --> 00:18:26.659	So, how did we do linear convolution from circular convolution by padding 0s.
33.srt	00:18:26.899 --> 00:18:35.779	Here also you can pad 0s and then compute linear correlation from the circular correlation.
33.srt	00:18:35.839 --> 00:18:39.829	So, this is going to be your assignment.
33.srt	00:18:41.039 --> 00:18:45.879	or take home I will call it as problem solving thing.
33.srt	00:18:45.879 --> 00:18:55.179	So, you can work it out and then come back and then tell me whether you have got the results correctly or not ok.
33.srt	00:18:55.469 --> 00:19:05.459	So, now, we will see some of the DFT property of our circular correlation just we did it for the convolution we will do it for correlation.
33.srt	00:19:05.809 --> 00:19:11.369	So, what is it say may be stated formally with this if.
33.srt	00:19:11.499 --> 00:19:15.439	Cxy of p is given by this equation.
33.srt	00:19:15.849 --> 00:19:28.359	Then we call it as correlation of xyr we will put it which is equivalent to 1 by n xr into yr conjugate.
33.srt	00:19:28.809 --> 00:19:42.719	So, the multiplication is going to be xr with yr conjugate and then scaled by 1 by n. So, here we say Cxyr xr and yr are the DFTs of Cxy.
33.srt	00:19:42.899 --> 00:19:58.899	P and x n and y n are the inputs and y r is the y r conjugate is the complex conjugate of r y r DFT of y small y n basically fine.
33.srt	00:19:59.259 --> 00:20:04.450	So, now, we will see how we are going to compute our correlation output.
33.srt	00:20:04.940 --> 00:20:07.919	So, just like we did for the DFT.
33.srt	00:20:08.009 --> 00:20:14.039	So, we will be using I will be putting it as D I F FFT.
33.srt	00:20:14.409 --> 00:20:17.230	So, this is the butterfly structure what we have it.
33.srt	00:20:18.890 --> 00:20:25.910	So, we have 1 by 4 is the here also because the length of the sequence is 4 what we have taken the thing.
33.srt	00:20:26.250 --> 00:20:37.100	So, 1 by n is 1 by 4 in this and these are the points what we will be getting it in basically inverse of DFT basically.
33.srt	00:20:37.370 --> 00:20:47.150	So, this is C0, C1 and sorry A0, A1, B0 and B1 and then we will be getting out our.
33.srt	00:20:49.809 --> 00:20:52.710	x of 0, x of 2, x of 1 and x of 3.
33.srt	00:20:53.090 --> 00:20:58.670	So, we have calculated our DFT of 2 0 0 1 in the previous class.
33.srt	00:20:58.990 --> 00:21:06.809	So, which gave us 3 2 plus j comma 1 comma 2 minus j are the DFT of this sequence.
33.srt	00:21:07.200 --> 00:21:24.500	So, I think we have not calculated DFT of H of n. So, you can calculate in the same way using DITFFT that is decimation in time for fast Fourier transform butterfly structure and compute the DFT of 4 3 2 1.
33.srt	00:21:24.880 --> 00:21:30.680	In this case we have assumed that we have calculated previously and using the values what we have it.
33.srt	00:21:31.080 --> 00:21:32.289	So, which gives us.
33.srt	00:21:32.630 --> 00:21:37.850	2 minus j 2 comma 2 comma 2 plus j 2.
33.srt	00:21:38.259 --> 00:21:43.000	So, these are the DFT of 4, 3, 2, 1.
33.srt	00:21:43.519 --> 00:21:49.970	Now, we will calculate the circular correlation C x, y, r what we have to calculate.
33.srt	00:21:49.970 --> 00:21:54.720	So, 1 by n into we have to do x r into y r conjugate.
33.srt	00:21:55.080 --> 00:22:02.430	So, if we substitute the thing, so this is our x r multiplication with.
33.srt	00:22:03.309 --> 00:22:07.029	Yr this is the one conjugate what we have to take the thing.
33.srt	00:22:08.220 --> 00:22:12.960	So, how we are going to represent this?
33.srt	00:22:13.390 --> 00:22:21.650	So, this is 10 2 minus j2 2 and then 2 plus j2.
33.srt	00:22:22.099 --> 00:22:30.190	So, when you take the conjugate of this, this becomes positive and this becomes negative and then calculate this values.
33.srt	00:22:30.470 --> 00:22:33.380	So, you will be seeing that it is going to be 7.5.
33.srt	00:22:34.769 --> 00:22:38.969	0.5 plus j1.5 and then 0.5 minus j1.5.
33.srt	00:22:39.240 --> 00:22:55.889	So, this is our value for Cxy R. Now, how we will be calculating our Cxy 0 as you can see the thing.
33.srt	00:22:56.899 --> 00:23:02.549	So, you will be putting a0 plus a1 which is nothing but 1 by 4 Cx.
33.srt	00:23:05.599 --> 00:23:07.509	y0 plus cxy2.
33.srt	00:23:07.689 --> 00:23:27.309	So, these are the values what we have it and then plus 1 by 4 cxy1 plus 6y3, here we have these are the values what we have it 7.5 plus 0.5 and then plus 1 by 4 into 0.5 plus j1.5.
33.srt	00:23:27.309 --> 00:23:30.949	So, plus 0.5 minus j1.5 for the second sequence.
33.srt	00:23:30.949 --> 00:23:34.489	So, which you can see that.
33.srt	00:23:37.129 --> 00:23:38.409	we are getting it as 2.25.
33.srt	00:23:38.509 --> 00:23:46.369	So, how we calculated the circular convolution using a DFT property.
33.srt	00:23:46.369 --> 00:23:49.729	So, we can calculate these values.
33.srt	00:23:49.729 --> 00:23:53.109	So, the next one is Cxy of 1.
33.srt	00:23:53.109 --> 00:23:58.219	So, you will be substituting these values and then calculate the thing.
33.srt	00:23:58.219 --> 00:24:04.859	So, you will be getting it as 1 in this case same with respect to the next two.
33.srt	00:24:04.859 --> 00:24:09.269	So, you will be seeing that the DFT using DFT.
33.srt	00:24:11.119 --> 00:24:20.199	The circular correlation values resemble as that of the direct circular correlation what we have calculated.
33.srt	00:24:20.969 --> 00:24:28.969	So, coming to the next topic we have to introduce little on random process.
33.srt	00:24:29.569 --> 00:24:39.799	So, we know that real world signals such as speech, music and noise are time varying and we know that they are random in nature.
33.srt	00:24:40.779 --> 00:24:47.549	The set of all possible outcomes in any given experiment is called the sample space S.
33.srt	00:24:48.159 --> 00:24:50.819	Why do we need random process?
33.srt	00:24:50.819 --> 00:25:13.589	So you are seeing that some of the applications what we will be seeing later on based on some of the speech and music already we have seen the thing how our noise is introduced in the music or in the speech how we are able to eliminate our noise if our noise is known in this case.
33.srt	00:25:13.589 --> 00:25:20.529	In some of the cases noise may not be known okay so we have to adapt to the.
33.srt	00:25:22.759 --> 00:25:26.309	So, which requires a random process.
33.srt	00:25:26.309 --> 00:25:30.909	So, the next topic we will be covering is adaptive filter.
33.srt	00:25:31.489 --> 00:25:44.369	So, we need this basic knowledge of random process only little bit of it whatever required for deriving our LMS algorithm will be covering it in this course.
33.srt	00:25:44.369 --> 00:25:50.849	So, those who want to have more they can take up as a course and then complete it.
33.srt	00:25:51.269 --> 00:25:55.549	So, this is the space for sample space what we have defined.
33.srt	00:25:56.119 --> 00:26:02.309	And we have to define the random variable x, how we are going to define it?
33.srt	00:26:02.599 --> 00:26:10.269	This is the function that maps all elements from sample space S into the points on the real line.
33.srt	00:26:11.329 --> 00:26:17.509	As an example, considering the outcome of our rolling fair die ok.
33.srt	00:26:17.509 --> 00:26:29.529	So, we have obtained the discrete random variable that can be any one of the discrete values from 1 through 6, all of us know that our fair die has 6 values.
33.srt	00:26:30.619 --> 00:26:31.589	when we roll it.
33.srt	00:26:31.589 --> 00:26:37.450	So, we do not know what we this is the outcome, but it should lie be 1 through 6.
33.srt	00:26:37.559 --> 00:27:00.899	So, the cumulative probability distribution function we call it as CDF of a random variable x is defined as the that basically you can see that there is a repetition here that is f of x is equal to probability of x less than or equal to.
33.srt	00:27:01.390 --> 00:27:12.329	capital X, where capital X is real number and Px less than or equal to x is the probability of x less than or equal to capital X.
33.srt	00:27:12.619 --> 00:27:28.430	So, we call it as probability density function of random variable x is going to be defined with that f of x is nothing but d by dx of f of x, if the derivative exists.
33.srt	00:27:29.000 --> 00:27:34.880	So, two important properties of probability density function is f of x are.
33.srt	00:27:35.390 --> 00:27:57.170	summarized as this way that is integration minus infinity to infinity f of x dx is equal to 1 and probability of x1 lies small x lies in x1 and x2 is given by our f of x2 minus f of x1.
33.srt	00:27:58.049 --> 00:28:03.970	So, which is nothing but we will be putting x1 to x2 f of x dx.
33.srt	00:28:04.080 --> 00:28:07.990	So, if x is a discrete random variable.
33.srt	00:28:08.529 --> 00:28:14.940	that can be any one of this discrete xi that is i is equal to 1, 2 etcetera.
33.srt	00:28:48.289 --> 00:28:51.839	As the result of an experiment we define the discrete probability function as Pi is equal to the P capital P of x equal to xi it belongs to this ok. As an example so we consider a random variable small x that has the following probability density function f of x is equal to 0 in this range x less than x1 or x greater than x2 in the region x1 to x2 which is equal to a.
33.srt	00:28:51.839 --> 00:29:22.700	So, that is we say it is uniformly distributed between x1 and x2 and constant value a can be computed as with this equation that is minus infinity to infinity f of x into dx which is equal to x1 to x2 what we are putting the thing a into d of x which is nothing, but a into when we expand our integration which is going to be with the values it is going to be a times x2 minus x1.
33.srt	00:29:23.219 --> 00:29:27.039	which is equal to 1 as this can be seen that.
33.srt	00:29:27.519 --> 00:29:40.009	So, the maximum value is 1 by x2 minus x1 and then we will be seeing that this is uniformly distributed between x1 and then x2.
33.srt	00:29:40.649 --> 00:29:48.029	So, a in this case is equal to 1 by x2 minus x1 what it has been taken.
33.srt	00:29:48.029 --> 00:29:50.769	So, that is the reason why we will be getting it as 1 here.
33.srt	00:29:51.469 --> 00:29:58.519	So, what is it if a random variable x is equally likely to be any value between 2 limits.
33.srt	00:29:58.930 --> 00:30:03.769	x1 and x2 and cannot assume any value outside that range.
33.srt	00:30:04.289 --> 00:30:09.409	It is uniformly distributed in the range that is x1 to x2.
33.srt	00:30:09.849 --> 00:30:16.190	So, that is as shown in the figure it is uniformly distributed in this region.
33.srt	00:30:16.539 --> 00:30:31.960	Then we call that is uniform density function is defined by this f of x is equal to 1 by x2 minus x1 in x is in the range x1 to x2 otherwise it is going to be 0 in the other places.
33.srt	00:30:32.619 --> 00:30:36.339	So, coming with some of the operations of random variables.
33.srt	00:30:36.819 --> 00:30:51.859	So, the statistics what we call it as one is the first is the mean what will be defining it that is nothing, but expected value of x which is given by integration minus infinity to infinity x into f of x into dx.
33.srt	00:30:52.289 --> 00:31:02.869	So, this is for the continuous time case is defined as this for the discrete time case it is a sigma or xipi.
33.srt	00:31:03.130 --> 00:31:09.089	So, we represent E dot denotes the expectation operation or ensemble averaging basically.
33.srt	00:31:09.430 --> 00:31:20.140	The mean mx defines the level about which the random process x is fluctuates or fluctuating.
33.srt	00:31:20.480 --> 00:31:35.859	So, you will be seeing that is linear operation the useful properties of the expectation operation are expected value of alpha is equal to alpha and expected value of A times alpha will be A into expected.
33.srt	00:31:37.220 --> 00:31:45.440	of x basically, where alpha is a constant what we assume it.
33.srt	00:31:45.440 --> 00:31:51.740	If expected value of x is equal to 0, x we call it as 0 mean random variable.
33.srt	00:31:52.200 --> 00:32:06.880	So, you will be using a matlab function if you see the thing, the mean calculation is given mx is equal to mean of x computes the mean mx of all the elements in the vector x using the matlab function.
33.srt	00:32:07.450 --> 00:32:11.849	So, as an example so we said that our fair die rolling of a fair die.
33.srt	00:32:11.849 --> 00:32:15.410	So, we said n times that is n can be up to infinity.
33.srt	00:32:15.410 --> 00:32:19.619	So, the what will be the probability of outcome from this.
33.srt	00:32:19.670 --> 00:32:31.029	So, you will be seeing that X i is we are taking 6 and then our probability is 1 by 6 in all the cases.
33.srt	00:32:31.420 --> 00:32:36.750	And in this case mean is calculated as m X is P i into X i.
33.srt	00:32:37.220 --> 00:32:40.470	So, 1 by 6 of this which is going to be 3.5.
33.srt	00:32:40.470 --> 00:32:41.589	And the variance.
33.srt	00:32:42.890 --> 00:32:53.140	The measure of spread about the mean and is defined as sigma x squared with equal to expected value of x minus mx whole squared.
33.srt	00:32:53.609 --> 00:33:13.099	So, which is by substituting our expected value minus infinity to infinity x minus mx whole squared into f of x into dx for the continuous time case and it is going to be sigma pi xi minus mx whole squared for the discrete time case.
33.srt	00:33:13.690 --> 00:33:23.250	So, these are the mean and then variance what we will be defining it, x minus mx is the deviation of x from the mean value mx.
33.srt	00:33:23.730 --> 00:33:37.029	The positive square root of the variance is called the standard deviation sigma x and MATLAB this thing function for the standard deviation calculation uses std function ok.
33.srt	00:33:37.029 --> 00:33:43.289	The various defined can be expressed as that is sigma x squared.
33.srt	00:33:45.279 --> 00:33:49.279	is equal to expected value of x minus x whole squared.
33.srt	00:33:49.679 --> 00:33:57.039	So, which is nothing but expected value of x squared minus 2 mx plus mx squared.
33.srt	00:33:57.389 --> 00:34:10.659	So, you are taking the expected value inside which is nothing but expected value of x squared minus 2 into mx into expected value of x and this is away from our x plus mx squared.
33.srt	00:34:11.029 --> 00:34:18.549	So, this is the value what we will be getting it that is this becomes 0.
33.srt	00:34:18.929 --> 00:34:22.839	So, it will be expected value of x squared plus mx squared.
33.srt	00:34:23.319 --> 00:34:26.889	So, we call this is the mean square value of x.
33.srt	00:34:27.469 --> 00:34:32.999	So, variance is the difference between the mean square value and the square root of the mean value.
33.srt	00:34:33.459 --> 00:34:39.419	So, this is the random variable definition some of it what we will be seeing it.
33.srt	00:34:39.839 --> 00:34:54.729	So, we see that if what is it a mean value is equal to 0 that is mx is equal to 0, then what happens to sigma x squared is nothing but expected value of x squared.
33.srt	00:34:55.190 --> 00:34:59.460	So, which we call it as Px which is the power of x basically.
33.srt	00:35:00.589 --> 00:35:15.019	Consider the uniform density function, the mean of the function can be computed by this mx is equal to expected value of x which is nothing but minus infinity to infinity x into f of x dx.
33.srt	00:35:15.339 --> 00:35:21.190	So, we have seen the uniform which is substituted at 1 by x2 minus x1.
33.srt	00:35:21.759 --> 00:35:27.759	So, your integration x1 to x2, x of dx.
33.srt	00:35:28.019 --> 00:35:33.879	which is nothing but x2 minus x1 divided by 2 what will be resulting in.
33.srt	00:35:34.369 --> 00:35:45.289	So, variance of the function is defined sigma x squared is equal to this is what we had it expected value of x squared minus x squared.
33.srt	00:35:45.769 --> 00:35:57.399	So, if we substitute the thing with expected value of x squared with that and then by simplifying so, we will be getting it as mx squared.
33.srt	00:35:59.109 --> 00:36:05.309	So, So, in general if x is the random variable uniformly distributed in the interval minus delta and delta.
33.srt	00:36:05.809 --> 00:36:24.979	So, then we will be having mx mean is equal to 0 and then standard deviation x squared is given by delta squared by 3 by substituting in this you can calculate with minus delta and delta substituting it here you will be getting delta squared by 3 as the value.
33.srt	00:36:25.689 --> 00:36:30.779	So, this completes our on correlation.
33.srt	00:36:31.129 --> 00:36:37.809	And, little bit on random process in the next class we will be taking it up adaptive filter.
33.srt	00:36:38.279 --> 00:36:40.279	So, how we are going to derive it.
33.srt	00:36:40.769 --> 00:36:41.289	Thank you.
32.srt	00:00:01.219 --> 00:00:24.699	Welcome back to real time digital signal processing course.
32.srt	00:00:24.870 --> 00:00:30.160	So, last class we discussed about overlap add method.
32.srt	00:00:30.529 --> 00:00:35.210	So, we will take up example in this class and then continue with overlap save method.
32.srt	00:00:36.409 --> 00:00:41.229	This is what we have discussed overlap add method for continuous signal.
32.srt	00:00:41.479 --> 00:00:44.119	So, how we can take care of doing FFT for it.
32.srt	00:00:44.239 --> 00:00:51.469	So, today we will take up an example and then see how it is going to work if you have still doubt.
32.srt	00:00:51.579 --> 00:00:57.250	So, this is the procedure what we are going to follow for overlap save add method.
32.srt	00:01:02.140 --> 00:01:15.060	This is the impulse response of the sequence that is we call it as H of n. So, H of n has m minus 0 to m length and then n is the length of the signal if we assume.
32.srt	00:01:15.210 --> 00:01:20.430	So, we will be adding n minus 1 zeros to this.
32.srt	00:01:20.810 --> 00:01:28.269	So, this is the what we call it as to make it power of 2 that is n length for our FFT.
32.srt	00:01:28.629 --> 00:01:32.120	So, we are going to pad zeros here.
32.srt	00:01:32.659 --> 00:01:43.990	So, then we will be considering all n length what we call it as one is the impulse response as well as the input signal as you can see it is more than n length.
32.srt	00:01:43.990 --> 00:01:45.480	So, this can be continuous.
32.srt	00:01:45.480 --> 00:01:52.420	So, here for example, we have taken 3 n length in this case.
32.srt	00:01:52.760 --> 00:01:58.689	So, we will be bifurcating into n length of sequences input sequence also.
32.srt	00:01:59.050 --> 00:02:03.510	Then what we do this is x of 0 to x of n minus 1.
32.srt	00:02:03.880 --> 00:02:24.180	we call that as x1 of n and pad this one with 0s and then the other n samples will be taking type x of n to x of 2n minus 1 and then pad with 0s and then the third and then so on what will be doing it.
32.srt	00:02:24.180 --> 00:02:34.300	So, in the n we will be adding 0s as you can see what I will be getting it when I convolve x1 of n with h of n basically we will be getting.
32.srt	00:02:35.030 --> 00:03:04.490	y1 of n. So, then what we have is 0s here the complete this is going to be added to the m minus 1 sequence output of y2 of n here and this is y2 of n. Next our m minus 1 will be getting added with the y3 of n in this case because only we are going to do 3 of it to make it clear for you, but it can happen continuously.
32.srt	00:03:04.730 --> 00:03:06.159	So, we add this.
32.srt	00:03:06.620 --> 00:03:19.190	And, then this is our y of n as you can see here there is a addition sign here this is getting added with the previous one and this is the last one which we will be discarding it.
32.srt	00:03:19.190 --> 00:03:23.100	So, our y of n will be of this length.
32.srt	00:03:23.690 --> 00:03:27.060	So, to make it clear so, we will take a example in a while.
32.srt	00:03:27.170 --> 00:03:33.280	So, how this overlap add method although we have discussed in the last class.
32.srt	00:03:33.280 --> 00:03:39.780	So, we will just see that whatever the previous thing I have explained how it is going to work.
32.srt	00:03:40.789 --> 00:04:01.199	So, this is padding n minus 1 0s to the end of the impulse response sequence h of n of length m to obtain a sequence m plus n minus 1 which is l length and perform l point FFT of the padded impulse response sequences and store the FFT output values.
32.srt	00:04:01.750 --> 00:04:10.530	Then we will be performing l point FFT on the selected data block where each data block consists of n input data block.
32.srt	00:04:10.909 --> 00:04:14.030	values and M minus 1 0s.
32.srt	00:04:14.699 --> 00:04:26.519	So, thing will have input data and M minus 1 0s to make it L point sequence which will be taking FFT of it.
32.srt	00:04:26.920 --> 00:04:33.319	Then multiply the stored FFT output sequences that is because we are doing the filtering basically.
32.srt	00:04:33.319 --> 00:04:44.810	So, take the FFT of the impulse response, take the FFT of the input sequence, then do the multiplication as we know in the frequency domain.
32.srt	00:04:45.500 --> 00:04:51.560	2 A 50 are going to be multiplied which is convolution in the time domain.
32.srt	00:04:52.019 --> 00:04:59.459	So, we will be obtaining in 1 by the A 50 output sequence and selected data block obtained from 2.
32.srt	00:05:00.230 --> 00:05:02.899	So, perform an L point I A 50.
32.srt	00:05:02.899 --> 00:05:04.430	So, we have got the result.
32.srt	00:05:04.790 --> 00:05:15.350	So, we will be taking inverse Fourier transform on the output and the product sequence obtained in 3 here what we will be doing the I A 50.
32.srt	00:05:16.209 --> 00:05:32.349	Then, what we will do is overlap the first m minus 1 FFT values obtained in this 4 with the last m minus 1 FFT values for the previous block and then perform addition to produce y of n output values.
32.srt	00:05:32.990 --> 00:05:53.959	And then we will be moving back to this stage because we need not have to as we discussed in the computation complexity FFT because once we have done the FFT of our impulse response we need not have to redo the thing only for the next set of input blocks we will be taking.
32.srt	00:05:54.829 --> 00:06:01.259	So, we will be moving to the next data block that is will be performing it in loop.
32.srt	00:06:01.750 --> 00:06:03.939	So, we will take up an example.
32.srt	00:06:03.970 --> 00:06:06.300	So, which will make it clearer to you.
32.srt	00:06:06.300 --> 00:06:17.960	So, in this case m point filter it is 3 bit what we have taken sorry 3 point length what we have taken the thing.
32.srt	00:06:18.509 --> 00:06:27.560	So, it is 3 to 1 is the impulse response and we will be using a overlap add method to determine the output sequence in response to the.
32.srt	00:06:28.050 --> 00:06:36.700	repeating input sequence the size what we have chosen is 2 0 minus 2 0 2 1 etcetera ok as it is shown.
32.srt	00:06:37.230 --> 00:06:49.480	So, now our m is the 3 and then our n what we are going to select as you can see the thing here 2 4 6 and 8.
32.srt	00:06:50.439 --> 00:06:58.060	So, x1 of n so, we will be first considering it with 0s.
32.srt	00:06:58.780 --> 00:07:04.960	at the what is it we call it as in the end of our sequence.
32.srt	00:07:05.230 --> 00:07:12.520	So, we are considering our end point as 6 in this case m is 3.
32.srt	00:07:12.520 --> 00:07:24.280	So, 6 plus 3 is 9 minus 1 will be l. So, which is equivalent to 8 in this case.
32.srt	00:07:25.050 --> 00:07:27.600	So, this is how we compute our.
32.srt	00:07:28.840 --> 00:07:32.360	L m and then n basically.
32.srt	00:07:33.150 --> 00:07:41.550	So, from here what we are going to do is are now x 2 of n is as you can see in the figure here.
32.srt	00:07:41.580 --> 00:07:48.840	So, we will be starting from here to here after padding with 0s.
32.srt	00:07:49.400 --> 00:08:04.820	So, in this case 0 minus 2 and then we are taking the rest of the signals here up to 0 here, then we pad again with 2 0s m minus 1 0s.
32.srt	00:08:05.090 --> 00:08:08.140	which is equivalent to 2 0s what we are adding it here.
32.srt	00:08:08.590 --> 00:08:14.630	And then next sequence what we will have it is minus 2 and 0 in this case and so on.
32.srt	00:08:15.080 --> 00:08:20.710	So, this is how we have calculated our l m and then n values.
32.srt	00:08:21.190 --> 00:08:23.570	So, coming with the thing how we are going to continue.
32.srt	00:08:23.600 --> 00:08:32.509	Now, we have x 1 of n x 2 of n. So, we will be convolving with our h of n which is padded with 5 0s.
32.srt	00:08:32.820 --> 00:08:34.530	So, as it is shown here.
32.srt	00:08:34.860 --> 00:08:37.019	So, and then we have to take the.
32.srt	00:08:37.519 --> 00:08:44.779	what we will be calling it as H of minus of k minus n values what we will be taking it.
32.srt	00:08:45.200 --> 00:08:52.240	So, what we have been given is 3 2 1 and then you will be doing the reversal of the sequence.
32.srt	00:08:52.529 --> 00:08:57.850	So, first these are the 5 0s then 1 2 3 what we will be taking it.
32.srt	00:08:58.230 --> 00:09:04.700	Then this is going to be convolved with X1 of n what we have chosen.
32.srt	00:09:09.899 --> 00:09:10.940	So, now our Y1 of n is going to be as it is seen.
32.srt	00:09:11.429 --> 00:09:19.789	So, we have it 3 into 2 which is going to be 6 ok.
32.srt	00:09:20.210 --> 00:09:28.860	So, some previous values what you can have it because you will be moving the sequence as it is shown it is going to be moved to the right.
32.srt	00:09:29.200 --> 00:09:33.580	In the next step what you will be getting 2 into 2 is 4.
32.srt	00:09:34.110 --> 00:09:38.809	So, then you will be getting 3 into minus 2.
32.srt	00:09:39.289 --> 00:09:41.700	So, which is going to be minus 6.
32.srt	00:09:42.360 --> 00:09:46.660	x and then here you are going to have 2 into 1.
32.srt	00:09:47.210 --> 00:09:51.520	So, this is what the value which is going to come here in the second clock cycle.
32.srt	00:09:51.840 --> 00:09:55.379	So, minus 6 plus 2 is going to be minus 4.
32.srt	00:09:55.900 --> 00:10:00.900	So, so on you will be till the all the values have been computed.
32.srt	00:10:00.940 --> 00:10:07.300	So, this is r y 1 of n. So, this is how you will be doing your circular convolution.
32.srt	00:10:07.740 --> 00:10:13.360	Then now x 2 of n is the sequence what we have it from the previous what we have taken the thing.
32.srt	00:10:13.730 --> 00:10:16.690	So, this is minus 2 minus 1 0.
32.srt	00:10:17.600 --> 00:10:28.660	2 and then 0 0 then 2 padded with 2 0s and then this will be going in the forward direction as you can see it here.
32.srt	00:10:29.090 --> 00:10:31.370	So, the first one will be 0 output.
32.srt	00:10:31.750 --> 00:10:38.040	So, when you move towards your right because as you know the circular convolution.
32.srt	00:10:38.040 --> 00:10:40.320	So, we will be repeating those values.
32.srt	00:10:40.740 --> 00:10:47.270	So, this is minus 2 into R 3 which is minus 6 and so on you can compute it.
32.srt	00:10:47.530 --> 00:10:50.370	So, the output of y 2 of n is given here.
32.srt	00:10:50.850 --> 00:10:56.529	Then, next is how we are going to use this overlap add method.
32.srt	00:10:57.000 --> 00:11:04.810	So, we know that convolution result by m minus 1 two values and adding yields the output sequence as shown below.
32.srt	00:11:05.250 --> 00:11:24.100	So, that is this is my y1 of n and next y2 of n is going to be aligned with these two that is what it says two values have to be overlapped from y2 of n and then we have to add these two and then our y3 of n because only we have.
32.srt	00:11:24.750 --> 00:11:27.920	2 and then 0 and then later on it is not defined.
32.srt	00:11:27.920 --> 00:11:30.030	So, we will be calling it as xx.
32.srt	00:11:30.490 --> 00:11:39.580	So, if we have some more values then I have to compute my y3 of n in the same way as y1 and then y2 take those values and then put it here.
32.srt	00:11:40.060 --> 00:11:42.250	Now, what will be the final sequence?
32.srt	00:11:42.250 --> 00:11:54.420	So, it is 6 4 minus 4 minus 4 4 7 and then 4 plus 0 is 4 minus 6 plus 1 is minus 5 and then these sequences will be repeating it.
32.srt	00:11:54.810 --> 00:11:58.750	And, then after that I am not bothered I can put it as x x x.
32.srt	00:11:59.070 --> 00:12:09.310	So, if you see your convolution what output you are going to get it whether it is equivalent to this or not one can look at it using the overlap add method.
32.srt	00:12:09.310 --> 00:12:21.970	To show that it is correct ok what we have to copy is copy this sequence and then copy your 3 2 1 and then do the normal convolution.
32.srt	00:12:25.069 --> 00:12:34.419	So, if you are interested it that is what we will put it as show with the think.
32.srt	00:12:34.819 --> 00:12:37.679	So, normal all of you know this convolution pattern.
32.srt	00:12:38.039 --> 00:12:47.139	So, this is what you have it is 2 0 minus 2 0 2 1 0 minus 2 minus 1 and then last 0.
32.srt	00:12:47.139 --> 00:12:49.199	So, this is what.
32.srt	00:12:49.199 --> 00:12:57.169	So, what we have is 3 0 3 2 1 are sequence.
32.srt	00:12:58.249 --> 00:13:15.539	I can put a line here 6 0 minus 6 0 6 3 0 minus 6 and then 1 what I have it 3 and then 0 last one.
32.srt	00:13:15.539 --> 00:13:27.489	So, here it is going to be 2 0 minus 4 0 4 2 0 minus 4 2 and then 0.
32.srt	00:13:28.379 --> 00:13:37.039	the last one will be 2 0 minus 2 0 2 1 0 minus 2 1 and then 0.
32.srt	00:13:37.659 --> 00:13:44.269	So, you know that this is the way what you will be adding up in normal linear convolution.
32.srt	00:13:44.379 --> 00:13:55.129	So, you can do that and then see whether you will be getting the whatever you have got the output correctly or not.
32.srt	00:13:59.349 --> 00:14:02.309	So, these 3 what I have to do the thing.
32.srt	00:14:02.719 --> 00:14:16.829	So, first one is 6, second one is 2, minus 6 plus 2 is minus 4 and then minus 4 and then 6 minus 2 is again minus 4.
32.srt	00:14:17.409 --> 00:14:28.899	So, then what we have it is 4 plus 3 is 7, 2 plus 2 is going to be 4.
32.srt	00:14:30.370 --> 00:14:38.519	So, I have minus 1 minus 5 and then minus 4 and you can compute the thing.
32.srt	00:14:38.860 --> 00:14:45.580	So, go back and then check whether our output what we have got it is correct or not here.
32.srt	00:14:46.070 --> 00:14:58.659	So, this is how will you can cross verify and then see whether your convolution output is using this overlap add method because this is a simple length of it what it has taken to work it out by hand.
32.srt	00:14:58.710 --> 00:15:03.529	So, that when you write your code in MATLAB or in C.
32.srt	00:15:06.549 --> 00:15:15.789	So, you can verify it and then for larger x of n sequence and then whatever filtering what you have to do it you can use that and then run it.
32.srt	00:15:15.819 --> 00:15:19.120	So, in the lab we will demonstrate that whether it is going to work or not.
32.srt	00:15:19.549 --> 00:15:25.779	This is one of the way of computing the long sequence using overlap add method.
32.srt	00:15:26.250 --> 00:15:29.720	So, the next one what we will see is overlap save method.
32.srt	00:15:30.340 --> 00:15:36.299	So, here it is this one is called also overlap discard method.
32.srt	00:15:36.639 --> 00:15:44.710	will please hold on a while, while we are there we have added the whatever m minus 1 0s we have added.
32.srt	00:15:44.919 --> 00:15:53.549	Here m minus 1 data we are going to discard it that is why either we can call it as overlap save or overlap discard method.
32.srt	00:15:53.779 --> 00:15:56.159	So, how this method is going to work?
32.srt	00:15:56.429 --> 00:15:58.950	Same as this we have impulse response.
32.srt	00:15:59.230 --> 00:16:06.429	So, we have h of 0 to h of m minus 1 is the m length impulse this thing sequences.
32.srt	00:16:06.810 --> 00:16:13.590	And then next we will be padding with n minus 1 zeros to make it a n length sequence.
32.srt	00:16:13.970 --> 00:16:26.050	Now we have n length input x of n what we are going to consider and the next all these are again just like previous overlap add method.
32.srt	00:16:26.050 --> 00:16:32.570	So, we have n length sequences what we have considered then what we are going to do.
32.srt	00:16:32.860 --> 00:16:38.170	So, for the first one we are going to add n minus 1 zeros.
32.srt	00:16:38.800 --> 00:16:41.960	to make it L length sequence.
32.srt	00:16:42.590 --> 00:16:53.980	And then for the next one we are going to have m minus 1 samples from the previous one what we will be adding for the current length of the sequence.
32.srt	00:16:54.509 --> 00:17:05.509	So, that is we call it as block 2, this is the first block, block 2 and then so on block 3 and then if we have other in this thing inputs it will be going on that way.
32.srt	00:17:06.090 --> 00:17:07.420	Then how it is going to work?
32.srt	00:17:07.420 --> 00:17:13.230	So, you can see what will be our output this is m minus 1 we will be discarding it.
32.srt	00:17:13.740 --> 00:17:30.740	And, then block 1 output after this thing multiplication will be working on y1 of n that is x of k into h of k is y1 of and then taking IFFT y1 of n is going to come.
32.srt	00:17:31.309 --> 00:17:46.909	And, here it is again we are going to discard m minus 1 in this sequence and then take the rest of the block 2 as y2 of n and the other m minus 1 we are going to discard this.
32.srt	00:17:47.509 --> 00:17:58.009	output and then take the rest of the y3 of n and we will be concatenating these 3 blocks y1, y2 and y3 this will be our output.
32.srt	00:17:58.420 --> 00:18:05.619	So, you would be wondering how this is going to work we will take the same example and run the case in a while ok.
32.srt	00:18:05.619 --> 00:18:17.480	So, what is the procedure for it that is for the overlap save method I have to pad same as overlap pad, pad n minus 1 0s to our filter length to make it.
32.srt	00:18:17.779 --> 00:18:25.519	length L by making n minus 1 zeros to m length impulse sequences to make it as L length.
32.srt	00:18:25.519 --> 00:18:34.319	Then do the L point FFT and then same thing with our input how we are going to select here.
32.srt	00:18:34.559 --> 00:18:49.029	So, selected data block where each data block begins with the last m minus 1 values in the previous data block except the first data block which begins with m minus 1 zeros.
32.srt	00:18:49.379 --> 00:18:51.969	That is what I showed you in the previous slide.
32.srt	00:18:52.309 --> 00:19:01.149	Now, do the multiplication of these two FFT and then take a by the FFT of this thing block with respect to this.
32.srt	00:19:01.149 --> 00:19:20.919	Then perform L point IFFT to the product sequence which is obtained in 3 and save the last n values of IFFT obtained from this place and then discard the first m minus 1 values of the IFFT.
32.srt	00:19:21.669 --> 00:19:26.669	So, then we will be moving back to calculate the next sequences.
32.srt	00:19:26.939 --> 00:19:30.739	So, we will see how it is going to work with the same example what we have taken.
32.srt	00:19:31.169 --> 00:19:45.059	So, the impulse response for the FIR filter order is m which is equal to 3, the values are same thing 3 to 1 and then input sequence is same what we have assumed in the previous case.
32.srt	00:19:54.359 --> 00:19:58.509	Now, you will be seeing that your m is 3 if the length of the FFT or IFFT operation L is selected based on this that is 2 power 3 which is equal to 8.
32.srt	00:19:59.169 --> 00:20:03.839	Then n becomes L minus m plus 1 which is nothing but 6.
32.srt	00:20:04.230 --> 00:20:14.509	This is how we arrived at 6 in the previous case also and the segmentation of the input sequence results in the data blocks shown in this case.
32.srt	00:20:14.829 --> 00:20:27.109	That is n what we have named it minus 2 minus 1 because we need m minus 1 0s which is going to be padded before the input sequence.
32.srt	00:20:31.169 --> 00:20:33.750	So, we will be naming it as minus 2 minus 1 and then the input starts from 0 onwards.
32.srt	00:20:34.019 --> 00:20:58.849	So, your input is 2 0 minus 2 and then up to here what we have it as x of this is a complete x of n and x 1 of n is going to be up to here that is padded with 2 0s and then we will be taking 6 sequences as you can see here 2 0 minus 2 0 2 and 1 are the sequences what it is been assumed.
32.srt	00:20:59.199 --> 00:21:00.939	Now what will be our x 2 of n?
32.srt	00:21:00.969 --> 00:21:01.359	We said.
32.srt	00:21:01.889 --> 00:21:07.799	x now m minus 1 previous samples from the x of n what we have to take it.
32.srt	00:21:08.209 --> 00:21:11.979	So, in this case we have ended x 1 of n here.
32.srt	00:21:12.319 --> 00:21:25.199	So, previous to that 2 samples means this 2 and 1 are going to be repeated in our x 2 of n and rest of the 6 samples are going to be from our x of n here.
32.srt	00:21:25.549 --> 00:21:35.619	So, you will be pushing it down same thing with the x 3 of n last 2 and then x 2 will be repeating it and then goes for further.
32.srt	00:21:36.259 --> 00:21:37.869	Now, we will see its operation.
32.srt	00:21:38.339 --> 00:21:43.899	First is we have taken x 1 of n. So, we are doing the circular convolution here.
32.srt	00:21:44.879 --> 00:21:52.559	This is our x 1 of n and after that as you can see it is repeated for the next length also.
32.srt	00:21:52.589 --> 00:21:59.250	And our impulse response h of minus k minus minus of k minus n is given by this.
32.srt	00:21:59.669 --> 00:22:06.299	We have padded here also with 5 0s.
32.srt	00:22:06.809 --> 00:22:13.220	And, then you have taken the reverse the sequence which is going to be 1 2 3.
32.srt	00:22:13.720 --> 00:22:15.470	Start the computation here.
32.srt	00:22:16.039 --> 00:22:17.309	So, what is it?
32.srt	00:22:17.980 --> 00:22:28.559	Initially you will be seeing that this is 2 into 1 plus 2 into 1 which is going to give us 4 and then shift by 1 bit and then start computing it.
32.srt	00:22:29.059 --> 00:22:32.399	So, the next will be 1 and so on compute till here.
32.srt	00:22:33.230 --> 00:22:37.619	Then next is x2 of n. So, we said that x2 of n.
32.srt	00:22:38.160 --> 00:22:57.470	The sample what we had was from the previous one what it was repeated, you will be seeing that 2 and then 1 here and then you will be having the input what it has been taken from the input sequence.
32.srt	00:23:09.059 --> 00:23:11.649	So, now, same thing with h of minus k minus n. So, you will be reversing it and then taking it and then you will be doing the convolution of the 2 sequences.
32.srt	00:23:12.149 --> 00:23:20.190	So, you will be seeing that the resultant y 2 of n is 8 7 4 minus 3 minus 7 minus 4 and 5 and then 4.
32.srt	00:23:20.740 --> 00:23:33.079	Now, the next step is we have to calculate y 3 y 1 of n is given y 2 of n and y 3 of n last 2 we can ignore them that is what it will be.
32.srt	00:23:33.529 --> 00:23:36.389	So, you are putting under y 1 y 2.
32.srt	00:23:36.559 --> 00:23:40.359	So, we are going to discard these 2 values after the thing.
32.srt	00:23:41.049 --> 00:24:08.099	doing inverse FFT and then this is what it will be resulting is 6 4 minus 4 minus 4 and then you are going to discard these 2 values from y 2 of n and then put 4 7 from here and then continue with whatever data you are going to get from y 2 of n after discarding these 2 samples.
32.srt	00:24:12.719 --> 00:24:12.969	So, you are seeing that both overlap save and then overlap method.
32.srt	00:24:13.179 --> 00:24:20.659	So, works same as with our regular linear convolution.
32.srt	00:24:20.959 --> 00:24:23.749	So, we are getting the same results.
32.srt	00:24:24.129 --> 00:24:28.489	So, this is the way how overlap save method works.
32.srt	00:24:28.489 --> 00:24:38.129	So, you will be seeing that how the discard output blocks is going to happen with respect to y1, y2, y3 is given in this case.
32.srt	00:24:38.629 --> 00:24:45.069	So, y is 1, 0, y1 and then up to m minus 2 what you will be discarding them.
32.srt	00:24:45.559 --> 00:24:53.229	m minus 1 points and then you will be considering only this points and then these things ok, you will be discarding.
32.srt	00:25:16.299 --> 00:25:25.059	So, this is equivalent to our regular that is linear convolution with x of n with h of n. So, this is what the desired output and first m minus 1 points of each output block are discarded and the remaining l points of each block are appended to form the y of n. So, this covers are both overlap add and then save method to compute A 50 for a long length sequence.
32.srt	00:25:25.089 --> 00:25:28.939	So, one can ask why we have to have a overlap.
32.srt	00:25:29.129 --> 00:25:37.909	So, without overlap I have not taken the example in this case one can work it out using MATLAB.
32.srt	00:25:37.909 --> 00:25:41.189	So, what is the thing is going to happen.
32.srt	00:25:41.569 --> 00:25:45.919	So, you will have the discontinuity as you know that.
32.srt	00:25:47.899 --> 00:25:59.099	There will be if it is a speech signal if time permits will show you in the next class demo of it without overlapping how the signal looks like ok.
32.srt	00:25:59.309 --> 00:26:05.649	So, now, what are the applications of DFT?
32.srt	00:26:05.649 --> 00:26:13.059	So, the first one as I have told in the previous class that it is spectrum analysis.
32.srt	00:26:13.479 --> 00:26:15.399	So, what do we mean by that?
32.srt	00:26:15.799 --> 00:26:17.989	That is x of k is nothing but.
32.srt	00:26:18.500 --> 00:26:23.889	our magnitude of x of k into this is the phase part of it.
32.srt	00:26:24.219 --> 00:26:37.619	So, we will be taking the magnitude spectrum is given by that is magnitude of x of k is nothing, but a real of x of k whole square plus imaginary of x of k whole square under square root what you will be computing it.
32.srt	00:26:38.179 --> 00:26:47.919	So, this we have already seen in MATLAB as well as in CCS what will be our magnitude spectrum is going to be.
32.srt	00:26:48.279 --> 00:26:50.939	And next is the phase spectrum one wants to have it.
32.srt	00:26:54.829 --> 00:27:14.779	So, which is going to be tan inverse imaginary part of X of k divided by real part of X of k. So, in the example in the last class we computed for DFT what will be the angle and we plotted manually both the phase and then magnitude spectrum.
32.srt	00:27:15.349 --> 00:27:22.609	So, now, one more application as we call it of the DFT is first convolution.
32.srt	00:27:24.769 --> 00:27:35.269	So, as we computed in the last class what will be the computation time for FFT calculation and then how this can be implemented to do a fast convolution.
32.srt	00:27:35.619 --> 00:27:45.579	That is x of n is we take the FFT which is x of k and then impulse response are b coefficients in FIR filter.
32.srt	00:27:46.049 --> 00:27:53.669	We can take the FFT of it pre computed we will do that and then do the multiplication.
32.srt	00:27:53.669 --> 00:27:55.169	So, we have considered.
32.srt	00:27:55.599 --> 00:28:06.210	the complete computation time and we have to do IFFT and then get the Y of n. So, compared to the direct DFT or direct convolution.
32.srt	00:28:06.210 --> 00:28:17.990	So, how we were able to achieve almost 5 times the computation speed compared to the normal one that was shown in the last class.
32.srt	00:28:18.109 --> 00:28:24.069	So, then to check the thing how to calculate.
32.srt	00:28:26.330 --> 00:28:32.410	although we have done it in the last class, we will see how to plot our magnitude spectra with an example.
32.srt	00:28:32.840 --> 00:28:45.809	So, the example is x of n is given as 0.5 volts in this range 0 less than or equal to n less than or equal to 3 and then x of n is going to be 0 in other places.
32.srt	00:28:45.809 --> 00:28:56.750	Then compute the DFT for lengths of 8 and then 16 and plot the resulting magnitude spectrum sampling frequency in telco.
32.srt	00:28:57.240 --> 00:29:05.500	So, the thing is what we have is if you calculate manually you can do this and then plot it.
32.srt	00:29:05.610 --> 00:29:25.730	So, the magnitude spectrum you will be seeing that the n is equal to 0 will be 2 and then which comes to 1 0 and then 0.5 and then you will be seeing 0.5 and then you have 1 and then 2 this is with respect to.
32.srt	00:29:29.130 --> 00:29:30.810	n is equal to 8.
32.srt	00:29:31.570 --> 00:29:44.370	So, the same thing if you do with n is equal to 16 that is what we checked it increasing the that is magnitude spectrum for DFT how it is going to look like.
32.srt	00:29:44.740 --> 00:29:53.170	So, you will be seeing that few of the samples are in between filled between are 0 to 1.
32.srt	00:29:53.570 --> 00:30:00.220	In this case because it is twice compared to 8 kilohertz 8 point it is 16 point.
32.srt	00:30:01.000 --> 00:30:04.300	So, adding one more point in between these 2 signals.
32.srt	00:30:04.300 --> 00:30:11.570	So, you will be seeing that between these 2 as you can see that this point at 3 has been added.
32.srt	00:30:12.060 --> 00:30:20.750	So, at here 1 and this 3 and then you will be seeing all odd values have got added with respect to n is equal to 16.
32.srt	00:30:21.120 --> 00:30:27.230	So, you will be seeing when you draw a line in the thing.
32.srt	00:30:27.690 --> 00:30:32.280	So, this may be much what is it we call it as a smoother one.
32.srt	00:30:32.710 --> 00:30:36.500	to predict your computation using FFT.
32.srt	00:30:37.430 --> 00:30:42.300	So, now we will see how we can do the spectrum analysis.
32.srt	00:30:42.700 --> 00:30:52.800	So, two important parameters in spectrum evaluation are one is the bandwidth resolution, the other one is the frequency resolution.
32.srt	00:30:53.250 --> 00:31:02.290	So, the bandwidth resolution sets the signal sampling frequency, whereas our frequency resolution sets the record length and FFT length.
32.srt	00:31:03.030 --> 00:31:11.240	So, as an example it is required to use FFT to compute the spectrum of voice signal with a bandwidth of 5 kilohertz.
32.srt	00:31:11.700 --> 00:31:18.290	Determine the minimum record length if the frequency resolution required to be at least 10 hertz.
32.srt	00:31:18.670 --> 00:31:23.060	So, that means, from sample to sample what we want to have it as 10 hertz.
32.srt	00:31:23.450 --> 00:31:24.830	Then what is it?
32.srt	00:31:25.120 --> 00:31:29.070	A sampling frequency has to be greater than or equal to twice our bandwidth.
32.srt	00:31:29.630 --> 00:31:33.270	So, which restrict our sampling frequency as 10 kilohertz.
32.srt	00:31:33.720 --> 00:31:38.300	Then we will see that what will be our record length n what we have to calculate.
32.srt	00:31:38.760 --> 00:31:41.840	This should be greater than or equal to or Fs by F naught.
32.srt	00:31:42.460 --> 00:31:46.010	F naught is a spacing what it has been given is 10 hertz.
32.srt	00:31:46.370 --> 00:31:56.050	So, that means, to say that 1 kilohertz 10 kilohertz divided by 10 is going to give us 1000 samples basically.
32.srt	00:31:56.410 --> 00:32:11.410	So, to do our FFT computation we know that nearest power of 2 what we have to assume it for 1000 it is going to be 1024 that is 2 to the power of 10 is going to be 1024 is the nearest.
32.srt	00:32:12.140 --> 00:32:20.210	FFT computation what we have to do it for this signal, order to produce the required frequency resolution fine.
32.srt	00:32:20.510 --> 00:32:25.710	So, then we will see that in the previous case.
32.srt	00:32:26.070 --> 00:32:29.530	So, now, you will be seeing that instead of 10 hertz.
32.srt	00:32:29.730 --> 00:32:46.270	So, you can go back and then check what will be the frequency resolution, because we are trying to fix the record length based on it the frequency resolution little bit get modified it may come to 9.9 or.
32.srt	00:32:46.820 --> 00:32:49.190	hertz you can check it up fine.
32.srt	00:32:49.490 --> 00:32:54.030	Next is how to compute our power spectral density.
32.srt	00:32:54.140 --> 00:33:07.710	So, we know that power density spectrum or periodogram we call it originally introduced to determine our hidden periodicities in data.
32.srt	00:33:08.160 --> 00:33:17.100	So, gives the distribution of average power over various frequencies for a signal with indefinite length and is defined as.
32.srt	00:33:17.790 --> 00:33:31.340	P r r is given by the magnitude of X r r to the power of r divided by n. So, we know that X r is our DFT of X of n and n is the window width.
32.srt	00:33:31.800 --> 00:33:39.740	If X of n is a non stationary random signal then the DFT of X of n for each window period will differ.
32.srt	00:33:40.310 --> 00:33:47.570	And the average of a set of our periodogram is used as an estimate of the power density spectrum.
32.srt	00:33:47.950 --> 00:33:51.110	which is given by P r r r of of.
32.srt	00:33:51.410 --> 00:33:55.500	So, we are averaging over m windows 1 by m times.
32.srt	00:33:55.920 --> 00:34:13.330	So, P x m of r m is equal to 0 to m minus 1, where the estimated power density spectrum P r r r over the thing what it is represented is given as the average of the periodograms obtained from m windows.
32.srt	00:34:13.740 --> 00:34:21.670	The winded sequence is given by example, if you take it 0.5 volts, 2 volts, minus 0.5 volts and minus 2.
32.srt	00:34:25.609 --> 00:34:27.669	This is our x of n. We will see the how we will be calculating it.
32.srt	00:34:28.169 --> 00:34:34.899	So, you have been given values as minus 0.52, minus 0.5 and minus 2.
32.srt	00:34:34.899 --> 00:34:40.459	So, now, we will see that if we because 4 point.
32.srt	00:34:40.459 --> 00:34:48.029	So, we will apply the decimation in time FFT butterfly diagram is shown here.
32.srt	00:34:48.029 --> 00:34:53.039	So, if we input the thing so, and then compute our x naught.
32.srt	00:34:53.169 --> 00:34:54.849	So, we have worked out this example.
32.srt	00:34:56.369 --> 00:34:59.429	So, if you want to see the steps have been given here.
32.srt	00:34:59.859 --> 00:35:05.419	So, the first x naught is 0 and then the second one is 1 minus j 4.
32.srt	00:35:05.889 --> 00:35:15.909	So, third again is 0 and then we know that x 3 is going to be conjugate of our x 1 basically.
32.srt	00:35:16.229 --> 00:35:21.289	So, which is going to be 1 plus j 4 or you can compute using our butterfly diagram.
32.srt	00:35:21.289 --> 00:35:26.319	So, then how we are going to compute our power spectral density.
32.srt	00:35:26.740 --> 00:35:33.280	So, you will be seeing that x naught square whole square divided by here it is m is 4.
32.srt	00:35:33.610 --> 00:35:37.010	So, divided by 4 and then you will be seeing this way.
32.srt	00:35:37.370 --> 00:35:41.630	Then what happens to the thing it is 0, 4.250 and then 4.25.
32.srt	00:35:41.630 --> 00:35:48.750	So, this is the distribution in the thing to find out the energy and power of the sequence.
32.srt	00:35:48.750 --> 00:35:53.640	So, we know that passivals relationship what we are going to apply.
32.srt	00:35:53.640 --> 00:35:55.880	So, for the energy sequence.
32.srt	00:35:57.700 --> 00:36:04.230	So, which is given by E is equal to R is equal to 0 to 3 in this case for the example.
32.srt	00:36:04.750 --> 00:36:10.240	So, this is Px of R. So, when you calculate 0 plus add them up.
32.srt	00:36:10.460 --> 00:36:17.350	So, we will be seeing that it is going to consume 8.5 joules in an 1 ohm resistor.
32.srt	00:36:17.350 --> 00:36:23.160	So, that is if you are passing this on a 1 ohm resistor it will consume 8.5 joules.
32.srt	00:36:23.240 --> 00:36:27.690	And the average power if you want to calculate of the sequence.
32.srt	00:36:28.690 --> 00:36:33.540	So, you will be calculating energy divided by n basically.
32.srt	00:36:33.920 --> 00:36:40.510	So, it is going to be 2.125 watts of power what this system is going to consume.
32.srt	00:36:40.510 --> 00:36:53.060	So, this ends our overlap add and then save method and how to compute our power spectral density and then energy of a sequence.
32.srt	00:36:53.060 --> 00:36:56.010	So, in the next class we will take up correlation.
32.srt	00:36:56.010 --> 00:36:56.550	Thank you.
26.srt	00:00:01.219 --> 00:00:25.100	Welcome back to real time digital signal processing lab.
26.srt	00:00:25.129 --> 00:00:30.230	So today we will discuss about DFT and FFT.
26.srt	00:00:30.570 --> 00:00:32.289	whatever we have covered in theory.
26.srt	00:00:32.530 --> 00:00:41.899	So, we will see first in MATLAB, then we will go to the DSP processor board and then see how we are going to run our code today.
26.srt	00:00:42.439 --> 00:00:44.950	So, first we will consider the MATLAB thing.
26.srt	00:00:44.950 --> 00:00:52.329	So, this example as I was mentioning about the filters.
26.srt	00:00:52.640 --> 00:00:56.019	So, this is from the book Welch Wright and then Morrow.
26.srt	00:00:56.019 --> 00:01:00.369	So, you will be seeing that real time digital signal crossing book published in 2005.
26.srt	00:01:00.369 --> 00:01:08.000	There was an M file which shows that how the windows can be generated.
26.srt	00:01:08.509 --> 00:01:14.289	And, then the filter responses for different kind of windows what we can see it.
26.srt	00:01:14.589 --> 00:01:27.209	So, we will be applying one of the window for our DFT or FFT to remove the noise and then see that how they will be represented in the frequency domain.
26.srt	00:01:27.719 --> 00:01:43.199	So, here number of inputs what it is chosen is 128 and then alpha for KZ window is chosen as 3 and then number of FFT points chosen as 1024 into 8.
26.srt	00:01:43.959 --> 00:01:47.259	And then the sampling frequency in this case chosen as 48000.
26.srt	00:01:47.439 --> 00:01:59.129	And then you will be representing that is line type control for the plot and then you will be setting the font size in the plot of MATLAB.
26.srt	00:01:59.509 --> 00:02:09.879	So, first one will be calculating barlet window with the end points and then hamming window, rectangular window and then the kz window.
26.srt	00:02:10.169 --> 00:02:13.879	So, we have to pass the alpha parameters which can be variable.
26.srt	00:02:13.879 --> 00:02:16.949	So, you can select them as we have seen in.
26.srt	00:02:17.490 --> 00:02:19.390	filter design toolbox.
26.srt	00:02:19.700 --> 00:02:29.400	So, you can generate this then you will be computing their frequency response we call it as frequency Z basically.
26.srt	00:02:29.400 --> 00:02:48.240	So, you will be calculating for the that is h 3 what you have seen the thing w 3 by sum of w 3 what you will be putting it and then the sampling frequency what you will generate and then.
26.srt	00:02:48.420 --> 00:03:00.390	the frequency response for H 2 is shown that with this parameters and you will be outputting the figures actually.
26.srt	00:03:00.390 --> 00:03:14.420	So, you will be plotting W 3 that is subplot what will be having it and then font size line width what it is shown and all the 4 figures what it will be plotted.
26.srt	00:03:14.700 --> 00:03:18.990	So, with different colors and then later on.
26.srt	00:03:19.380 --> 00:03:40.620	You will be seeing that subplot what you are going to calculate that is P3 what it is chosen and then you will be finding these are the plot parameters one can go through you will be getting help file in MATLAB and then you will be all these are the subplot.
26.srt	00:03:41.450 --> 00:03:51.400	So, you will be seeing that you will be calculating a hamming window what it is going to be used and then.
26.srt	00:03:52.260 --> 00:03:58.460	its frequency after passing your data through that what you will be seeing it.
26.srt	00:03:58.460 --> 00:04:03.000	So, we will run and then see how we are going to get the output.
26.srt	00:04:03.390 --> 00:04:11.410	So, you can see the thing you will be seeing the first the figure we will look at it.
26.srt	00:04:12.050 --> 00:04:24.660	So, you will be seeing that this is a rectangular window and you will be seeing with the pink as a case of window with alpha is equal to 3 what it has been selected.
26.srt	00:04:25.129 --> 00:04:38.850	and then hamming window and this is the barlet window what you are seeing it is just like a triangular and then this is a rectangular and then the other two represent your smooth response.
26.srt	00:04:38.850 --> 00:04:42.160	So, the second figure we will see what has happened.
26.srt	00:04:42.610 --> 00:04:55.410	So, you will be seeing that in this you have passed through the rectangular window and then you are seeing the frequency response of after passing through the rectangular window.
26.srt	00:04:55.960 --> 00:04:59.210	And, then you will be seeing using the hamming window.
26.srt	00:04:59.689 --> 00:05:02.879	So, how the output is going to be represented?
26.srt	00:05:02.879 --> 00:05:11.379	So, you will be seeing that this is our main lobe, this is a low pass filter basically and then these are the side lobes.
26.srt	00:05:11.640 --> 00:05:23.689	So, you will be seeing that rectangular window you will be seeing it is has a main lobe is very narrow compared to your hamming window or any other window what you can take the thing.
26.srt	00:05:23.980 --> 00:05:26.010	So, you will be seeing the ripple somewhere.
26.srt	00:05:26.380 --> 00:05:29.850	in minus 14 dB or something like that what they have come down.
26.srt	00:05:30.320 --> 00:05:33.980	And then finally, it will be settling down to 21 dB also.
26.srt	00:05:34.430 --> 00:05:41.500	Whereas, in the case of your hamming window, this is a smooth response what you are having with your input signal.
26.srt	00:05:41.910 --> 00:05:55.260	So, the main lobe is little bit increased and then you will be seeing your side lobes have come down approximately what we can take it as minus 40 or 41 dB.
26.srt	00:05:57.350 --> 00:06:13.740	So, this shows that how our filter helps in having the main lobe and then side lobe required for your application what you can select one of the windows basically designing with windows.
26.srt	00:06:13.740 --> 00:06:20.730	So, we will close this and then we will go to the DFT basically.
26.srt	00:06:20.890 --> 00:06:26.260	So, here what we have is.
26.srt	00:06:27.930 --> 00:06:35.650	Usually, we ask the students to run DFT, FFT and then overlap add and save method.
26.srt	00:06:35.650 --> 00:06:51.210	So, we will demonstrate today up to this thing ok. We will go with the DFT, FFT editor because I can split the windows or editor can be in one of the thing.
26.srt	00:06:51.210 --> 00:06:59.540	So, here we will maximize on the editor so that you can see the codes what it has been written.
26.srt	00:06:59.750 --> 00:07:01.290	So, initially we use the clear all.
26.srt	00:07:01.790 --> 00:07:05.030	So, you should be calling back the theory.
26.srt	00:07:05.030 --> 00:07:06.010	So, we did.
26.srt	00:07:08.120 --> 00:07:12.670	the circular convolution using DFT properties.
26.srt	00:07:12.930 --> 00:07:22.280	So, we will be using in this case FFT to run our circular convolution.
26.srt	00:07:22.640 --> 00:07:28.120	One of the way of doing it is I can put a break point because the continuous code is running.
26.srt	00:07:28.530 --> 00:07:31.700	So, I will be setting the break point here.
26.srt	00:07:31.890 --> 00:07:36.530	So, that we will be seeing one after the other.
26.srt	00:07:36.560 --> 00:07:39.260	So, first one is a circular convolution.
26.srt	00:07:39.750 --> 00:07:47.860	using FFT as you can see that x has the value 1, 2, 3, 4 and then h is 1, 0, 1, 1.
26.srt	00:07:48.300 --> 00:07:51.480	So, this example we manually worked it out.
26.srt	00:07:51.810 --> 00:07:54.400	Now, we will see MATLAB how it is going to compute.
26.srt	00:07:54.689 --> 00:08:02.470	So, we will be first what we are doing convolution usually direct convolution as we have done it earlier.
26.srt	00:08:02.840 --> 00:08:08.250	Now, using FFT how we are going to do the circular convolution we look at it.
26.srt	00:08:12.910 --> 00:08:18.040	So, first what we do is xk is our FFT of x and then h k is FFT of h what we will be taking it.
26.srt	00:08:18.570 --> 00:08:44.270	And in the frequency domain we know that y k is going to be represented by direct multiplication of h k into x k. So, that is r as you can see y k is equal to x k into h k or h k into x k. Then what we will be doing is I can take the inverse FFT of the y k.
26.srt	00:08:44.780 --> 00:08:47.840	And compute and display circular convolution result.
26.srt	00:08:48.660 --> 00:08:53.620	So, then accordingly we can do the linear convolution.
26.srt	00:08:54.030 --> 00:09:02.790	So, how it is going to what are the values we are going to get it through a linear convolution is given by this equation.
26.srt	00:09:02.790 --> 00:09:07.590	Now, what is it L y linear y output what we will be getting it.
26.srt	00:09:08.010 --> 00:09:12.420	So, the convolve is the command prompt in MATLAB.
26.srt	00:09:12.420 --> 00:09:19.600	So, you can one can use it x comma h. So, it will be computing and display linear convolution results.
26.srt	00:09:19.950 --> 00:09:26.160	So, we will run this code since I have put the breakpoint till here what it will be running.
26.srt	00:09:26.560 --> 00:09:34.190	So, you can check the thing results it will be displayed on the command window.
26.srt	00:09:36.130 --> 00:09:37.310	So, I have to bring it down.
26.srt	00:09:37.780 --> 00:09:51.300	So, you can see that as the convolution of circular convolution of 1 2 3 4 and 1 0 1 1 what we got the result was 6 9 8 7 in the theory.
26.srt	00:09:51.300 --> 00:09:57.560	So, you are seeing using the MATLAB it was asked for you to verify with MATLAB whether you are going to get the same thing.
26.srt	00:09:57.990 --> 00:10:05.800	And, then the linear convolution what you can see is it is 1 2 4 7 5 7 4 what we got it.
26.srt	00:10:06.150 --> 00:10:10.460	So, that will be seeing that is direct convolution what it has been done.
26.srt	00:10:10.800 --> 00:10:17.180	So, using the convolution whether we can do the linear convolution that is what the example we worked it out.
26.srt	00:10:17.560 --> 00:10:25.590	So, here you will be seeing that linear convolution by 0 padding in the MATLAB code what we had has been written.
26.srt	00:10:25.980 --> 00:10:31.010	So, you will be 1 2 3 4 and you will be we have added the 1 2 4 0s.
26.srt	00:10:31.390 --> 00:10:33.260	So, this is 0s 1 2 4.
26.srt	00:10:33.530 --> 00:10:42.660	So, it will be generating 1, 2, 3, 4, 4 zeros followed by and then the same way with H z also 4 zeros what it has been added.
26.srt	00:10:42.980 --> 00:10:59.140	Now, you will be doing the DFT of or FFT computation basically of R X z and then H z, then we multiply in the frequency domain both of it ok.
26.srt	00:10:59.590 --> 00:11:03.560	So, why we can take the IFFT of IFT and then.
26.srt	00:11:03.950 --> 00:11:05.750	will be getting the results.
26.srt	00:11:05.750 --> 00:11:14.460	So, just to show that I can put the break point and then see that what our output is going to be.
26.srt	00:11:14.460 --> 00:11:16.340	So, we will continue the running.
26.srt	00:11:17.009 --> 00:11:21.590	So, we will see that the results are displayed here.
26.srt	00:11:22.820 --> 00:11:39.060	So, you can see that what was the thing the previous one we had 1 2 4 7 5 7 4 and then y is the what we have got the output with linear convolution and using FFT.
26.srt	00:11:39.410 --> 00:11:43.890	So, you will be seeing that it is 1.0, 2.0 and then so on.
26.srt	00:11:44.280 --> 00:11:54.140	The last one is minus 0 because we added one extra 0 in the thing because l plus m minus 1 as we know about it.
26.srt	00:11:54.140 --> 00:11:55.910	So, it has to be 7.
26.srt	00:11:55.910 --> 00:12:01.500	So, till there what you will have it rest of them are 0s by doing the 0 padding.
26.srt	00:12:01.680 --> 00:12:05.870	So, we will go back to the next this thing.
26.srt	00:12:05.870 --> 00:12:09.180	So, I can maximize when I want to show you the results.
26.srt	00:12:09.180 --> 00:12:11.600	So, we will reduce it and then go back.
26.srt	00:12:11.600 --> 00:12:13.080	Now, what is it?
26.srt	00:12:14.790 --> 00:12:20.200	Calculate the amplitude spectrum of sine wave using F50 and then display it.
26.srt	00:12:20.750 --> 00:12:38.990	So, here are this thing is number of samples that is 256, we call it as sampling rate and then sine wave frequency what chosen is 50 basically hertz and number of points chosen is 120.
26.srt	00:12:39.430 --> 00:12:43.909	So, this up to 128 points 0 to n minus 1.
26.srt	00:12:44.570 --> 00:12:50.769	So, you will be calculating sine of 2 pi.
26.srt	00:12:52.190 --> 00:12:58.990	f by f s into n. So, that is how we will be getting our x n samples in input sample.
26.srt	00:12:59.370 --> 00:13:06.019	Then we can calculate x of k that is f f t of x of n comma n number of points.
26.srt	00:13:06.610 --> 00:13:14.610	And then we will be plotting the absolute value of x k because we know that it is a complex conjugate what we will be getting it.
26.srt	00:13:15.110 --> 00:13:17.519	Only the amplitude what I want to have the thing.
26.srt	00:13:17.519 --> 00:13:25.210	So, we will be taking the absolute of x of k which gives us the plot the amplitude spectrum alone.
26.srt	00:13:25.809 --> 00:13:29.609	And, then this is going to give us the magnitude spectrum.
26.srt	00:13:30.139 --> 00:13:39.909	So, for the axis is going to represent 1 to 64 show only up to points fs by 2.
26.srt	00:13:40.209 --> 00:13:51.609	So, in this case what we have is 128 points which represents up to 1 to 2 pi or fs values.
26.srt	00:13:51.990 --> 00:13:53.639	So, you will be labeling.
26.srt	00:13:53.639 --> 00:13:57.199	So, what we will do is we will put a breakpoint again.
26.srt	00:13:58.039 --> 00:14:09.329	So, I have to go down and then the select a breakpoint here.
26.srt	00:14:10.329 --> 00:14:17.279	So, we will set enable the breakpoint here.
26.srt	00:14:17.679 --> 00:14:22.879	So, you will be seeing where next computation is going to happen we will have the breakpoint.
26.srt	00:14:23.689 --> 00:14:29.129	So, we can continue this is to avoid multiple files.
26.srt	00:14:29.629 --> 00:14:33.639	all the codes have been incorporated in one.
26.srt	00:14:34.059 --> 00:14:40.750	So, you will be seeing that this is the for up to 64 samples what you have it.
26.srt	00:14:41.100 --> 00:14:47.189	So, what we have is f is equal to 50.
26.srt	00:14:47.769 --> 00:15:00.189	So, you will be seeing the magnitude whatever you are going to get the thing and then the frequency index you will be seeing that it is at approximately.
26.srt	00:15:00.490 --> 00:15:05.919	So, what you are having the frequency at k is equal to 25.
26.srt	00:15:05.919 --> 00:15:13.259	So, can you compute and then look at it whether you are getting the frequency as 50 hertz.
26.srt	00:15:13.519 --> 00:15:15.539	How it is going to be?
26.srt	00:15:15.569 --> 00:15:28.889	So, you have to multiply it by 2 which you will be getting it as 50 hertz ok.
26.srt	00:15:29.289 --> 00:15:32.069	So, now the next one is.
26.srt	00:15:32.879 --> 00:15:38.999	compute and display amplitude spectra at 2 sine waves.
26.srt	00:15:39.539 --> 00:15:41.829	So, how we are going to do this?
26.srt	00:15:42.269 --> 00:15:43.599	We hold on for a while.
26.srt	00:15:43.629 --> 00:15:46.649	So, we will set the break point here also.
26.srt	00:15:47.089 --> 00:15:49.449	So, you know that next break point is set.
26.srt	00:15:49.829 --> 00:15:51.469	So, what we are going to do here?
26.srt	00:15:51.689 --> 00:16:02.979	So, again our sampling frequency we have chosen as 256 sampling rate and sine wave frequency is 50 hertz and number of points what we have chosen is 128.
26.srt	00:16:03.549 --> 00:16:08.959	And we will be calculating sine of the thing 50 hertz sine wave.
26.srt	00:16:09.299 --> 00:16:17.389	So, we will be doing the FFT of this one and then calculate our this thing magnitude.
26.srt	00:16:19.319 --> 00:16:22.869	So, this is what we did the thing.
26.srt	00:16:23.189 --> 00:16:29.979	So, the next one is we will see that amplitude spectra 2 sine waves what is going to happen.
26.srt	00:16:30.409 --> 00:16:35.659	So, we will put up the next break point it has already selected.
26.srt	00:16:35.989 --> 00:16:37.159	So, it is the same thing.
26.srt	00:16:37.539 --> 00:16:47.859	So, what you have is the first frequency is 50, f1 is 61 frequency of first sine wave and then second sine wave what it has been chosen.
26.srt	00:16:48.309 --> 00:17:04.009	And you will be calculating xn is sin 2 pi f by fs into n and then x1 of n will be 2 star pi f1 by fs into n. So, generate 61 hertz generate 50 hertz.
26.srt	00:17:04.399 --> 00:17:08.089	Then take xk is equal to fft of the first.
26.srt	00:17:08.809 --> 00:17:33.619	input signal and x1 k is of f of t of x1 comma n basically second sine wave and then calculate their magnitude spectrum first sine wave and the second sine wave magnitude spectrum and then plot them with n values which is varying between 0 to 127.
26.srt	00:17:33.619 --> 00:17:38.809	So, you will be only representing 1 to 64.
26.srt	00:17:39.189 --> 00:17:47.929	run this you will be seeing that how the two of them look like.
26.srt	00:17:48.379 --> 00:17:59.169	So, you are seeing this is a multiple as you can see this is you will be seeing at 50 hertz and this should be at 31.
26.srt	00:17:59.589 --> 00:18:10.629	So, you can see that approximately x is there 30 little bit movement will give select 31.
26.srt	00:18:11.500 --> 00:18:24.490	So, So, So, So, that is what your y magnitude is 40.7109 what you will be seeing it and you will be seeing this if I put the thing x is 25 and then y is 64.
26.srt	00:18:24.490 --> 00:18:39.779	So, you will be seeing that approximately you will be getting between 60 to 61 what you are seeing the thing which is 61 hertz sine wave generated.
26.srt	00:18:43.190 --> 00:18:56.250	Whereas, your peak is at 25 for your 50 hertz signal as because we are representing with 64 samples in the thing pi by 2 what we have done the thing ok.
26.srt	00:18:56.619 --> 00:19:02.029	So, this is how we are frequency spectrum and other things work.
26.srt	00:19:02.029 --> 00:19:12.829	So, the next one is we are going to see that overlap of two spectral lines due to frequency separation is less than frequency resolution.
26.srt	00:19:14.980 --> 00:19:18.829	So, how we have defined our frequency resolution?
26.srt	00:19:18.829 --> 00:19:22.789	It is fs by n what we have taken the thing.
26.srt	00:19:23.140 --> 00:19:37.609	So, you have 256 here again n is 128 and fn in this case sampling frequencies sorry the frequency that has to be passed first sine wave is 60 the next one is 61.
26.srt	00:19:37.990 --> 00:19:42.470	So, compared to the previous one so, we have 1 hertz difference.
26.srt	00:19:42.789 --> 00:19:46.400	So, we will see the resolution how it is going to be represented.
26.srt	00:19:46.400 --> 00:19:50.130	Then we will be calculating x in and then x to n.
26.srt	00:19:50.789 --> 00:19:54.500	generate 60 hertz and then 61 hertz as usual previous.
26.srt	00:19:54.890 --> 00:20:08.730	Then add them up and take the F f t of x in that is mix these two sine waves and take the DFT computation find the magnitude response and then plot.
26.srt	00:20:09.460 --> 00:20:13.019	So, we will be checking the break point again.
26.srt	00:20:15.490 --> 00:20:20.970	So, we will see.
26.srt	00:20:25.859 --> 00:20:38.150	sorry almost they are overlapping you are unable to see even the expansion of it.
26.srt	00:20:38.660 --> 00:20:42.339	So, you can reduce the thing.
26.srt	00:20:45.430 --> 00:20:51.519	So, approximately it shows at 30 R combined frequency response.
26.srt	00:20:52.210 --> 00:20:58.409	So, your resolution what you are going to see is very this thing small in this case.
26.srt	00:20:59.089 --> 00:21:02.339	So, we may have to increase number of samples.
26.srt	00:21:02.339 --> 00:21:21.980	So, what we can do is I can sample at this thing what we will call it as 1024 we can modify this sorry 1024 and whether number of points whether I can increase it to 256 we will see the thing.
26.srt	00:21:22.709 --> 00:21:25.939	And, then we will rerun the code again.
26.srt	00:21:32.709 --> 00:21:53.719	Actually, it has gone off to further ok. We will clear all the breakpoints and now we will put the breakpoint here.
26.srt	00:21:58.709 --> 00:22:02.529	And, the next rig point will be in the next place.
26.srt	00:22:13.039 --> 00:22:18.339	She had your dark suit in greasy wash water all year.
26.srt	00:22:21.399 --> 00:22:27.719	So, one second clear all will help.
26.srt	00:22:27.919 --> 00:22:28.629	break the thing.
26.srt	00:22:29.379 --> 00:22:33.669	So, that we can restart it because it has gone into the end.
26.srt	00:22:34.220 --> 00:22:36.740	So, we will come back and then run that portion.
26.srt	00:22:37.059 --> 00:22:58.490	So, I have to put the break point now where we are calculating here f is we had given it as enable the break point here and then again we will enable the break point here.
26.srt	00:23:10.830 --> 00:23:12.779	So, it has come to this.
26.srt	00:23:13.710 --> 00:23:21.980	So, you can see that it the previous one what we are seeing it as the output.
26.srt	00:23:22.460 --> 00:23:28.350	So, now, I have to run it again because it is pointing to here, we will continue the thing.
26.srt	00:23:28.870 --> 00:23:30.870	So, now, you will be seeing that.
26.srt	00:23:31.560 --> 00:23:35.180	all the sorry it is been mapped to only 64 points.
26.srt	00:23:35.180 --> 00:23:43.519	So, it will be little shifted you have to multiply still you will be seeing that the peak has gone up to 200 and odd.
26.srt	00:23:43.910 --> 00:23:45.740	So, whether we can expand it.
26.srt	00:23:45.900 --> 00:24:00.360	So, you will be seeing that 60 and 61 almost has got merged in this that is what we call it as frequency resolution which we are unable to look into the thing.
26.srt	00:24:00.769 --> 00:24:02.380	So, now, what is it?
26.srt	00:24:02.890 --> 00:24:09.240	How we are going to compare a rectangular and k-zer windows for spectral analysis?
26.srt	00:24:09.240 --> 00:24:11.710	So, the next example.
26.srt	00:24:11.710 --> 00:24:33.890	So, here the sampling frequency is 256 and we have n is equal to 128 points that is what it says sampling rate and then signal length and then the frequency selected it is 61 that is sine wave what we are going to generate it and then beta value in this case is selected as 8.96.
26.srt	00:24:36.149 --> 00:24:47.879	And, then the we are going to use instead of alpha we will be selecting beta in this case, w and k 0 n comma beta we will be applying it.
26.srt	00:24:48.470 --> 00:24:55.019	And then we are going to do the normalize the gain against again as rectangular window.
26.srt	00:24:56.099 --> 00:25:01.730	And then rectangular windowed spectrum what we will be calculating absolute of that.
26.srt	00:25:02.099 --> 00:25:06.799	And the other one is we will be calculating kz windowed spectrum.
26.srt	00:25:07.289 --> 00:25:14.620	from that that is normal g into absolute of x l k and then we will try to plot the thing.
26.srt	00:25:15.009 --> 00:25:21.600	So, here we will put again the break point.
26.srt	00:25:22.420 --> 00:25:25.500	So, that will not spill over ok.
26.srt	00:25:25.500 --> 00:25:32.740	So, we will run and then see what will be the frequency and then magnitude what we will be getting it.
26.srt	00:25:33.559 --> 00:25:35.610	So, you can see that.
26.srt	00:25:38.960 --> 00:25:58.100	So, what is the first one what we have it here is absolute of x k. So, that means, to say which is the window you are going to have it rectangular window here.
26.srt	00:25:58.170 --> 00:26:07.700	And then this is my rectangular window and this is the k z window what it is representing.
26.srt	00:26:08.140 --> 00:26:09.260	So, with the beta.
26.srt	00:26:09.650 --> 00:26:15.930	So, we will be having the response of the k-zer window as this way.
26.srt	00:26:15.930 --> 00:26:26.240	So, we you will be seeing that the almost equivalent to rectangular window the main lobe what you will be selecting it.
26.srt	00:26:26.240 --> 00:26:39.769	So, you will be seeing your frequency will be approximately 61 hertz both of them are passing with both rectangular and then.
26.srt	00:26:40.500 --> 00:26:49.820	So, we will see how to find the power spectral density of 2 sine waves embedded in our random noise.
26.srt	00:26:50.240 --> 00:26:55.730	So, you can generate a random noise that is initialized random signal generator.
26.srt	00:26:56.400 --> 00:27:10.250	So, and then your sampling frequency what you have chosen as 1 kilohertz and then you will be having generate fs by 10 is you will be seeing that 100 samples.
26.srt	00:27:10.780 --> 00:27:29.400	of the every one point what you will be selecting it and you have been given what is it amplitude of 2 sine waves that is 1 and then 2 which is 150 and 140 frequencies of sine waves.
26.srt	00:27:30.130 --> 00:27:34.640	And then amplitude of the first sine wave is 1 second sine wave is 2.
26.srt	00:27:35.000 --> 00:27:41.080	So, generate xn with a sine 2 star pi f star t plus.
26.srt	00:27:41.560 --> 00:27:47.720	0.1 times the random value what you will be adding with your signal.
26.srt	00:27:48.250 --> 00:27:53.140	Then you will be calculating your spectrum and periodogram ok.
26.srt	00:27:53.790 --> 00:28:03.500	So, that is what the next assignment or lab portion of it will again enable the break points here.
26.srt	00:28:03.500 --> 00:28:09.780	So, we will run it and then you will be seeing the spectral density here.
26.srt	00:28:13.760 --> 00:28:19.390	So, that is what your power spectral density.
26.srt	00:28:19.570 --> 00:28:25.640	So, what we had was two frequencies 150 and then 140.
26.srt	00:28:26.050 --> 00:28:41.360	So, you will be seeing that this is approximately 140 and this is approximately 150 4 or something approximate what you have the thing.
26.srt	00:28:41.800 --> 00:28:43.440	And you will be seeing that.
26.srt	00:28:43.730 --> 00:28:51.990	how your side loops are buried in your noise what you are seeing it fine.
26.srt	00:28:53.520 --> 00:29:00.350	So, the next one is whether we can play and compute a spectrogram of speech file in this case.
26.srt	00:29:00.880 --> 00:29:10.360	So, next we will put the this thing.
26.srt	00:29:10.520 --> 00:29:12.040	In this case.
26.srt	00:29:14.530 --> 00:29:34.740	So, you have a speech file sampled at 8 kilohertz you can record it using MATLAB and number of bits chosen is 16 bits in this case and sound is play the speech signal and then you can find its spectrogram using the function spectrogram ok.
26.srt	00:29:34.860 --> 00:29:40.960	So, we will see that first and then we look at it.
26.srt	00:29:45.230 --> 00:29:47.400	Hopefully, you have heard the thing.
26.srt	00:29:47.809 --> 00:29:51.940	This is the speech spectrogram what you will be seeing it.
26.srt	00:29:52.259 --> 00:30:00.859	So, you will be seeing that your power of frequency 0 dB per hertz what it is shown.
26.srt	00:30:01.240 --> 00:30:06.049	So, these are the 50 hertz and this is frequency in kilohertz what it is marked.
26.srt	00:30:06.390 --> 00:30:11.319	So, most of the speech signal as we say that it is going to be up to 3.1 kilohertz.
26.srt	00:30:11.319 --> 00:30:18.589	So, that is the reason why the or maximum 4 kilohertz that is why the sampling frequency is chosen as.
26.srt	00:30:19.370 --> 00:30:24.460	8 kilohertz and time duration in seconds this is the 3 second.
26.srt	00:30:24.799 --> 00:30:32.720	So, this is how you can generate your sign distinct speed signal and see its spectrogram.
26.srt	00:30:33.220 --> 00:30:45.640	So, now, what we will do is we will overlap add techniques for fast convolution what we are going to use it.
26.srt	00:30:45.670 --> 00:30:53.490	So, this theory will be covering it in the how to do this fast convolution will be covered in the theory.
26.srt	00:30:54.230 --> 00:31:05.259	And, then how to implement FIR filter that attenuate this whatever 1 kilohertz sine wave tonal noise speech file.
26.srt	00:31:05.710 --> 00:31:06.659	So, what is it?
26.srt	00:31:06.730 --> 00:31:12.450	So, you will be using the same speech file and then sampling rate is chosen as 8 kilohertz.
26.srt	00:31:12.779 --> 00:31:20.000	So, first we will be playing the original speech signal, then pure that is what speech is played.
26.srt	00:31:20.379 --> 00:31:25.970	Then what you are going to do is you are going to generate a 1 kilohertz sine wave which is called.
26.srt	00:31:26.440 --> 00:31:30.700	So, what is the omega 2 star pi into f by f s frequency of sine wave.
26.srt	00:31:31.240 --> 00:31:41.850	So, you have done the thing and you will be merging with your speech signal that is what we call it as corrupt switch by 1 kilohertz sine wave.
26.srt	00:31:42.440 --> 00:31:55.009	And then you can hear that corrupt voice and then you we can display the spectrum of noisy speech and then later on we will be applying window technique.
26.srt	00:31:59.140 --> 00:32:27.430	that is pass band filter 900 to 1100, fs by 2 is 4000 in this case what we have given and apply FIR 1 filter with stop band that design in FIR filter to stop the frequency this is a band stop filters what it is not band pass it is a band stop 900 to 1100.
26.srt	00:32:27.430 --> 00:32:33.220	So, we want to eliminate 1000 hertz so that is why it is stop band filter what it is designed.
26.srt	00:32:33.700 --> 00:32:42.450	And then you will be passing this coefficient b coefficient through your FFT filter that is FIR filtering using overlap add method is being used here.
26.srt	00:32:42.490 --> 00:32:46.839	So, that it is a continuous signal input signal what you have it.
26.srt	00:32:46.839 --> 00:32:51.319	So, you would not be able to take the complete FFT.
26.srt	00:32:51.759 --> 00:33:00.640	So, part by part what it will be done, done actually in the overlap method add method is being used.
26.srt	00:33:00.710 --> 00:33:08.019	So, we have the overlap save method also one of them can be used here overlap add method is going to be demonstrated.
26.srt	00:33:08.289 --> 00:33:12.240	So, you will be displaying the spectrogram of the filter speech.
26.srt	00:33:14.519 --> 00:33:16.059	this is a noisy signal.
26.srt	00:33:16.539 --> 00:33:19.649	So, we will go back and then press the this thing.
26.srt	00:33:21.740 --> 00:33:27.230	She had your dark suit in greasy wash water all year.
26.srt	00:33:27.289 --> 00:33:38.629	Although you faintly see the 1 kilohertz, but still in the speech you are unable to hear the sine wave.
26.srt	00:33:38.629 --> 00:33:41.149	So, this is a filtered output what you have got it.
26.srt	00:33:41.199 --> 00:33:46.169	So, this shows that how our discrete Fourier transform is computed using.
26.srt	00:33:46.819 --> 00:33:52.389	FFT method to implement for different applications.
26.srt	00:33:52.389 --> 00:34:02.139	It can be circular convolution, linear convolution or you want to eliminate your noise from the speech using the filtering technique.
26.srt	00:34:02.599 --> 00:34:06.319	So, we can do it in the frequency domain.
26.srt	00:34:06.389 --> 00:34:06.899	Thank you.
41.srt	00:00:01.219 --> 00:00:25.780	Welcome back to real time digital signal processing lab.
41.srt	00:00:26.140 --> 00:00:31.640	So, we will see that how our adaptive filter is going to run.
41.srt	00:00:31.769 --> 00:00:34.479	Yesterday one of the wave file was missing.
41.srt	00:00:35.359 --> 00:00:36.420	in the previous class.
41.srt	00:00:36.420 --> 00:00:40.780	So, today it has been put into the system.
41.srt	00:00:41.060 --> 00:00:49.599	So, we will see that how it is going to run with different people writing their own code and then testing their algorithm ok.
41.srt	00:00:49.849 --> 00:00:54.519	So, the adaptive filter what it is shown in this matlab file.
41.srt	00:00:54.679 --> 00:00:59.280	So, you will be seeing that this also GUI.
41.srt	00:00:59.679 --> 00:01:03.820	Yesterday we were trying to run the LMS algorithm.
41.srt	00:01:03.909 --> 00:01:05.829	So, the voice.
41.srt	00:01:08.939 --> 00:01:22.920	then the tone dot waver together basically that is what we call it as here it is included in the combined stereo basically.
41.srt	00:01:22.950 --> 00:01:27.569	So, you will be seeing that there is a mistake in the stereo spelling.
41.srt	00:01:27.599 --> 00:01:35.140	So, that is what you have to do the thing and then we can run it.
41.srt	00:01:35.390 --> 00:01:39.859	So, when we are running it independently then we have to open this.
41.srt	00:01:42.739 --> 00:01:56.480	Now, we will see that How using the adaptive filter directly including we call this as the adapt now you will be seeing that code is written in this way GUI code basically.
41.srt	00:01:56.480 --> 00:02:05.180	So, that you can change your input file and then mu and other parameters you need not have to go back to the system to change it.
41.srt	00:02:05.219 --> 00:02:10.810	So, you will be seeing that it is getting as yesterday I said.
41.srt	00:02:13.299 --> 00:02:29.039	in the last class sorry that is two tones what it is taking it one and then two one is the input the other one is tone and then you will be combining it and then sending it that is we have left channel and then right channel for stereo.
41.srt	00:02:29.310 --> 00:02:30.859	So, both are taken together.
41.srt	00:02:31.289 --> 00:02:37.750	So, then how our algorithm is going to work with mu and definition that is LMS algorithm.
41.srt	00:02:43.789 --> 00:02:51.929	alpha mu value what it is taken because it contains both NLMS and LMS algorithm.
41.srt	00:02:52.219 --> 00:02:58.549	So, you will be selecting alpha for NLMS and only mu for our LMS algorithm.
41.srt	00:02:58.589 --> 00:03:04.739	So, these are the inputs because you can see they are getting in handles me you can vary those values.
41.srt	00:03:05.419 --> 00:03:08.750	So, this is the complete code what it has it.
41.srt	00:03:14.109 --> 00:03:28.389	as it is given the thing it is going to code for adaptive filter dot figure creates a new adaptive filter and raises the existing single tone.
41.srt	00:03:29.109 --> 00:03:33.459	So, you will be seeing the property GUI what it is going to run it.
41.srt	00:03:33.749 --> 00:03:38.599	So, we will run and then see how it is going to work on this file ok.
41.srt	00:03:38.929 --> 00:03:45.499	So, you have seen that in the previous class that all the algorithms were together.
41.srt	00:03:46.399 --> 00:03:49.489	Here, you can select the wave file.
41.srt	00:03:50.279 --> 00:04:00.869	So, this is a combined stereo what I will be selecting it from this place and then the n is given 61 order mu is selected as 0.1.
41.srt	00:04:01.299 --> 00:04:12.519	So, what I will do is I will change the thing to 31 order and then 0.1 for 0.01 for my adaptive mu what I will be delaying it.
41.srt	00:04:16.489 --> 00:04:20.789	So, we will run the LMS algorithm first on this, run it.
41.srt	00:04:22.049 --> 00:04:37.319	So, if I want to see the unfiltered output, it is F 50 and then output what you are seeing it.
41.srt	00:04:38.019 --> 00:04:43.379	So, filtered output always if I run the filtered output.
41.srt	00:04:48.259 --> 00:04:53.319	So, you will be hearing it clear speech which is coming out of it ok.
41.srt	00:04:53.679 --> 00:05:04.789	So, now what we will do is we will change the order to 61 and then our mu value to 0.1 and then see what is the thing is going to happen.
41.srt	00:05:04.789 --> 00:05:07.949	I will run the LMS algorithm it is a clear speech.
41.srt	00:05:07.949 --> 00:05:16.799	So, you are seeing how your output is coming.
41.srt	00:05:19.250 --> 00:05:25.459	So, change of the order of the filter and then the mu value which is set to 0.1 step size.
41.srt	00:05:25.459 --> 00:05:29.109	So, you will be seeing how output is going to behave.
41.srt	00:05:29.439 --> 00:05:38.370	So, now we will see with respect to NLMS algorithm same thing what I will keep it and then alpha what selected is 0.9.
41.srt	00:05:38.370 --> 00:05:40.799	So, we will run the algorithm.
41.srt	00:05:40.799 --> 00:05:45.319	Remember the force will be with you always.
41.srt	00:05:49.159 --> 00:05:57.529	always, remember the force will be with you always.
41.srt	00:05:57.529 --> 00:06:10.769	So, if it is unfiltered output here also we will check the thing to make sure that our input contains both the that is noise plus our speech signal.
41.srt	00:06:11.110 --> 00:06:21.199	Remember the force will be with you always.
41.srt	00:06:21.709 --> 00:06:22.050	correct.
41.srt	00:06:22.370 --> 00:06:26.139	This is the way how you can design your adaptive filter.
41.srt	00:06:26.729 --> 00:06:36.279	Now, what we will do is we will take up as you can see there are different assignments.
41.srt	00:06:36.279 --> 00:06:40.009	So, we have done the demo also the same way.
41.srt	00:06:40.409 --> 00:06:45.620	So, this was LMS algorithm was given as a mini project to all of them.
41.srt	00:06:45.620 --> 00:06:49.810	So, they designed their own way in programming.
41.srt	00:06:51.500 --> 00:06:57.949	concept what they have taken because usually we do not allow for copying.
41.srt	00:06:58.029 --> 00:07:00.170	So, you have seen two different.
41.srt	00:07:00.170 --> 00:07:04.670	So, we will have multiple students developing their own algorithm.
41.srt	00:07:05.189 --> 00:07:11.430	Now we will see that one of the student think how our echo is going to work ok.
41.srt	00:07:12.089 --> 00:07:14.539	So, we have seen the thing echo generation.
41.srt	00:07:15.199 --> 00:07:21.370	So, what is the echo how we have given the equation.
41.srt	00:07:21.779 --> 00:07:24.539	So, I will show you the equation here.
41.srt	00:07:25.069 --> 00:07:37.209	So, you will be seeing that you are going to read your audio sampling frequency is set at 8000 and then echo duration what you will be setting from the your handles.
41.srt	00:07:37.209 --> 00:07:51.079	You can set the thing minimum how you will not have the echo path and then if you set the duration little more then how you will be seeing the echo path.
41.srt	00:07:51.679 --> 00:08:04.199	And then this is the delay so that is given by echo duration multiplied by your sampling frequency divided by 1 kilohertz basically.
41.srt	00:08:04.659 --> 00:08:07.409	So 1000 what you have taken the thing.
41.srt	00:08:07.779 --> 00:08:12.529	So in this case delay 1 is this is the time duration what you will take it.
41.srt	00:08:12.929 --> 00:08:21.789	So our out of i will be input of i what you will be taking it and you will be calculating the delay plus 1 to length of it.
41.srt	00:08:22.109 --> 00:08:24.579	So you will be adding with input of i.
41.srt	00:08:24.969 --> 00:08:29.109	your echo weight into output of I minus delay.
41.srt	00:08:29.489 --> 00:08:40.429	So, this is how you will be adding to your input the as you have called out of I is input itself.
41.srt	00:08:40.429 --> 00:08:54.350	So, this is the input delay what we are going to give it whereas, in the reverberation it is the output which is come whatever out of I you have calculated will be going as delay ok.
41.srt	00:08:54.559 --> 00:08:57.589	So, the will run thus.
41.srt	00:08:57.819 --> 00:09:01.729	and see how it is going to respond to our data.
41.srt	00:09:02.259 --> 00:09:10.389	So, here also you will be seeing that you have been given echo duration millisecond default first we will run the thing and then we can modify and then see it.
41.srt	00:09:10.819 --> 00:09:19.939	This is 300 millisecond what the delay is there and then echo weight is between 0 and 1 what we have to give it.
41.srt	00:09:20.279 --> 00:09:26.509	So, here it is taken 50 percent that is 0.5 what it is and then we have to select the wave file for running it.
41.srt	00:09:26.509 --> 00:09:28.109	So, we will see that.
41.srt	00:09:28.999 --> 00:09:31.559	This is the voice signal what we will take it.
41.srt	00:09:32.149 --> 00:09:40.059	So then we will run and then please see that whether you are going to hear the echo.
41.srt	00:09:40.859 --> 00:09:46.649	Remember the force will be with you always.
41.srt	00:09:46.649 --> 00:09:47.789	So you have heard the echo coming.
41.srt	00:09:48.109 --> 00:09:50.059	So what is the FFT of it?
41.srt	00:10:00.250 --> 00:10:05.389	So this is how the FFT of your echo path what you will be seeing both your input and then So, we will change the duration we will make it 30 millisecond.
41.srt	00:10:05.649 --> 00:10:14.750	So, in the theory we said that 40 millisecond are path what it is going to take for the telephone line to come back.
41.srt	00:10:14.980 --> 00:10:24.429	So, here we will make it and then we will make it as 0.1 also in this case and we will see whether we are going to hear the delay or not.
41.srt	00:10:32.819 --> 00:10:43.500	So, this shows that If the delay is lesser, you will not be hearing the echo in your telephone lines or voice over IP or if you want to generate it ok.
41.srt	00:10:44.179 --> 00:10:46.009	So, this is how it works.
41.srt	00:10:46.009 --> 00:10:57.209	So, we will increase it to little more and see how the echo can be perceived ok. And I will give wait for it is 0.5 and see it.
41.srt	00:10:57.209 --> 00:11:04.069	Remember, remember, so you have heard that.
41.srt	00:11:04.809 --> 00:11:08.529	Remember which is occurring so many times.
41.srt	00:11:08.529 --> 00:11:13.700	So, you can consider echo can be used for your reverberation.
41.srt	00:11:13.740 --> 00:11:19.460	So, it is not once it is multiple times what it is coming fine.
41.srt	00:11:19.840 --> 00:11:22.100	This is one of the example.
41.srt	00:11:22.440 --> 00:11:25.789	So, we will see from next is our scrambler basically.
41.srt	00:11:25.860 --> 00:11:31.740	So, you have to hold your breath for this example.
41.srt	00:11:31.970 --> 00:11:40.100	In the next example, I will show you I will go with this example later because.
41.srt	00:11:40.579 --> 00:11:48.069	they have not given a reset command to reset the thing sometimes it goes continuously fine.
41.srt	00:11:48.399 --> 00:11:54.949	So, we will go to the other this thing this is the MATLAB code.
41.srt	00:11:54.949 --> 00:11:57.389	So, I have to go to the particular thing.
41.srt	00:11:57.850 --> 00:12:03.750	So, you will be seeing that this is echo scrambler and equalizer all together in this case.
41.srt	00:12:04.090 --> 00:12:07.519	In the previous case we saw only one running it.
41.srt	00:12:07.840 --> 00:12:10.600	So, here everything is combined.
41.srt	00:12:10.889 --> 00:12:15.169	So, we will run the thing one more student thing how it is going to work.
41.srt	00:12:15.449 --> 00:12:18.189	Here you will be seeing that all the three should be coming.
41.srt	00:12:18.579 --> 00:12:23.439	So, there will be a case statement to take care of it which one you are going to select.
41.srt	00:12:23.889 --> 00:12:39.429	Based on it you will be running you will be seeing that scrambler which is going to run or it can be your echo the first one will be running echo the next one will be scrambler and then the last one will be equalizer.
41.srt	00:12:39.969 --> 00:12:41.539	We will be seeing.
41.srt	00:12:41.989 --> 00:12:44.929	that also how it is going to work ok.
41.srt	00:12:45.339 --> 00:13:04.279	So, you are seeing the codes here, this is scramble and then this scramble both is going to happen, you can select one of it and then you will be getting the plot also how it is going to look like and you are this thing audio file what you can read the thing.
41.srt	00:13:04.389 --> 00:13:10.109	Here it is echo strength you are calling with alpha in this case and then.
41.srt	00:13:12.500 --> 00:13:17.609	you will be computing your delay i minus d is the delay.
41.srt	00:13:18.000 --> 00:13:27.000	So, which with the wait function will getting added with your input and this is what it is going to generate your echo.
41.srt	00:13:27.579 --> 00:13:33.359	So, we will run this code I may have to as it is going out of the thing.
41.srt	00:13:35.219 --> 00:13:38.870	So, we will just reduce the delay.
41.srt	00:13:43.250 --> 00:13:51.669	thing to 100 that is size basically scale the thing so that I will be able to show you the demo part of it.
41.srt	00:13:52.129 --> 00:13:53.209	So, we will run it.
41.srt	00:13:53.209 --> 00:13:57.819	So, now, you will be seeing the complete GUI otherwise some of it is getting suppressed.
41.srt	00:13:58.299 --> 00:14:15.909	So, what we will see first we will check the echo basically you can here it is given in seconds there in the previous example from the other student it was in millisecond here you can define it as in seconds, but it is.
41.srt	00:14:17.099 --> 00:14:20.149	As you can see 0.1 to 0.6 what you can go with it.
41.srt	00:14:20.149 --> 00:14:27.370	So, we will choose same as that one and then I have to load the input wave file.
41.srt	00:14:27.370 --> 00:14:36.639	So, here we will be putting the same speech file in this case and then first we will play the input wave file.
41.srt	00:14:36.639 --> 00:14:43.159	Remember the force will be with you always.
41.srt	00:14:43.159 --> 00:14:45.370	So, one can select any wave file.
41.srt	00:14:45.370 --> 00:14:52.250	So, usually we give this and then even noise getting added, corruptive signals are given to the students to run the thing.
41.srt	00:14:53.629 --> 00:14:56.879	So, now we will generate the echo from this case.
41.srt	00:14:57.899 --> 00:15:04.819	Remember, remember the force will be with you, will be with you always, always.
41.srt	00:15:04.819 --> 00:15:08.059	So, as you can see here you do not have the option to select the delay.
41.srt	00:15:08.379 --> 00:15:11.889	So, only single echo has been generated.
41.srt	00:15:11.889 --> 00:15:20.429	In the previous case even the echo duration you are had the provision to do it, here only what weight what you are giving it.
41.srt	00:15:20.749 --> 00:15:23.839	So, if I give the weight little lesser.
41.srt	00:15:24.749 --> 00:15:27.769	0.1 ok and then generator echo.
41.srt	00:15:27.799 --> 00:15:34.469	Remember the force will be with you always.
41.srt	00:15:34.469 --> 00:15:36.109	So, you will not be hearing any echo.
41.srt	00:15:36.109 --> 00:15:42.529	So, as and when my weight is going to increase delay path is defined then I will be getting the delay.
41.srt	00:15:42.899 --> 00:15:47.909	Now, we will see the same thing how the scrambler is going to work.
41.srt	00:15:47.949 --> 00:15:53.619	It is the same input file what I will be giving it and then we can.
41.srt	00:15:55.009 --> 00:15:57.409	the frequency what I have to choose it.
41.srt	00:15:57.819 --> 00:15:59.749	So, as we discussed in the theory.
41.srt	00:16:00.149 --> 00:16:07.749	So, we had selected 3000 hertz as the thing we can, but here you have the variable thing.
41.srt	00:16:07.749 --> 00:16:12.159	So, first we will check 1000 and then do the scrambling.
41.srt	00:16:12.629 --> 00:16:15.369	So, you will be hearing a scrambled voice.
41.srt	00:16:16.509 --> 00:16:16.569	.
41.srt	00:16:16.569 --> 00:16:22.609	So, you heard the scrambled and do this de scrambling.
41.srt	00:16:25.459 --> 00:16:31.539	Remember the force will be very powerful.
41.srt	00:16:31.769 --> 00:16:35.189	So, you can see the plot how does it look like.
41.srt	00:16:35.889 --> 00:16:48.969	This is the scrambled signal unable to make out much difference in this case and then the descrambled output which is almost equivalent to your input.
41.srt	00:16:49.439 --> 00:16:56.859	So, we will change the duration that is filter frequency basically.
41.srt	00:16:57.189 --> 00:17:02.169	So, we will choose it as 2000 and then do the scrambling.
41.srt	00:17:06.859 --> 00:17:14.839	So, you can hear that is there is some this thing speech you can make out and then this .
41.srt	00:17:14.839 --> 00:17:20.599	We will choose 2500 hertz 3000 anyway ok.
41.srt	00:17:20.599 --> 00:17:25.989	So, then we will scramble it and then here how much you can hear or it is completely scrambled.
41.srt	00:17:34.689 --> 00:17:43.729	Since, you have heard the thing earlier, so you would be able to make out what is that disc rambling.
41.srt	00:17:43.799 --> 00:17:52.299	Remember, the force will be with you always.
41.srt	00:17:52.299 --> 00:17:56.049	Next, equalizer, so what is an equalizer?
41.srt	00:17:56.349 --> 00:18:02.819	If you have a nowadays anyway music system nobody is buying the thing.
41.srt	00:18:03.209 --> 00:18:18.809	So, although headphones and other things what you buy for noise cancellation and you know boss is the best manufacturer of your all the you we call it as audio equipments.
41.srt	00:18:18.809 --> 00:18:26.049	So, here the equalizer you can select which one you want to retain and which one you want to suppress it.
41.srt	00:18:26.049 --> 00:18:32.409	So, as you will be seeing here it is a 4 channel equalizer.
41.srt	00:18:32.809 --> 00:18:34.199	So, some of them go with.
41.srt	00:18:34.630 --> 00:18:36.210	10 channel equalizer.
41.srt	00:18:36.549 --> 00:18:44.220	So, that you are narrow band only those frequencies which you want to highlight it you can do the thing.
41.srt	00:18:44.839 --> 00:18:51.220	When all of them are in the center you know that it is a balanced system what you will be getting it.
41.srt	00:18:51.589 --> 00:18:56.730	So, some of them design a 3 channel equalizer with the frequencies.
41.srt	00:18:56.799 --> 00:19:04.140	In this case what is that it is 0 to 500 hertz is a low pass filter what it has been designed.
41.srt	00:19:04.559 --> 00:19:08.509	So, that anything above 500 hertz by making it 0.
41.srt	00:19:08.870 --> 00:19:15.110	Whether I can cancel it we will see the thing whether they have given the 0 option or not I am not sure of the thing.
41.srt	00:19:15.420 --> 00:19:16.840	So, we will verify it.
41.srt	00:19:17.240 --> 00:19:19.600	So, the next one is band pass filter.
41.srt	00:19:20.049 --> 00:19:22.529	What is the frequency after passing 500 hertz?
41.srt	00:19:22.850 --> 00:19:33.000	Next 500 hertz to 1300 hertz what we can use it to do are this thing frequencies that can be passed.
41.srt	00:19:33.000 --> 00:19:39.250	So, if I suppress the low pass filter and then only using this.
41.srt	00:19:39.440 --> 00:19:42.880	some of it is going to be highlighted and some of them will be suppressed.
41.srt	00:19:43.380 --> 00:19:49.730	And then the next band pass filter is 1300 to 2500 hertz.
41.srt	00:19:50.320 --> 00:19:57.640	So, this is what are this thing two band pass filters in different two frequencies from here to here what you have the thing.
41.srt	00:19:58.100 --> 00:20:06.930	So, they will be passing the signal between these two frequencies from them one can be 0 the other can be uploaded.
41.srt	00:20:07.030 --> 00:20:15.200	The last one band pass filter what it is been used is 2500 to 4000 hertz.
41.srt	00:20:15.660 --> 00:20:18.519	The sampling rate here it is assumed is.
41.srt	00:20:19.440 --> 00:20:27.360	8000 total fs by 2 that is up to pi value what you are giving your frequencies to pass through.
41.srt	00:20:27.810 --> 00:20:41.910	So, what we will do is here because we have to hear the speech file does not have all the frequencies usually all your bands and other things you will be having in the higher frequencies.
41.srt	00:20:42.250 --> 00:20:51.920	So, we will see that how it is going to work for a music in this case so, because usually the.
41.srt	00:20:52.950 --> 00:21:02.960	regular are August semester ends in December this student has chosen a merry Christmas as music signal to run the thing.
41.srt	00:21:03.260 --> 00:21:08.930	So, we will play and then see what is the output will be getting it.
41.srt	00:21:08.930 --> 00:21:11.770	So, I have loaded the thing I can play the input way file.
41.srt	00:21:11.800 --> 00:21:27.740	It is a part of it not the complete because it will take little time nobody will have patience to listen to the thing.
41.srt	00:21:28.110 --> 00:21:30.900	So, we will play the thing with respect to.
41.srt	00:21:31.680 --> 00:21:37.050	the thing because I think it might not have got cleared.
41.srt	00:21:37.510 --> 00:21:49.380	So, we will load the file again speech file, we will set minimum value for all of them we will make it at least little higher.
41.srt	00:21:51.120 --> 00:21:58.920	Remember the force will be with you always.
41.srt	00:21:59.150 --> 00:22:02.680	We will change the input file, we will load the music.
41.srt	00:22:04.110 --> 00:22:20.660	So, now we will reduce these two, if you had noticed some of the thing.
41.srt	00:22:20.660 --> 00:22:24.070	As you have seen the thing.
41.srt	00:22:37.620 --> 00:22:39.920	only it is getting passed with this ok.
41.srt	00:22:40.380 --> 00:22:45.730	So, I will include one more frequency and then we will play the thing.
41.srt	00:22:47.010 --> 00:22:58.300	Still some of the things are missing.
41.srt	00:22:58.300 --> 00:23:04.280	So, we can make it 0 here and then play only one frequency is getting passed.
41.srt	00:23:14.570 --> 00:23:16.820	So, you the clarity is gone ok.
41.srt	00:23:17.140 --> 00:23:40.370	So, we will make it all of them this way you can as I mentioned in the introductory class that you can keep playing like this writing your own code what you want to generate it.
41.srt	00:23:41.270 --> 00:23:46.890	So, as this example shows that this is from the MATLAB file what we are running it.
41.srt	00:23:47.230 --> 00:23:49.680	So, you want to design your own hardware.
41.srt	00:23:50.140 --> 00:23:50.960	So, you can do that.
41.srt	00:23:50.960 --> 00:23:52.590	So, you can see that.
41.srt	00:23:53.050 --> 00:23:58.650	And, then we will be seeing the demo in the next class using our DSP processor.
41.srt	00:23:59.140 --> 00:24:10.930	So, as you have seen it is a programmable device DSP processor, we will be using it for demoing all these experiments in the hardware.
41.srt	00:24:11.440 --> 00:24:11.960	Thank you.
7.srt	00:00:00.330 --> 00:00:25.920	So, last class we discussed about the DSP architecture 1.
7.srt	00:00:26.219 --> 00:00:30.359	So, today we will see what how we are going to continue the architecture part.
7.srt	00:00:30.779 --> 00:00:35.769	So, as a recap to refresh you what we discussed in the last class.
7.srt	00:00:36.170 --> 00:00:50.570	So, we discussed about the multiplier, how to design a parallel brawn multiplier and how to design a shifter, barrel shifter what we discussed and then how to design our arithmetic logic unit what we have considered.
7.srt	00:00:50.570 --> 00:00:59.579	In this class we will discuss about memory and then what are the addressing modes compared to our.
7.srt	00:01:01.250 --> 00:01:10.819	regular microprocessor what we need it and then why we need the bit reversal and pipelining and then parallelism of aspects of DSP processor.
7.srt	00:01:10.819 --> 00:01:15.739	So, coming to the memory architecture.
7.srt	00:01:16.230 --> 00:01:17.969	So, you see pyramid here.
7.srt	00:01:17.969 --> 00:01:21.420	So, registers are the closest to the CPU.
7.srt	00:01:21.599 --> 00:01:31.989	So, and then what we have is L1 cache, L2 cache and then you will be seeing the main memory and then flash memories and then.
7.srt	00:01:33.909 --> 00:01:40.159	for more storage magnetic disc, optical disc and then tape comes in the last part of it.
7.srt	00:01:40.599 --> 00:01:47.109	All of us know that these are almost extinct from the present a situation.
7.srt	00:01:47.479 --> 00:01:50.199	So, seeing the left hand side of it.
7.srt	00:01:50.469 --> 00:01:58.060	So, you will be seeing that speed is the highest in this case and it is going to slow down when as we go down in this pyramid.
7.srt	00:01:58.780 --> 00:02:06.750	Whereas, in the case of size and then axis time as we will be seeing it size is very small in this.
7.srt	00:02:07.049 --> 00:02:22.120	access time for these registers are the smallest one whereas for the magnetic tape is the last one sizes as we know a lot of it what we can store it and then access time is going to increase.
7.srt	00:02:22.680 --> 00:02:32.840	So, continuing with the memory architecture so how it is going to be stored in our DSP processor or how it is designed what we will be seeing it.
7.srt	00:02:33.280 --> 00:02:39.419	So, you will be seeing that CPU will be incorporated with the registers.
7.srt	00:02:39.919 --> 00:02:46.179	And then you will be seeing the cache for level 1, 2 and then 3.
7.srt	00:02:46.519 --> 00:02:50.929	So, these are the direct CPU access what we are going to have it.
7.srt	00:02:51.469 --> 00:02:56.370	And then even some of the temporary storages access what you will be seeing it.
7.srt	00:02:56.679 --> 00:02:58.829	That is physical RAM virtual memory.
7.srt	00:02:59.219 --> 00:03:03.669	And the other ones are it is going to be indirect access to CPU.
7.srt	00:03:04.009 --> 00:03:08.289	So, they do not have any direct bus connectivity in the thing.
7.srt	00:03:08.829 --> 00:03:11.859	Whereas, we have to use the external bus too.
7.srt	00:03:12.679 --> 00:03:15.929	access these memories basically.
7.srt	00:03:16.479 --> 00:03:22.799	So, you will be seeing some of them are going to have a overlapping spectrum basically.
7.srt	00:03:23.249 --> 00:03:29.549	So, these are the assisted memory management what we call them.
7.srt	00:03:30.199 --> 00:03:38.969	So, coming these we call it as secondary storage devices and then we have the input sources here.
7.srt	00:03:39.429 --> 00:03:44.199	So, you will be seeing that these are the permanent storage areas.
7.srt	00:03:44.409 --> 00:03:47.669	and these are the temporary storage for the processor.
7.srt	00:03:48.339 --> 00:03:55.889	So, coming to some of the addressing modes you would have learnt in your 8085 or 8086 course.
7.srt	00:03:56.249 --> 00:04:07.039	So, we have to provide immediate addressing mode, register, direct, indirect, special addressing modes we will be seeing it as circular and bit reversed.
7.srt	00:04:07.339 --> 00:04:11.809	Addressing modes are the typical to DSP processors.
7.srt	00:04:12.289 --> 00:04:14.949	So, when you come to immediate addressing mode.
7.srt	00:04:15.199 --> 00:04:26.869	All of us know that when I want to add directly some value from the memory, we will be giving it as add hash immediate address what we will be giving it or immediate value.
7.srt	00:04:27.279 --> 00:04:34.879	So, this value is going to be added to our accumulator and the result is going to be stored in the accumulator that is what it says.
7.srt	00:04:35.469 --> 00:04:39.909	Hash immediate is the value represented by immediate fixed number.
7.srt	00:04:40.379 --> 00:04:46.049	So, usually if we have to have the filter coefficient, so if we know a prior then we can.
7.srt	00:04:46.569 --> 00:04:53.800	give this as a immediate value and then as normal notation A is the accumulator in this.
7.srt	00:04:54.269 --> 00:05:14.349	Coming to register addressing mode, we say operand is always in processor register, we call it as REG and capability to reference data through its register, we call it as add register means the value whatever stored in the register is going to be added with the accumulator and result in accumulator.
7.srt	00:05:14.349 --> 00:05:17.000	So, this REG are the processor register.
7.srt	00:05:19.160 --> 00:05:22.509	which provides the operands for our addition.
7.srt	00:05:23.149 --> 00:05:33.060	So, coming to the next one we have to have a direct addressing mode, we have to take a data directly from the memory location we call it as MEM.
7.srt	00:05:33.639 --> 00:05:37.949	So, it is going to be reference data by giving its memory location directly.
7.srt	00:05:38.420 --> 00:05:40.000	So, we say add memory.
7.srt	00:05:40.269 --> 00:05:49.300	So, we are giving the address of it whatever the value stored in it that is MEM is going to be added with our accumulator and result is MEM.
7.srt	00:05:49.540 --> 00:05:50.540	the accumulator.
7.srt	00:05:50.980 --> 00:05:54.199	This is the specified memory location MAM.
7.srt	00:05:55.290 --> 00:06:19.360	And in the indirect addressing mode we have to say that operand accessed using pointer add register because all of our operations are continuous that is sigma what we call it the from 0 to n minus 1 times what we want to multiply and add for that we should have a pointer so that I can access one after the other.
7.srt	00:06:19.910 --> 00:06:27.090	So, operand memory location is the variable in this case and operand address is given by the value of register.
7.srt	00:06:27.610 --> 00:06:29.060	in this case.
7.srt	00:06:29.360 --> 00:06:39.200	So, you will be specifying add star gives the from where the memory location where it is available the data address register.
7.srt	00:06:39.550 --> 00:06:53.450	So, the value provided by this whatever pointer it is address register is pointing to the value is taken from that memory and then it is added with the accumulator and result is an accumulator back.
7.srt	00:06:54.000 --> 00:06:59.400	So, that is what it says add register loaded with register location before use.
7.srt	00:07:00.270 --> 00:07:09.980	And, coming to special addressing modes as I am telling these are the ones which classifies digital signal processor apart from normal processors.
7.srt	00:07:10.100 --> 00:07:13.100	The first one is the circular addressing mode.
7.srt	00:07:13.130 --> 00:07:20.070	So, here circular buffer allows continuous stream of incoming data samples.
7.srt	00:07:20.460 --> 00:07:28.180	So, once the end of buffer is reached samples are wrapped around and added to the beginning again.
7.srt	00:07:28.840 --> 00:07:29.820	So, this is.
7.srt	00:07:30.380 --> 00:07:35.520	required for real time implementation in DSP processor.
7.srt	00:07:35.960 --> 00:07:39.440	So, we know that the input is coming continuously.
7.srt	00:07:39.770 --> 00:07:57.130	The other addressing mode what we need is the bit reversed addressing all of you have taken the digital signal processing course will be knowing it that for the FFT algorithm if I am using the radix II FFT I need the input in the reversed format.
7.srt	00:07:57.130 --> 00:08:02.920	So, first we will see what is the circular addressing mode.
7.srt	00:08:03.690 --> 00:08:16.140	So, in this case this is the reference index the value what I have taken here is 8 basically that means, to say that there are 8 values what we can store.
7.srt	00:08:17.700 --> 00:08:27.440	If I put the circular address, so I will call it as what we have bifurcated into 8 the circle into 8 parts.
7.srt	00:08:27.760 --> 00:08:33.480	So, I will be seeing that this is the 0 and then this is 1, 2, 3.
7.srt	00:08:34.139 --> 00:08:37.320	4, 5, 6 and 7.
7.srt	00:08:37.680 --> 00:08:44.610	So, these are the values what I needed to store them and when the 8th sample comes what we are going to do it.
7.srt	00:08:44.980 --> 00:08:47.310	So, we have taken as it is seen here.
7.srt	00:08:47.710 --> 00:08:52.350	So, we are taking 8 mod 8 is going to be 0.
7.srt	00:08:52.350 --> 00:09:00.690	So, the 8th sample whichever is coming in the real time which overwrites this 0th location as the 8th sample.
7.srt	00:09:01.110 --> 00:09:03.629	So, what is going to happen to the 9th sample?
7.srt	00:09:03.659 --> 00:09:05.420	So, we will be overwriting on 1.
7.srt	00:09:05.820 --> 00:09:06.160	9.
7.srt	00:09:06.670 --> 00:09:13.500	This is what it is shown with the mod values how we will be storing it only in the 7 location.
7.srt	00:09:13.879 --> 00:09:16.200	So, why we need the circular addressing?
7.srt	00:09:16.610 --> 00:09:26.870	All of us know that we are working for the real time signal which is coming continuously if I start storing in the memory it is going to overflow.
7.srt	00:09:27.129 --> 00:09:29.810	So, I will not have any memory to store the thing.
7.srt	00:09:30.120 --> 00:09:35.740	So, how much I need it will consider it when I take up the filters class basically.
7.srt	00:09:35.740 --> 00:09:41.780	So, in this case we have taken only 8 values are sufficient for us.
7.srt	00:09:42.450 --> 00:09:47.330	Then once the next sample comes eighth one.
7.srt	00:09:47.330 --> 00:09:56.690	So, we will be discarding thus the first whichever is the last sample and then we will be overwriting on it.
7.srt	00:09:56.690 --> 00:10:00.659	So, that way we will be saving my memory in overflowing.
7.srt	00:10:00.909 --> 00:10:12.759	So, coming to the next is why do we need bit reversal addressing just now I said the thing how we are going to do that or how it is going to be represented.
7.srt	00:10:12.940 --> 00:10:19.430	So, if it we know that this is the input index what I wanted, but output I want it in this order.
7.srt	00:10:20.130 --> 00:10:31.830	So, as we know that if we do it in software it will take multiple clock cycles instead of that can we do this bit reversal in the hardware.
7.srt	00:10:32.280 --> 00:10:34.460	So, as you can see in the right hand side.
7.srt	00:10:34.790 --> 00:10:44.500	So, from 0 the length of the number of samples what I want capital N is equal to here also 8.
7.srt	00:10:45.110 --> 00:10:48.259	So, we take it as 8 by 2 which is 4.
7.srt	00:10:48.750 --> 00:10:54.050	So, number 4 in binary is 100.
7.srt	00:10:54.550 --> 00:10:58.170	So, we add 100 to 000.
7.srt	00:10:58.779 --> 00:11:05.000	So, you will be seeing there is no difference in this addition to whatever we consider example for fixed point addition.
7.srt	00:11:05.000 --> 00:11:13.600	So, we get next number is 0 4 as you can see this is the 4.
7.srt	00:11:14.159 --> 00:11:18.610	Now, next I have to add the same this 100 to this number.
7.srt	00:11:19.060 --> 00:11:28.400	How I am going to add instead of adding from right to left for generating this bit reversal this adder is going to do left to right.
7.srt	00:11:28.590 --> 00:11:35.490	So, when I add 1 plus 1 I will get 0 and I will have a carry here which will be taken to the next stage.
7.srt	00:11:35.710 --> 00:11:37.840	So, it becomes 0 1 0.
7.srt	00:11:38.110 --> 00:11:42.640	So, which is nothing but 2 that is what it is listed in the table here.
7.srt	00:11:43.010 --> 00:11:44.400	So, how we get the next one?
7.srt	00:11:44.760 --> 00:11:46.400	So, I add 1 0 0.
7.srt	00:11:46.400 --> 00:11:47.470	So, this is a normal.
7.srt	00:11:47.470 --> 00:11:49.510	So, it will be 1 1 0 which is 6.
7.srt	00:11:49.800 --> 00:11:51.350	So, like this we continue.
7.srt	00:11:51.660 --> 00:12:03.400	and then these are the numbers what it has to be input to my FFT algorithm to show that why we need the bit reversal it is shown in this figure.
7.srt	00:12:03.740 --> 00:12:14.920	So, what we have is x of 0 is the input and x of 4, x of 2, x of 6, x of 1, x of 5 and then x of 3 and then x of 7.
7.srt	00:12:15.500 --> 00:12:18.810	So, the output is going to be in order.
7.srt	00:12:19.180 --> 00:12:21.550	So, always input is in the bit reversed.
7.srt	00:12:21.840 --> 00:12:23.170	output will be in order.
7.srt	00:12:23.510 --> 00:12:30.150	So, if I give input in order output is going to be in bit reversed order what I will be getting it.
7.srt	00:12:30.600 --> 00:12:38.060	So, this is what the thing the detail of butterfly structure what we call it for 8 point FFT.
7.srt	00:12:38.220 --> 00:12:48.800	So, which has 3 stages the detail of the design and then how we are going to implement it in real time we will discuss when I take up FFT lecture.
7.srt	00:12:48.800 --> 00:12:56.370	So, coming to the thing next is what we have to worry about the speed issues.
7.srt	00:12:57.030 --> 00:13:03.020	So, in this case what we call it is why I need the speed part of it.
7.srt	00:13:03.430 --> 00:13:19.010	I know that TP is my processing type for the any processor and then I have to allow for some I O operations we know that we have to get input and then even the output has to go out.
7.srt	00:13:19.290 --> 00:13:21.550	So, which we call it as T O is the time.
7.srt	00:13:21.890 --> 00:13:28.240	So, this should be less than or equal to the sampling time of.
7.srt	00:13:28.550 --> 00:13:32.310	what we will call it as T s of the processor.
7.srt	00:13:32.680 --> 00:13:55.120	So, when we talk about in terms of frequency I can call it as 1 by f p plus 1 by f naught should be less than or equal to 1 by f s. So, the this is going to decide my what should be my input clock rate what I can feed it into my processor or how I am going to select the processor.
7.srt	00:13:55.120 --> 00:13:59.930	If you are designing your own processor this has to be considered depending on the application.
7.srt	00:14:01.410 --> 00:14:05.580	Here we are considering only the algorithm in this case that is processing time of one of the algorithm.
7.srt	00:14:05.910 --> 00:14:13.600	If it has multiple thing you have to take the longest one which is going to take depending on it what your clock frequency has to be designed.
7.srt	00:14:14.180 --> 00:14:20.500	So, if this is not going to be met then can I use pipelining and then parallelism.
7.srt	00:14:21.020 --> 00:14:31.640	So, that is we will be seeing in this case high speed instruction operations also one is in the data what we will be considering it as pipelining and parallelism.
7.srt	00:14:31.900 --> 00:14:33.380	How about in the instruction?
7.srt	00:14:33.610 --> 00:14:36.540	So, I can have a high speed instruction operations.
7.srt	00:14:36.970 --> 00:14:46.210	as in the 6x processors we have 32 bit 8 instructions I can fetch it simultaneously.
7.srt	00:14:46.430 --> 00:14:53.690	So, this is one of the speed at which I can get instruction in the DSP processor.
7.srt	00:14:54.140 --> 00:14:56.370	So, coming to hardware architecture.
7.srt	00:14:56.770 --> 00:15:05.590	So, we said that we have a design dedicated hardware supports multiplication scaling loops and then repeats.
7.srt	00:15:06.220 --> 00:15:09.020	Something here I want to tell that.
7.srt	00:15:09.210 --> 00:15:13.730	what is how we are going to avoid the loop why we need the repeats.
7.srt	00:15:14.130 --> 00:15:18.810	Most of the cases instead of loops we want to have the repeats.
7.srt	00:15:19.100 --> 00:15:25.390	What we call it as in the DSP processor as 0 overhead loop.
7.srt	00:15:25.390 --> 00:15:26.180	So, what is this?
7.srt	00:15:26.800 --> 00:15:35.260	If I define my variable with hash assign or anything which we will discuss in the lab thing how it has to be done.
7.srt	00:15:35.430 --> 00:15:41.190	If I declare that some value I know that what is the loop is going to run actually.
7.srt	00:15:41.460 --> 00:15:43.020	So, if I call it as 40.
7.srt	00:15:43.430 --> 00:15:47.220	And, then I will be repeating the instruction 40 times.
7.srt	00:15:47.420 --> 00:15:57.720	So, I need not have to spend that whether decrement everything is going to happen in the background and then I need not have to spend any time on the loop to come back.
7.srt	00:15:58.230 --> 00:16:01.120	So, for loop can be avoided this way.
7.srt	00:16:01.590 --> 00:16:06.290	So, the other ones we said we have use using the special addressing modes.
7.srt	00:16:06.650 --> 00:16:09.680	So, for these fast DSP applications.
7.srt	00:16:10.000 --> 00:16:21.630	The other architecture in the last class we said that we are going to use the Harvard architecture which is going to improve our execution time compared to Von Neumann architecture and even on chip memories.
7.srt	00:16:22.000 --> 00:16:24.640	aid speed of program execution considerably.
7.srt	00:16:24.910 --> 00:16:35.640	So, that is the reason why I was telling in the last class that why my intermediate result has to be in the register or stored in the accumulator.
7.srt	00:16:36.000 --> 00:16:50.420	So, that will not be spending because of your memory structure access in the external memory is going to cost me your number of clock cycles which I want to avoid so that I can increase my speed of operation.
7.srt	00:16:50.850 --> 00:16:53.780	This is how we will be designing our architecture.
7.srt	00:16:54.140 --> 00:16:56.620	Now if this is not possible.
7.srt	00:16:57.280 --> 00:16:59.970	Can we have the parallelism built into this?
7.srt	00:17:00.560 --> 00:17:05.019	That is, is there any data dependency in my algorithm I am going to check?
7.srt	00:17:05.440 --> 00:17:11.450	If there are no dependencies, then I can have multiple function units.
7.srt	00:17:11.830 --> 00:17:15.800	So, which may operate in parallel to increase my throughput.
7.srt	00:17:16.370 --> 00:17:26.519	So, then I need multiple memories and we need different ALUs for these operations and even the data and addressing computations have to be done.
7.srt	00:17:27.980 --> 00:17:29.400	differently for these ones.
7.srt	00:17:29.740 --> 00:17:49.660	As an example whatever DSK board we have using in this course DSK6713 has two parallel sites that is we call it as A and B which have four functional units on both the sides that means to say two CPUs are going to run in parallel.
7.srt	00:17:50.190 --> 00:17:56.580	So, the advantage of using this parallelism is algorithms can perform more than one operation at a time.
7.srt	00:17:57.110 --> 00:17:59.540	that how we can increase the speed.
7.srt	00:18:00.050 --> 00:18:11.390	The disadvantage of this is we need a complex hardware required to control units because which side you are working and then how we are going to transfer the data from one side to the other.
7.srt	00:18:12.220 --> 00:18:28.280	And some of the issues like you will be branching or call and then pop operations most of these DSP process does not have call and then return because we do not know where which side of the processor they will be working.
7.srt	00:18:28.790 --> 00:18:36.490	will be controlling through the branch operations those who are interested can go into hex coding and other things.
7.srt	00:18:36.770 --> 00:18:41.830	If time permits I will be presenting one of the example in the lab.
7.srt	00:18:42.100 --> 00:18:48.100	So, how we can decide what is the thing happening in both the sides of the CPU.
7.srt	00:18:48.130 --> 00:18:59.630	Otherwise most of the examples will be in C code and then how we will be extracting the parallelism is going to depend on how we will be configuring our compiler.
7.srt	00:19:00.200 --> 00:19:10.290	Next, is disadvantage of this is as we are mentioning it and then we have to make sure that instructions data can be fetched simultaneously.
7.srt	00:19:10.510 --> 00:19:12.650	Otherwise, one of them is going to slow down.
7.srt	00:19:12.920 --> 00:19:21.980	So, we will landing in the that whatever we are thinking that we will be getting twice that of that 1 clock cycle.
7.srt	00:19:22.320 --> 00:19:23.540	So, we may not achieve.
7.srt	00:19:23.840 --> 00:19:26.020	So, one of them delays the thing.
7.srt	00:19:27.390 --> 00:19:28.560	Coming to pipelining.
7.srt	00:19:30.040 --> 00:19:35.620	So, All of us know that a water pipe is an example I can take it.
7.srt	00:19:35.660 --> 00:19:41.260	We know that when the water flows when you are installed your pipe for the water line.
7.srt	00:19:41.550 --> 00:19:41.940	So, it is empty.
7.srt	00:19:41.940 --> 00:19:48.920	Once you open the tap it takes some time for you to get the water in your tap.
7.srt	00:19:48.920 --> 00:19:57.070	That is the delay what it is going to be or one more example is going to be car assembly what you can take it.
7.srt	00:19:57.500 --> 00:20:00.180	It is units are working at different parts of a car.
7.srt	00:20:02.340 --> 00:20:06.660	And once everything is done so finally, it will come for the assembly.
7.srt	00:20:06.990 --> 00:20:14.050	So, that is what it says separate unit performs each stage at the same time usually working on different stage of data.
7.srt	00:20:14.580 --> 00:20:24.560	So, advantage of this pipelining is the repetition of instruction after initial setup will produce output every clock cycle.
7.srt	00:20:24.950 --> 00:20:27.040	This one we call it as latency.
7.srt	00:20:27.370 --> 00:20:34.670	So, the first output will depend on how many clock cycles it takes to complete it after that we will be getting it.
7.srt	00:20:35.220 --> 00:20:37.170	output every clock cycle.
7.srt	00:20:37.690 --> 00:21:04.800	The disadvantage part of it is pipeline latency first one is that because we have to wait for first car assembly or first water to get it in the tap, the pipe has to be filled in this whereas, in the car assembly the complete unit has to finish it then it has to come out that is the longest delay what we have to wait what we will call it just like in multiplier we said that what was the longest path delay.
7.srt	00:21:05.580 --> 00:21:14.550	And then in the break instruction up into equally timed units if it is so then we will be arriving at the same time.
7.srt	00:21:15.310 --> 00:21:24.690	As I was just now mentioning collar branching may cause delays if because depends on what is the length of pipe what we have taken it.
7.srt	00:21:25.110 --> 00:21:38.160	So, I want to clean it up then even the water pipe I have to completely empty the pipe and then start different water if it is become dirty or whatever may be.
7.srt	00:21:38.500 --> 00:21:50.130	Even in the car assembly I have done one car design and then it is process is going on if there is one car which fails or something like that then everything has to be stopped.
7.srt	00:21:50.440 --> 00:21:53.980	and then restart the car building.
7.srt	00:21:54.340 --> 00:21:58.920	So, these are the delays disadvantage one has to take into account.
7.srt	00:21:59.250 --> 00:22:05.490	So, depending on this how many stages of pipeline what we can provide what will be looked at.
7.srt	00:22:05.790 --> 00:22:12.270	So, with discussion and everything all DSP process most of them use 5 stage pipeline.
7.srt	00:22:12.960 --> 00:22:20.610	So, the first stage is going to be instruction fetch we represent it as INSTR.
7.srt	00:22:21.080 --> 00:22:27.210	So, what happened at T0 time slot the first instruction is fetched in the stage 1.
7.srt	00:22:27.670 --> 00:22:38.590	result is out actually, but if it is going to take more clock cycle then our result may be little bit delayed ok.
7.srt	00:22:38.850 --> 00:22:45.420	So, just we will see how we can implement this parallelism and pipelining using an example.
7.srt	00:22:45.790 --> 00:22:58.270	So, although I have not discussed my FIR filter still I am taking this is an example ATAP FIR filter or you can assume it as it is a convolution summation what we will be doing it.
7.srt	00:22:58.820 --> 00:23:27.360	So, y of n is given by the equation k is equal to 0 to 7 h of k into x of n minus k. I was telling in the previous class why I am going to consider x of n minus k instead of h of k. One of the example I gave it as my memory basically what I will be using for h of k is the program memory which is going to be stored much earlier in the memory.
7.srt	00:23:27.760 --> 00:23:32.400	So, whereas, x of n minus k because I want to implement the circular buffer.
7.srt	00:23:32.710 --> 00:23:40.140	So, this gives me that whatever the latest after k whatever sample comes I can be rewriting in the same memory location.
7.srt	00:23:40.140 --> 00:23:50.160	So, that is how we use this equation to implement our convolution output or we call that also FIR filter.
7.srt	00:23:50.450 --> 00:23:55.470	So, you will be seeing that normal notation what your people will be using it h of k into 0.
7.srt	00:23:55.870 --> 00:24:05.190	convolved with x of n minus k. So, when I expand this, this is the equation and further the summation is going to be expanded.
7.srt	00:24:05.400 --> 00:24:16.250	So, then you will be seeing the sum y of n is given by your h of 0 into x of n and then h of 1 into x of n minus 1 and so on h of 7 into x of n minus 7.
7.srt	00:24:16.650 --> 00:24:25.010	So, this can be completed sorry implemented in many ways depending on number of multipliers and accumulators available.
7.srt	00:24:25.470 --> 00:24:27.990	So, we will see what is the thing is going to happen.
7.srt	00:24:28.450 --> 00:24:33.040	So, that is input needed in registers as we know.
7.srt	00:24:33.300 --> 00:24:47.720	This should be x of n to x of n minus 7 is continuously available for us and then when we are going to get the output that is we call it as time to produce y of n, time to process the input block.
7.srt	00:24:47.960 --> 00:24:54.810	So, we say that this is my input and y of n is given by this equation.
7.srt	00:24:55.200 --> 00:25:02.910	So, the new input x of n plus 1 can be processed after y of n is produced.
7.srt	00:25:03.220 --> 00:25:05.230	That is y of n plus 1 will be.
7.srt	00:25:05.520 --> 00:25:09.630	with respect to x of n plus 1 input what it is coming.
7.srt	00:25:10.210 --> 00:25:33.410	So, how is this shown in this as I mentioned in the one of the slide that it takes T b here it is shown with capital T there I showed it as small t. Time units to process your register block then for a continuous input stream the throughput is 1 output sample per T b time units.
7.srt	00:25:33.940 --> 00:25:36.430	So, a new input time is placed.
7.srt	00:25:36.610 --> 00:25:40.160	into the register block every tb time units.
7.srt	00:25:40.880 --> 00:25:47.700	A shift in the register block every tb time units is needed to accommodate a new input sample.
7.srt	00:25:48.140 --> 00:25:51.970	This is the theory how it is going to be done is shown in this block diagram.
7.srt	00:25:52.290 --> 00:25:53.580	So, time is 0.
7.srt	00:25:53.840 --> 00:25:59.010	So, I have all the inputs x of n to x of n minus 7 in the register.
7.srt	00:25:59.360 --> 00:26:07.180	When next clock cycle tb that is the delay of my computation time basically our this block takes tb unit.
7.srt	00:26:07.620 --> 00:26:09.380	then I will be getting the new sample.
7.srt	00:26:09.760 --> 00:26:19.700	So, x of n plus 1 to x of n minus 6 here in this case x of n minus 7 is the last data which is going to be thrown out.
7.srt	00:26:20.430 --> 00:26:29.450	So, in the second clock cycle we will be seeing that you will be throwing out even x of n minus 6 so on whenever new data comes into your buffer.
7.srt	00:26:30.820 --> 00:26:38.670	So, the thing is we said that sampling period we have assumed is T s which should be greater than my T b.
7.srt	00:26:39.060 --> 00:26:55.690	Then, what happens because my sampling frequency is much higher than my computation time, then whatever data sample comes basically I need to store them because input is coming at a much faster rate.
7.srt	00:26:56.100 --> 00:26:59.800	So, which I have to store it so that I would not miss any of the sample.
7.srt	00:27:00.380 --> 00:27:11.960	At the same time if my sampling period is less than the computation time, then what is going to happen processor may become idle because I have finished my computation I have to wait for my data to come in.
7.srt	00:27:12.230 --> 00:27:14.530	So, my processor is idling at that time.
7.srt	00:27:15.110 --> 00:27:24.950	So, how we can reduce this TB with appropriate parallelism and then pipelining what we will see in the next few slides.
7.srt	00:27:25.340 --> 00:27:37.400	So, first one what is it if I am using only single multiplier and accumulator then what is the thing I am going to how I am going to do this filtering basically.
7.srt	00:27:37.720 --> 00:27:47.970	So, I have x of n here n minus 1 usually we will be assigning it as 0 all of them initially and this is a 80 clock.
7.srt	00:27:48.170 --> 00:27:54.000	sample delay because I have seen that it is going to take 8 clock cycle for the new data to come in.
7.srt	00:27:54.330 --> 00:28:07.030	So, which are fed through the multiplexer and then this is my MAC unit because I have a single MAC I have to do all these 8 operations and then how I am going to feed in my coefficients basically.
7.srt	00:28:07.410 --> 00:28:22.450	H 0 to H 7 is through other multiplexer which is appropriately fed whenever this data is going to be there I will be doing the multiplication accumulation in a single block in this case what is the example we have considered.
7.srt	00:28:22.920 --> 00:28:42.180	And then once a complete thing is done after t what we say this 8 clock cycles my y of n is a valid output although it is coming every clock cycle, but we say at the 8 clock cycle I will be getting the correct output and from there onwards every clock cycle I will get the output.
7.srt	00:28:42.610 --> 00:28:53.570	So, here you can say t is the time taken to compute one product term and add it to accumulator and then new input sample can be processed over 80 time units.
7.srt	00:28:53.820 --> 00:28:56.520	So, our block computation time is 80.
7.srt	00:28:56.930 --> 00:28:58.060	80 in this.
7.srt	00:28:58.240 --> 00:29:04.560	So, I can take the new sample after 80 time units.
7.srt	00:29:05.010 --> 00:29:12.130	So, continuing with the thing at time t is equal to 0, we will be doing the initialization and accumulator is also made 0.
7.srt	00:29:12.540 --> 00:29:17.650	So, this is how the previous slide itself what it shows in this case.
7.srt	00:29:18.050 --> 00:29:24.990	So, in the next clock cycle what happens at t is equal to capital T, the accumulator which was initially 0.
7.srt	00:29:25.400 --> 00:29:26.760	Now, the first sample.
7.srt	00:29:27.100 --> 00:29:38.759	H of 0 is taken from here this multiplexer and then your X of n is taken the first sample from this side from through this multiplexer to your MAC.
7.srt	00:29:38.759 --> 00:29:45.140	So, they get multiplied here and then added with the previous value in the accumulator.
7.srt	00:29:45.190 --> 00:29:46.280	So, what happens at 2 t?
7.srt	00:29:46.600 --> 00:29:52.490	So, you will be seeing that whatever data here X of n gets moved to here fine.
7.srt	00:29:52.490 --> 00:29:58.440	So, this X of n minus 1 in the next clock cycle becomes.
7.srt	00:30:00.820 --> 00:30:03.900	and then you have to multiply with your h of 1.
7.srt	00:30:04.220 --> 00:30:09.320	So, that is how the samples have been chosen by these multiplexer which are fed to MAC unit.
7.srt	00:30:09.370 --> 00:30:12.450	So, then you will be getting the output.
7.srt	00:30:12.450 --> 00:30:17.000	So, this is the second clock cycle h of 0 into x of n in the previous one.
7.srt	00:30:17.310 --> 00:30:20.580	Now, h of 1 into x of n minus 1 is going to happen.
7.srt	00:30:21.100 --> 00:30:23.320	So, what happens in the next clock cycle?
7.srt	00:30:23.610 --> 00:30:31.970	So, we are skipping few of them we can put it as dot dot dot that is how we will be going with the thing t is equal to 3 t to.
7.srt	00:30:32.760 --> 00:30:37.420	at the last 80 what is the thing is going to happen what it is shown here.
7.srt	00:30:37.750 --> 00:31:00.060	So, the last sample your x of n minus 1 and then h of 7 is going to be taken into account from the multiplexer which is getting multiplied and all the previous samples you will be seeing it which has come will be added with multiplied value as you are seeing in the accumulator.
7.srt	00:31:00.060 --> 00:31:02.830	So, that is what we said was.
7.srt	00:31:03.300 --> 00:31:07.830	To do 8 bit of multiplication it takes 8 clock cycles.
7.srt	00:31:08.160 --> 00:31:12.540	Can I improve upon it by doing the parallel implementation?
7.srt	00:31:12.910 --> 00:31:14.110	So, how I can do it?
7.srt	00:31:14.190 --> 00:31:18.440	I will show in this case 2 MAC units I am going to provide.
7.srt	00:31:18.930 --> 00:31:22.720	Then I will be having as you are seeing the hardware is increasing here.
7.srt	00:31:23.100 --> 00:31:26.590	There are 4 multiplexer and 2 MAC units.
7.srt	00:31:27.050 --> 00:31:33.440	And you will be seeing that because they are working in parallel they do not have any dependency basically.
7.srt	00:31:33.620 --> 00:31:45.230	Whatever data they have stored it they will be working on it and then you will be seeing that 4 of them are connected to one of the MAC unit and 4 samples are connected to the other MAC unit.
7.srt	00:31:45.620 --> 00:31:54.430	So, they can work in parallel and then we have to last sample what we have to do is we have to add them from both the cases.
7.srt	00:31:54.770 --> 00:32:00.300	Then only I will be getting Y of n. Approximately we say that Tb is equal to 4T.
7.srt	00:32:00.490 --> 00:32:14.610	So, although this one addition we have not accounted for there will be we assume it as delta T 4T plus delta T which is ignorable that is what we said, but for large cases it may have to be considered.
7.srt	00:32:15.070 --> 00:32:21.710	So, we say that my computation is twice that of with single MAC.
7.srt	00:32:22.770 --> 00:32:40.700	So, you will be also multiple cores in your CPU you will be seeing it what you want is 8 core or 7 core what you will be telling I want to have 7 times what I have to get it why you would not get that result you can see from this visually saying that I would not be getting it twice what I wanted.
7.srt	00:32:41.130 --> 00:32:45.480	So, we will see that instead of 2 MAC units I will use.
7.srt	00:32:45.840 --> 00:32:49.400	For each multiplication I know what should be my filter length.
7.srt	00:32:49.790 --> 00:33:09.200	Most of you know that in FPGAs multiple DSP blocks are there and even GPUs for that matter you have multiple multiplication and then add units are there in the GPUs that is how you will be getting your speed up using GPUs compared to your CPUs.
7.srt	00:33:09.380 --> 00:33:12.680	So, here I have used 8 Macs in this case.
7.srt	00:33:12.980 --> 00:33:16.150	So, 0 will be for the first adder.
7.srt	00:33:16.360 --> 00:33:22.400	it is going to be pushed in and then rest of the thing can be fed from the previous stages ok.
7.srt	00:33:22.750 --> 00:33:40.160	So, there will be as we worked out in the previous class accumulator it will be taking n plus 1 clock cycle from this you will be seeing it for this the previous one what you will be getting it in the next clock cycle you can add it and then send it out.
7.srt	00:33:40.590 --> 00:33:46.140	So, you will be having every t units I can get the input clock in this case.
7.srt	00:33:46.480 --> 00:33:48.610	So, all of them are working in parallel.
7.srt	00:33:49.069 --> 00:33:55.019	And then we will be adding them up and then y of n will be my output.
7.srt	00:33:55.069 --> 00:33:59.219	So, we say 8 multipliers and 8 accumulators what we have used it.
7.srt	00:33:59.919 --> 00:34:04.459	T is equal to time taken to compute one product term and then add it to accumulator.
7.srt	00:34:04.809 --> 00:34:08.699	And new input sample can be processed every T time units.
7.srt	00:34:09.079 --> 00:34:11.579	We call it as 8 times faster.
7.srt	00:34:11.579 --> 00:34:17.229	That is why you will be seeing a exclamatory mark whether I am going to achieve this or not.
7.srt	00:34:17.769 --> 00:34:18.649	As I have mentioned.
7.srt	00:34:19.190 --> 00:34:21.080	will be overheads and other things.
7.srt	00:34:21.080 --> 00:34:25.370	So, we may not get so much speed in this case.
7.srt	00:34:25.630 --> 00:34:31.290	So, one has to bear with whatever we are going to get the thing with additional overheads.
7.srt	00:34:31.720 --> 00:34:38.310	Happy learning and then thank you for listening to this lecture.
55.srt	00:00:01.219 --> 00:00:24.699	Welcome back to real time digital signal processing lab actually.
55.srt	00:00:24.750 --> 00:00:29.260	So, today we will see on code composer studio.
55.srt	00:00:30.870 --> 00:00:38.000	and on the board how we are going to run some of the examples what we have looked in MATLAB.
55.srt	00:00:38.560 --> 00:00:43.049	So, the first one I will display is echo generation.
55.srt	00:00:43.509 --> 00:00:46.980	Here it can be either I can take voice or mic input.
55.srt	00:00:47.159 --> 00:00:50.549	So, we will see how to do the mic input.
55.srt	00:00:51.000 --> 00:00:58.039	Later on if we have time we will give the even the line input what we call it.
55.srt	00:00:58.109 --> 00:01:01.140	So, whatever the speech I am going to talk about it.
55.srt	00:01:01.140 --> 00:01:04.379	So, you will be hearing it multiple times.
55.srt	00:01:05.750 --> 00:01:08.430	So, that is what our echo generation is.
55.srt	00:01:08.689 --> 00:01:15.939	So, here the buffer size chosen is 4000 and gain for the thing is given 0.8.
55.srt	00:01:15.939 --> 00:01:20.469	So, we can vary the gain so that the intensity is going to be reduced.
55.srt	00:01:20.469 --> 00:01:35.730	So, we will be taking the input sample from the mykin and then we will be calling the codec both left and right channel what we will be putting it back.
55.srt	00:01:36.340 --> 00:01:38.049	So, how we are going to do the thing?
55.srt	00:01:38.049 --> 00:01:45.790	So, we will be having the input and then output getting delayed with respect to gain whatever has been given.
55.srt	00:01:46.350 --> 00:01:54.500	So, we can buffer length also you can change and then see the repetition how it can be reduced or it can be increased.
55.srt	00:01:55.859 --> 00:02:04.740	So, this is after that you will be incrementing your eye sample and then you will be outputting it in the codec.
55.srt	00:02:05.280 --> 00:02:08.740	So, you will be initializing from the main function here.
55.srt	00:02:09.310 --> 00:02:13.039	that is mic input what we will be taking it and then running it.
55.srt	00:02:13.039 --> 00:02:15.949	So, we will see that how the demo is going to run.
55.srt	00:02:17.979 --> 00:02:24.120	We will because it is recompiled as I have been mentioning in the previous classes.
55.srt	00:02:24.490 --> 00:02:26.590	So, if it is done it will be much faster.
55.srt	00:02:26.650 --> 00:02:28.169	So, we will run the thing.
55.srt	00:02:34.159 --> 00:02:34.949	Hello.
55.srt	00:02:35.219 --> 00:02:35.349	Hello.
55.srt	00:02:35.659 --> 00:02:38.879	Welcome back to real time digital signal processing course.
55.srt	00:02:50.960 --> 00:03:00.400	So, you can observe how long it is taking for the echo to come back also.
55.srt	00:03:07.330 --> 00:03:14.590	So, you will be observing that even if I stop running the debugger mode, still the code is running in the board.
55.srt	00:03:19.650 --> 00:03:20.900	So, I will reset it.
55.srt	00:03:21.180 --> 00:03:25.080	So, you have observed that this is from the mykin.
55.srt	00:03:25.379 --> 00:03:45.280	So, if we change the delay of it that is buffer size we can make it as 2000 and then our gain will try to reduce it to 0.4 or so and then we will save them and then we will recompile and see how it is going to behave.
55.srt	00:03:45.280 --> 00:03:59.069	We will observe it once again.
55.srt	00:03:59.759 --> 00:04:00.810	by running it.
55.srt	00:04:01.969 --> 00:04:08.349	Hello, welcome back to real time digital signal processing course.
55.srt	00:04:09.919 --> 00:04:15.610	So, you can see that how the echo has got reduced.
55.srt	00:04:15.610 --> 00:04:31.680	Earlier it was multiple once what it was coming because we had a low intensity of the signal that is we said 0.8 and then now it is 0.4 and then only 2000 of the samples what we are repeating it.
55.srt	00:04:33.110 --> 00:04:39.279	So, this you can go and then play around whatever way you want to do it.
55.srt	00:04:39.689 --> 00:04:51.529	So, if you want to run using the line input, then I had to give the sample from there, I had to comment on this.
55.srt	00:04:51.529 --> 00:05:03.670	So, we will see running this code, I had to because I forgot to save the thing it is asking me whether to save it to this.
55.srt	00:05:03.949 --> 00:05:08.860	So, I can give ok, then it will start compiling and then debugging the thing.
55.srt	00:05:09.259 --> 00:05:22.069	So, in the meantime we will try to select one of the, we will select a clean voice here, either it can be 16 kilohertz or clean voice, I will 8 kilohertz.
55.srt	00:05:22.069 --> 00:05:31.060	So, I will choose this as the voice which I want to run it and then we will see how we are going to get the echo from this.
55.srt	00:05:32.500 --> 00:05:44.509	So, the input signal is coming in, as you can see here.
55.srt	00:05:46.089 --> 00:05:49.899	there is a mistake in the code that is the reason why you are not getting the output.
55.srt	00:05:50.189 --> 00:05:59.039	So, what it is selected is line input has to run at 48 kilohertz, but the speed signal what I have is at 8 kilohertz.
55.srt	00:05:59.339 --> 00:06:11.199	So, we will change the input sampling rate that is ADC codec what we are going to select the thing to 8 kilohertz and then we will see whether it is going to run again.
55.srt	00:06:16.779 --> 00:06:18.279	So, I have to over rebuild the code.
55.srt	00:06:28.849 --> 00:06:42.909	This is how you can interchange between the line input and then.
55.srt	00:06:46.939 --> 00:06:47.860	mic input.
55.srt	00:06:47.860 --> 00:06:55.310	So, if you want to see your own voice how it is echoing for playing or whatever may be the thing you can give it through the mic input.
55.srt	00:06:56.050 --> 00:07:05.019	And then a line input see that your sampling rate is properly chosen because all speech voices in this case 8000.
55.srt	00:07:05.019 --> 00:07:16.000	So, if you are selecting any of the music which is sampled at 48 kilohertz or 44.1 kilohertz you can select that and then give it as an input.
55.srt	00:07:19.160 --> 00:07:22.069	So, this is one of the thing we demonstrated in the MATLAB.
55.srt	00:07:22.069 --> 00:07:25.519	So, you have seen in the board also how it is running.
55.srt	00:07:25.879 --> 00:07:43.470	So, we will see the scrambler here, but in the I will be closing this and then we will see the scrambler that is dot c in this case.
55.srt	00:07:43.470 --> 00:07:53.970	So, what it has is it is going to include the sign 160 dot h.
55.srt	00:07:54.759 --> 00:08:06.569	And, you have the filter coefficient which is 64 order, we will look at the thing and what we have is basically all are interrupt driven here.
55.srt	00:08:06.569 --> 00:08:17.720	So, the x of 1 will be getting the input from whatever you are playing 1 that is 160 hertz sine basically sample.
55.srt	00:08:17.720 --> 00:08:23.670	And, then you will be combining with your that is.
55.srt	00:08:26.439 --> 00:08:32.419	input, whatever input speed signal I am going to give it.
55.srt	00:08:32.819 --> 00:08:49.700	So, either it can be from the mic or same thing what we can select here I have chosen at present mic I can include with it or I can give it as a line input also both we will see the thing here how it is going to happen and then what is the thing is going to happen.
55.srt	00:08:49.970 --> 00:08:57.799	So, y 1 in this case is sin 160 sample that means to say that.
55.srt	00:08:58.139 --> 00:09:06.639	Whatever the input samples are coming, you are mixing with the sine function that is you are adding it basically.
55.srt	00:09:06.979 --> 00:09:10.559	Then how you are going to do the thing?
55.srt	00:09:11.259 --> 00:09:17.919	So, your X2 sample is generated with this Y1 that is get new input into delay line basically.
55.srt	00:09:17.919 --> 00:09:27.829	Then this one you would be filtering it that is Yn2 plus will be your HFI.
55.srt	00:09:28.269 --> 00:09:35.259	So, the order of the filter what you have chosen and then multiplied by your input signal X2 of Y.
55.srt	00:09:35.990 --> 00:09:41.169	So, then what is the thing this again X2 of Y because we have to move it.
55.srt	00:09:41.169 --> 00:09:42.679	So, we will be delaying it.
55.srt	00:09:42.679 --> 00:09:51.370	Here one FIR filter is happening the other place here it is FIR filter what we are doing the thing with both the signals.
55.srt	00:09:51.879 --> 00:09:56.559	That means, to say that after mixing it.
55.srt	00:09:58.490 --> 00:10:07.559	So, we will be passing it through the filter even the input signal is restricted to or the length whatever low pass filter length.
55.srt	00:10:07.559 --> 00:10:15.600	So, that we are not passing more frequency in the thing after adding with it we are passing it through again filter.
55.srt	00:10:16.019 --> 00:10:22.000	So, that will be cutting off anything above 3 kilohertz in this case.
55.srt	00:10:22.470 --> 00:10:29.730	So, then we will be outputting Y n to our left sample in this case it is going through the DAC.
55.srt	00:10:30.379 --> 00:10:53.470	So, what you can do one of the thing is you can repeat this so that again you will be using this as an input scrambled signal is given to the other board if you want to use it or you can give this as an input and then run this algorithm again then you will be getting the unscrambled output.
55.srt	00:10:53.470 --> 00:10:56.529	So, we will see now scrambling how it is going to happen.
55.srt	00:10:56.559 --> 00:10:58.710	Next we will be putting it as a mic in.
55.srt	00:10:58.909 --> 00:11:02.490	So, I will be doing the.
55.srt	00:11:03.529 --> 00:11:06.470	debugging is going to happen.
55.srt	00:11:06.470 --> 00:11:08.920	So, it has to, it is already compiled.
55.srt	00:11:09.060 --> 00:11:12.509	So, we have to go and then load the code on to the board.
55.srt	00:11:12.509 --> 00:11:13.029	So, it is done.
55.srt	00:11:13.029 --> 00:11:18.620	So, we will see the output what is you are going to get out of it.
55.srt	00:11:22.889 --> 00:11:27.620	So, you are hearing one tone that is signed tone.
55.srt	00:11:27.990 --> 00:11:29.320	Hello, hello, hello.
55.srt	00:11:33.120 --> 00:11:39.449	Hello, hello, so you are, hello, it got mixed up.
55.srt	00:11:40.059 --> 00:11:47.480	To give a better feel of the thing, what I will do is, I will run the speech signal.
55.srt	00:11:47.669 --> 00:11:52.240	Anyway, it is, as you can see, it is running continuously here, my speech signal.
55.srt	00:11:52.669 --> 00:11:57.720	So, I will take this as input and then we will combine and then see how it is going to look like.
55.srt	00:11:58.269 --> 00:12:03.610	So, I will call this instead of mic, I will be giving it as line.
55.srt	00:12:09.149 --> 00:12:11.899	So, we will compile it.
55.srt	00:12:20.629 --> 00:12:21.990	We will run the code again.
55.srt	00:13:08.889 --> 00:13:11.730	So, your speech has scrambled so we are seen in the theory that scrambling is going to keep our original voice whatever we want to convey to the other the one who is interested in not to all the people so that at the receiving end so you know with what this thing sample you have done the scrambling so they do the de-scrambling with the same method they can get back the original signal.
55.srt	00:13:11.789 --> 00:13:26.120	So, I will leave this as a exercise for you to put the code here to run to get back your own voice or your speech signal.
55.srt	00:13:26.169 --> 00:13:35.289	So, if you want you can record using MATLAB your own speech and then give it as an input to this and then see how your speech get distorted.
55.srt	00:13:35.860 --> 00:13:38.509	So, that nobody can make out that who is speaking.
55.srt	00:13:38.509 --> 00:13:38.580	Okay.
55.srt	00:14:17.570 --> 00:14:24.110	then at the receiving end you can get back the thing so this is the other example what it was pending so the next one is what I will do is here it is YC or BR basically what we have it so we will see the source file this is sorry in the previous one I told you I will show you the filter coefficients so you will be seeing this is a sine wave the generation basically psi 160 which is generated from MATLAB and then you are keeping it as a dot H file The other one is your coefficients what you have generated using MATLAB again.
55.srt	00:14:24.630 --> 00:14:45.400	So, you will be seeing that automatically using a function you can use the DSKFIR 67.m in the MATLAB file and then it generates the coefficient order n is equal to 65 here as you can see that and this is the coefficients what it has been generated.
55.srt	00:14:45.400 --> 00:14:49.730	Either you can use the FDA toolbox or.
55.srt	00:14:50.610 --> 00:14:54.840	use this code to generate from the book basically.
55.srt	00:14:55.340 --> 00:15:00.520	So, now, we will see what is our YCR, BR.
55.srt	00:15:00.520 --> 00:15:03.930	So, we said in the image processing.
55.srt	00:15:04.340 --> 00:15:19.060	So, I can convert RGB into my chrominance Y and chrominance CR and then BR and then intensity as Y illumination basically what we are going to have the thing.
55.srt	00:15:20.650 --> 00:15:39.150	Here, what it is going to do is as you will see this is from the book code basically that is real time digital signal processing to show you that how the this is actually this book supports 5505 board basically.
55.srt	00:15:39.300 --> 00:15:53.200	So, the code how it can be why if it is written in C code how you can reuse in other boards also with little modification what I want to show the thing.
55.srt	00:15:53.649 --> 00:15:58.420	So, in the DCT part of it as we said it was assembly code which was lying there.
55.srt	00:15:58.800 --> 00:16:09.550	So, one has to modify because that was meant for this board and then to make it a 6x board you have to modify all the assembly instructions.
55.srt	00:16:10.000 --> 00:16:14.500	So, you are doing input files are binary formatted.
55.srt	00:16:15.029 --> 00:16:20.019	So, that is files and output file is a BMP file what it is generating.
55.srt	00:16:20.670 --> 00:16:26.500	So, only 8 bit data made mode is going to be supported in this.
55.srt	00:16:59.299 --> 00:17:00.559	then minimum processing unit is 2 pixels in the same row what it is going to do so it will be using some of the dot H file here also this is the you what you have is Y C B C R to RGB dot H what you have generated and then kept so you will be seeing that these are the include files so in the previous one we had put all the required files in now the same folder.
55.srt	00:17:00.830 --> 00:17:03.629	Here you will be seeing that multiple folders are there.
55.srt	00:17:03.629 --> 00:17:16.329	One is you will be keeping only the source files in this case and then the include files are coming in this and you will be having the data in different place what you will be storing it.
55.srt	00:17:16.799 --> 00:17:19.170	So, you will be seeing the butterfly structure.
55.srt	00:17:19.170 --> 00:17:28.809	If you want you can this is getting stored back actually you can rename them and then you will be getting the data in this.
55.srt	00:17:28.809 --> 00:17:32.630	So, whatever the reference butterfly you can.
55.srt	00:17:33.259 --> 00:17:36.210	take it and then compare with both of them.
55.srt	00:17:36.640 --> 00:17:41.480	So, you will be seeing that this is the dot h file.
55.srt	00:17:42.180 --> 00:17:43.529	So, what you have it.
55.srt	00:17:44.119 --> 00:17:47.089	So, input pointer to y element.
55.srt	00:17:47.549 --> 00:17:53.519	So, and then CBCR and then this will be pointing to RGB basically.
55.srt	00:17:54.009 --> 00:18:05.339	So, the width of the image what you will be defining it and then you will be creating the BMP header file with these are the parameters.
55.srt	00:18:05.700 --> 00:18:13.700	So, this is an initialized 16 bit and then header file what you will have it width and then height has been given.
55.srt	00:18:13.980 --> 00:18:17.960	So, you have when you store this image and then you read in the MATLAB.
55.srt	00:18:18.310 --> 00:18:28.550	So, you have to take care of these things to read them and then decifer the image and then you have to plot it there.
55.srt	00:18:28.590 --> 00:18:34.009	So, this is types basically what it has been defined.
55.srt	00:18:35.700 --> 00:18:39.039	So, So, if it is not defined it will be defining it.
55.srt	00:18:39.039 --> 00:18:48.730	So, some of them boolean and then what are the integer format and unsigned int what you are will be calling it character and other things.
55.srt	00:18:49.140 --> 00:19:04.090	So, long what it is defined with uninitialized int 32 bit and short will be usually uninitialized int 16 and you can have unsigned character is going to be 8 bit what the definition.
55.srt	00:19:04.410 --> 00:19:11.309	So, you will be seeing that long again will be int 32 and short will be int 16 and character ints.
55.srt	00:19:11.850 --> 00:19:16.299	So, you have to first define and then use them in your code.
55.srt	00:19:16.850 --> 00:19:28.279	So, coming to the code we will see the this thing what we have I will close the rest of it.
55.srt	00:19:28.769 --> 00:19:41.059	So, you will be now what is it your image width chosen is 160 image height is 120 and then you will be calculating some offset.
55.srt	00:19:41.440 --> 00:19:49.110	So, number of rows what you will be calculating is image height divided by 15 what you will have it.
55.srt	00:19:49.990 --> 00:19:58.309	And, then you will be defining some data hash pragma specifies where your variable data has to lie.
55.srt	00:19:58.309 --> 00:20:08.110	So, here you call it as data section and it is named as RGB and then you will be getting as image buffer 1 whatever we are reading it here.
55.srt	00:20:08.110 --> 00:20:18.009	And the other one definition is it is the alignment as it was told that 2 pixels what you will be doing it.
55.srt	00:20:18.370 --> 00:20:20.420	So, it is aligned for.
55.srt	00:20:21.070 --> 00:20:30.350	2 bytes basically and then you will be defining some of the thing and your main variables what it is declared here.
55.srt	00:20:30.350 --> 00:20:44.190	So, you will be opening the file actually that is data file you have got it that is butterfly 160 into 20 into 8 dot data for reading purpose.
55.srt	00:20:44.190 --> 00:20:48.140	So, this is the original as you reference butterfly what you have it.
55.srt	00:20:48.640 --> 00:20:52.240	So, you will be reading that butterfly the input.
55.srt	00:20:52.780 --> 00:20:57.960	And, then if it is unable to open you have the error reflecting.
55.srt	00:20:58.810 --> 00:21:10.280	So, then again you will be using this is your elimination what you have read the thing y component next you will be reading your CB and then CR for reading purpose.
55.srt	00:21:10.750 --> 00:21:16.130	Again you will be opening the file and then you will be reading the other data.
55.srt	00:21:16.190 --> 00:21:20.130	So, then you have to write it back.
55.srt	00:21:24.019 --> 00:21:35.700	So, for this again what is it CR, one is Y the other one is CB and CR.
55.srt	00:21:35.700 --> 00:21:52.700	These are the three data what you will be reading from your input file separately and then open writing file that is order written is that is what it says it is B6 and then B, B is 6.
55.srt	00:21:54.340 --> 00:21:56.340	what you will be writing it.
55.srt	00:21:56.760 --> 00:22:07.320	So, this is bgb dot rgb what sorry bgr dot rgb means the file which is going to be open for writing into the thing.
55.srt	00:22:08.130 --> 00:22:18.690	So, you will be specifying rest of the sizes in this case and allocating your memory, so that you can release it later.
55.srt	00:22:19.240 --> 00:22:24.250	So, dynamic allocation of memory what it is happening here.
55.srt	00:22:25.000 --> 00:22:32.800	And, then you will be doing the data one block at a time what you are going to take it.
55.srt	00:22:32.800 --> 00:22:34.140	So, you will do the conversion.
55.srt	00:22:34.580 --> 00:22:43.680	So, you are reading from the thing and then do the conversion and then for both your C B C R what you have to do the thing.
55.srt	00:22:43.680 --> 00:22:53.380	And later on you will go back and then write it into initially temporary file and then you will be.
55.srt	00:22:55.880 --> 00:22:56.770	writing it out.
55.srt	00:22:57.160 --> 00:23:03.250	So, then once everything is done so, you have to free all the memories so that it can be used.
55.srt	00:23:03.250 --> 00:23:06.090	So, you will be using or releasing them.
55.srt	00:23:06.810 --> 00:23:11.630	So, then if you want you are allocating a memory to your temporary buffer.
55.srt	00:23:11.680 --> 00:23:18.780	So, that is the image width into 3 because RGB what you want to have the thing.
55.srt	00:23:18.820 --> 00:23:24.810	So, this is the RGB file read you will be doing it.
55.srt	00:23:26.850 --> 00:23:38.070	And, then you will be creating the BMP file here, create BMP file and then write into the thing all temporary data whatever you have the thing.
55.srt	00:23:38.070 --> 00:23:41.670	So, you will be writing into your output file.
55.srt	00:23:42.560 --> 00:23:45.340	So, we will see how it is going to run.
55.srt	00:23:45.900 --> 00:23:50.810	So, you will be getting the printf statement continuously.
55.srt	00:23:56.470 --> 00:23:57.890	So, we will run the code.
55.srt	00:24:03.089 --> 00:24:08.660	So, it is doing YCBCR to RGB conversion and writing it into dot BMP.
55.srt	00:24:09.029 --> 00:24:12.599	So, it in between you can give the printf statement.
55.srt	00:24:12.599 --> 00:24:16.339	So, how you are proceeding otherwise it may take little longer time to see the thing.
55.srt	00:24:16.779 --> 00:24:22.269	So, 8 by 8 bit what it is getting operated on as you can see the thing.
55.srt	00:24:28.369 --> 00:24:33.630	Working on the row now it is working on the BMP that is writing is happening here.
55.srt	00:24:55.190 --> 00:24:58.409	So, now, it says that it is completed.
55.srt	00:24:58.950 --> 00:25:05.399	So, one thing as I have been mentioning the things since I have did not give breakpoint.
55.srt	00:25:06.160 --> 00:25:18.619	or so what happens is it is unable to find the last line that is what it says I cannot find a source file at whatever exit dot c it is unable to find the thing.
55.srt	00:25:18.619 --> 00:25:22.619	So, it gives an warning in the end.
55.srt	00:25:22.910 --> 00:25:26.640	So, but we have completed running the complete code.
55.srt	00:25:27.009 --> 00:25:29.990	So, we can if you want to see the thing.
55.srt	00:25:29.990 --> 00:25:31.839	So, we can go and then tools.
55.srt	00:25:32.170 --> 00:25:33.930	So, what we have sorry.
55.srt	00:25:36.059 --> 00:25:47.539	So, what is one second, if you have declared them as global variable, then you would be able to monitor the output basically.
55.srt	00:25:47.539 --> 00:25:54.849	So, here you will be seeing that it is declared as global, I can see RGB.
55.srt	00:25:54.849 --> 00:25:57.919	So, you can go to tools, either I can put the graph.
55.srt	00:26:06.949 --> 00:26:24.159	It will be a variable or I can view the memory basically, memory browser I can do it and then give my this thing, what is it the thing I will be giving it as RGB here, the variable.
55.srt	00:26:24.159 --> 00:26:30.599	It is declared as int 16.
55.srt	00:27:22.769 --> 00:27:27.430	So, the style because it is declared as int 16, 16 but signed in tile give it so you will be seeing that RGB is the star this is the place where your data will start and these are the values what you're storing it in RGB format okay this is how it is stored and the other one what we can look at is so if you want to see the offset what is it you can go and then see that also So, the rest of them are not declared global.
55.srt	00:27:27.900 --> 00:27:35.680	So, if you want to look at the memory of it, so declare them global, so that you can see their values.
55.srt	00:27:35.769 --> 00:27:40.779	Otherwise, internal to the function, so you would not be able to look at it.
55.srt	00:27:40.910 --> 00:27:44.450	This is one of the ways of looking at it.
55.srt	00:27:44.450 --> 00:27:49.480	Now what you can do is, it is written the, I can close it.
55.srt	00:27:49.529 --> 00:27:52.029	After this, you would not be able to see the memory.
55.srt	00:27:52.330 --> 00:27:54.460	After running it, what you can go and do that.
55.srt	00:27:54.890 --> 00:27:57.880	So, what it has created is this bgr dot.
55.srt	00:27:58.320 --> 00:28:00.570	RGB file has got created.
55.srt	00:28:00.940 --> 00:28:10.560	So, this file what you have to do is take it to MATLAB and then read it with proper formatting given to the thing.
55.srt	00:28:11.310 --> 00:28:18.680	So, this completes the one more equalizer what we have it.
55.srt	00:28:18.970 --> 00:28:26.560	So, what you can do that also you can take it as an example to run the thing.
55.srt	00:28:26.910 --> 00:28:28.330	So, you will be seeing that.
55.srt	00:28:28.769 --> 00:28:31.040	So, this is a graphic equalizer.
55.srt	00:28:31.040 --> 00:28:38.480	So, it has low pass filter, high pass filter and then the band pass filter what it has been built across.
55.srt	00:28:39.190 --> 00:28:43.500	And then your buffers have been given and then amplitude for that and it is also interrupt driven.
55.srt	00:28:44.300 --> 00:28:55.840	So, you will be getting in low pass filter what you will be passing it through and then your band pass filter and then high pass filter and then band pass filter.
55.srt	00:29:00.980 --> 00:29:11.650	So, if you have generated a gel file, so you can select just how we selected in MATLAB different filters passing through the thing.
55.srt	00:29:12.000 --> 00:29:15.370	So, in this case the complete thing passes out.
55.srt	00:29:15.370 --> 00:29:36.730	So, you will be initializing the line input here and then you can generate a music whatever you have the thing and then with proper adjustment of this your band pass filter and whether you want to include all of them as you can see here it is getting.
55.srt	00:29:36.970 --> 00:29:43.910	multiplied with output from the filters all of them added.
55.srt	00:29:44.310 --> 00:29:46.050	So, you will be outputting it.
55.srt	00:29:46.050 --> 00:29:48.820	So, we will here what is we are going to get it.
55.srt	00:29:48.820 --> 00:29:52.120	So, you have to guess the thing I will be giving the speech signal.
55.srt	00:29:52.150 --> 00:29:56.620	So, if you want to give it music you can give it and then look at it.
55.srt	00:30:02.720 --> 00:30:05.280	I think my speech signal is still running.
55.srt	00:30:07.720 --> 00:30:12.420	So, I can we can test what equalizer it is because all of them have mixed together.
55.srt	00:30:12.970 --> 00:30:15.940	So, you will be hearing the sound there.
55.srt	00:30:16.390 --> 00:30:34.560	So, what you have to do is, you have to modify your gain in this and select whether you want only the low pass filter and then you can eliminate.
55.srt	00:30:34.660 --> 00:30:38.070	So, gel file has to be created for this and then.
55.srt	00:30:39.680 --> 00:30:56.130	You can select only low pass filter then because we know that up to 8 kilohertz what I can run this code and you will be seeing that the increase whatever the volume what you have given multiplied by 32000 what you have it.
55.srt	00:30:56.130 --> 00:31:02.779	So, I can select audio file and run it at high input the thing at high this thing sampled signal.
55.srt	00:31:10.240 --> 00:31:13.619	and run this code and then you can check it.
55.srt	00:31:13.619 --> 00:31:24.319	So, you can experiment with this audio equalizer by only passing through the only low pass filter and rest of it you can comment it out.
55.srt	00:31:24.319 --> 00:31:24.640	So, thank you.
55.srt	00:31:25.730 --> 00:31:31.730	So, this I will leave it as an assignment for you to venture.
55.srt	00:31:32.329 --> 00:31:35.930	Thank you for hearing to this lab.
55.srt	00:31:41.689 --> 00:31:44.969	Welcome back and then any queries or anything you can ask me.
55.srt	00:31:45.279 --> 00:31:46.219	Thank you.
6.srt	00:00:01.219 --> 00:00:25.379	Welcome back to real time digital signal processing course.
6.srt	00:00:25.379 --> 00:00:30.329	So, we will discuss today DSP architecture.
6.srt	00:00:30.850 --> 00:00:34.409	So, just to give a recap what we did in the last class.
6.srt	00:00:34.829 --> 00:00:36.990	So, we discussed about the number system.
6.srt	00:00:37.509 --> 00:00:46.189	So, hopefully you enjoyed that course it is fixed and then floating point number system what we discussed in the last class.
6.srt	00:00:46.560 --> 00:00:50.100	So, in this class we will be seeing DSP architecture.
6.srt	00:00:50.560 --> 00:00:55.390	So, how this is going to cater to whatever number system we have discussed.
6.srt	00:00:55.909 --> 00:01:00.469	So, coming to the problem what I have posed in the last class.
6.srt	00:01:00.820 --> 00:01:02.750	So, you are supposed to add.
6.srt	00:01:03.600 --> 00:01:07.159	2 numbers in the floating point format.
6.srt	00:01:07.549 --> 00:01:13.719	So, the thing was given is exponent was 4 mantissa 5 and bias 7.
6.srt	00:01:14.259 --> 00:01:17.620	So, when your this were the 2 numbers what it was given.
6.srt	00:01:17.620 --> 00:01:30.090	So, you know the first bit is sign bit and 4 bits because you have been given 4 as exponent, 4 bits will be representing exponent in this and rest of them are going to be your mantissa.
6.srt	00:01:31.549 --> 00:01:33.590	And then same thing with the other number.
6.srt	00:01:34.180 --> 00:01:40.579	Now, we will see that how we can represent this number in the exponential format.
6.srt	00:01:40.579 --> 00:01:53.909	So, if I see the thing it is going to be 0.0010 into 2 power 10 and then the next number has a exponent value 9, 1001 is 9.
6.srt	00:01:53.909 --> 00:01:55.599	So, it is multiplied by 2 power 9.
6.srt	00:01:55.599 --> 00:02:05.490	So, in this case usually what we do is the smaller exponent we are going to adjust it to the larger one.
6.srt	00:02:06.409 --> 00:02:14.449	So, that both the exponent become equal then only we can add the two numbers in the floating point number system.
6.srt	00:02:15.039 --> 00:02:18.919	We will adjust the exponent to the same exponent.
6.srt	00:02:19.210 --> 00:02:31.469	So, we shift this number by one right bit and then increase the exponent to 2 power 10 as it is seen here and then we do the addition and keeping the same exponent.
6.srt	00:02:40.510 --> 00:02:49.080	So, coming to fraction part it is equivalent as we see the thing it is 1 into 2 power minus 3 what we have it and 1 into 2 power minus 4 and 1 into 2 power minus 5 which is going to give me the value as 0.21875.
6.srt	00:02:49.080 --> 00:03:02.070	As we discussed in the last class we will be doing 1 plus f. So, it the fractional value will be 1 plus f is equal to 1.21875 and then we said exponent is the biased 1.
6.srt	00:03:02.070 --> 00:03:05.220	So, bias is given as 7 in this case.
6.srt	00:03:05.220 --> 00:03:11.220	So, it will be 10 minus 7 which is going to be 2 power 3 and if we do the multiplication by 8.
6.srt	00:03:12.080 --> 00:03:13.780	So, the resultant is 9.75.
6.srt	00:03:13.780 --> 00:03:19.650	So, this was the first assignment problem what I had given the thing.
6.srt	00:03:19.650 --> 00:03:22.530	The second one was fixed point multiplication.
6.srt	00:03:22.530 --> 00:03:26.090	So, the numbers were given as minus 0.75 and minus 0.375.
6.srt	00:03:26.090 --> 00:03:33.099	So, I told you to not to use that the result is going to be positive.
6.srt	00:03:33.099 --> 00:03:40.710	So, still we will work out both the methods and see how the result is going to be same in both of them.
6.srt	00:03:42.099 --> 00:03:55.800	So, first is we know that minus 0.75 in binary is represented as 1.110 which is nothing, but 0.5 plus 0.25 is going to give me 0.75 and then minus 0.375 is this number.
6.srt	00:03:55.800 --> 00:04:01.189	So, since I know it is the positive value what I am going to get it.
6.srt	00:04:01.189 --> 00:04:04.789	So, I can take both as positive numbers and then do the multiplication.
6.srt	00:04:04.789 --> 00:04:09.629	So, the resultant as you are seeing it here it is 0.010010.
6.srt	00:04:14.939 --> 00:04:25.319	So, because I said input and output has to be in the 4 bit format and we said we will be discarding the LSB bits in this case these 3 bits are going to be discarded.
6.srt	00:04:25.319 --> 00:04:27.009	So, the result is 0.010.
6.srt	00:04:27.470 --> 00:04:30.079	So, we will be getting it as 0.25.
6.srt	00:04:30.079 --> 00:04:43.610	So, originally what we are supposed to get is 0.2815 completely taken into account even in the decimal if you multiplied 0.75.
6.srt	00:04:45.400 --> 00:04:47.840	0.375 you should get it as 0.28125.
6.srt	00:04:47.840 --> 00:04:55.350	So, what we say is this 2 power minus 5 LSB bit has got discarded.
6.srt	00:04:55.350 --> 00:04:59.100	So, we will see how to do a 2's complement multiplication.
6.srt	00:04:59.389 --> 00:05:06.519	So, we said that in 2's complement minus 0.75 is this number.
6.srt	00:05:06.519 --> 00:05:14.750	First I take 0.75 and take the 2's complement of that number and this is the number same with respect to 0.35.
6.srt	00:05:16.670 --> 00:05:19.709	2's complement of that number is this.
6.srt	00:05:19.709 --> 00:05:25.110	So, in the second method we will be doing the multiplication in the 2's complement.
6.srt	00:05:25.110 --> 00:05:27.399	So, the 1.010 into 1.1101.
6.srt	00:05:27.769 --> 00:05:34.819	So, in this case one has to consider that when you are multiplying with 1.
6.srt	00:05:34.819 --> 00:05:40.149	So, you have to extend the digits by 1.
6.srt	00:05:40.420 --> 00:05:45.850	So, the we call it as sign bit extension in this case.
6.srt	00:05:47.620 --> 00:05:55.269	So, although it is 1010 later on we will be putting it 1 when multiplying with 0 we need not have to bother it is going to be 0.
6.srt	00:05:55.689 --> 00:06:06.189	Again multiplying 1 so we have done the sign extension with 1 and the last one because this is the sign bit what we are going to multiply with this number.
6.srt	00:06:06.560 --> 00:06:10.889	So, we have to take the 2's complement of this number and then put it there.
6.srt	00:06:11.180 --> 00:06:16.139	So, we know that 2's complement for 1010 is 0.110.
6.srt	00:06:18.960 --> 00:06:36.080	with 0, 0, 0, 1, 1, 0 then we add we are getting the same result as the previous method and here also we will be considering it as 0.010 which is equivalent to 0.25 which is not equivalent to 0.28125 what we are supposed to get.
6.srt	00:06:36.080 --> 00:06:49.689	So, this is the truncation what we are supposed to have in multiplication of fixed point numbers here also the 2 power minus 5 bit whatever 1 has got.
6.srt	00:06:51.379 --> 00:07:01.290	So, with this we will see how the architecture is going to get fine tuned for these numbers handling in that.
6.srt	00:07:01.680 --> 00:07:09.100	As an example we will consider how one novice wants to prepare a salad in our kitchen.
6.srt	00:07:09.420 --> 00:07:23.490	So, what are the things required we have said refrigerator, counter, cutting board and recipe first of all required what are the corners of the cutting board are kept free for partially chopped ones to add.
6.srt	00:07:23.819 --> 00:07:24.610	rest of the thing.
6.srt	00:07:25.069 --> 00:07:29.939	So, in the next slide we will see that how the bowl is taken and then mixed everything.
6.srt	00:07:30.439 --> 00:07:35.099	Once all the veggies have been considered and then mixed.
6.srt	00:07:35.370 --> 00:07:39.879	So, you can keep it back in your fridge or you can use it for consumption.
6.srt	00:07:40.310 --> 00:07:43.490	This is how the procedure is going to follow.
6.srt	00:07:43.860 --> 00:07:51.899	So, we always think in a simple term, but here you will be seeing each step has been recorded, how long it is going to say it take.
6.srt	00:07:52.169 --> 00:08:01.349	So, the same way we are considering our DSP application also in this manner and see how the architecture has been developed.
6.srt	00:08:07.479 --> 00:08:16.429	So, all of us know that regular processor has this architecture basically we have a motherboard here and then we have the ROM and then we have the processor chip in this.
6.srt	00:08:16.759 --> 00:08:21.599	Then through the bus all the peripheral units have been connected.
6.srt	00:08:21.889 --> 00:08:37.439	So, what are the peripheral the registers memory and secondary storage are all going to work together and we have the port ports for taking the input and then putting it on the output also.
6.srt	00:08:37.960 --> 00:08:41.690	So, coming to the basic architecture of the DSP.
6.srt	00:08:42.129 --> 00:08:49.000	So, we say it is a specialized microprocessor for the purpose of real time DSP computing.
6.srt	00:08:49.730 --> 00:08:56.070	So, the applications what are they in the commonly used in digital signal processing is.
6.srt	00:08:56.480 --> 00:09:04.539	So, they are mathematically intensive that is common algorithms require many multiply and accumulation.
6.srt	00:09:05.210 --> 00:09:08.909	And then we know that algorithm is run in real time.
6.srt	00:09:09.679 --> 00:09:18.440	That is current data must be processed before next data arise in the clock cycle what we call it every clock cycle I am going to get the data.
6.srt	00:09:18.809 --> 00:09:37.870	So, before the next data comes I should have finished my computation and algorithms are under development and hence DSP system should be flexible to support the changes if the algorithm is going to be changed or whatever may be the thing and we have to implement them in real time.
6.srt	00:09:39.090 --> 00:09:44.320	So, coming to the continuing with the architecture what all the other things what we needed.
6.srt	00:09:44.980 --> 00:09:59.779	So, one is arithmetic operations like any other general purpose processor add, subtract and multiply is one extra what we will be adding it and other support has to be logic operations like AND, XOR, ROR not.
6.srt	00:10:00.509 --> 00:10:11.710	And we need extra is the MAC operations because we need multiply and accumulate and some of the earlier processors had both multiply and accumulate.
6.srt	00:10:12.050 --> 00:10:21.039	Nowadays multiply unit is separate and then accumulator is separate, but we can run them in parallel so that I can get the MAC operations in one clock cycle.
6.srt	00:10:21.720 --> 00:10:33.150	The next one is we have to do scaling of the signal before and after hold on a while why we need it we will come to that discussion in a while.
6.srt	00:10:33.820 --> 00:10:44.810	So, coming to the next one what all the other things from the memory point of view we need a RAM on chip memories for samples because we are telling real time signals are coming in.
6.srt	00:10:45.160 --> 00:10:52.200	So, we have to have the RAM to collect it and next one is the ROM that is on chip program memory.
6.srt	00:10:52.570 --> 00:11:00.880	for storing our program and then we will see that with modification we can store our filter coefficients also in the ROM.
6.srt	00:11:01.610 --> 00:11:11.100	The next one is on chip registers for storing intermediate results because we know that memory access is going to slow down our operations.
6.srt	00:11:11.560 --> 00:11:14.650	So, we want to have it everything is faster.
6.srt	00:11:14.650 --> 00:11:23.860	So, we say that we can store the intermediate results in registers which are much closer to our architecture.
6.srt	00:11:25.240 --> 00:11:28.330	Basically, we will say it as a DSP chip.
6.srt	00:11:29.240 --> 00:11:46.820	So, the building blocks for our digital signal processing computations are multiplier, shifter and MAC units their capabilities and the last one not the least one we will say it as ALU that is Arithmetic Logic Units.
6.srt	00:11:47.520 --> 00:11:52.330	So, first we will take up multiplier how it can be designed.
6.srt	00:11:52.880 --> 00:11:58.100	So, one is we are looking at because we have lot of multiplication and accumulation.
6.srt	00:11:58.450 --> 00:12:00.520	So, speed is one of the criteria.
6.srt	00:12:01.030 --> 00:12:04.050	This is going to be decided by the architecture.
6.srt	00:12:04.480 --> 00:12:08.960	So, we have to have a trade off between hardware complexity and power dissipation.
6.srt	00:12:09.440 --> 00:12:15.350	As the hardware increases our power is going to be increased also.
6.srt	00:12:15.580 --> 00:12:22.240	So, we want to keep it lower power consumption and then we want to have more complexity in the hardware.
6.srt	00:12:22.240 --> 00:12:24.610	So, we have to match between the two of them.
6.srt	00:12:25.280 --> 00:12:27.230	The next one is accuracy.
6.srt	00:12:27.710 --> 00:12:31.070	So, this is going to be decided by number of bits.
6.srt	00:12:31.520 --> 00:12:38.690	As we discussed in the last class, it is going to be the format can be floating point a fixed point.
6.srt	00:12:39.050 --> 00:12:44.130	So, we know that for the floating point number of bits are going to be more.
6.srt	00:12:44.600 --> 00:12:49.570	So, our hardware is going to increase, but at the same time accuracy will be more.
6.srt	00:12:49.920 --> 00:12:52.950	So, what is the tradeoff between the two one has to look at it.
6.srt	00:12:53.380 --> 00:12:59.550	The next one is whether we can cater our architecture to large dynamic range.
6.srt	00:13:00.030 --> 00:13:03.800	So, this again is going to be decided by format representation.
6.srt	00:13:04.250 --> 00:13:17.800	at floating point numbers have large dynamic range whereas, fixed point will be having the low dynamic range, but they equal floating point numbers in precision.
6.srt	00:13:18.170 --> 00:13:33.630	So, it depends on what kind of application one is choosing depending on it one has to match all these things and then choose a correct DSP processor or design your own DSP processor using FPGA.
6.srt	00:13:36.660 --> 00:13:41.680	how we can increase the parallel or array multipliers what we call it.
6.srt	00:13:41.800 --> 00:13:46.300	Just now we did the fixed point multiplication.
6.srt	00:13:46.680 --> 00:13:52.170	So, you saw that the multiplication is basically a successive addition.
6.srt	00:13:52.510 --> 00:14:05.160	So, if we considered n bits we will take n clock cycles and then n plus 1 clock cycle will be required to do our successive addition.
6.srt	00:14:05.410 --> 00:14:08.650	So, whether we can improve on this.
6.srt	00:14:08.910 --> 00:14:20.360	So, for that we will be going with parallel or array multipliers because VLSI technology provides hardware capabilities for accommodating these multipliers.
6.srt	00:14:21.040 --> 00:14:32.800	And we want in process 1 clock cycle we have to complete the multiplication of 2 binary numbers that is what our aim is our goal is ok.
6.srt	00:14:33.170 --> 00:14:37.550	So, how we can do that with little bit of bit expansion we will see it.
6.srt	00:14:37.870 --> 00:14:40.100	So, we will be considering the multiplication and.
6.srt	00:14:40.300 --> 00:15:04.110	to unsigned fixed point numbers in this case a is m bit and then b will be n bit number what it has been chosen and then it can be represented in the summation form like this a will be ranging between 0 to 2 power m minus 1 and a will be belonging to either 0 or 1 same way with b operand also.
6.srt	00:15:12.800 --> 00:15:18.140	So, we say that we need r bits where r is going to be greater than maximum of m comma n to represent the product which is p is equal to a into b.
6.srt	00:15:18.590 --> 00:15:30.360	We know that we need more than maximum of one of the bits m and n are not equal need not have to be equivalent in this case that is what we are considering it.
6.srt	00:15:30.360 --> 00:15:33.710	So, we are taking the maximum of it, but it should be greater than that.
6.srt	00:15:34.180 --> 00:15:36.540	So, we will see how much greater we need it in a while.
6.srt	00:15:37.320 --> 00:15:45.360	So, that is what the question is posed also that is what should be the number of bits that is r has to be.
6.srt	00:15:45.910 --> 00:15:51.450	We will say first consider the minimum number of bits required P or B R bits we will say.
6.srt	00:15:51.960 --> 00:15:55.800	R bit will be in the range 0 to 2 power R minus 1.
6.srt	00:15:56.280 --> 00:16:00.550	Therefore, R P will be in the range between these two.
6.srt	00:16:01.130 --> 00:16:10.410	We will see first P minimum when A bits are all 0s and B bits are 0s then the minimum is going to be product will be 0.
6.srt	00:16:10.990 --> 00:16:12.480	When will be the maximum?
6.srt	00:16:12.850 --> 00:16:18.020	When all A bits are 1s and B bits are 1s which is we call it as maximum.
6.srt	00:16:18.450 --> 00:16:22.120	So, then we know that there are m and n bits.
6.srt	00:16:22.120 --> 00:16:25.540	So, it will be 2 power m minus 1 into 2 power n minus 1.
6.srt	00:16:26.020 --> 00:16:29.220	So, when we expand this multiplication.
6.srt	00:16:29.220 --> 00:16:40.790	So, we will be we are resulted with 2 power n plus 1 n plus m minus 2 power n minus 2 power m plus 1 is the number of bits what we needed.
6.srt	00:16:41.160 --> 00:16:45.600	So, we will see that how P max can be represented.
6.srt	00:16:46.010 --> 00:16:50.660	So, we have represented this and what the term is going to say is.
6.srt	00:16:51.140 --> 00:17:23.259	So, this terms can be represented as minus 1 that is it should be less than or equal to 2 power n plus m minus 1 for positive n and m and approximately if n and m are very large we can approximate this P max to 2 power n plus m. So, therefore, we say that the maximum number of bits required to represent the product is less than 2 power n plus m.
6.srt	00:17:23.850 --> 00:17:58.019	So, we say this as a tight bond then what will be R. So, we take the log of it log 2 P max which is nothing, but log 2 of 2 power n plus m which is going to be m plus n is the number of bits maximum bits what we need it for this it may be less than that that is what we have put for large n and m. So, how to do that we will take an example in this case I have taken n is equal to m is equal to 4 both of them are same.
6.srt	00:18:00.440 --> 00:18:04.570	So, then We need R is equal to M plus N in the maximum that is 8 bits.
6.srt	00:18:04.950 --> 00:18:05.850	Do we need that?
6.srt	00:18:05.990 --> 00:18:13.269	We will see with the expansion of our multiplication A and B are represented with 4 bits.
6.srt	00:18:13.820 --> 00:18:24.980	A and here 4 bits and B and when you expand this summation basically multiplication and summation you do the thing this is the result what we will be getting it.
6.srt	00:18:31.290 --> 00:18:35.490	So, when we further multiply both of them so these are the products what will be getting it.
6.srt	00:18:35.940 --> 00:18:42.750	So, from here to here are the products which have to be summation has to happen for them.
6.srt	00:18:43.230 --> 00:18:47.040	Then when we represent these with products as P0.
6.srt	00:18:47.509 --> 00:18:52.970	So, we will be putting their powers what are they because it is in terms of powers what it has been segregated.
6.srt	00:18:53.310 --> 00:18:56.810	So, we will be needing P0, P1, P2.
6.srt	00:18:56.810 --> 00:19:00.820	P7 is the maximum what we need it.
6.srt	00:19:01.180 --> 00:19:02.960	So, 0 to 7 which is the maximum.
6.srt	00:19:03.509 --> 00:19:04.670	gives me 8 bits.
6.srt	00:19:04.950 --> 00:19:14.009	So, this is what we say p 7 to power minus 7 to power 7 minus m what will be putting the number.
6.srt	00:19:14.440 --> 00:19:18.500	So, we will see why we need p 7 also we will see the thing.
6.srt	00:19:19.059 --> 00:19:24.619	So, we have to compensate for carry over bits what we will say that.
6.srt	00:19:24.960 --> 00:19:30.269	So, we have represent p 0 to p 1, p 2, p 6 how the summation is going to happen.
6.srt	00:19:30.579 --> 00:19:35.539	So, the first one is only the multiplication later on we have multiply and accumulate.
6.srt	00:19:36.009 --> 00:19:52.210	And, then this is a half adder what we needed for the P1 product, but from P2 onwards we need full adder as you are seeing it we are adding these numbers and with the previous carry.
6.srt	00:19:52.740 --> 00:20:03.879	And then same thing with the P6 and then P7 represent only the carry that is coming out of after adding in the last stage.
6.srt	00:20:04.149 --> 00:20:06.849	So, we will see the architecture how does it look like.
6.srt	00:20:07.159 --> 00:20:10.740	So, most of the DSP processor use a Braun multiplier.
6.srt	00:20:11.420 --> 00:20:16.890	So, you can see that 4 by 4 Braun multiplier how it is represented.
6.srt	00:20:17.140 --> 00:20:19.160	So, this is your full carry.
6.srt	00:20:19.420 --> 00:20:33.769	So, I have a operand and previous carry in is going to be input with this and the second operand is coming from this side and the result is going to be sum and then carry out is going to be generated from full order is shown in this way.
6.srt	00:20:34.140 --> 00:20:39.590	So, we say that I need because we have taken m is equal to n is equal to 4.
6.srt	00:20:39.950 --> 00:20:43.400	So, these are the structures what I need it.
6.srt	00:20:43.869 --> 00:20:48.779	from the multiplication and addition these are the adders.
6.srt	00:20:48.779 --> 00:21:05.460	So, as you can see that this is the multiplier what we are representing, but we need AND gates to do multiplication of these numbers whatever you are seeing that is the additional hardware what it requires.
6.srt	00:21:06.069 --> 00:21:11.609	And then in the first stage you will be having no carry in is going to be there.
6.srt	00:21:11.609 --> 00:21:14.660	So, you will be pump we are using all full adders.
6.srt	00:21:14.940 --> 00:21:19.490	So, that is why the carry in is going to be 0 in this case this is one apparent.
6.srt	00:21:19.759 --> 00:21:21.059	and then the other operand.
6.srt	00:21:21.059 --> 00:21:26.090	The first one we said P 0 is A naught into B naught which comes out directly.
6.srt	00:21:26.430 --> 00:21:34.480	After that what we will be doing is our addition what it is going to follow with these numbers.
6.srt	00:21:34.900 --> 00:21:53.940	And we say that the last stage in this multiplier what we have to do is we have to do a ripple carrier adder what we are supposed to use it that means, to say this adder has to give its carry out to this and from here to here and then from here what the P 7 bit is going to be.
6.srt	00:21:54.339 --> 00:22:16.630	So, coming to the Braun multiplier we say the speed that is longest path delay as we are seen the thing in this case is all these additions and then the last stage ripple carrier adder delay also one has to add it which gives the longest path delay.
6.srt	00:22:16.910 --> 00:22:25.220	So, what is it through the gates and then adders we say this will be within one processor clock cycle.
6.srt	00:22:25.880 --> 00:22:31.100	So, my in internal clock rate may be much faster than the outer clock.
6.srt	00:22:31.100 --> 00:22:35.240	So, that see that all these are done in one clock cycle.
6.srt	00:22:36.080 --> 00:22:46.670	And we say that there should be additional hardware before and after brawn multiplier required to take care of sign numbers because we took it as unsigned number.
6.srt	00:22:47.009 --> 00:23:00.320	So, as we did sign multiplication if one of the number is both of them are negative then we have seen that we have to do the two's complement this is the hardware which is required for the.
6.srt	00:23:01.130 --> 00:23:05.750	before we do the multiplication of the number for the sign numbers.
6.srt	00:23:07.410 --> 00:23:13.380	Coming to the array multiplier or parallel multiplier, what is the bus width required?
6.srt	00:23:14.020 --> 00:23:21.720	So, we need two buses of n bits to directly give the parallely give the input to our multiplier.
6.srt	00:23:21.720 --> 00:23:32.860	And we know that x into y the product we said maximum length is n plus n which is going to be if I am taken both are n.
6.srt	00:23:35.140 --> 00:23:43.920	actually bits for the two inputs then 2 n will be the maximum bits what I need it output of the multiplier.
6.srt	00:23:44.009 --> 00:23:49.540	So, that can be Z it depends on the application that is what it says.
6.srt	00:23:49.570 --> 00:24:04.590	So, program bus can be reused for our multiplication instruction is when it fetch after fetching the instruction and that is most of the cases coefficients what will be taking it.
6.srt	00:24:04.870 --> 00:24:06.280	So, which can be pre.
6.srt	00:24:07.539 --> 00:24:13.269	stored in the ROM and then we can fetch it from the program bus.
6.srt	00:24:13.910 --> 00:24:20.980	So, bus for x can be used for z once we have done use the input.
6.srt	00:24:20.980 --> 00:24:31.240	So, I can use the same bus for my z that is discarding the lower n bits from z or storing two consecutive memory locations.
6.srt	00:24:31.630 --> 00:24:38.519	So, as we know that if we want to store two n bits output in the memory it is going to take twice that of the.
6.srt	00:24:38.890 --> 00:24:39.820	memory requirement.
6.srt	00:24:40.930 --> 00:24:50.460	And then computation loading when we have to load 2 in I would not be able to load them in one shot I have to do them in 2 clock cycles.
6.srt	00:24:50.460 --> 00:24:51.630	So, which is going to slow down.
6.srt	00:24:51.960 --> 00:25:08.570	So, most of the DSP processor what we do is we only store the higher bits as we discarded in our example also lower bits high bits n bit whatever is defined is going to be stored in R.
6.srt	00:25:08.970 --> 00:25:10.870	memory through Z bus.
6.srt	00:25:12.140 --> 00:25:15.680	So, the next one is after the multiplier we need the shifter.
6.srt	00:25:16.710 --> 00:25:19.940	So, first is why do we need the shifter?
6.srt	00:25:20.590 --> 00:25:31.960	One is it is to scale down or scale up to operands and results to avoid errors resulting from our overflows and reflows during the computations.
6.srt	00:25:32.400 --> 00:25:39.319	So, as we saw in the previous case in the example we scaled down all our numbers.
6.srt	00:25:39.930 --> 00:25:47.420	So, And, then used it for our multiplication that is converted into fractional from integers to fractional numbers.
6.srt	00:25:47.650 --> 00:25:51.250	So, that fractional multiplication is not going to overflow.
6.srt	00:25:51.670 --> 00:26:04.990	So, we have we need that scaled down in there and then once the result is there we may have to scale it up back to the previous whatever scaled down value and then give the output.
6.srt	00:26:05.680 --> 00:26:08.780	So, this avoids our overflows and reflows.
6.srt	00:26:09.170 --> 00:26:11.570	So, overflows all of you must be knowing that.
6.srt	00:26:11.770 --> 00:26:20.490	the value is much more androflu is it goes below or whatever maximum negative value what it has been provided.
6.srt	00:26:21.020 --> 00:26:23.780	So, when computing the sum of n numbers.
6.srt	00:26:24.220 --> 00:26:33.660	So, each is going to be represented by n bits the overall sum will have we know that n plus log 2 n bits.
6.srt	00:26:34.210 --> 00:26:36.680	So, we have to say why this is.
6.srt	00:26:41.830 --> 00:26:53.120	So, each number is represented by n bits we said and sum of n numbers you have seen that sigma i is equal to 0 to n minus 1 then the maximum width is going to be n into 2 power n minus 1.
6.srt	00:26:53.590 --> 00:27:12.670	So, therefore, our r whatever for the bits that is required for my product we will be putting it as log 2 P max approximate it as log 2 n into 2 power n. So, which is nothing but log 2 2 power n plus log 2 n. So, we know that log 2 2 power n is nothing but.
6.srt	00:27:13.050 --> 00:27:19.060	n plus log 2 n is the representation what we are going to have it.
6.srt	00:27:19.540 --> 00:27:24.970	So, depending on this we will say when is scaling required.
6.srt	00:27:25.420 --> 00:27:34.050	So, we said to avoid overflow either at the input or before addition that is scaling by log 2 n bits.
6.srt	00:27:34.290 --> 00:27:38.440	So, that is what we said that maximum what we can represent here.
6.srt	00:27:38.860 --> 00:27:43.550	So, depending on that we may have to scale the number by log 2 n bits.
6.srt	00:27:44.010 --> 00:27:50.940	So, after summation to get back the original results we will be doing the scale up by log 2 in bits.
6.srt	00:27:51.420 --> 00:27:58.130	So, this is a trade of between overflow and then accuracy one has to consider.
6.srt	00:27:58.600 --> 00:28:05.240	So, we will see that how we can do the shifting in this case why we need scale up or down.
6.srt	00:28:05.690 --> 00:28:15.570	So, as an example n is equal to 4 bits and then capital N number of additions what we are going to have it also 4 basically.
6.srt	00:28:15.910 --> 00:28:19.500	we have chosen unsigned fixed point integers case.
6.srt	00:28:19.790 --> 00:28:29.390	So, then our summation is going to be x 1 is represented with 4 bits and then x 3 x 4, 4 variables are there we are adding it up.
6.srt	00:28:29.650 --> 00:28:36.110	As an example these are the values what we have taken their binary representation shown in the square bracket.
6.srt	00:28:36.310 --> 00:28:41.570	So, when we sum up we are going to get it as 21 is the result.
6.srt	00:28:41.890 --> 00:28:50.400	So, the maximum because we are representing it 4 bits what I can represent maximum value is 15 that is 2 power 4 minus 1.
6.srt	00:28:50.730 --> 00:28:52.380	So, which is much greater than.
6.srt	00:28:52.660 --> 00:28:54.010	this 15, 21.
6.srt	00:28:54.340 --> 00:28:56.290	So, then we have to do the scaling.
6.srt	00:28:56.800 --> 00:29:02.020	So, in this case because we have assumed n is equal to also 4 numbers what we have it.
6.srt	00:29:02.330 --> 00:29:04.920	So, log 2 capital N is 4.
6.srt	00:29:05.320 --> 00:29:09.040	So, we have divide by that is scaling by 2.
6.srt	00:29:09.470 --> 00:29:15.950	So, that is scaling by 1 right shift is basically equivalent to dividing by 2.
6.srt	00:29:16.640 --> 00:29:19.780	So, we will be scaling all inputs by 2.
6.srt	00:29:20.060 --> 00:29:25.790	We will see the same numbers when we do the scaling what you will be getting is x 1 hat.
6.srt	00:29:26.150 --> 00:29:28.560	So, that is not equivalent to x 1.
6.srt	00:29:28.860 --> 00:29:42.160	So, when it is going to be 4 when I do multiply by 2 here I will get 8 not 9 same thing whatever shown in the red are the approximated value to the original one.
6.srt	00:29:42.760 --> 00:29:50.270	So, if they are divisible by 2 you know that we will be getting back the number otherwise we will be having the approximation.
6.srt	00:29:50.690 --> 00:29:56.260	Then we will see what is the summation I am going to get it when I add these numbers which is going to be 9.
6.srt	00:29:56.650 --> 00:30:03.350	So, to get back result we have to scale up the number by 2 which is going to be 18.
6.srt	00:30:03.660 --> 00:30:05.360	which is not equivalent to 21.
6.srt	00:30:05.730 --> 00:30:09.630	So, these are the errors one has to consider.
6.srt	00:30:10.020 --> 00:30:15.120	If it is not tolerable then we may have to go for the floating point number representation.
6.srt	00:30:15.490 --> 00:30:24.000	Otherwise if it is within whatever are errors usually we call it as signal to noise ratio.
6.srt	00:30:24.370 --> 00:30:31.370	So, if it is in that we can accept this and go ahead with these processor architecture.
6.srt	00:30:31.990 --> 00:30:34.600	So, when can we use the scaling?
6.srt	00:30:34.970 --> 00:30:51.130	That is what we said conducting of floating point additions when we need to align our exponent that is what it says where each operand should be normalized to the same exponent prior to addition I need the scaling.
6.srt	00:30:51.620 --> 00:30:59.270	And one of the operands can be shifted to the required number of bit positions to equalize the exponents that is what we did in our example.
6.srt	00:30:59.900 --> 00:31:03.140	So, how we can accommodate this shifting?
6.srt	00:31:03.760 --> 00:31:05.140	So, we know that.
6.srt	00:31:05.410 --> 00:31:12.530	But sequential shifting is going to cost us n clock cycles if we need n bit shift.
6.srt	00:31:13.390 --> 00:31:23.940	So we have a barrel shifter that is normal shifting any microprocessor that is what it says 1 clock cycle for every single bit shift.
6.srt	00:31:24.350 --> 00:31:29.620	So what the latency will be multiple clock cycles due to many shifts ok.
6.srt	00:31:30.070 --> 00:31:40.060	Whereas the barrel shifters allow shifting of multiple bit positions within 1 clock cycle reducing the latency for our real time DSP computations.
6.srt	00:31:40.410 --> 00:31:41.760	So what we have.
6.srt	00:31:42.130 --> 00:32:04.430	I have a shifter here input is going to be n bits and output will also will be maintaining n bits and we will be telling the these are the two control bits one is whether we want to do a shift left or shift right and then how many number of bit positions I want to shift it is given as the control inputs.
6.srt	00:32:04.640 --> 00:32:15.290	So, we will see how barrel shifter works we have taken example as a 4 bit shift right barrel shifter has been designed here.
6.srt	00:32:15.770 --> 00:32:23.680	So, you will be seeing these are the a 0, a 1, a 2, a 3 are the bit inputs and then outputs are going to be b 0, b 1, b 2, b 3.
6.srt	00:32:23.970 --> 00:32:28.390	So, what are the input bits it will be going into this what we will be seeing in a while.
6.srt	00:32:28.820 --> 00:32:46.670	And we have switches s 0, s 1, s 2 and s 3 and we say that switch closed on control signal is on and then only one switch can be.
6.srt	00:32:46.980 --> 00:32:48.790	operated at a time.
6.srt	00:32:49.120 --> 00:32:52.410	So, we will see how this write operation is going to help us.
6.srt	00:32:52.860 --> 00:33:03.090	So, the first is 4 bit write shift barrel shifter what we are considering it and logic circuit takes a fraction of a clock cycle to execute this.
6.srt	00:33:03.630 --> 00:33:11.320	And majority of delay is in decoding the control lines and setting up the path from input lines to the output lines.
6.srt	00:33:11.690 --> 00:33:18.330	These are causing the delay otherwise we will be getting the output in a fraction of a second or clock cycle we will say.
6.srt	00:33:18.370 --> 00:33:29.370	So, my input first is a 3, a 2, a 1, a 0 are the thing and we will see this which positions actually first is 0 that is represented with S 0.
6.srt	00:33:29.710 --> 00:33:33.000	and output is b 0 b 1 b 2 b 3.
6.srt	00:33:33.270 --> 00:33:38.000	Since I am only a 0 is being used I am not doing any shift operation.
6.srt	00:33:38.310 --> 00:33:44.600	So, the input whatever you have given will be going into these output lines as it is.
6.srt	00:33:45.100 --> 00:33:49.830	When switch 1 is operated I have to do a shift right operation by 1.
6.srt	00:33:50.180 --> 00:33:59.640	So, in this case whatever the MS b value is going to be pushed into the last place basically.
6.srt	00:33:59.950 --> 00:34:02.110	So, we will be shifting a 0 out of it.
6.srt	00:34:02.310 --> 00:34:04.340	it becomes a 1 a 2 a 3 a 3.
6.srt	00:34:04.720 --> 00:34:09.590	So, when s 2 is on then 2 shift what I needed.
6.srt	00:34:09.590 --> 00:34:20.430	So, a 0 a 1 is going to be shifted out and the result will be a 3 a 3 a 3 and then a 2 which are going into this output b 0 to b 3.
6.srt	00:34:20.690 --> 00:34:23.150	So, when I want the maximum shift.
6.srt	00:34:23.470 --> 00:34:33.370	So, you will be seeing that all the a 0 to a 2 are shifted out and then the result will have bits are going to be only a 3 in this.
6.srt	00:34:33.849 --> 00:34:38.530	So, as an example how the switching is going to be done is shown in this.
6.srt	00:34:38.910 --> 00:34:44.369	So, what is the result I want a 2, a 3, a 3, a 3 on the my b 0s.
6.srt	00:34:44.590 --> 00:34:54.099	So, you will be seeing that S 2 switch is closed wherever you have seen the S 2 switch you have it is marked highlighted here.
6.srt	00:34:54.380 --> 00:34:57.900	So, these are the ones which is going to these lines are going to be connected.
6.srt	00:34:58.349 --> 00:35:01.010	So, when you connect this one what happens?
6.srt	00:35:01.260 --> 00:35:04.070	So, you will be seeing this red line correct.
6.srt	00:35:05.730 --> 00:35:25.760	your a 2 is going to be pushed into b 0 and then your a 3 is going to be pushed into b 1 and then a 3 will be pushed into b 2 also and a 3 as it is it will be in b 3.
6.srt	00:35:26.079 --> 00:35:36.619	So, you will be getting the output as a 2 a 3 a 3 a 3 that is what we wanted since a switch is closed this is how the barrel shifter works.
6.srt	00:35:36.929 --> 00:35:38.210	So, one can try.
6.srt	00:35:38.470 --> 00:35:42.780	how the left shift operation is going to happen.
6.srt	00:35:42.780 --> 00:35:51.370	So, you hope you have done a little bit on microprocessor 885 or something like that there are two ways of shifting left.
6.srt	00:35:51.660 --> 00:36:04.180	So, either you can push the 0 into the first LSB bit or you can push the carry into your or last MSB into your LSB bit.
6.srt	00:36:04.470 --> 00:36:08.660	So, you can try how you can implement using the barrel shifter.
6.srt	00:36:10.019 --> 00:36:17.500	Now, we say that multiply and accumulate what we needed, how it is going to be represented in 6713.
6.srt	00:36:17.950 --> 00:36:32.100	So, we will be we said we want a MAC operation, but the later versions all 6 6 processors have only multiplier and accumulator separately which will be done in parallel.
6.srt	00:36:32.600 --> 00:36:39.530	So, common DSP applications we said filters and then Fourier fast Fourier transform what we want to implement.
6.srt	00:36:39.700 --> 00:36:43.020	2 of it and then rest of the things you can consider.
6.srt	00:36:43.390 --> 00:36:46.750	So, what is their equation what it is shown here.
6.srt	00:36:46.750 --> 00:36:56.640	So, here y of n is x of n minus k that is my input and this is my filter coefficients.
6.srt	00:36:56.970 --> 00:37:04.240	So, you would have seen that some of the equation it looks like your convolution equation.
6.srt	00:37:10.020 --> 00:37:23.550	So, either x of n into h of n minus k would have been comfortable but we use here input for X of n minus k and then H of k why I will consider it when we take up the architecture further I need circular convolution what I need it.
6.srt	00:37:23.550 --> 00:37:28.740	So, we will be taking it up in the next class and then see why I need that.
6.srt	00:37:29.490 --> 00:37:49.850	So, the next one I know that the X of k is my Fourier output and X of is in input X of n and then e power minus j to pi n k by n and this also I need multiplication and accumulation I can consider sine and then cos function separately and then do it parallelly.
6.srt	00:37:49.850 --> 00:37:55.130	So, we will see when I take up FFT how we will be doing the.
6.srt	00:37:55.590 --> 00:37:58.770	operations in our DSP processor.
6.srt	00:37:58.770 --> 00:38:04.350	So, coming to MAC operations we said in parallel what it is going to happen.
6.srt	00:38:04.680 --> 00:38:06.820	So, what are the things we needed?
6.srt	00:38:07.430 --> 00:38:17.090	So, if n products to be accumulated we know that we need n minus 1 multiplies can overlap with the accumulation basically.
6.srt	00:38:27.000 --> 00:38:35.280	That is during the first multiply accumulator is going to be idling in the next clock onwards we can do the thing parallelly and the last clock cycle because I one value is left out to be added.
6.srt	00:38:35.580 --> 00:38:39.960	So, this will be adding the last product.
6.srt	00:38:40.640 --> 00:38:49.750	So, to compute MAC for n products we say that we need n plus 1 instruction execution cycles are going to be required.
6.srt	00:38:58.160 --> 00:39:01.880	If n is much greater than 1 it is almost equivalent to 1 and then we say that MAC operation per instruction cycle what I will be getting it instead of n plus 1.
6.srt	00:39:02.200 --> 00:39:15.660	So, you will be seeing that either adder or subtractor we have not discussed the subtractor we will be using the adder itself for our subtraction because we are doing it in the two complements.
6.srt	00:39:15.660 --> 00:39:26.110	So, I do not need a separate subtractor only the one of the thing what we have to say is I want to do the subtraction.
6.srt	00:39:26.440 --> 00:39:28.880	So, that it will be happening in the two's complement.
6.srt	00:39:29.920 --> 00:39:58.240	So, are 2 n what is the input and then for the addition and you are seeing the sorry first multiplier is n bit 2 n bits are coming I will be doing the multiplication and product register will hold the 2 n bits which are fed as input to our adder and then which is coming in here as 2 n and whatever accumulator is storing in the thing which is fed back.
6.srt	00:39:58.550 --> 00:40:00.090	So, which is going to be added.
6.srt	00:40:00.500 --> 00:40:04.140	in the accumulator and then the output will be coming out of it.
6.srt	00:40:04.180 --> 00:40:11.790	Then we will final round will be making 2 n to n when we are storing back in the memory.
6.srt	00:40:11.920 --> 00:40:23.670	So, just to see that how the each instruction is going to take we will see that what is the time required for MAC operation.
6.srt	00:40:24.140 --> 00:40:34.600	So, we say that if I want to do 1024 products to be computed using a MAC unit and if the MAC execution time we have given it as 15 nanosecond.
6.srt	00:40:35.059 --> 00:40:36.880	the hardware takes.
6.srt	00:40:37.190 --> 00:40:41.320	So, we have to say what is the total time required to compute the operation.
6.srt	00:40:41.760 --> 00:40:44.539	So, we said 1024 MAC what we needed.
6.srt	00:40:44.900 --> 00:40:52.519	So, we need basically n plus 1 which is nothing, but 1025 execution cycles what we needed.
6.srt	00:40:52.849 --> 00:41:08.700	So, the total time required what we are putting is 1025 into because each operation is taking 10 15 nanosecond which is nothing, but 15 into 10 power minus 9, 1 nanosecond is equal to 10 power minus 9 second.
6.srt	00:41:10.990 --> 00:41:16.260	So, which comes 51.25 microseconds which is required to do this computation.
6.srt	00:41:16.490 --> 00:41:21.920	So, you can see which is very small it depends on the clock speed of your processor.
6.srt	00:41:22.190 --> 00:41:32.559	Coming to we said we need this scaling we have taken care of in the multiplication by considering only fractional numbers.
6.srt	00:41:32.559 --> 00:41:40.480	So, that the result of the multiplier is not going to overflow, but we have a constrained in the adder.
6.srt	00:41:41.390 --> 00:41:47.519	So, how overflow and underflow can be taken care in the MAC operations.
6.srt	00:41:47.769 --> 00:41:51.970	So, our addition or subtraction cause of overflow or underflow.
6.srt	00:41:52.519 --> 00:41:59.620	To take care of this most of the DSP processor have 40 bits for as a accumulator.
6.srt	00:41:59.990 --> 00:42:03.590	We call it as long addition what we can have it.
6.srt	00:42:03.590 --> 00:42:05.530	So, then 40 bits are going to be used.
6.srt	00:42:06.120 --> 00:42:16.019	If it is a 16 bit 2 operands the maximum can be 32 plus 1 carry bit, but we say we can accommodate the overflow of.
6.srt	00:42:16.300 --> 00:42:19.200	to 2 power 8 bits in this case.
6.srt	00:42:19.560 --> 00:42:27.450	So, the barrel shifter at input and output to normalize the values what we needed and the other one is the saturation logic.
6.srt	00:42:28.110 --> 00:42:43.020	We know that when there is a saturation happens if the maximum value is more than the whatever the processor can represent it goes as a negative value.
6.srt	00:42:43.370 --> 00:42:47.570	So, we want to restrict to that the maximum value.
6.srt	00:42:47.910 --> 00:42:54.780	So, the largest and then what we say is overflow accumulator has to stop.
6.srt	00:42:55.080 --> 00:43:16.490	So, in that case for 16 bit processor the maximum value what we can represent a sign number what we are considering it is going to be 0x7FFF in hex which is nothing but 32767 and the minimum number what I can represent is 0x800 minus 32768.
6.srt	00:43:22.690 --> 00:43:23.610	So, these are the values what has to be output if it is below this value or above this value.
6.srt	00:43:23.850 --> 00:43:27.120	So, this is taken care of in the hardware.
6.srt	00:43:27.510 --> 00:43:41.780	So, we have the least negative value and then the most positive value and you are taking the sign bit MSB and then you are going to consider whether it is going to exceed one of it you are doing the exclusive var.
6.srt	00:43:42.150 --> 00:43:54.050	So, you will be setting overflow or underflow bit is set then you will see that the maximum value is going or minimum value is going to be stored in the accumulator which is going to be output.
6.srt	00:43:54.480 --> 00:44:23.650	So, this is our arithmetic logic unit apart from addition it has to take care of our the increment decrement negate or other operations and then shift multiply and additional features in the like other processes we should have a status flags for sign 0 or carrier overflow and then overflow management via saturation logic can be incorporated and register files for.
6.srt	00:44:24.620 --> 00:44:26.740	storing the intermediate results.
6.srt	00:44:27.100 --> 00:44:38.680	So, coming to the bus architecture, it depends on the cost speed and size of DSP process basically width of the bus and memory.
6.srt	00:44:38.920 --> 00:44:50.130	So, we have two architecture lot of normal CPUs use one human architecture whereas, DSP processor use the Harvard architecture.
6.srt	00:44:50.480 --> 00:44:58.860	So, in this case both address and data bus are as you will be seeing that program and data reside in the same memory.
6.srt	00:44:59.310 --> 00:45:04.290	and single bus to access both your address as well as data.
6.srt	00:45:04.290 --> 00:45:14.930	So, which is going to slow down the program execution whereas, in this case so, we will be having program memory separate and then data memory separate.
6.srt	00:45:14.930 --> 00:45:21.010	So, I can access the program from the program memory and then data from the data memory.
6.srt	00:45:21.280 --> 00:45:26.810	As we know that there are two operands what I needed for my multiplication and accumulation.
6.srt	00:45:27.130 --> 00:45:33.020	So, the coefficients which are already designed and fixed I can store it in my program memory.
6.srt	00:45:33.430 --> 00:45:43.180	And once the program fetch operand opcode has been fetched I can release this bus and then get the data from here.
6.srt	00:45:43.600 --> 00:45:51.910	So, that is what it says separate program and data memory faster execution that is what it says how to fetch two operands.
6.srt	00:45:52.290 --> 00:46:07.400	So, in summary of this class we discussed little bit on Von Neumann and then Harvard architecture how we can design parallel multiplier and then how we can do the shifting parallel shifting using barrel shifter.
6.srt	00:46:08.210 --> 00:46:10.780	and then the bus architecture we saw it.
6.srt	00:46:11.050 --> 00:46:15.560	So, whether we have to have 2 n bus or n bus.
6.srt	00:46:16.110 --> 00:46:26.190	In the next class we will discuss about memory, how we will be incorporating a pipeline and parallel architecture using our hardware.
6.srt	00:46:26.810 --> 00:46:28.940	So, thank you.
6.srt	00:46:29.430 --> 00:46:31.950	So, we will meet in the next class.
54.srt	00:00:01.219 --> 00:00:25.370	Welcome back to real time digital signal processing lab.
54.srt	00:00:25.679 --> 00:00:28.339	So today we will see DCT.
54.srt	00:00:28.809 --> 00:00:33.820	So how we are going to implement discrete cosine transform with quantization.
54.srt	00:00:34.179 --> 00:00:38.409	So how much we can see the view or image.
54.srt	00:01:10.969 --> 00:01:13.519	then look at it so the first we will see the MATLAB so you will be seeing that these are the students who are developed it as you can see this shows as an assignment 7 basically here we will be considering the histogram equalization that is when we feel that the image is little black so we want to do the histogram equalization to give the perception a little bit clear The other one is the noise what it has.
54.srt	00:01:13.759 --> 00:01:17.509	So, by using the gamma correction it is going to improve upon it.
54.srt	00:01:17.870 --> 00:01:24.799	And the other one is whatever demo I will be showing is with respect to DCT.
54.srt	00:01:25.209 --> 00:01:33.209	So, we will run this code actually and then see how we are going to get the images out.
54.srt	00:01:33.549 --> 00:01:36.739	So, we will go to this folder.
54.srt	00:01:37.239 --> 00:01:40.030	So, you will be seeing this is a GUI developed.
54.srt	00:01:40.390 --> 00:01:41.969	So, as you can see the thing.
54.srt	00:01:42.469 --> 00:01:46.359	It has DCT histogram equalization and gamma correction.
54.srt	00:01:46.719 --> 00:01:50.280	So, we can load the image as an input.
54.srt	00:01:50.549 --> 00:01:53.799	So, we will see that load an image.
54.srt	00:01:54.120 --> 00:02:00.620	So, the first what we will do is load our first image as a baby image ok.
54.srt	00:02:00.620 --> 00:02:04.710	So, you will be seeing this is the image what it has got loaded ok.
54.srt	00:02:04.710 --> 00:02:06.950	So, we will do the DCT.
54.srt	00:02:07.450 --> 00:02:12.310	So, you will be seeing that the knob can vary from here to here.
54.srt	00:02:14.050 --> 00:02:27.230	Only the thing is in this case the slider values have not been given in steps of you have to go back to the code and see how what will be the steps of the slider is going to move ok.
54.srt	00:02:27.719 --> 00:02:35.189	So, now, we will run the DCT in this is the compression whatever it is shown with the slider.
54.srt	00:02:35.540 --> 00:02:36.670	So, we will run it.
54.srt	00:02:38.110 --> 00:02:42.790	So, this compression has not much change the output.
54.srt	00:02:42.790 --> 00:02:48.900	So, you will be seeing the histogram of the original image and histogram of the.
54.srt	00:02:49.490 --> 00:02:50.319	So, almost they look alike.
54.srt	00:02:50.319 --> 00:03:02.389	So, now, what we will do is we will increase the slider little bit and then I will be doing the DCT.
54.srt	00:03:08.539 --> 00:03:15.009	So, now, what you have seeing is only the complete thing has gone to black.
54.srt	00:03:15.009 --> 00:03:20.930	So, the compression what we have taken is almost more than 70 percent what we can see.
54.srt	00:03:21.319 --> 00:03:24.560	a little bit reduce and then do the DCT of it.
54.srt	00:03:26.360 --> 00:03:27.879	So, we have got back the thing.
54.srt	00:03:28.280 --> 00:03:35.270	So, this way you will know that what how much compression you can achieve with respect to this.
54.srt	00:03:35.330 --> 00:03:40.250	Now, if I want to do the histogram equalization.
54.srt	00:03:40.250 --> 00:03:46.620	So, we will load a different image to see that whether we are going to look at that difference or not.
54.srt	00:03:46.680 --> 00:03:48.900	So, we load the Einstein image.
54.srt	00:03:49.620 --> 00:03:51.699	So, you will be seeing this.
54.srt	00:03:52.010 --> 00:03:57.130	So, I can do the I can do DCT or histogram equalization.
54.srt	00:03:57.130 --> 00:03:59.420	So, we will run the histogram equalization.
54.srt	00:03:59.860 --> 00:04:20.210	So, you have seen that the original histogram is centered between this thing what is it black and then some of the grey values here ok. And then little part of it is here and after that we have 0, but I want to have the uniform distribution of the thing.
54.srt	00:04:20.580 --> 00:04:22.460	So, we do the equalization.
54.srt	00:04:22.460 --> 00:04:24.889	So, you can see how the image has got.
54.srt	00:04:25.290 --> 00:04:33.610	So, we can load the other image and then see whether it is going to give us a better histogram equalization.
54.srt	00:04:34.009 --> 00:04:37.050	So, we will run the histogram equalization for this.
54.srt	00:04:37.490 --> 00:04:47.180	So, you will be seeing that whatever that the background which were a little darker now you will be seeing that they have been exposed.
54.srt	00:04:47.180 --> 00:04:50.089	So, by doing the histogram equalization.
54.srt	00:04:50.560 --> 00:04:56.839	So, if you want to see background properly then you can do the histogram equalization.
54.srt	00:04:57.490 --> 00:04:58.439	and then run it.
54.srt	00:04:58.819 --> 00:05:02.069	Now, we will see how the gamma correction is going to happen.
54.srt	00:05:02.069 --> 00:05:06.500	So, now, this is what the gamma correction.
54.srt	00:05:06.500 --> 00:05:12.800	So, if I will increase the gamma part of it and then we will run the gamma correction.
54.srt	00:05:13.300 --> 00:05:21.689	So, you will be seeing that what happened is that you will not be seeing not much output.
54.srt	00:05:22.060 --> 00:05:29.639	So, by the this thing elimination of lot of noise what happened is we have lost the thing.
54.srt	00:05:30.599 --> 00:05:33.620	So, depends on what the gamma value is going to be.
54.srt	00:05:33.620 --> 00:05:42.500	So, here you are seeing that it is little darker at the background and then this is little bit prominent what you will be seeing.
54.srt	00:05:42.500 --> 00:05:49.719	This is how your gamma correction is going to happen and this are the histogram how when you do the gamma correction.
54.srt	00:05:50.129 --> 00:06:01.159	So, this way you can play around and then see what will be your output you can get the thing with different images.
54.srt	00:06:01.729 --> 00:06:11.719	So, now, we will see the other way of doing it this is from the same batch one more student how he has implemented we will look at it.
54.srt	00:06:12.170 --> 00:06:15.050	So, we will run the code again.
54.srt	00:06:15.389 --> 00:06:18.509	So, it is from a different flow folder.
54.srt	00:06:18.550 --> 00:06:24.810	So, we will be changing it and you will be seeing that this is the GUI what it has got ok.
54.srt	00:06:25.310 --> 00:06:28.329	Here also you have to select a image file.
54.srt	00:06:28.990 --> 00:06:31.279	So, these are the.
54.srt	00:06:31.679 --> 00:06:33.919	images are stored in a different file.
54.srt	00:06:34.359 --> 00:06:41.729	So, you will be seeing different images basically from black and white and color images what you have it.
54.srt	00:06:41.729 --> 00:06:47.429	So, we will see that you know the personality of this person.
54.srt	00:06:47.429 --> 00:07:00.000	So, we will do the DCT compression one second because the aspect ratio is more you are unable to see the figure here.
54.srt	00:07:01.929 --> 00:07:05.489	I will change the thing for the viewing thing and then come back from the settings.
54.srt	00:07:06.119 --> 00:07:19.029	So, we will change it to 100 and then we will run this code ok.
54.srt	00:07:19.029 --> 00:07:24.729	So, now you would be I will be aligning the thing.
54.srt	00:07:24.949 --> 00:07:26.639	So, we will select the image.
54.srt	00:07:26.639 --> 00:07:33.149	So, the images what you have seeing the thing this is the input image.
54.srt	00:07:33.579 --> 00:07:35.859	I am going to do first DCT compression.
54.srt	00:07:36.139 --> 00:07:43.219	See here as you can see the compression factor is varying between 0 to 1 in this case.
54.srt	00:07:43.489 --> 00:07:45.019	So, if I change it.
54.srt	00:07:46.069 --> 00:07:54.649	So, we will do the what is the compression factor what we shown in the class that it has taken it as 4.8832 is the compression.
54.srt	00:07:54.649 --> 00:07:57.000	So, do the DCT compression.
54.srt	00:07:57.000 --> 00:08:05.609	So, you are not seeing much changes in the thing again I will increase the thing.
54.srt	00:08:06.229 --> 00:08:07.739	do the DCT compression.
54.srt	00:08:08.449 --> 00:08:11.239	So, you are not identifying much of it.
54.srt	00:08:11.239 --> 00:08:16.739	So, in this case it is between 0 and 1 what they have selected.
54.srt	00:08:18.469 --> 00:08:22.269	So, this is sorry the output was taking little time to come.
54.srt	00:08:22.639 --> 00:08:26.019	So, even with 20 compression factors.
54.srt	00:08:26.019 --> 00:08:31.969	So, you will be seeing not much difference between the this is the input image, this is the output image.
54.srt	00:08:31.969 --> 00:08:36.789	So, I can reduce it, we will do the DCT compression.
54.srt	00:08:40.439 --> 00:08:42.279	ok, not much difference.
54.srt	00:08:42.600 --> 00:08:59.529	Now, we will see that what is the thing is going to happen, we will load a different image I can go to the images.
54.srt	00:09:00.009 --> 00:09:07.149	So, you will see that this image basically how is going to.
54.srt	00:09:07.389 --> 00:09:10.969	So, we will do the gamma correction for it.
54.srt	00:09:25.969 --> 00:09:28.189	Now, it has loaded the thing.
54.srt	00:09:28.609 --> 00:09:33.799	So, you are seeing that the plane is not much visible.
54.srt	00:09:34.189 --> 00:09:36.189	So, we will do the gamma correction.
54.srt	00:09:40.919 --> 00:10:03.189	As you can see that the background has also become little brighter and then even the plane is completely visible and then you are seeing the whatever luggage carriers what you know of actually which are there and even the whatever the petrol fueling thing is also visible.
54.srt	00:10:03.579 --> 00:10:06.669	So, I can do that.
54.srt	00:10:06.729 --> 00:10:11.939	So, if I want to do the compression I can look at the compression how it is going to look like.
54.srt	00:10:12.449 --> 00:10:13.859	with our original image.
54.srt	00:10:25.369 --> 00:10:29.109	So, not much to the original image.
54.srt	00:10:29.339 --> 00:10:32.829	So, you will be seeing that not much changes has happened.
54.srt	00:10:33.379 --> 00:10:40.689	So, in this case gamma correction has helped us to get more clearer one.
54.srt	00:10:40.799 --> 00:10:42.179	So, we will see.
54.srt	00:10:42.689 --> 00:10:53.289	By doing the histogram equalization we will select an image file again to show that their functions are working properly.
54.srt	00:10:53.599 --> 00:11:01.359	Since it is running in loop it will take little time to come read the thing.
54.srt	00:11:01.449 --> 00:11:05.399	So, this we will see that this is a low light this thing.
54.srt	00:11:05.429 --> 00:11:08.829	So, we will use this still it has not loaded the image.
54.srt	00:11:23.990 --> 00:11:33.750	So, you are seeing it this has a low lighting conditions as you can see, we will do the histogram equalization for it, still it is processing.
54.srt	00:11:36.479 --> 00:11:39.519	So, now, you can see that whatever the lighter.
54.srt	00:11:39.519 --> 00:11:46.209	So, you are seeing the reflection completely in this thing water in front of it.
54.srt	00:11:51.159 --> 00:11:54.089	And, this is become much brighter.
54.srt	00:11:54.729 --> 00:12:11.419	So, this way you can have a different ways of doing your DCT compression and then your gamma correction and then histogram equalization by making a different image processing applications you can incorporate.
54.srt	00:12:11.819 --> 00:12:19.019	So, in this as an application what I will do is our audio file.
54.srt	00:12:24.449 --> 00:12:31.879	So, I said we have not covered the what I will call it as interpolation and decimation.
54.srt	00:12:31.879 --> 00:12:38.289	So, our audio application one can use it at different sampling frequencies.
54.srt	00:12:38.370 --> 00:12:41.719	In this case we show that input is 44.1 kilohertz input.
54.srt	00:12:42.139 --> 00:12:49.979	How we can convert it into a 48 kilohertz is this.
54.srt	00:12:54.249 --> 00:12:56.109	demo is going to show you.
54.srt	00:12:56.449 --> 00:13:13.919	So, this way you can incorporate and what are the filters will be choosing it, it is going to be FIR filter what it has been chosen of different length and then we will have three stages in this case to run the algorithm.
54.srt	00:13:14.409 --> 00:13:25.979	So, one is decimation, the other one is interpolation what we are going to have it in the second stage and the last stage is going to do again decimation.
54.srt	00:13:27.959 --> 00:13:37.709	So, to get our So, you may not feel the audio file, but from looking at their responses we will see that how it is going to look like.
54.srt	00:13:37.709 --> 00:13:37.829	.
54.srt	00:13:37.909 --> 00:13:37.969	.
54.srt	00:13:37.969 --> 00:13:38.159	So, you are .
54.srt	00:14:16.689 --> 00:14:29.179	So, seeing that how the changes is going to happen that is 3 stage output what you are hearing the sine wave from 44 kilohertz to 48 kilohertz which got modified ok.
54.srt	00:14:29.509 --> 00:14:33.309	So, did you notice any differences between the two?
54.srt	00:14:33.849 --> 00:14:36.659	So, that is what the thing is going to be.
54.srt	00:14:36.659 --> 00:14:41.359	So, if you want to expand here so, we will see that.
54.srt	00:14:50.049 --> 00:14:51.859	So, you can do this zoom in.
54.srt	00:14:52.799 --> 00:15:03.849	So, to see the frequencies what it has got.
54.srt	00:15:04.239 --> 00:15:11.369	So, from this is input that is 44.1 kilohertz to 48 kilohertz what it has got transmitted.
54.srt	00:15:11.489 --> 00:15:17.789	How it 3 stages what it has done the thing that you will be seeing in this figure.
54.srt	00:15:17.789 --> 00:15:22.629	So, the original you will be seeing it in red and then.
54.srt	00:15:23.479 --> 00:15:24.279	What is it?
54.srt	00:15:24.729 --> 00:15:32.899	You will be seeing it is getting pushed to little bit black and then little green and then the final is your blue.
54.srt	00:15:32.899 --> 00:15:45.729	So, you will be seeing here this is original, this is stage 1 what it has got little bit shifted and then later on this and later on this is the final.
54.srt	00:15:46.079 --> 00:15:51.449	So, instead of because it is not possible to shift from 44.1 kilohertz it is an odd number to.
54.srt	00:15:56.579 --> 00:16:12.779	So, we do what we call it as multiple times so that the output will be visible that is what the MATLAB what is shown the same experiment is available even in the code composer studio.
54.srt	00:16:13.019 --> 00:16:17.469	So, we will take up now the code composer studio.
54.srt	00:16:33.209 --> 00:16:35.729	We will start our code composer studio.
54.srt	00:16:37.579 --> 00:16:45.849	What is happening is as you are seeing it, so it is creating it has little bit crashed I think so when shutting down.
54.srt	00:16:45.849 --> 00:16:47.669	So we will open a new this thing.
54.srt	00:16:47.669 --> 00:16:58.379	I will call it as V9 because recently I have closed it.
54.srt	00:16:58.379 --> 00:17:01.459	So we will launch a new.
54.srt	00:17:01.499 --> 00:17:01.529	workspace.
54.srt	00:17:02.089 --> 00:17:18.519	All the files whatever demos have been shown.
54.srt	00:17:18.519 --> 00:17:28.159	So, I have put it in CCS 9 as you can see the things.
54.srt	00:17:28.159 --> 00:17:32.599	So, I have to pull out these files now into the new workspace.
54.srt	00:17:33.259 --> 00:17:37.149	And, then I have to load them let it come up.
54.srt	00:17:37.149 --> 00:17:51.029	So, we were discussing about the DCT and then I have the other and we will see little on echo today on the DSP processor.
54.srt	00:17:51.359 --> 00:17:55.369	Some of the equalizer and other things are giving little error in the thing.
54.srt	00:17:55.789 --> 00:18:04.240	So, till I settle solve the problem once it is done in the next class we will be taking the demo of it.
54.srt	00:18:04.589 --> 00:18:08.519	So, what I will do is I will copy these directories to here.
54.srt	00:18:09.729 --> 00:18:11.309	Hopefully one shot it should work.
54.srt	00:18:11.339 --> 00:18:19.199	Let us see if everything is copied otherwise we may have to copy the include files and then libraries.
54.srt	00:18:19.229 --> 00:18:34.499	If it ask you to install you can sometimes it gives an error.
54.srt	00:18:34.499 --> 00:18:37.669	So, it is better to.
54.srt	00:18:38.579 --> 00:18:44.009	not to install the new one whatever you have installed the original let it be there.
54.srt	00:18:44.599 --> 00:18:51.249	So, we will open the thing, we will open the from the project from the directory.
54.srt	00:18:51.409 --> 00:18:59.629	So, we will put the thing, I will be opening this folders hopefully.
54.srt	00:18:59.629 --> 00:19:10.889	If you want to create a new project you can go and then create it since all that already these projects have been running.
54.srt	00:19:12.449 --> 00:19:18.500	So, what I will be doing is you will be getting started and everything in your code composer studio.
54.srt	00:19:18.949 --> 00:19:21.119	So, you can have a look at them.
54.srt	00:19:49.299 --> 00:19:53.490	So, we will first run the DCT let because I had to because it is a new workspace I had to do compilation first and this is the C file in the mean time let the compilation happen we will see what is it.
54.srt	00:19:53.959 --> 00:20:03.399	So, this is what you are hopefully you are able to read the thing I am reducing this also.
54.srt	00:20:04.469 --> 00:20:06.579	So, this is the code what we have it.
54.srt	00:20:06.990 --> 00:20:13.000	So, here you are defining 64 by 64 image.
54.srt	00:20:13.439 --> 00:20:19.740	So, you will be considering 64 by 8 to the power of 2 what you will be looking at it.
54.srt	00:20:20.289 --> 00:20:28.469	Because, you are going to give image file dot h file has to be input as this or you have to read from the file.
54.srt	00:20:28.869 --> 00:20:36.029	As you know in the hardware it is going to be in a continuous memory what you will be storing it.
54.srt	00:20:36.509 --> 00:20:43.419	We may not be able to read 8 by 8 image correctly.
54.srt	00:20:43.679 --> 00:20:46.149	So, you will be storing it as dot h file.
54.srt	00:20:46.250 --> 00:20:50.139	So, if you see that image file dot h you will be looking at.
54.srt	00:20:50.479 --> 00:20:51.549	So, it is a continuous.
54.srt	00:20:51.549 --> 00:21:14.279	So, you will be seeing that it is a 64 by 64 the image has been taken from the MATLAB and then dot h file values have been created and then you will be storing it in the continuous format like this which you will be inputting it into your CCS ok.
54.srt	00:21:14.449 --> 00:21:18.359	So, this thing is going to run in your.
54.srt	00:21:22.279 --> 00:21:26.919	what we will call it as even simulator you can run the thing.
54.srt	00:21:27.379 --> 00:21:32.289	So, if you want you can have the leno.h also what you can look at it.
54.srt	00:21:32.289 --> 00:21:38.289	So, and then it can be image file up to 128 by 128 what it has supported.
54.srt	00:21:38.289 --> 00:21:46.399	Otherwise, we have the input directly from the camera you can feed it in and then do the compression and then take it out also.
54.srt	00:21:46.399 --> 00:21:47.889	So, both.
54.srt	00:21:51.629 --> 00:22:03.869	DCT and IDCT have been incorporated in this code basically and the compression factor what is this factor array compression ratio is chosen as 4 here.
54.srt	00:22:21.859 --> 00:22:30.179	So, if you want you can change the compression ratio here and then you will be seeing that whatever chromium and other things is 8 what you have taken it ok. And you will be allocating the memory and then you will be performing the DCT using this equation as you can see that it is direct DCT has been implemented.
54.srt	00:22:30.769 --> 00:22:36.049	So, less than n so, you will be seeing that there will be a 4 for loops here.
54.srt	00:22:36.119 --> 00:22:40.169	So, that is why order of n power 4 it is going to be.
54.srt	00:22:40.449 --> 00:22:47.599	So, if you want to reduce it so, you can go and then use a butterfly structure to implement the thing.
54.srt	00:22:48.139 --> 00:22:53.709	So, you will be seeing that calculating you are doing the compression here.
54.srt	00:22:54.159 --> 00:22:57.789	whatever CR value what you have chosen the thing and then.
54.srt	00:22:58.159 --> 00:23:24.239	So, you will be doing row wise and then column wise and then once you have stored this you have made the rest of them 0s whatever is less than what you are selecting the thing the values DCT matrix you are making them 0s ok. And then you will be storing it.
54.srt	00:23:24.639 --> 00:23:26.669	and then do the idct.
54.srt	00:23:27.169 --> 00:23:30.929	So, this is what the output is going to be.
54.srt	00:23:30.929 --> 00:23:35.279	So, matrix u comma v will be your idct.
54.srt	00:23:35.279 --> 00:23:39.539	So, you will be seeing from this thing a main function is here.
54.srt	00:23:40.049 --> 00:23:54.259	So, you will be seeing that total by compression ratio what you have set the thing and then compression ratio parameter what you have set it here square root of CR and you will be sealing that basically.
54.srt	00:23:56.729 --> 00:24:08.329	So, not to have the We will call it as decimal values are avoided only integer what you will be selecting the thing to the higher what you have sealed the thing.
54.srt	00:24:08.659 --> 00:24:11.649	So, you will be seeing that some of the assignment.
54.srt	00:24:11.929 --> 00:24:14.599	So, you are putting it as a test block.
54.srt	00:24:14.929 --> 00:24:22.929	So, your input image block wise what you are operating 8 by 8 blocks i comma j what you will be working on.
54.srt	00:24:23.599 --> 00:24:28.959	This is the DCT you are passing the test DCT or image.
54.srt	00:24:29.539 --> 00:24:37.389	And, then block whatever the you have selected test block and then you will be giving x and y dimensions.
54.srt	00:24:37.799 --> 00:24:45.749	Then once you have done that DCT which uses the compression also, then I you will be doing IDCT.
54.srt	00:24:46.399 --> 00:24:47.569	As you can see there are.
54.srt	00:24:54.709 --> 00:24:59.439	So, first we have to make clean and then run the project.
54.srt	00:25:54.469 --> 00:25:56.989	ok. As I have mentioned in the first class we have to go to properties.
54.srt	00:25:57.519 --> 00:26:17.249	So, when we have this the latest version support ELF file format, but what we want is the legacy cof file generation in the new one.
54.srt	00:26:17.739 --> 00:26:24.539	So, I have to apply and then close hopefully we will not get any errors let us see the thing.
54.srt	00:26:28.109 --> 00:26:36.159	That is the reason why it was cribbing that no this thing what is it make option is available.
54.srt	00:26:36.289 --> 00:26:48.779	When you get this error it is better to go for sometimes even the warnings you may have to see that if it has to be eliminated you have to eliminate warnings.
54.srt	00:26:48.779 --> 00:26:52.059	So, in this case what it says is.
54.srt	00:26:56.779 --> 00:26:59.519	declared in the thing and then it is not used.
54.srt	00:26:59.519 --> 00:27:00.089	So, that is fine.
54.srt	00:27:00.089 --> 00:27:19.449	So, what we will do is we will build the thing ok, because I have started the new project thing.
54.srt	00:27:20.269 --> 00:27:24.669	So, what I have is I do not have the target configuration.
54.srt	00:27:27.589 --> 00:27:29.239	So, I have to specify which I will be using it.
54.srt	00:27:29.669 --> 00:27:38.439	So, it is going to load the target configuration and it will ask me which one you want to have it, I have to wait for it to give me that.
54.srt	00:27:50.769 --> 00:27:58.149	The first time it is going to take little longer time ok. Usually whatever demos all these days I was doing it.
54.srt	00:27:58.509 --> 00:28:02.989	So, it was prebuilt so, that I need not have to waste time on the thing.
54.srt	00:28:03.409 --> 00:28:07.439	Today because one of the workspace it is having a problem.
54.srt	00:28:07.439 --> 00:28:08.769	So, I had to recreate it.
54.srt	00:28:09.169 --> 00:28:14.189	So, it is running for the first time, it is going to take a little time on the thing.
54.srt	00:28:14.569 --> 00:28:18.719	It is asking me to update it.
54.srt	00:28:18.839 --> 00:28:21.039	So, we will not do any updation here.
54.srt	00:28:27.969 --> 00:28:31.769	So, when we rerun the thing second time it is going to be.
54.srt	00:28:32.229 --> 00:28:55.179	much faster ok. One more thing what I can do is I can stop the debugging and then go back and then give it a I will call it as new because it was asking me for the target configuration file I will give it as configuration.
54.srt	00:28:55.259 --> 00:28:56.649	So, we will try to finish it.
54.srt	00:28:56.649 --> 00:29:00.529	So, it will ask me which one I am going to use it here.
54.srt	00:29:07.579 --> 00:29:08.739	So, what I have is as I I told you in the beginning.
54.srt	00:29:09.089 --> 00:29:21.609	So, I have a XDS110 debug USB debug what I have connected here and then it is going to be LCDK6748 board what I am using it.
54.srt	00:29:21.609 --> 00:29:40.459	So, this is the target configuration what I will be giving it and then I will save this one and then I can do the test the connection whether it is getting connected or not.
54.srt	00:29:40.869 --> 00:29:44.639	So, you will be looking at it software log files and other things.
54.srt	00:29:44.639 --> 00:29:50.629	So, it is connected to the board or not what it is testing.
54.srt	00:29:50.629 --> 00:30:01.369	Some of this scan test what it says is it is failed anyway finally, it says scan has succeeded ok.
54.srt	00:30:01.369 --> 00:30:08.499	So, that is how the board whatever you are going to connect it you can look at them.
54.srt	00:30:08.899 --> 00:30:11.789	So, we will recompile the thing.
54.srt	00:30:13.569 --> 00:30:21.089	So, and then see whether it will go it is as you can see the debugger is going and loading on to the board.
54.srt	00:30:21.089 --> 00:30:50.639	Some of the whatever you have configured.
54.srt	00:30:50.639 --> 00:30:51.889	Your memory you can.
54.srt	00:30:52.449 --> 00:30:54.729	You have assigned Kellogg basically.
54.srt	00:30:55.189 --> 00:31:02.979	So, you can release them later on you will be freeing the memory once you come out of the loop.
54.srt	00:31:07.679 --> 00:31:12.139	As you can see you will be freeing them in the end.
54.srt	00:31:14.039 --> 00:31:18.919	All the blocks what you have assigned nothing they are going to be freed.
54.srt	00:31:27.479 --> 00:31:35.519	you will be seeing that everything has got loaded onto the board and your pointer is at the main here.
54.srt	00:31:36.099 --> 00:31:40.889	So, now, you have got icon to run and then if you want to break you can do the thing.
54.srt	00:31:41.349 --> 00:31:52.609	So, what we will do is we will put a break point here so that and run the code.
54.srt	00:31:57.799 --> 00:31:58.949	So, it has finished it.
54.srt	00:31:59.359 --> 00:32:23.899	So, you will be seeing that whatever the modification values are dimension of y, x and then i and j, k, k is gone up to 64 and then what we will see is because it is in this case although image analyzer is there it is giving little problem in this version.
54.srt	00:32:23.959 --> 00:32:30.149	So, what we have to do is we have to view the memory basically.
54.srt	00:32:32.199 --> 00:33:01.749	So, whether it has got So, we will go to the memory browser and then I can give output image is the where it is getting stored as you can see coming from the test adct, the value is going to be stored here.
54.srt	00:33:02.139 --> 00:33:05.529	So, you will be seeing that it is a floating point number.
54.srt	00:33:05.969 --> 00:33:19.359	So, you will be seeing that here it is stored in your data memory basically 1D what it shows and this is output image all the values what it has stored.
54.srt	00:33:19.639 --> 00:33:26.809	So, if you want you can write this memory back into a file and then you have to read it properly.
54.srt	00:33:26.889 --> 00:33:31.349	So, this is a floating point number what it has stored.
54.srt	00:33:31.419 --> 00:33:34.889	So, you can see that the values have come.
54.srt	00:33:34.889 --> 00:33:38.809	So, some of the values if you want to see the.
54.srt	00:33:39.509 --> 00:33:42.349	with respect to the original value.
54.srt	00:33:42.719 --> 00:33:46.409	So, you will be seeing that reconstructed we will look at it.
54.srt	00:33:46.829 --> 00:33:50.739	It is 804100 what we have it.
54.srt	00:33:51.139 --> 00:33:55.869	So, I can give it as input file we can dot h file what we can open.
54.srt	00:34:28.499 --> 00:34:31.209	Some values what you will be seeing is 100 or So, we have to check our memory ok.
54.srt	00:34:31.309 --> 00:34:48.859	So, once we close the thing the output file is not going to be available.
54.srt	00:34:49.159 --> 00:34:53.519	So, what you have to do is you can copy it and then paste it and then look at it.
54.srt	00:34:53.589 --> 00:34:55.139	So, the other one.
54.srt	00:35:00.689 --> 00:35:25.329	will see here also there will be a problem with the thing because this is from the book of you will be converting from YCBCR to RGB ok.
54.srt	00:35:25.759 --> 00:35:30.329	So, this is the DCT S dot C what it is gives ok.
54.srt	00:35:30.759 --> 00:35:33.519	from the code book what it has been selected.
54.srt	00:35:33.989 --> 00:35:42.679	So, I have to have the here also I have to call my CCXML.
54.srt	00:35:43.029 --> 00:35:46.479	So, what I can do is I can copy this one to here.
54.srt	00:35:46.689 --> 00:36:01.109	So, that I need not have to again put the thing and we have to see its properties again you will.
54.srt	00:36:01.819 --> 00:36:05.139	Here it is chosen as legacy cof file here.
54.srt	00:36:05.719 --> 00:36:16.019	So, I need not have to worry and then you will be when you are doing the thing the family I will be selecting it as C6000 and you will be seeing it as LCDK6748.
54.srt	00:36:16.499 --> 00:36:26.939	And then the compiler version for this board is although there are higher versions of it, it is better to use a TI v7.4.4 in this case.
54.srt	00:36:26.939 --> 00:36:38.089	So, we will just do that I am directly gone to do the debugging because.
54.srt	00:36:42.609 --> 00:36:45.049	It is asking me there is an error.
54.srt	00:36:46.349 --> 00:36:49.199	Oh, ok.
54.srt	00:36:49.499 --> 00:36:55.559	Here what happened was this code book gives 55 version.
54.srt	00:36:56.069 --> 00:36:59.669	I have this one DCT has been written in assembly.
54.srt	00:37:00.059 --> 00:37:05.439	So assembly with respect to 6, 7 and then 5, 5 are different.
54.srt	00:37:05.829 --> 00:37:11.909	Most of this as you know now why assembly coding is particular to one of the board.
54.srt	00:37:12.469 --> 00:37:42.949	So, we will modify this DCT to what we will call it as to the 6 7 processor and then we will see in the next class how we are going to implement this using assembly programming little bit of it what I will give a little flavor only multiplication what we can do it and then we can look at the rest of it if you are interested in assembly programming you can learn it and then implement it.
54.srt	00:37:43.589 --> 00:37:44.039	Thank you.
40.srt	00:00:01.219 --> 00:00:25.839	Welcome back to real time digital signal processing course.
40.srt	00:00:26.210 --> 00:00:30.350	So today we will be covering adaptive echo cancellation.
40.srt	00:00:31.009 --> 00:00:45.759	So, in the last class we discussed about how do we do the prediction and we saw scrambling why do we need it to protect our own voice or audio files from misuse of it.
40.srt	00:00:45.759 --> 00:00:53.399	So, we can do the scrambling and then send it to people who are only connected with our network.
40.srt	00:00:53.399 --> 00:01:01.570	The other one is echo generation so, most of the time we know that it is an hobby.
40.srt	00:01:02.009 --> 00:01:09.239	So, how to generate the echo first we have seen the thing today we will be seeing how to do the cancellation of echo.
40.srt	00:01:09.569 --> 00:01:32.179	So, most of the places what we visit which has the capability of echoing that is we will have stones and other things which sometimes if it our voices reflect then we will be enjoying that when you go when all of us go for a picnic or other places.
40.srt	00:01:32.569 --> 00:01:33.719	So, in this case.
40.srt	00:01:33.980 --> 00:01:38.299	Synthetic echo generation what we saw in the last class.
40.srt	00:01:38.729 --> 00:01:49.709	So, we will continue how to because this is one of the welcome for a hobbyist, but in some of the cases we will see in a while that how it is going to hinder our output.
40.srt	00:01:50.479 --> 00:01:54.539	So, we will be looking at it how to do the cancellation.
40.srt	00:01:55.299 --> 00:01:59.400	So, first is we will see the line echoes basically.
40.srt	00:01:59.400 --> 00:02:01.719	So, in this case what we have is.
40.srt	00:02:08.689 --> 00:02:35.539	This is the line indication that is most of you may ask that is what you will be getting the cartoon network saying that it is what is it antic whatever phone lines or telephones what we show it to the kids because they are used to mobile basically, but still some of the places only in the cities it may be not there, but in.
40.srt	00:02:37.739 --> 00:02:54.489	what we will call it as villages still all of us know that in those people are also using most places mobile phones, but still telephone communication is one of the part of for past life and then some places it is still there ok.
40.srt	00:02:54.959 --> 00:02:59.060	So, what is it what we call it as line or network ok.
40.srt	00:02:59.179 --> 00:03:08.029	So, it echo is caused by impedance mismatches at various point of interest what we will call it.
40.srt	00:03:08.029 --> 00:03:13.339	So, we are seeing this is a telephone where it is connected and then the.
40.srt	00:03:13.840 --> 00:03:17.949	This is from the sender side and this is the receiver if we call it.
40.srt	00:03:17.949 --> 00:03:20.409	So, these are the paths what it has to take it.
40.srt	00:03:20.719 --> 00:03:24.439	So, at different places you may have a echo basically.
40.srt	00:03:24.759 --> 00:03:34.180	So, we say this effects are they are going to depend on their loudness, spectral disk and time delay.
40.srt	00:03:34.579 --> 00:03:37.519	So, these are the ones which will be causing echo.
40.srt	00:03:37.519 --> 00:03:44.759	So, if there is no delay then we say that we are not hearing any echo from the transmission part of it.
40.srt	00:03:45.640 --> 00:03:58.490	What it says is longer delay requires a higher degree of echo attenuation and time delay between the original speech and then the echo is short then echo may not be noticeable.
40.srt	00:03:58.689 --> 00:04:01.390	So, we will be seeing in the lab.
40.srt	00:04:01.390 --> 00:04:04.379	So, how we are going to run the thing.
40.srt	00:04:04.980 --> 00:04:06.230	What is it?
40.srt	00:04:06.500 --> 00:04:12.740	This is a simplified telecommunication network which is being illustrated.
40.srt	00:04:13.080 --> 00:04:15.780	So, what are it contains basically.
40.srt	00:04:15.780 --> 00:04:20.800	So, this is the local telephone is connected to the central office by it.
40.srt	00:04:21.439 --> 00:04:28.339	2 wire line in which both directions of the transmission are carried on a single pair of wires.
40.srt	00:04:28.719 --> 00:04:33.989	So, as you can see here it is connected with 2 wire basically.
40.srt	00:04:34.399 --> 00:04:51.259	So, the connection between 2 central offices they use 4 wire facility which physically segregates the transmission from the 2 wire facilities and this is because long distance transmission requires.
40.srt	00:04:51.770 --> 00:04:56.130	repeated amplification that is a one way function.
40.srt	00:04:56.200 --> 00:05:08.370	So, you will be seeing that this is a of office 1 you call it office 2 basically you will be seeing 2 lines going from here and then other 2 lines to 4 lines what is going.
40.srt	00:05:08.720 --> 00:05:14.680	So, this is how it is connected and when you are putting it to the receiver.
40.srt	00:05:15.080 --> 00:05:17.120	So, you receiver telephone.
40.srt	00:05:17.120 --> 00:05:22.410	So, you will be seeing again from the office it will be 2 wire connection what we will be having it.
40.srt	00:05:23.100 --> 00:05:34.890	So, what happens in the thing is a hybrid located in the central office makes the conversion between the 2 wire and 4 wire facilities.
40.srt	00:05:35.270 --> 00:05:40.640	So, this is used for most homes and then small offices.
40.srt	00:05:40.890 --> 00:05:49.410	Otherwise, what we are going to have is basically exchanges switches through which you can be connected.
40.srt	00:05:50.260 --> 00:05:53.050	So, as an example for this.
40.srt	00:05:53.420 --> 00:06:03.520	We know that internet protocol trunk applications that use IP packets to relay a circuit switch network traffic.
40.srt	00:06:04.129 --> 00:06:09.420	The round trip delay can easily exceed 40 milliseconds.
40.srt	00:06:10.080 --> 00:06:13.960	So the you can see this is how it is connected.
40.srt	00:06:13.960 --> 00:06:19.900	So what you have is we call from here to here is your round trip delay.
40.srt	00:06:19.900 --> 00:06:23.890	So which can cause 40 millisecond.
40.srt	00:06:24.720 --> 00:06:36.060	This is a voice over IP example using a gateway in which the voice is converted from the time division multiplex circuits to your IP packets.
40.srt	00:06:36.439 --> 00:06:38.889	So, you have an encoder.
40.srt	00:06:39.329 --> 00:06:53.639	So, you will be having the RTP packets basically and use the IP cloud and then you will be either transmitted this way or you can pass it through the jitter buffer.
40.srt	00:06:55.740 --> 00:07:03.520	And, finally you will be decoding it and this is the hybrid circuit what you will have it as you are seeing the telephone is here.
40.srt	00:07:03.910 --> 00:07:15.400	From there you can do the encoding and then you will be sending the RP packet here to the cloud and then it this is going to have a jitter buffer and then you can decode it.
40.srt	00:07:15.740 --> 00:07:27.050	So, this is how what happens although this is the receiver what you are intended to send the thing, but there will be a round trip delay which is coming back.
40.srt	00:07:27.250 --> 00:07:29.439	to the person who is calling.
40.srt	00:07:29.760 --> 00:07:42.470	So, this is how the what you will call it as echo comes back from here to here whatever you have spoken sometimes as I pointed out in the last class.
40.srt	00:07:42.830 --> 00:07:45.680	So, that you will be hearing yourself.
40.srt	00:07:46.040 --> 00:07:55.160	So, that delay includes speech compression and decompression that is why you have both encoder and decoder there and jitter compensation.
40.srt	00:07:55.560 --> 00:07:58.620	So, what you call as jitter.
40.srt	00:07:59.160 --> 00:08:13.139	It may be a little bit of noise or it may be little delayed that is what we call it as jitter ok. And the network delay, so we have to include the network delay also.
40.srt	00:08:13.590 --> 00:08:27.170	So, the standard used for this voice over IP is G.729, we call it as ITUT standard for speech coding standard is widely used for voice over IP application.
40.srt	00:08:27.170 --> 00:08:29.660	So, why it is being used?
40.srt	00:08:29.660 --> 00:08:32.409	Because of it good performance.
40.srt	00:08:33.659 --> 00:08:50.759	And, it is 15 millisecond low algorithm delay what it has it that is round trip delay where we said it is 40 millisecond whereas, in the G dot 79 it is 10 millisecond low logarithm algorithm delay what we have it to compute the thing.
40.srt	00:08:51.249 --> 00:09:08.289	So, when a 10 millisecond frame real time protocol what we call it as RTP packet and 10 millisecond jitter compensation are used the round trip delay of this G dot 729 speech coder based system will be at least.
40.srt	00:09:08.769 --> 00:09:13.310	twice that of 15 plus 10 which is equal to 50 millisecond.
40.srt	00:09:13.909 --> 00:09:27.940	So, that is 10 millisecond is our jitter and then we have algorithm delay of 15 millisecond because it has to go and then come back as you can see encoder and decoder is here.
40.srt	00:09:28.230 --> 00:09:32.879	Here also we have the encoder and decoder that is why it is twice what it is getting multiplied.
40.srt	00:09:33.250 --> 00:09:42.029	So, which comes to about 50 millisecond without counting the IP network delay here IP cloud what you are using it.
40.srt	00:09:42.730 --> 00:09:47.579	you have not counted and as well the processing delay is ignored.
40.srt	00:09:48.259 --> 00:10:06.949	So, if such a long delay is this is the reason why our adaptive echo cancellation is required for voice over IP applications, if one or both ends are connected by our TDM that is time division multiplex circuit.
40.srt	00:10:07.559 --> 00:10:13.529	So, for this reason one has to use the echo canceller as you can see that.
40.srt	00:10:13.899 --> 00:10:19.200	that is what it shows that round trip delay can exceed 40 millisecond.
40.srt	00:10:19.550 --> 00:10:26.389	This is with respect to G.729 shown that it is going to have a 50 millisecond round trip delay fine.
40.srt	00:10:27.040 --> 00:10:33.259	So, how we are going to design the adaptive echo canceller what it is shown here.
40.srt	00:10:33.290 --> 00:10:43.230	Using echo cancellation the echo canceller is located in 4 wire section basically that is the reason why all the.
40.srt	00:10:45.220 --> 00:10:51.870	stations they use the 4 wire section of the network near the origin of echo sources.
40.srt	00:10:51.939 --> 00:11:02.990	So, you have the telephone this is near end and then the principle of adaptive echo cancellation is what shown in the diagram here.
40.srt	00:11:03.610 --> 00:11:18.230	So, we will see how it is going to work to overcome the line echo problem in full duple communication I think you must be knowing half duple is going to be only one way communication full duple is.
40.srt	00:11:18.500 --> 00:11:25.359	you will be getting back your signal that that is known as our full duple.
40.srt	00:11:25.919 --> 00:11:31.919	It is necessary to cancel the echoes in both directions of the trunk basically.
40.srt	00:11:32.459 --> 00:11:40.699	So, only one echo canceller located at the left end of network is it is what it is shown here basically.
40.srt	00:11:40.819 --> 00:11:50.169	For showing a telephone and two airline is indicate that this side is defined as the near end.
40.srt	00:11:50.689 --> 00:11:53.539	While the other side is referred to as the far end.
40.srt	00:11:53.949 --> 00:12:01.849	So, this you are calling it as far end and you will be having the near end the circuit what you are having is the hybrid circuit.
40.srt	00:12:01.849 --> 00:12:07.409	So, which you will be giving a compensation for the echo.
40.srt	00:12:07.859 --> 00:12:12.169	So, we will see how principles of echo cancellation will be looking at it.
40.srt	00:12:12.169 --> 00:12:12.669	So, what is it?
40.srt	00:12:12.719 --> 00:12:22.539	Echo cancellation the function of the hybrid is whatever we have put the H here.
40.srt	00:12:22.980 --> 00:12:27.740	the hybrid circuit is shown in this case which is expanded.
40.srt	00:12:28.289 --> 00:12:53.500	So, where the foreign signal this is what your foreign signal X of n passing through the your echo path that is P of z is your echo path results in an undesired echo R of n. So, when it is passing through so it will be P of z will be causing this thing echo.
40.srt	00:12:53.779 --> 00:13:16.700	which is known as R n. So, near end signal U of n what you have considered and noise is defined with V of n. So, based on the principle of adaptive system in this case identification the adaptive filter W of z here models the echo path P of z.
40.srt	00:13:24.620 --> 00:13:32.150	What is the echo path is going to be modeled and So, what happens using the foreign speech X of n as an excitation signal.
40.srt	00:13:32.259 --> 00:13:54.509	So, for this it is modeling P of z based on R X of n and what happens the output signal Y of n generated by this W of z we have Y of n here will be subtracted from the primary signal D of n. So, this is this becomes our.
40.srt	00:13:56.810 --> 00:14:04.520	desired signal and subtracting it will be calculating the error will try to minimize that error.
40.srt	00:14:05.040 --> 00:14:19.890	After the adaptive filter identifies our echo path its output y of n echo replica what we call it approximates the echo thus the error y of n contains the near end speech noise and then residual echo.
40.srt	00:14:20.050 --> 00:14:25.470	We may not be able to completely suppress the thing, but little bit of it is there most of it is going to be.
40.srt	00:14:27.840 --> 00:14:29.010	suppressed basically.
40.srt	00:14:29.650 --> 00:14:34.200	So, what we call it as tail delay, what is that delay?
40.srt	00:14:34.540 --> 00:14:42.620	So, we will be seeing the impulse response of this P of n of an echo path is what it is shown here.
40.srt	00:14:43.110 --> 00:14:51.280	The time span or the hybrid is usually about 4 millisecond which is called the dispersive delay.
40.srt	00:14:51.590 --> 00:15:02.760	So, you will be seeing that this is approximately 4 millisecond which is going to be dispersive delay, because the 4-way circuit is located between the echo canceller and the hybrid.
40.srt	00:15:03.830 --> 00:15:11.080	The impulse response of the echo path has a flat delay as you can see it here it there is a flat delay.
40.srt	00:15:11.630 --> 00:15:13.700	Then you will be getting the dispersive delay.
40.srt	00:15:14.100 --> 00:15:18.020	The impulse response of the echo path has a flat delay.
40.srt	00:15:18.020 --> 00:15:26.910	The flat delay depends on the transmission delay caused by the distance between the echo canceller and then the hybrid.
40.srt	00:15:27.590 --> 00:15:35.230	And also depends on the filtering delay associated with the frequency or time division multiplex equipment.
40.srt	00:15:35.740 --> 00:15:40.770	The sum of the flat delay and the dispersive delay is called tail delay.
40.srt	00:15:41.060 --> 00:15:49.560	So, the complete thing including flat delay plus dispersive delay is known as the time delay which is shown in this figure.
40.srt	00:15:50.300 --> 00:15:52.920	So, how we are going to estimate the echo?
40.srt	00:15:53.680 --> 00:16:05.570	So, that is echo path what we have is a P of z, we say it is a linear time invariant and with infinite impulse response that is IAR.
40.srt	00:16:06.080 --> 00:16:16.879	filter what will be defining it which is given by P of n is equal to P of n which is n is going from 0 to infinity.
40.srt	00:16:17.410 --> 00:16:31.170	The primary signal d of n in that case can be expressed as which is given by R of n plus U of n plus V of n which is given by this equation.
40.srt	00:16:31.560 --> 00:16:39.070	So, we call it as V of n as the additive noise which is uncorrelated with the near end speech.
40.srt	00:16:39.680 --> 00:17:14.019	u of n and the echo is r of n. So, this is the when you substitute the thing P of l x of n minus l plus u of n plus v of n. So, what will be the adaptive FIR filter w of z is going to be estimated as echo basically y of n is given by we have seen that l is equal to 0 to l minus 1 is the length of the filter, w, l are the weights of the filter.
40.srt	00:17:14.370 --> 00:17:19.600	And, then x of n minus l is the input to the filter.
40.srt	00:17:20.250 --> 00:17:46.650	So, that is what l is our length and error signal in this case can be expressed as e of n is equal to d of n minus y of n which is given by after substituting from this d of n, u of n plus v of n plus this summation l is equal to 0 to l minus 1, p of l minus w l of.
40.srt	00:17:47.259 --> 00:18:06.890	n into x of n minus l plus l is equal to 0 to infinity p of l into x of n minus l. So, this is how the substitution is going to happen d of n and then y of n. So, when you put the terms in proper way.
40.srt	00:18:06.920 --> 00:18:12.019	So, how we are going to do the echo cancellation?
40.srt	00:18:12.559 --> 00:18:16.799	So, due to the changing power of speed signals.
40.srt	00:18:17.280 --> 00:18:26.170	The normalized LMS algorithm is commonly used for adaptive echo cancellation for all these applications ok.
40.srt	00:18:26.890 --> 00:18:47.860	Assuming that the disturbances what we call it as V of n and the near end speech U of n are uncorrelated with the foreign speech X of n then W of z is going to converge to P of z that is W L of n is approximated as.
40.srt	00:18:48.140 --> 00:18:53.309	p of L and L is varying between 0 to L minus 1.
40.srt	00:18:53.970 --> 00:19:06.049	So, the adaptive filter W of z adapts its weights W L of n to mimic the first L samples of the impulse response of the echo path.
40.srt	00:19:06.890 --> 00:19:12.369	So, as it is shown in the figure this is our hybrid.
40.srt	00:19:12.710 --> 00:19:17.319	So, that is what it is tried this W z is getting adapted ok.
40.srt	00:19:22.170 --> 00:19:43.299	The residual after W of z has converged can be expressed as this is convert then you will be putting our error of n is approximated as L is equal to capital L to infinity P of L x of n minus L plus u of n plus v of n. So, where the first term on the right hand side is called the residual echo.
40.srt	00:19:43.779 --> 00:19:52.289	This what we call it as residual echo which is carried and then our signal and then the noise what we said that will be there.
40.srt	00:19:52.660 --> 00:19:53.660	at the fore end.
40.srt	00:19:54.470 --> 00:19:58.400	So, how to estimate the performance basically.
40.srt	00:20:24.269 --> 00:20:35.230	So, effectiveness of our audio echo canceller is usually measured by the echo return loss, enhancement that is E R L E which is defined as that is based to the log what we will be taking it 10 log expected value of our desired signal squared D squared of n divided by expected value of the error square function E square of n. So, for a given application how we are going to consider it?
40.srt	00:20:35.549 --> 00:20:52.609	Here really depends on the step size m that is mu what we consider it the filter length l signal to noise ratio and the nature of the signal in terms of power and spectral contents.
40.srt	00:20:55.349 --> 00:21:07.679	A larger step size results in faster initial convergence, but final ERLA will be smaller due to the excess minimum mean square error and quantization errors.
40.srt	00:21:08.750 --> 00:21:16.139	And if the filter length is long enough to cover the echo tail or tail delay what it is known as.
40.srt	00:21:16.509 --> 00:21:19.980	So, further increases L will reduce the ERLA.
40.srt	00:21:19.980 --> 00:21:26.639	So, ERLA achieved by an adaptive echo canceller is limited by.
40.srt	00:21:27.089 --> 00:21:57.939	many practical factors, the detailed requirements for adaptive echo cancellers are defined by the standard ITUT that is telecommunication standard, recommendation for G.165 and then G.168 ok, including the maximum residual echo level that is separation effect on the hybrid, the convergence time, the initial setup time and the degradation in a double talk.
40.srt	00:21:58.859 --> 00:22:05.549	So, one has to will look at the what is that double dock in the next slide ok.
40.srt	00:22:05.589 --> 00:22:17.779	So, in the past adaptive echo cancellers what was happening implemented using customized devices in order to handle the heavy computation for real time applications.
40.srt	00:22:18.229 --> 00:22:21.389	So, we know that software delay is going to be much more.
40.srt	00:22:21.809 --> 00:22:32.999	So, hence there was a hardware which was designed to do this cancellation in real time applications to reduce the delay.
40.srt	00:22:33.579 --> 00:22:51.969	So, what was the thing disadvantages of VLSI implementation are long development time, high development cost, lack of flexibility to meet new application specific requirements and inability to be upgraded for more advanced algorithms.
40.srt	00:22:52.379 --> 00:23:03.109	So, when you design hardware VLSI implementation it is very large system integration.
40.srt	00:23:03.449 --> 00:23:08.079	So, if the volume is too high then you can go for the VLSI.
40.srt	00:23:08.429 --> 00:23:09.549	implementation.
40.srt	00:23:10.079 --> 00:23:13.009	So, what are the drawbacks of it?
40.srt	00:23:13.389 --> 00:23:19.879	One is because development time one has to design your circuit from a transistor level.
40.srt	00:23:20.259 --> 00:23:30.659	So, which is going to take longer time that is what it says long development delay and high development cost because once it becomes a long development.
40.srt	00:23:31.009 --> 00:23:35.069	So, you know that the person has to be paid and other things.
40.srt	00:23:35.409 --> 00:23:39.819	So, the cost is going to be very high and then what is the.
40.srt	00:23:41.119 --> 00:23:44.039	Other disadvantage, lack of flexibility.
40.srt	00:23:44.379 --> 00:23:51.049	So, if I want to modify any circuit, so then I have to go for redesigning.
40.srt	00:23:51.049 --> 00:23:57.249	So, I would not be able to do that design within the time constraints.
40.srt	00:23:57.379 --> 00:24:01.759	So, these two will be going up again if I had to redo the design.
40.srt	00:24:02.139 --> 00:24:05.629	With little modification it is not possible to accommodate it.
40.srt	00:24:06.009 --> 00:24:08.919	That is what it says any new application is coming.
40.srt	00:24:09.259 --> 00:24:11.069	So, we may not be able to.
40.srt	00:24:11.319 --> 00:24:16.109	use the same circuit it has to be completely modified.
40.srt	00:24:16.699 --> 00:24:21.759	And what is it the other thing is you cannot upgrade the system.
40.srt	00:24:22.129 --> 00:24:35.279	So, most of you must be knowing that you will be upgrading your memories if you know DDR3 and then now DDR4 which is coming in earlier DDR1, 2 ok.
40.srt	00:24:35.539 --> 00:24:41.509	So, whenever those systems were there so, if you want to upgrade it you had a limitation of memory for those systems.
40.srt	00:24:41.839 --> 00:24:43.849	For the other one you have to.
40.srt	00:24:44.289 --> 00:24:45.769	completely change your CPU.
40.srt	00:24:46.039 --> 00:24:53.229	So, what you will be doing now also it is so fast they become obsolete ok.
40.srt	00:24:53.679 --> 00:24:58.119	So, for the advanced algorithms whatever nowadays being used.
40.srt	00:24:58.119 --> 00:25:04.359	So, you will be not be upgrading the whatever you have designed in hardware.
40.srt	00:25:04.759 --> 00:25:06.589	So, these are the drawbacks.
40.srt	00:25:06.839 --> 00:25:14.939	So, what is the solution what they gave is recently adaptive echo canceller design and development have been based on.
40.srt	00:25:15.409 --> 00:25:18.649	programmable digital signal processors.
40.srt	00:25:19.059 --> 00:25:25.029	So most of the even your mobile has a DSP.
40.srt	00:25:25.379 --> 00:25:36.639	So which is programmable so hence you will be avoiding you will be getting once in a while upgrade your software correct.
40.srt	00:25:36.979 --> 00:25:43.419	So whenever you upgrade the software even the hardware must be able to run those softwares.
40.srt	00:25:43.599 --> 00:25:48.689	So if it is not going to do that then you may not be able to upgrade your software.
40.srt	00:25:49.229 --> 00:25:53.969	or any of the hardware system for that matter.
40.srt	00:25:54.329 --> 00:26:04.109	So, that is how from the custom design it has gone to the programmable device what you can look at it now signal process.
40.srt	00:26:04.469 --> 00:26:22.049	So, what are the practical considerations we call it as pre whitening of signals in this case that is the convergence time of adaptive FIR filter using LMS algorithm we have discussed is proportional to the spectral ratio.
40.srt	00:26:22.419 --> 00:26:25.699	that is L max is equal to L min.
40.srt	00:26:26.249 --> 00:26:34.699	So, since speed signal is highly correlated with a non-flat spectrum, the convergent speed is generally going to be slow.
40.srt	00:26:34.699 --> 00:26:43.259	So, the de-correlation that is what we call it as whitening of the input speed signal can be used to improve the convergence speed.
40.srt	00:26:43.809 --> 00:26:51.659	So, this is one of the application practical consideration one has to.
40.srt	00:26:52.419 --> 00:26:58.239	So, the other practical consideration what it is shown in the figure here.
40.srt	00:26:58.869 --> 00:27:07.389	Typical pre whitening structure for input signals where the whitening and then adaptation are processed in the background.
40.srt	00:27:07.859 --> 00:27:22.699	The same whitening filter what you call it as FW of Z what it is given here is used for the both foreign signal X of n and the near end signal your D of n.
40.srt	00:27:25.209 --> 00:27:37.629	So, you will be using for both far n is R x of n and then d of n is R near n. So, you will be using the same this thing filter for both of it.
40.srt	00:27:38.059 --> 00:27:44.059	So, the whiten signals are used to update the background adaptive filter W of z.
40.srt	00:27:44.709 --> 00:27:52.269	So, from here you will be based on it what you will be updating your weight functions of your filter.
40.srt	00:27:52.849 --> 00:27:55.089	For improving the convergence rate.
40.srt	00:27:55.489 --> 00:28:08.699	The foreground echo cancellation uses the original far end and near end signals thus the resulting signal E of n will not be affected by the pre whitening process.
40.srt	00:28:09.099 --> 00:28:16.989	So, the function of the non-linear processor what it calls will be used for this effectiveness.
40.srt	00:28:17.209 --> 00:28:25.559	So, this is how you will be putting the thing although if it this thing what it says is it is.
40.srt	00:28:27.349 --> 00:28:40.379	So, original foreign and foreground echo cancellation is not going to be affected with your what you call it as whitening part of it that is pre whitening.
40.srt	00:28:41.119 --> 00:28:55.929	So, how you are going to estimate the delay that is what the next slide shows that is fixed filter what we have is Fw of z can be obtained using a reversed statistical or temporal function.
40.srt	00:28:56.279 --> 00:28:57.919	average spectrum values.
40.srt	00:28:58.499 --> 00:29:12.369	So, the example is anti tile filter used to lift up the high frequency component since the power of most speed signals is concentrated in the low frequency region.
40.srt	00:29:13.079 --> 00:29:22.239	So, the whitening filter can be updated based on the foreign signal X of n which is similar to the adaptive channel equalization.
40.srt	00:29:22.839 --> 00:29:29.099	So, initial part of the impulse response of our echo path that is flat delay in the.
40.srt	00:29:29.609 --> 00:29:36.839	figure what you will be seeing it represents the transmission delay between the echo canceller and the hybrid.
40.srt	00:29:37.439 --> 00:29:52.849	So, this is what the delay which is getting represented thus that is what represented with z minus delta and your input is getting delayed by x of n minus delta in this case.
40.srt	00:29:53.369 --> 00:29:59.609	So, delta is the number of flat delay samples and by estimating the length of the flat delay.
40.srt	00:29:59.999 --> 00:30:11.949	And, using delay unit z minus delta the echo canceller W of z can be shortened by delta samples since it covers only the dispersive delay part of it.
40.srt	00:30:11.949 --> 00:30:22.079	So, this technique effectively improves the convergence speed and reduces the excess mean square error and computational requirements.
40.srt	00:30:22.459 --> 00:30:29.949	So, however, there are three major difficulties in realizing this technique in real applications.
40.srt	00:30:31.399 --> 00:30:37.679	that is the existence of multiple echoes the difficulty in estimating the flat delay.
40.srt	00:30:38.059 --> 00:30:58.689	So, if it is a single delay you can estimate it and then do the cancellation otherwise if like example we considered as reverberation if we have multiple echoes then your flat delay and the delay variation during a call it is little bit difficult to cancel it.
40.srt	00:30:59.169 --> 00:31:02.029	So, how you are going to estimate your delay.
40.srt	00:31:02.719 --> 00:31:12.239	So, one is using the cross correlation function between the foreign signal x of n and the near end signal d of n can be used to estimate the delay.
40.srt	00:31:34.019 --> 00:31:42.019	So, what is the we have derived this normalized cross correlation function is given by rho of k which is equal to Rx d of k divided by what is it this is autocorrelation value of X that is input signal and this is the desired signal autocorrelation value under the square root of it.
40.srt	00:31:42.339 --> 00:31:50.849	So, what it defines is Rxd is the cross correlation function and Rxxk and Rdd of k are the autocorrelations.
40.srt	00:31:51.259 --> 00:32:01.449	So, it can be estimated with typical values of length between 128 to 256 for an 8 kilohertz sampling rate.
40.srt	00:32:01.739 --> 00:32:04.039	So, this is our sampling rate.
40.srt	00:32:04.469 --> 00:32:09.299	that is narrow band frequency what it has been considered in this case.
40.srt	00:32:09.929 --> 00:32:12.879	So, what are the double talk effects?
40.srt	00:32:13.279 --> 00:32:22.319	So, you would be seeing your own echo is coming and someone else also there will be a cross talk is going to happen.
40.srt	00:32:22.819 --> 00:32:25.099	So, how you are going to look into this?
40.srt	00:32:26.059 --> 00:32:33.719	Designing adaptive echo cancellers for practical application is how to handle the double talk problem.
40.srt	00:32:34.099 --> 00:32:35.559	So, which occurs when the.
40.srt	00:32:35.739 --> 00:32:38.869	far end and near end talkers are speaking.
40.srt	00:32:39.519 --> 00:32:42.469	So simultaneously it is going to happen ok.
40.srt	00:32:42.849 --> 00:32:59.559	So during the double talk periods what you will call that is sign basically D and contains both the near end speech U of n and then the undesired echo R of n. So that is what it is shown.
40.srt	00:32:59.559 --> 00:33:07.819	So you have the hybrid as well as this is the far end what you have the NLP in this case ok.
40.srt	00:33:08.129 --> 00:33:12.489	So how you will be detecting and then control algorithm what you will be providing it.
40.srt	00:33:12.919 --> 00:33:15.219	So thus the error signal.
40.srt	00:33:15.709 --> 00:33:42.989	or E of n contains the residual echo, the uncorrelated noise V of n and then near end speech U of n. So, for adaptive system identification that is D of n must be generated solely from its excitation input signal X of n. So, in order to correctly identify the characteristics of R, P of z for the hybrid.
40.srt	00:33:46.859 --> 00:33:52.689	So, you will be generating from the X of n. So, to do the thing.
40.srt	00:33:53.019 --> 00:34:02.179	So, we will consider in the next class equalizer and then some of the speech coding techniques available in the literature.
40.srt	00:34:02.709 --> 00:34:06.879	So, thank you for this hearing and then happy learning.
56.srt	00:00:01.219 --> 00:00:25.399	Welcome back to real time digital signal processing lab.
56.srt	00:00:32.119 --> 00:00:41.909	So today we will see how you can use your own mobile either it is Android platform or or iPhone you can run your some of the real time signal processing experiments on it.
56.srt	00:00:42.170 --> 00:00:55.280	So this has been developed by using Java from Arizona State University say they call it as what I am using today for the recording is JDSP basically.
56.srt	00:00:55.620 --> 00:00:58.780	So they have for the Android AJDSP.
56.srt	00:01:06.570 --> 00:01:09.050	So you can use that or in the normal thing they have the JDSP basically Java based DSP which has been developed so you can use them.
56.srt	00:01:09.050 --> 00:01:13.630	So what I am using as I said you are seeing the screen that we have the do net.
56.srt	00:01:13.800 --> 00:01:19.090	So here manuals have been given so you can go and then check with them.
56.srt	00:01:19.230 --> 00:01:23.010	So here we will do some experiments whatever we had done the thing.
56.srt	00:01:23.090 --> 00:01:30.290	So we will see that how signal generator is going to generate some signals.
56.srt	00:01:30.290 --> 00:01:32.600	So whether we want the sinusoid signal rectangular.
56.srt	00:01:39.020 --> 00:01:44.390	or a triangular or delta exponential any of the functions what you can select from this.
56.srt	00:01:44.800 --> 00:01:47.060	So here we will select the sinusoid.
56.srt	00:01:47.500 --> 00:02:02.800	So I will be doing the save actually and the gain is given as 1 and pulse width is 20 and we have not taken any time shift for this and frequency in pi radians that is 0.2 pi radians what it has been selected.
56.srt	00:02:02.800 --> 00:02:05.750	So default what it is there I am taking it.
56.srt	00:02:05.750 --> 00:02:11.759	So we are adding a block as you can see it is a block level design what you will be doing it.
56.srt	00:02:13.250 --> 00:02:18.270	Next, what we will do is I will see what kind of sine wave I am going to get it.
56.srt	00:02:18.569 --> 00:02:19.860	So, we will do a plot.
56.srt	00:02:20.719 --> 00:02:22.780	So, it ask our add plot.
56.srt	00:02:22.900 --> 00:02:24.909	So, I have added the thing.
56.srt	00:02:25.250 --> 00:02:31.360	So, now the connectivity is going to be between output of the sine generation and then the plot.
56.srt	00:02:31.629 --> 00:02:33.329	So, we will click on it.
56.srt	00:02:33.670 --> 00:02:36.219	So, I want to see the magnitude of it.
56.srt	00:02:36.620 --> 00:02:39.599	So, you are seeing the sine wave how it is looking like.
56.srt	00:02:40.090 --> 00:02:48.000	So, you can have it as linear or in dB if you want to see the thing continuous or discontinuous what you want to see you can do it.
56.srt	00:02:48.360 --> 00:02:52.340	So, linear sine wave what I am displaying it here.
56.srt	00:02:52.780 --> 00:02:57.430	So, number of samples there if you want you can increase also.
56.srt	00:02:57.430 --> 00:03:04.769	So, what we will do is if you click on the thing, so it will ask me to delete it, so I can delete this.
56.srt	00:03:05.069 --> 00:03:08.879	So, now what we will do is I will select one more sign generator.
56.srt	00:03:09.549 --> 00:03:16.569	So, here also I am clicking on the sinusoid save.
56.srt	00:03:16.990 --> 00:03:22.039	In this case what I will do is I can select the values what I want.
56.srt	00:03:22.039 --> 00:03:23.870	So, we will select it as point.
56.srt	00:03:26.240 --> 00:03:34.879	3 in this case and then save it and then the pulse width if you want you can increase the thing.
56.srt	00:03:35.449 --> 00:03:40.979	So, we will make it as 30 and then save it and then add them.
56.srt	00:03:41.539 --> 00:03:44.819	So, I have a 2 sine waves what I have it.
56.srt	00:03:45.139 --> 00:03:51.009	Now, what I can do is I can take a sum of this and see how my output is going to look like.
56.srt	00:03:51.490 --> 00:03:54.229	So, I will you have a adder.
56.srt	00:03:54.770 --> 00:04:03.680	So, we will select the add this thing and then put it here and connect these two and output I can put it on to the plot.
56.srt	00:04:04.039 --> 00:04:07.180	So, now, we will see what is the magnitude of it.
56.srt	00:04:07.500 --> 00:04:14.329	So, you are seeing this is your output basically what you are getting from the two of it.
56.srt	00:04:14.620 --> 00:04:22.079	So, if I want I can add one more sine wave or what I can do is I can do the filtering.
56.srt	00:04:22.079 --> 00:04:25.029	So, I will disconnect.
56.srt	00:04:25.490 --> 00:04:36.470	So, we will move it a little on the left hand side of it so that I have a place for me to put the I can do the FFT magnitude also.
56.srt	00:04:36.860 --> 00:04:42.990	So, first we can see FFT it is FFT size is 256.
56.srt	00:04:43.270 --> 00:04:44.980	So, I can add it here.
56.srt	00:04:45.450 --> 00:04:49.950	So, what I get FFT magnitude and I can do the plot.
56.srt	00:04:50.310 --> 00:04:51.900	So, once I click on the thing.
56.srt	00:04:51.900 --> 00:04:53.490	So, we will see the magnitude plot.
56.srt	00:04:53.870 --> 00:04:54.870	So, you are seeing.
56.srt	00:04:55.720 --> 00:05:03.420	different plots for the frequencies whatever you can see this is going to give you approximately 0.2 pi.
56.srt	00:05:03.500 --> 00:05:17.750	So, and then here sorry this is your this thing 0.2 pi and then multiple what you are generating 0.6 to 0.3 is not a multiple of 0.2.
56.srt	00:05:17.750 --> 00:05:24.910	So, that is the reason why what you will be seeing here approximately 0.94 what the repetition is happening.
56.srt	00:05:27.480 --> 00:05:36.600	So, now what we can do is we can create a filter in between and then see that.
56.srt	00:05:36.980 --> 00:05:44.259	So, first I have to define the filter coefficient.
56.srt	00:05:44.710 --> 00:05:54.699	So, here it is going to give me a 0 is always 1 and then if I do not give any part of the thing only b coefficients what I am going to specify.
56.srt	00:05:55.150 --> 00:05:57.180	So, it is going to create me.
56.srt	00:05:57.879 --> 00:06:07.410	So, I will give the moving average basically I can say V1 and then V2 I can give it as a 0.5.
56.srt	00:06:09.530 --> 00:06:21.560	We will see what is the thing is going to happen with the filter coefficients and then we will put the filter basically.
56.srt	00:06:21.560 --> 00:06:29.000	So, we will add the filter here and coefficients are given from here.
56.srt	00:06:29.930 --> 00:06:37.660	And, then input is from here and then what we will do is we will connect this to FFT here.
56.srt	00:06:38.160 --> 00:06:42.000	So, now, we will see what is the plot I am going to get it magnitude plot.
56.srt	00:06:42.800 --> 00:06:47.459	So, you can see that it has it is a moving average.
56.srt	00:06:47.459 --> 00:06:50.540	So, you have seen that the peaks have been amplified.
56.srt	00:06:50.889 --> 00:06:58.209	So, if I want I can change my this thing pulse width I will keep it as 20 here.
56.srt	00:06:59.110 --> 00:07:01.209	Or same as the previous one.
56.srt	00:07:01.660 --> 00:07:05.329	I will increase it to this one to 0.4.
56.srt	00:07:07.210 --> 00:07:13.460	I can update the thing and see what is the plot I am going to get magnitude plot.
56.srt	00:07:13.460 --> 00:07:17.100	So, you will be seeing that different kinds of it what it is generated.
56.srt	00:07:17.100 --> 00:07:28.009	So, like this you can create your own this thing either FIR filter or IAR filter whatever filter operations you want to do the thing.
56.srt	00:07:28.009 --> 00:07:37.360	So, what I will do is delete all means the work space is going to be deleted there is no way you can save these work spaces in these.
56.srt	00:07:41.879 --> 00:07:49.220	So, now what we will see some of the examples, what we have it here that is all of you know what is a midi basically.
56.srt	00:07:49.750 --> 00:07:56.529	So, if I click on the thing, so you will be looking at the your piano basically.
56.srt	00:07:56.870 --> 00:08:01.670	So, if you want to play and then see what is the music tone it is going to generate.
56.srt	00:08:01.670 --> 00:08:04.139	So, we will only work on the black one.
56.srt	00:08:08.850 --> 00:08:10.839	So, you will be seeing different.
56.srt	00:08:11.379 --> 00:08:13.560	tones also coming along with it.
56.srt	00:08:14.189 --> 00:08:28.269	So, and you will be seeing what are the frequencies as in our lab using the sign generation we created a Sarigamapadhanisa.
56.srt	00:08:28.269 --> 00:08:33.500	So, you will be seeing same kind of it what it is generated here ok.
56.srt	00:08:33.700 --> 00:08:41.830	So, this is one of the example and if you want to see the in between the magnitude what it will be giving up to pi what you have it.
56.srt	00:08:42.100 --> 00:08:50.490	So, you if you click on the thing, so what is the peak value what you will be seeing it 0.04 pi what it is for the first white one.
56.srt	00:08:50.490 --> 00:09:03.100	And so, next one you can see that what is the displacement you have between the thing ok and for this what is the peak you will be getting it point approximately 0.05 ok.
56.srt	00:09:03.100 --> 00:09:10.579	So, this is at these distance 1 twelfth of the distance basically in the piano what they frequency what it will be getting.
56.srt	00:09:13.159 --> 00:09:14.439	aligned basically.
56.srt	00:09:14.699 --> 00:09:17.219	So, this is one of the examples.
56.srt	00:09:17.219 --> 00:09:19.019	So, we will delete this also.
56.srt	00:09:19.479 --> 00:09:21.490	Now, other examples.
56.srt	00:09:21.490 --> 00:09:23.429	So, all of you know that are D2MF.
56.srt	00:09:23.429 --> 00:09:27.429	So, if I click on the thing.
56.srt	00:09:27.519 --> 00:09:34.399	So, you will be seeing the numbers as in your phone telephone basically.
56.srt	00:09:34.399 --> 00:09:41.279	So, I can click one of them 1, 2, 3 or whatever may be the thing.
56.srt	00:09:41.799 --> 00:09:45.049	So, and then even the hash function what we have it.
56.srt	00:09:45.469 --> 00:09:52.709	So, this is what different frequencies what you will be getting generated.
56.srt	00:09:52.709 --> 00:09:56.959	So, if you want to see what are the things generated.
56.srt	00:09:56.959 --> 00:09:59.559	So, what we will do is we will put FFT here.
56.srt	00:10:00.149 --> 00:10:06.219	So, add the thing with the DTMF and then we will do the plot basically.
56.srt	00:10:12.589 --> 00:10:27.159	So, the magnitude plot what you will be seeing because we know that.
56.srt	00:10:27.749 --> 00:10:34.809	it has two frequencies, one is the horizontal frequency, the other one is the vertical frequencies for the D2MF.
56.srt	00:10:34.809 --> 00:10:39.339	So, you will be seeing this is approximately 0.53 and then this is 0.93.
56.srt	00:10:39.429 --> 00:10:43.419	So, for one these are the two frequencies what it generated.
56.srt	00:10:43.419 --> 00:10:46.119	So, if I click on now 8 ok.
56.srt	00:10:46.119 --> 00:10:53.339	So, I will go back and you can check the magnitude what it has got created.
56.srt	00:10:53.509 --> 00:10:56.139	So, you will be seeing that it is.
56.srt	00:10:58.509 --> 00:11:03.239	x-axis 0.63 what you will be seeing the thing the other one is 1.04.
56.srt	00:11:03.239 --> 00:11:06.809	So, you can go to the DTMF.
56.srt	00:11:06.809 --> 00:11:10.569	So, each digit what are the frequencies that get generated.
56.srt	00:11:10.569 --> 00:11:13.079	So, you can map it into that.
56.srt	00:11:13.079 --> 00:11:19.379	So, this is how you can play along using your mobile also that is what I wanted to bring in.
56.srt	00:11:19.379 --> 00:11:32.269	So, next is using the PZ placement that is your pole 0 placement you can generate your coefficient and then use it for your.
56.srt	00:11:34.059 --> 00:11:37.379	So, this is a demo what you have it.
56.srt	00:11:37.379 --> 00:11:46.959	So, if I want to add a 0, I can add a 0 or if I want to add pole I can do it or you can reset.
56.srt	00:11:47.219 --> 00:11:48.369	So, this is the demo.
56.srt	00:11:48.369 --> 00:11:50.679	So, I will put it as 0 what I have to add it.
56.srt	00:11:50.979 --> 00:11:54.689	So, I am going to put it my 0 in this position.
56.srt	00:11:54.999 --> 00:12:04.449	So, you are seeing what is the magnitude response I am getting it and then now this is the frequency that is phase what it is at the bottom what it is showing.
56.srt	00:12:04.829 --> 00:12:06.749	Now, add a pole to this.
56.srt	00:12:07.079 --> 00:12:12.439	So, what we will do is what kind of frequency you want to have it.
56.srt	00:12:12.789 --> 00:12:14.829	So, I can put it in this way also.
56.srt	00:12:16.729 --> 00:12:21.439	So, what is the thing approximately what I am getting is a high pass filter in this case.
56.srt	00:12:21.839 --> 00:12:27.389	So, by adjusting your zeros and then poles you can fine tune.
56.srt	00:12:27.669 --> 00:12:35.009	So, I can add one more 0 and then I can place it here and then add a pole here.
56.srt	00:12:35.539 --> 00:12:37.109	I will be fine tuning it.
56.srt	00:12:38.659 --> 00:12:44.119	So, you will be seeing that what is my cut off what how it is varying.
56.srt	00:12:44.119 --> 00:12:46.669	So, I want to fine tune the thing.
56.srt	00:12:46.979 --> 00:12:52.639	So, you can place the poles and zeros in whatever way you want.
56.srt	00:12:52.849 --> 00:12:58.679	So, if you want to delete if you have not satisfied with whatever the response what it is showing.
56.srt	00:12:58.969 --> 00:13:00.039	So, we can move them.
56.srt	00:13:00.399 --> 00:13:03.389	So, or if you want to put the zeros outside.
56.srt	00:13:03.599 --> 00:13:08.789	So, you will be seeing that what is the phase response is going to happen.
56.srt	00:13:09.259 --> 00:13:11.289	and then how it is getting moved.
56.srt	00:13:11.569 --> 00:13:18.069	So, this is how you can play around by placing your poles and zeros using this PZ demo.
56.srt	00:13:19.069 --> 00:13:24.319	So, the next one what we have is a little bit on sound record and then player.
56.srt	00:13:24.349 --> 00:13:34.929	So, what the manual says is you can play from one of the unit and then you can get it in the other unit through your Wi-Fi or whatever way it is connected.
56.srt	00:13:43.539 --> 00:13:49.219	So, if you want to see the frequency response demo, so you will be seeing the demo here.
56.srt	00:13:49.719 --> 00:13:59.889	So, if I want to have a low pass filter to be built in, so this is how it shows that what are the components A and B it is a IR filter what it has designed it.
56.srt	00:13:59.889 --> 00:14:04.869	So, these are the values what it has taken to get this response.
56.srt	00:14:05.169 --> 00:14:09.729	So, if I want to design an high pass filter, so this is my poles.
56.srt	00:14:13.099 --> 00:14:21.419	And, these are my zeros what it is coming in my system ok. And same way you can define the band pass filter.
56.srt	00:14:21.509 --> 00:14:28.639	So, these are the what you will be seeing poles and then zeros which is getting done.
56.srt	00:14:28.639 --> 00:14:29.909	So, this is one of the thing.
56.srt	00:14:30.989 --> 00:14:36.279	So, like this you have a sound player.
56.srt	00:14:36.279 --> 00:14:45.379	So, if I want to do the convolution demo I can take the thing convolution demo or you can do your own convolution.
56.srt	00:14:45.749 --> 00:14:52.849	So, the demo will whether I want discrete convolution or linear convolution what you have seen the thing.
56.srt	00:14:52.929 --> 00:14:54.329	So, if I click on the thing.
56.srt	00:14:54.679 --> 00:14:58.619	continuous convolution if I want to do it or discrete convolution.
56.srt	00:14:58.659 --> 00:15:01.329	So, we want to have a discrete convolution.
56.srt	00:15:01.669 --> 00:15:11.249	So, it will ask me signal 1 is rectangular and signal 2 is also rectangular what it has been default what it is chosen.
56.srt	00:15:11.249 --> 00:15:14.419	So, we will see what is the output we are going to have it.
56.srt	00:15:14.709 --> 00:15:22.519	So, you will be seeing that this is the output y what you will be getting your convolved signal.
56.srt	00:15:22.839 --> 00:15:27.689	So, if you want to do this thing different one we will take a triangular.
56.srt	00:15:28.549 --> 00:15:34.449	1 and the other one also we will take a triangular and then save it update the thing.
56.srt	00:15:34.779 --> 00:15:42.749	So, you will be seeing the output is what you will be getting 2 triangular how you will be representing the output y basically.
56.srt	00:15:43.179 --> 00:15:49.999	So, one is I can choose it as rectangular and then save the thing update it.
56.srt	00:15:50.349 --> 00:15:56.909	So, you will be seeing that wherever you have the thing convolute signal what it shows.
56.srt	00:15:56.909 --> 00:16:00.159	So, this way you can play around with the thing and then see.
56.srt	00:16:00.539 --> 00:16:03.169	whether your DSP concept is clear or not.
56.srt	00:16:03.169 --> 00:16:24.409	So, the next one is if you want to design FIR design you can you do use it or if you want to design IR filter you can design the thing, but the coefficients have to be given from the FIR coefficient values will be given from this block basically.
56.srt	00:16:24.409 --> 00:16:33.679	If you want to design a window you can do the window design frequency response you can get the thing.
56.srt	00:16:34.199 --> 00:16:41.099	filter coefficients had to be fed into your filter design block basically.
56.srt	00:16:41.279 --> 00:16:43.429	So, we will take up FIR filter design.
56.srt	00:16:43.429 --> 00:16:45.559	So, I have asked for this thing.
56.srt	00:16:46.179 --> 00:16:59.149	It has chosen in this case hamming window, order is 8 and then the design is low pass and cutoff frequencies it is taken it as 0.2.
56.srt	00:16:59.269 --> 00:17:02.279	So, we will update the same thing.
56.srt	00:17:05.209 --> 00:17:09.269	So, these are the coefficients what you have it for the 8th order filter.
56.srt	00:17:09.599 --> 00:17:20.269	So, now, what we can do is I can generate this thing signal generator I can use it.
56.srt	00:17:20.500 --> 00:17:26.909	So, we will give it as we will see the rectangular what is the output we are going to get it.
56.srt	00:17:27.809 --> 00:17:29.250	So, I will add this.
56.srt	00:17:29.649 --> 00:17:42.009	So, I have to select the filter.
56.srt	00:17:43.419 --> 00:17:49.339	I will be selecting the filter input from here to here and coefficients what I have taken from here.
56.srt	00:17:49.710 --> 00:17:52.450	So, now, because I have to see what I have got the thing.
56.srt	00:17:52.789 --> 00:17:56.049	So, what we will put is FFT block in this case.
56.srt	00:17:56.769 --> 00:18:01.089	So, I will add a FFT and then I need a plot.
56.srt	00:18:07.000 --> 00:18:08.019	So, I will connect that.
56.srt	00:18:08.440 --> 00:18:12.190	So, now, we will see what is the output magnitude what I am going to get.
56.srt	00:18:12.859 --> 00:18:19.039	So, we have designed the low pass filter and then cut off frequency what it has chosen is 0.2.
56.srt	00:18:19.119 --> 00:18:21.779	So, sine wave if you want to ok.
56.srt	00:18:21.779 --> 00:18:33.289	So, one more plot what you want to see it ok what is the signal generated one with FFT what we can plot it after the filter we can plot the thing.
56.srt	00:18:33.339 --> 00:18:38.049	So, for that what it has is a junction what it calls.
56.srt	00:18:38.049 --> 00:18:40.529	So, I can put a junction here.
56.srt	00:18:40.529 --> 00:18:42.639	So, from here.
56.srt	00:18:43.849 --> 00:18:46.049	I will be taking input to this.
56.srt	00:18:46.399 --> 00:18:50.109	So, from here I will be taking one of the input to here.
56.srt	00:18:50.719 --> 00:18:57.719	So, I can directly plot the other one let us I will put a FFT there also.
56.srt	00:19:04.289 --> 00:19:13.509	So, from here I will be giving to this and then I want to have one more plot I can select it and then I will be putting.
56.srt	00:19:17.049 --> 00:19:17.889	I will be connecting.
56.srt	00:19:18.269 --> 00:19:28.849	So, now, we will see what is this I will see the magnitude response of this and then after filtering so, what I will going to get is this one.
56.srt	00:19:28.849 --> 00:19:31.149	So, there is no difference between the thing.
56.srt	00:19:31.490 --> 00:19:44.819	So, what we will do is our signal generator directly instead of putting a FFT.
56.srt	00:19:46.649 --> 00:19:54.419	So, if you hold it for a thing you can delete the thing I can directly give it to the plot.
56.srt	00:19:54.979 --> 00:19:57.999	So, you will be seeing that magnitude of it.
56.srt	00:19:57.999 --> 00:20:01.959	So, this is a flat response what you have it correct.
56.srt	00:20:02.269 --> 00:20:10.059	So, when I pass it through the filter because I am passing through the low pass filter the rectangular wave.
56.srt	00:20:10.149 --> 00:20:15.059	So, you will be seeing that this is what the output is going to be ok.
56.srt	00:20:15.490 --> 00:20:25.549	So, after filtering so, I can you can keep playing with the thing one or two more demos what I will be showing you the thing.
56.srt	00:20:25.549 --> 00:20:45.539	So, if you want to do up sampling or down sampling I have shown you one of the example and then if I want to do the inverse FFT both FFT and then IFT I can do the thing.
56.srt	00:20:46.380 --> 00:20:52.440	So, if you want to pick up the peak you can do that and then if you want to signal to noise ratio you can do it.
56.srt	00:20:52.819 --> 00:20:57.730	So, the other one is if you want to see the spectrogram of your signal what you can do it.
56.srt	00:20:58.190 --> 00:21:01.549	So, there is one provision for long signal generator.
56.srt	00:21:01.549 --> 00:21:16.230	So, if you click on it and then you if you do the thing what it says is it is a male speaker and then the gain what they have is 1 and frame size 256.
56.srt	00:21:16.629 --> 00:21:25.669	frames are there and then overlap there is no overlap between the frames and then you will be seeing that current frame is there are 32 frames in it.
56.srt	00:21:26.139 --> 00:21:29.359	So, I can go with the thing.
56.srt	00:21:30.490 --> 00:21:34.220	So, you are seeing that where your voice is going to come.
56.srt	00:21:34.220 --> 00:21:36.839	So, you will be picking up the peak of it.
56.srt	00:21:39.089 --> 00:21:46.529	So, you can use that one for your usage in any of the thing.
56.srt	00:21:46.990 --> 00:21:54.359	So, you will be seeing that one of the example you have is a linear predictive coding what you can use it.
56.srt	00:21:54.809 --> 00:22:02.349	So, we have a little demo on the thing there is a LMS demo is also there for your adaptive filter.
56.srt	00:22:02.899 --> 00:22:08.779	So, whatever the quantization and then pole 0 to LSF what you have the thing.
56.srt	00:22:09.109 --> 00:22:10.819	So, we will take the LMS demo.
56.srt	00:22:11.399 --> 00:22:12.959	So, if I click on the thing.
56.srt	00:22:13.369 --> 00:22:18.519	So, you are seeing that initially original filter is value has this.
56.srt	00:22:18.930 --> 00:22:22.359	and then the estimated filter what you have is this one.
56.srt	00:22:22.789 --> 00:22:26.980	So, by doing the next this is a default what it has taken.
56.srt	00:22:27.159 --> 00:22:36.750	So, if you give the next step, so you will be seeing that it is getting adjusted to these values whatever you had the thing.
56.srt	00:22:38.139 --> 00:22:40.940	Step size you can choose between the thing.
56.srt	00:22:41.389 --> 00:22:48.740	So, we will give it as point 1 is our step size.
56.srt	00:22:49.069 --> 00:22:51.450	it was 0.05 earlier now it is 0.1.
56.srt	00:22:51.450 --> 00:22:54.649	So, you are seeing that it is going into the negative.
56.srt	00:22:54.649 --> 00:22:58.409	So, what is the thing happening?
56.srt	00:23:01.490 --> 00:23:02.639	It is not reaching the 1.0.
56.srt	00:23:02.639 --> 00:23:08.139	So, they are varying much away from the thing.
56.srt	00:23:08.609 --> 00:23:18.089	So, by varying your step size smaller the step size you will be seeing that it is getting adapted and then by making little more.
56.srt	00:23:20.130 --> 00:23:24.349	you can see that it is oscillating between positive and negative side of the thing.
56.srt	00:23:24.930 --> 00:23:37.579	So, this is how what you can look into the thing and then the there is a quantization set up to what this is a demo basically.
56.srt	00:23:39.490 --> 00:23:42.200	So, what it has got created.
56.srt	00:23:42.200 --> 00:23:51.369	So, you will be seeing that what it has is a long signal generator and then this is a LPC 1 coder basically.
56.srt	00:23:51.890 --> 00:23:59.730	and then quantizer what it has in it and then there is a filter and it will be going for the player.
56.srt	00:24:00.269 --> 00:24:14.210	So, you can see the play sound in your this thing it will be coming out I think sound because it is taking my recording.
56.srt	00:24:14.210 --> 00:24:15.870	So, here you would not be able to hear this sound.
56.srt	00:24:15.870 --> 00:24:21.509	So, you will be seeing the long signal here it has been chosen as male speaker.
56.srt	00:24:21.540 --> 00:24:28.110	So, if you want to see a different speakers are there whether you want to have a music.
56.srt	00:24:59.620 --> 00:25:03.750	you can play with it or a female speaker or noise or sign 1 2 and then you can have a music and noise combined and then you can pass it through your adaptive filter and then see that your noise is eliminated using your filtering and then you will be getting only the music back So these are the play things what we what one has okay So the other one is quantization if you want to see the thing So, we will LPC quantization.
56.srt	00:25:04.100 --> 00:25:09.700	So, what it will happen is signal to noise ratio what it is going to give you as the output.
56.srt	00:25:10.130 --> 00:25:19.009	So, here it is a long signal generator, same thing what you have is a male speaker and it has 32 frames which will be continuously played.
56.srt	00:25:19.519 --> 00:25:30.180	So, and then from the junction one is signal to noise ratio what you are calculating, the other one is you have pass it through the linear predictive coding LPC coding.
56.srt	00:25:30.620 --> 00:25:41.440	And, then you have the quantization two level quantization what you are doing the thing and then you are doing the filtering from that and giving to signal to noise ratio.
56.srt	00:25:41.790 --> 00:25:48.620	What we will do is we will see the thing here that is in dB what it is going to give you.
56.srt	00:25:49.010 --> 00:25:57.350	So, if you the whatever the male voice getting played is going to be showing its signal to noise ratio.
56.srt	00:25:57.350 --> 00:26:01.990	So, if I play the thing so, you will be seeing continuously changing with it.
56.srt	00:26:02.270 --> 00:26:04.800	So, that is from the sound recorder.
56.srt	00:26:05.230 --> 00:26:13.160	what you can connect with the signal to noise ratio and then see what is your signal to noise ratio is coming.
56.srt	00:26:13.630 --> 00:26:27.720	So, one is the direct signal what you have taken the other one is noise what you have whatever the output of LPC coding what you have got it the difference between the thing that dB what it is showing here.
56.srt	00:26:28.110 --> 00:26:35.470	So, this is how you can use this help files are there in this when you.
56.srt	00:26:36.540 --> 00:26:38.800	So, if you want you can go to the information.
56.srt	00:26:38.850 --> 00:26:49.100	So, you will be having the IGDSP video demo one can look at it and then you have the DSP with book with simulations this has to be bought basically.
56.srt	00:26:49.190 --> 00:26:52.070	So, you can web page is also available.
56.srt	00:26:52.230 --> 00:26:58.470	So, if you go to the demo.
56.srt	00:26:58.890 --> 00:27:08.340	So, you will be seeing the so, it will show you how to go about using it with the.
56.srt	00:27:09.990 --> 00:27:10.320	demo.
56.srt	00:27:12.360 --> 00:27:20.940	What are the things available and how is it signal generator how you can do it whatever demo have seen the thing.
56.srt	00:27:20.940 --> 00:27:27.090	So, you can go with this demo and then use in your own design basically.
56.srt	00:27:28.380 --> 00:27:32.670	So, hopefully you will be enjoying this course.
56.srt	00:27:33.370 --> 00:27:37.620	So, with this thank you very much for listening to me.
56.srt	00:27:37.890 --> 00:27:38.960	So, you can go.
56.srt	00:27:39.350 --> 00:27:45.530	And, then play around with your mobile phone with the block level simulations also.
56.srt	00:27:45.770 --> 00:27:46.140	Thank you.
4.srt	00:00:01.219 --> 00:00:24.739	Welcome back to real time digital signal processing course.
4.srt	00:00:25.230 --> 00:00:31.719	Today we are going to discuss what are the few things that we can do it in laboratory.
4.srt	00:00:32.140 --> 00:00:35.450	So, first lab course is going to be demonstrated today.
4.srt	00:00:35.980 --> 00:00:42.939	In the present laboratory we will be using DSK6713 board from TI.
4.srt	00:00:42.939 --> 00:00:52.269	So, in this case we will see how to go with the Code Composer Studio and then the first part of it how to download the software.
4.srt	00:00:52.859 --> 00:01:02.650	So, the below link gives you how you can download the Code Composer Studio version 5 and are the downloads.
4.srt	00:01:03.200 --> 00:01:13.219	So, this will try to install in Windows version, this is the release version of Code Composer Studio 5.5 in C drive.
4.srt	00:01:13.219 --> 00:01:21.460	So, you have to have a permission to download it, if there is any issue you can come back to me.
4.srt	00:01:21.460 --> 00:01:25.200	So, I will be giving the license because we have the user licenses here.
4.srt	00:01:25.200 --> 00:01:27.240	So, you can use that.
4.srt	00:01:27.240 --> 00:01:30.480	So, first we will see that after installation.
4.srt	00:01:32.909 --> 00:01:39.420	what are the features of this DSK6713 or we call it as TMS320C6713.
4.srt	00:01:39.890 --> 00:01:51.219	So, we have a 32 bit instruction cycle processor, typically it runs at 225 megahertz and it can go up to 300 megahertz clock frequency.
4.srt	00:01:52.040 --> 00:02:03.960	And then what is the MIPS or what we will call it as Million Instructions Per Second or Mega Floating Point Operations what this board can do is shown here.
4.srt	00:02:04.439 --> 00:02:11.550	So, 2400 MIPS and then 1800 mega flops instructions processing what it has the capability.
4.srt	00:02:36.140 --> 00:02:46.560	So, this has 4 ALUs and 2 32 bit MAC functional units and we have 4 KB level 1 program cache and then 4 KB level data cache basically and then 256 KB level 2 data cache and it supports external memory interface up to 512 MB addressable external memory space what is provided in this board.
4.srt	00:02:47.210 --> 00:02:57.319	And we have two I2C ports, two MAC BSP that is serial port interface and two 32 bit timers in this board.
4.srt	00:02:59.349 --> 00:03:03.319	Coming to the block diagram of the DSK6413.
4.srt	00:03:03.689 --> 00:03:08.710	So we have the core 6713 CPU is shown here.
4.srt	00:03:09.260 --> 00:03:15.760	So, which has instruction fetch, instruction dispatch and then instruction decode.
4.srt	00:03:15.760 --> 00:03:25.960	So after that we have the data path for two functional units what we have it.
4.srt	00:03:25.960 --> 00:03:31.740	We call it one as path A, the other one is path B.
4.srt	00:03:32.030 --> 00:03:38.490	So it has A registers which are connected to these functional blocks and B registers.
4.srt	00:03:40.689 --> 00:03:47.580	file are connected to this functional block and this is some of the functional units.
4.srt	00:03:47.950 --> 00:03:56.189	So, when we take up in the class about the architecture of the processor, I will be discussing about these functional blocks.
4.srt	00:03:56.819 --> 00:04:11.240	Coming to how it is going to be controlled, you can see control registers are there, we have controlled some logic and then test what we can do the thing and in circuit emulation and then interrupt.
4.srt	00:04:11.680 --> 00:04:13.380	control is also available.
4.srt	00:04:13.410 --> 00:04:26.939	So, these are the external which can be connected and you can see that whatever cache memory which is a two way set associative 4 k bytes L 1 0 is available.
4.srt	00:04:27.460 --> 00:04:41.009	And then we have the clock generator here and then power down logic is available and then you will be seeing that for this is the data cache what you have seen L 1 D and then here this is the program cache.
4.srt	00:04:41.580 --> 00:04:45.019	So, L 1 P cache which is a direct map.
4.srt	00:04:45.250 --> 00:04:50.970	but this also has a 4 K bytes total basically.
4.srt	00:04:51.560 --> 00:05:16.970	And this is the interfaces what we can see this is the L2 memory interface and this is the L which can go up to 4 wave whatever it supports and then L2 memory which can go up to 492 K bytes of data which you can interface.
4.srt	00:05:17.420 --> 00:05:23.290	The other one is we know that whenever direct memory access has to be done we need the DMA.
4.srt	00:05:23.590 --> 00:05:49.120	So we have the external DMA controller here which is 16 channel what is available and some of the interfaces for the memory interface and then MAC BSP what it has and then it has a MAC ASP and then there are two MAC BSPs board support logic application specific logic interfaces.
4.srt	00:05:49.730 --> 00:05:55.650	is MAC ASP and then I2C what we saw there were two and then there are two timers.
4.srt	00:05:55.770 --> 00:06:09.930	So, using the timer we can interface the external world and this is the GPIO which is going to be connected to the board and then we can have a host port interface also using the USB.
4.srt	00:06:10.610 --> 00:06:15.470	So, this is gives the overall picture of the board basically.
4.srt	00:06:15.850 --> 00:06:20.400	So, we have the DSP processor here.
4.srt	00:06:21.050 --> 00:06:26.210	TMS320C6713DSP and then we have the SD RAM.
4.srt	00:06:26.210 --> 00:06:43.810	So, we can see flash memory is also available and some CPLDs and if we want to have the memory expansion we can go here actually some of the memory expansion and then we have the point external interface for this unit also.
4.srt	00:06:43.810 --> 00:06:51.200	And then for the peripheral expansion also what we can do it here.
4.srt	00:06:54.310 --> 00:07:12.230	And then you will be seeing some of the things this is the mic in for real time application I can use my input as speech through mic in or audio stereo what I can put it in the line in basically from any external device with audio and then some noise if you can feed in from the line in.
4.srt	00:07:12.410 --> 00:07:16.720	And then there are dual output basically here which is line out and then headphone.
4.srt	00:07:16.720 --> 00:07:21.130	So both are stereo basically so any from any one of it what we can.
4.srt	00:07:28.560 --> 00:07:29.070	take the output.
4.srt	00:07:29.070 --> 00:07:38.530	If a line out is taken and then it can be interfaced with a 1 volt board as a line in we can have the loop back system.
4.srt	00:07:38.920 --> 00:07:45.670	Or if I want to hear what is my after processing in the processor what output I am going to get.
4.srt	00:07:45.670 --> 00:07:50.530	So, I can connect the headphone or speaker out basically.
4.srt	00:07:50.990 --> 00:07:54.650	So, we have little bit of JTAG emulation.
4.srt	00:07:59.310 --> 00:08:02.250	So, which provides a to do the debugging friendly basically.
4.srt	00:08:02.250 --> 00:08:17.350	And then we have some power jack is what it is going to be connected which is a 5 volts power supply and this is the USB port which is going to be interfaced with our laptop or desktop any of the system.
4.srt	00:08:18.540 --> 00:08:33.050	And there are some DIP switches through which you can configure if you want to control your input and output and some LEDs immediately if you want to say whether your board is working or not you can do that.
4.srt	00:08:33.520 --> 00:08:45.310	and there is a software reset switch available here and then there is a configuration switch how this has to boot basically what you can configure with the switches.
4.srt	00:08:45.680 --> 00:08:49.930	And we have the external JTAG interface also.
4.srt	00:08:50.360 --> 00:08:56.920	So, which can be used for more debugging and then go deep into the in-circuit debugging part of it.
4.srt	00:08:56.920 --> 00:09:01.530	So, this what they call it as hurricane header what is.
4.srt	00:09:04.420 --> 00:09:12.450	So, coming to the functional block diagram, you saw the board diagram with all the components there.
4.srt	00:09:12.900 --> 00:09:25.800	From the functional block diagram what you will be seeing this is a chip and then you have the CPLD logic and some flash memory and then SD RAM and then these are the memory expansion unit what we have it.
4.srt	00:09:26.250 --> 00:09:32.840	We call this as external memory and then we have the peripheral this thing interfaces here.
4.srt	00:09:35.480 --> 00:09:39.650	expansion for host port interface what we can use the thing.
4.srt	00:09:40.040 --> 00:09:49.300	So using Mac BSPs one of them is going to be selected either your codec or peripheral expansion one can use the thing.
4.srt	00:09:49.300 --> 00:10:00.000	So with the peripheral expansion so we can add on camera unit, daughter card and other things to give extra features to the port.
4.srt	00:10:00.379 --> 00:10:07.670	And we have as I said in the theory class we will be using the AAC23 codec in this board.
4.srt	00:10:08.030 --> 00:10:20.440	And, other higher versions will be using AAC 3 1 versions and as we saw in the board these are the inputs, two inputs and then two outputs what is available.
4.srt	00:10:21.030 --> 00:10:26.620	And then we have the JTAG interface using the USB will be connecting and voltage regulator.
4.srt	00:10:27.060 --> 00:10:30.980	So, here it is going to be 5 volts what will be operating.
4.srt	00:10:30.980 --> 00:10:37.430	Some of the boards 5 5 series will be operating at 3 volts suboptimal voltage.
4.srt	00:10:37.870 --> 00:10:40.160	to run the board.
4.srt	00:10:42.840 --> 00:10:47.430	So, we will see little bit on AC23 codec interfaces how it can be done.
4.srt	00:10:47.840 --> 00:11:03.600	So, we will be using the MAC BSP 0 to input to this codec chip and then output ADC output is going to be taken out through MAC BSP 1 interface to the DSP board.
4.srt	00:11:04.020 --> 00:11:07.910	And then whatever the format it has to be defined we are going to provide it here.
4.srt	00:11:07.910 --> 00:11:12.990	And then as we can see that I can given as a mykin.
4.srt	00:11:13.590 --> 00:11:22.040	or stereo we will be seeing input or stereo output or I can connect the headset for it.
4.srt	00:11:22.480 --> 00:11:25.370	And then we have different configuration here.
4.srt	00:11:25.370 --> 00:11:31.430	So, we will be seeing in later classes how we will be interfacing these things.
4.srt	00:11:31.690 --> 00:11:37.899	So, coming to development kit features in this case.
4.srt	00:11:38.310 --> 00:11:45.259	So, we say that this is a Texas Instrument TMS320C6713DSP.
4.srt	00:11:45.639 --> 00:11:48.319	operating at 225 megahertz.
4.srt	00:11:48.799 --> 00:12:03.529	So, it has a AC23C stereo codec and then we have 6MB synchronous DRAM this is complete to the board what we are using it or whatever features I have mentioned it will be referring to the board.
4.srt	00:12:03.850 --> 00:12:15.299	Here we can go up to this memory if it is we in the full fledged board basically this would this is a.
4.srt	00:12:16.069 --> 00:12:21.429	development kit what we will be using it which is a subset of this features.
4.srt	00:12:21.809 --> 00:12:29.819	And we have 512 KB non volatile flash memory which is 256 KB usable in default configuration.
4.srt	00:12:30.519 --> 00:12:37.949	And we have 4 user accessible LEDs and DIP switches which can be configured for depending on our application.
4.srt	00:12:38.549 --> 00:12:47.769	And we have the software board configuration through registers implemented in complex programmable logic device that is the CPLD.
4.srt	00:12:48.419 --> 00:12:50.959	And, we have the configurable boot options.
4.srt	00:12:51.299 --> 00:12:55.959	Once the system is booted it can run on its own once the power is given.
4.srt	00:12:56.250 --> 00:13:02.039	So, it can continuously take the input and then it will be providing the output.
4.srt	00:13:02.370 --> 00:13:12.169	Only for loading your program and then debugging purposes we should have the interface with one of the hardware either laptop or desktops.
4.srt	00:13:12.679 --> 00:13:20.500	And then we have the standard expansion connectors for data card usage if it has to be connected.
4.srt	00:13:20.959 --> 00:13:30.069	and we have JTAG emulation through onboard JTAG emulator with USB host interface or external emulator.
4.srt	00:13:30.429 --> 00:13:36.839	And as it was said that it works on 5 volts power supply in this development kit.
4.srt	00:13:37.339 --> 00:13:44.969	So, coming to the programming language and little on the number system detail of it will be taking it up in the theory class.
4.srt	00:13:45.269 --> 00:13:50.199	So the type was DSK6713 supports.
4.srt	00:13:52.120 --> 00:13:56.500	ANSI C basically not complete C is available.
4.srt	00:13:56.889 --> 00:14:12.159	So based on that we have the characters and signed character are going to be 8 bits and the representation is the ASCII format and minimum is minus 128 and then maximum what it can go up to is 127.
4.srt	00:14:12.659 --> 00:14:17.399	And we can define unsigned character which is going to be 8 bits.
4.srt	00:14:17.569 --> 00:14:22.309	This also in the ASCII representation we have the representation.
4.srt	00:14:22.800 --> 00:14:27.899	and the minimum from 0 to 255 what it can take the range.
4.srt	00:14:28.379 --> 00:14:36.330	Coming to the integer sign basically sorry this is short which is 16 bits.
4.srt	00:14:36.330 --> 00:14:38.580	So which is represented as 2's complement.
4.srt	00:14:38.580 --> 00:14:53.930	So which will be having the range from minus 32768 to 32767 and unsigned short is going to be 16 bits but it is going to be binary so it will vary from 0 to 655.
4.srt	00:14:55.690 --> 00:14:57.800	3 3.
4.srt	00:14:57.800 --> 00:15:07.090	Coming to integer and then signed integer it is represented as 32 bits and then the representation is going to be 2's complement.
4.srt	00:15:07.410 --> 00:15:13.090	So, the range what you can see which can take in the board is so much for 32 bit.
4.srt	00:15:13.500 --> 00:15:24.220	Coming to unsigned int it can take 32 bits binary it will be from 0 to the 2 power minus 32 minus 1 is the value what it is represented here.
4.srt	00:15:25.800 --> 00:15:32.280	And then even it supports long and signed long, here it is going to be restricted to 40 bits.
4.srt	00:15:32.690 --> 00:15:44.670	So you will be seeing that usually long and then signed long has to be 64 bit, but only 40 bits is supported in DSK6713 board.
4.srt	00:15:45.120 --> 00:15:52.240	So if you want to use 64 bits then we have to provide long long and signed long long.
4.srt	00:15:52.900 --> 00:15:58.750	So which is represented as two complement and then the range what you will be seeing.
4.srt	00:15:59.140 --> 00:16:10.780	2 power minus 40 to 2 power 40 minus 1 and in this case 2 power minus 64 to 2 power 64 minus 1 on the positive range.
4.srt	00:16:11.750 --> 00:16:18.430	And the this thing unsigned you can have long long which is going to be 64 bits which can be binary.
4.srt	00:16:18.710 --> 00:16:22.680	So, 0 to 2 power 64 minus 1 will be the value in this case.
4.srt	00:16:23.750 --> 00:16:29.920	And then enumeration what we can have so which is also this thing 2's complement.
4.srt	00:16:30.290 --> 00:16:40.490	And, since this is DSK6713 is a floating point board this is going to support float 32 bits and double is going to be 64 bits.
4.srt	00:16:40.840 --> 00:16:53.550	So, the format what it is going to take is IEEE 32 bit format and for 64 bit is IEEE 64 bit format and then the range is going to be as specified here.
4.srt	00:16:54.430 --> 00:17:07.190	And then along double also what it supports it is 64 bits and IEEE 64 bit standard what it will be using and the range what it is shown here.
4.srt	00:17:07.909 --> 00:17:15.679	And like any other processes you should have a pointers, references, pointer to data members.
4.srt	00:17:15.939 --> 00:17:30.429	So which everything is going to be 32 bits in this which is a binary format and 0 to as you will be seeing it is in hex is 0 x all f f f basically ok.
4.srt	00:17:30.709 --> 00:17:42.009	So, we will now go to some of the example will show one I will be showing sine wave generation using the sine function.
4.srt	00:17:42.510 --> 00:17:48.790	on the board and then the dot product will be working on the simulator.
4.srt	00:17:49.200 --> 00:18:00.720	Both can run on the board, but to show that those who are unable to get hold of the DSK board some of the examples whatever shown here can be run using the simulator.
4.srt	00:18:01.320 --> 00:18:19.680	So, as an example for dot product what we have is we have taken one of the x of n is 1, 2, 3, 4 values and then the other one is 0, 2, 4, 6 as we know that the dot product of these two numbers is going to be given by this formula.
4.srt	00:18:20.110 --> 00:18:41.750	So, the total what we are supposed to get is 40 and then sine wave since we have discussed in the theory class that what will be the case if there is aliasing happens if proper sampling frequency is not selected that also will be showing you that what is the result of it.
4.srt	00:18:41.750 --> 00:18:45.890	So, we will go to the board to run our examples.
4.srt	00:18:46.260 --> 00:18:55.420	So, I will try to open the code composite studio as you can see there are two versions of it in my system.
4.srt	00:18:57.340 --> 00:19:00.070	So, this is a code composer studio 5.
4.srt	00:19:00.360 --> 00:19:09.430	So, you will be seeing the icon is going to be represented this way and if it is higher versions more than 6 or something like that now 11 version is also available.
4.srt	00:19:09.430 --> 00:19:15.660	So, it will be having this, but for this interface you have to have a board connected to that.
4.srt	00:19:15.930 --> 00:19:21.890	So, to show that the simulator is going to run only the simulator is provided up to version 5.
4.srt	00:19:22.310 --> 00:19:25.040	So, we will click on the code composer studio.
4.srt	00:19:25.350 --> 00:19:29.970	So, it will show you what is the workspace you want to select.
4.srt	00:19:30.380 --> 00:19:40.810	So, wherever your workspace either in C drive or D drive or whatever multiple drives you have it, you can use that directory.
4.srt	00:19:40.810 --> 00:19:49.560	In this case what I have used is so, D colon C6713 what I have given the name and then we will try to open this workspace.
4.srt	00:19:50.000 --> 00:19:58.940	If it is not there, if you are restarting it, you can browse where you want to create this directory and then give.
4.srt	00:20:00.800 --> 00:20:04.540	So, it will take a little time to open it.
4.srt	00:20:04.540 --> 00:20:15.320	So, if any of this thing up tradition is going to happen.
4.srt	00:20:15.610 --> 00:20:21.170	So, it will be showing that what are the files available for you to upgrade.
4.srt	00:20:21.570 --> 00:20:27.700	So, better not go for the up tradition because sometimes compilers gets corrupted.
4.srt	00:20:27.700 --> 00:20:33.950	So, you cancel them and then it shows welcome to code composer studio v5.
4.srt	00:20:34.310 --> 00:20:36.670	So, if you want to create a new project.
4.srt	00:20:36.970 --> 00:20:38.840	So, we can open here.
4.srt	00:20:39.259 --> 00:20:42.789	So, I will show from the scratch although I have two of them.
4.srt	00:20:43.160 --> 00:20:46.110	So, I will show you new project we will open it.
4.srt	00:20:46.490 --> 00:20:52.870	So, it will show you what is the requirement of the thing project name what I have to give.
4.srt	00:20:53.140 --> 00:21:01.240	Since I have already have the dot product what I will give is dot product 1 I will give it so that I will be creating a new one.
4.srt	00:21:01.740 --> 00:21:10.759	So, then it what I want output type is a executable which is default and then the processor families you will have different processor families.
4.srt	00:21:11.110 --> 00:21:15.549	It depends on how you have installed your code composer studio.
4.srt	00:21:15.920 --> 00:21:27.059	Since I have board for with ARM and then 5 4x series also boards we have in the lab and 55x boards are also there I have given option of these.
4.srt	00:21:27.279 --> 00:21:31.660	So, if you do not want anything you can give only C6000 option.
4.srt	00:21:31.660 --> 00:21:33.529	In your case and then go with it.
4.srt	00:21:33.850 --> 00:21:40.160	So, in this case I will be selecting platform is C6000 because 6713 is the board what I will be using it.
4.srt	00:21:40.640 --> 00:21:54.820	And then I have to select what kind of this thing type of filter if you want to have the thing or directly you can select it as DSK6713.
4.srt	00:21:55.280 --> 00:22:00.650	Now here what I have to do is whether I want to have that simulator or the emulator.
4.srt	00:22:01.019 --> 00:22:11.910	If I am connecting the board then I have to select that spectrum digital EZDSP on board USB emulator if I am connecting the board.
4.srt	00:22:12.140 --> 00:22:16.549	So, if I am running in the simulator mode then I will be selecting simulator.
4.srt	00:22:16.640 --> 00:22:23.390	So, first we are doing the dot product as I said promise that I will be showing you in the simulator mode.
4.srt	00:22:23.390 --> 00:22:29.049	So, I will be selecting the simulator in this case and then we can do finish.
4.srt	00:22:31.759 --> 00:22:38.789	So, you will be seeing on the left hand side what we the new project has got created.
4.srt	00:22:38.920 --> 00:22:43.549	So, and then you will be seeing that.
4.srt	00:22:44.210 --> 00:22:49.099	There is a C basic minimum has been come in here.
4.srt	00:22:49.519 --> 00:22:54.149	So, that is return of your main is integer what you are calling it.
4.srt	00:22:54.149 --> 00:23:02.019	So, void and then return 0 what it is going to be the default with the braces what you will be seeing it.
4.srt	00:23:02.019 --> 00:23:08.970	So, now, there is a little this thing what it ask for is the target configuration.
4.srt	00:23:08.970 --> 00:23:11.899	So, when I go to this one and then.
4.srt	00:23:14.980 --> 00:23:16.450	click on this board.
4.srt	00:23:16.769 --> 00:23:21.710	So, here you will be seeing that there will be little emulator what it will be coming.
4.srt	00:23:22.119 --> 00:23:25.740	So, what I want is the little endian.
4.srt	00:23:26.240 --> 00:23:37.109	So, one thing what we say is a little endian means that in the memory lower bits are stored first and then higher bits are stored later on.
4.srt	00:23:37.609 --> 00:23:45.190	So, when it comes to big endian then it is going to be higher bits first and then lower bits later.
4.srt	00:23:45.190 --> 00:23:52.879	Some interfaces may need that higher endian, but most of us need we are comfortable with lower bits first and then higher bits later.
4.srt	00:23:53.169 --> 00:23:55.839	So, we will be using the little endian in this case.
4.srt	00:23:56.230 --> 00:24:09.409	and then it will be asking default they started with the 62x that is why it will be showing 62x as a thing and some gel file wherever it has downloaded it is showing me emulator here.
4.srt	00:24:09.809 --> 00:24:13.309	But I want to have a simulator connected to this.
4.srt	00:24:13.399 --> 00:24:25.980	So, what I will do is I can first thing is I can remove this CCXML file.
4.srt	00:24:26.589 --> 00:24:28.819	And, then create my own new one.
4.srt	00:24:29.089 --> 00:24:32.509	So, we will see that how to create my configuration file.
4.srt	00:24:33.279 --> 00:24:47.329	I can give delete and then delete it and then now I will go to right click on this dot product one and then I will say new what I want is the target configuration file.
4.srt	00:24:48.089 --> 00:25:01.579	So, I will say yes to this and then I will click on the new configuration file.
4.srt	00:25:01.869 --> 00:25:07.439	So, you will be seeing that it is a Texas instrument simulator what it is giving me the thing.
4.srt	00:25:07.979 --> 00:25:17.219	So, now, what I will do is I have to come back to my main dot c and then put the dot product.
4.srt	00:25:17.509 --> 00:25:21.009	So, since I have already created the dot product.
4.srt	00:25:21.009 --> 00:25:32.699	So, we are calling it as a short, x count is 4 numbers what I showed in the this thing slide and then y count is going to be this and then we will.
4.srt	00:25:33.029 --> 00:25:41.159	what we will do is to save the time we will cut and paste this in our new directory.
4.srt	00:25:41.939 --> 00:25:47.189	So, I will be replacing this also main also because everything is given there.
4.srt	00:25:48.039 --> 00:26:03.649	So, this is a default main and we are initializing result is 0 and then result is what we calling as a function dot product of x comma y comma count and then finally, we can print a result.
4.srt	00:26:03.889 --> 00:26:12.569	because this is a integer what we have taken the thing short is 16 bit as already format what I have specified it.
4.srt	00:26:12.959 --> 00:26:20.589	So, I will be printing the result value in the integer format.
4.srt	00:26:21.279 --> 00:26:25.119	So, then the function dot product as you can see the thing.
4.srt	00:26:25.679 --> 00:26:35.729	So, you will be initializing i value and sum is 0 then depending on the count in this case count is going to be.
4.srt	00:26:35.999 --> 00:26:37.719	for what it is defined.
4.srt	00:26:38.109 --> 00:26:40.189	So, it will be less than count.
4.srt	00:26:40.549 --> 00:26:51.569	So, we will be incrementing it and then you are doing the product of A of i and B of i and it will be returning sum to the main this thing function.
4.srt	00:26:51.569 --> 00:26:56.879	So, what we will do now is you are seeing so many blocks on the thing.
4.srt	00:26:57.339 --> 00:27:05.319	So, this is where your project explorer is going to lie and then this is where your C code is going to be seen.
4.srt	00:27:05.319 --> 00:27:15.049	If you are writing in C and if you want to somebody wants to do assembly we can do that also, but the extension is going to be dot asm.
4.srt	00:27:15.329 --> 00:27:17.849	Here as you are seeing it is main dot C.
4.srt	00:27:18.269 --> 00:27:25.179	So, we can interface assembly and then see programming if time permits we will be seeing one example of that also in the end.
4.srt	00:27:25.639 --> 00:27:37.479	So, now, what I have is a console and then if there is any error what it will be coming and this is a GUI basically a code composer studio.
4.srt	00:27:37.829 --> 00:27:40.619	So, you have different options in this case.
4.srt	00:27:40.619 --> 00:27:42.549	So, we will be making use of one by one.
4.srt	00:27:42.989 --> 00:27:49.559	In this case what it shows is either there are icons to do build debug and then now.
4.srt	00:27:50.559 --> 00:28:01.699	compile the thing or I can go to the project option and then I can say that build automatically what it is shown ok.
4.srt	00:28:01.699 --> 00:28:08.029	So, I can use this or this one to see whether I have any errors in my code basically.
4.srt	00:28:08.029 --> 00:28:13.539	So, what it says is it is telling me there is an error in the case ok.
4.srt	00:28:13.539 --> 00:28:16.739	So, I can click on it to show me that.
4.srt	00:28:16.869 --> 00:28:18.149	So, that is.
4.srt	00:28:21.809 --> 00:28:25.749	undefined main dot c what it is showing me here.
4.srt	00:28:25.749 --> 00:28:28.949	Here as you can see count is undefined.
4.srt	00:28:28.949 --> 00:28:30.389	So, we will define the count here.
4.srt	00:28:30.489 --> 00:28:52.539	I can call this also short is equal to 4 what I will give the thing and then let us see by.
4.srt	00:28:53.339 --> 00:28:54.299	compiling again.
4.srt	00:29:42.539 --> 00:29:47.239	So, if you have not given control s. So, when you are trying to compile it will ask you whether to save the thing.
4.srt	00:29:47.699 --> 00:29:49.119	So, as you can see the thing.
4.srt	00:29:51.129 --> 00:30:16.729	I forgot to include these two in the beginning.
4.srt	00:30:17.329 --> 00:30:26.319	So, because for printing I need to have these two function defined.
4.srt	00:30:26.769 --> 00:30:29.319	So, we will be defining the count here itself.
4.srt	00:30:29.319 --> 00:30:35.999	So, I can remove the count from here this place and then now we will try to compile the thing.
4.srt	00:30:38.229 --> 00:30:42.629	So, as you can see the error is gone now, but still I have a warning.
4.srt	00:30:43.269 --> 00:30:48.189	So, what we will be seeing sometimes these warnings becomes critical in the board.
4.srt	00:30:49.279 --> 00:30:54.939	in the simulator it does not matter, but we have to take care of this warning also.
4.srt	00:30:55.269 --> 00:31:05.839	So, what it does is it is showing is stack is not defined and then some system memory has to be defined for heap operations.
4.srt	00:31:06.119 --> 00:31:19.659	So, what we can do is click right click on the thing and then go to the properties and then we will be getting the properties for this.
4.srt	00:31:20.059 --> 00:31:26.789	So, here we have the compiler option because it is the linker option.
4.srt	00:31:27.139 --> 00:31:30.999	So, what we will be doing is basic options what we have to take it.
4.srt	00:31:31.259 --> 00:31:35.509	So, you will be seeing that stack whatever the size has to be defined here.
4.srt	00:31:35.509 --> 00:31:46.119	So, I will give it as 512 as the stack size and then you will be seeing the dynamic and memory allocation that is basically heap size.
4.srt	00:31:46.499 --> 00:31:50.569	So, you can give it as 512 in this case also and then.
4.srt	00:31:50.899 --> 00:31:54.149	do ok and then do the recompilation.
4.srt	00:32:03.209 --> 00:32:11.659	So, you can see that there are no warnings also.
4.srt	00:32:23.359 --> 00:32:38.409	Now, what I can do is I can go to build and then I can build the working set whatever doing the current working set or I can I will be giving the or build this as you can see in the thing dot product.
4.srt	00:32:40.769 --> 00:32:43.789	So, you will be seeing that this is the active directory.
4.srt	00:32:43.789 --> 00:32:48.849	So, I can give active debug also or there is an icon.
4.srt	00:32:49.199 --> 00:32:54.149	So, that is debug this one because this is the current one I can do debug.
4.srt	00:32:54.619 --> 00:32:56.859	So, I have to select the simulator.
4.srt	00:33:40.509 --> 00:33:54.789	So, one way of doing it is I can copy whatever I have set the thing into this and then paste the configuration file and then I can go for debug.
4.srt	00:33:58.819 --> 00:34:04.949	See here because it takes little time to set the simulator what you have to do the thing.
4.srt	00:34:05.259 --> 00:34:11.959	So, what I will put is how to set a breakpoint because when I run the thing I do not want it to go beyond my control.
4.srt	00:34:12.339 --> 00:34:16.369	So, what I do is if I double click on whichever line I have it.
4.srt	00:34:16.759 --> 00:34:19.369	So, it will be generating a break point here.
4.srt	00:34:19.769 --> 00:34:46.129	So, now either I can go and run in different I can load the project and then I can resume from wherever I have stopped it or I can terminate or I can reset the software reset what I can provide from the code composer studio or I can restart or I can do step function in running or step over that particular function and then go to the next one.
4.srt	00:34:46.649 --> 00:34:49.209	or if you have done assembly programming.
4.srt	00:34:49.209 --> 00:34:51.899	So, you I can go into the assembly thing also ok.
4.srt	00:34:52.369 --> 00:34:56.449	So, here what I will give is the there is an icon to show that.
4.srt	00:34:56.449 --> 00:34:57.779	So, I can click on it.
4.srt	00:34:58.089 --> 00:35:06.519	So, it will be running as you will be seeing that from the start of the thing it has run up to the wherever I have put the break point.
4.srt	00:35:06.519 --> 00:35:09.999	So, now, you will be seeing that the sum value is 40.
4.srt	00:35:09.999 --> 00:35:14.969	So, this is how the product has been calculated.
4.srt	00:35:17.979 --> 00:35:26.379	I can stop debugging this and then what I will be showing one more example on the board.
4.srt	00:35:26.859 --> 00:35:37.769	So, you will be seeing that sign generation using the what I will do is I will close all of them because it may be getting confusion for you people.
4.srt	00:35:37.929 --> 00:35:41.509	So, I will click on the main dot c here.
4.srt	00:35:42.189 --> 00:35:50.329	So, you will be I will be using the mat dot h and then we are defining the sampling frequency initially we will define it as 8000.
4.srt	00:35:50.899 --> 00:35:56.749	And, then pi value has to be defined here it is not some of them are not explicit.
4.srt	00:35:56.749 --> 00:36:05.089	So, we have to provide it to the system and then we will be defining the float as my output.
4.srt	00:36:05.089 --> 00:36:17.079	So, the length of it I have given it as 256 depending on your sampling frequency and then sample period how many sample periods you have to generate you can specify it.
4.srt	00:36:17.669 --> 00:36:20.029	And then we are starting the main.
4.srt	00:36:20.389 --> 00:36:24.579	So, the frequency of interest in this case what I have given is 1000 Hertz.
4.srt	00:36:25.939 --> 00:36:26.699	So, what is it?
4.srt	00:36:26.989 --> 00:36:28.479	So, I will be incrementing.
4.srt	00:36:28.699 --> 00:36:32.519	So, as I said I will be using the sine function down actually.
4.srt	00:36:32.919 --> 00:36:43.999	So, we are defining 2 star pi into frequency divided by in my sampling frequency what I will be giving as frequency of interest and this is the sampling frequency.
4.srt	00:36:44.249 --> 00:36:57.269	So, in this case 1000 by 8000 what it is going to be 1 by 8 will be the value of this and theta will be incrementing it is going to go in steps plus equal to.
4.srt	00:36:57.659 --> 00:37:03.469	And, then if it goes beyond 2 pi will be resetting it to 2 pi basically.
4.srt	00:37:04.029 --> 00:37:07.099	And then output of i what we are going to calculate.
4.srt	00:37:07.099 --> 00:37:13.009	So, amplitude to increase its amplitude I said and will be finding the sine theta.
4.srt	00:37:13.009 --> 00:37:17.139	So, we have different ways of sine generation.
4.srt	00:37:17.139 --> 00:37:23.069	So, we are using the built in function which is defined in mat dot h sine function basically.
4.srt	00:37:23.479 --> 00:37:27.999	And then we will be calculating this.
4.srt	00:37:28.289 --> 00:37:32.199	So, now, what I will do is since it is already pre compiled.
4.srt	00:37:32.509 --> 00:37:42.980	So, you can see that it is compiled and here you will be seeing a little change in the thing I will show you the configuration thing here.
4.srt	00:37:43.349 --> 00:37:52.920	So, you will be seeing that it will be using the emulator basically that is DSK spectrum digital DSK board what it is going to use.
4.srt	00:37:53.409 --> 00:37:56.449	So, we will do the compilation.
4.srt	00:37:58.949 --> 00:38:04.839	You will be seeing that when it is loading onto the board you saw that green one running.
4.srt	00:38:05.199 --> 00:38:15.980	So, that the complete code and then go it will be placed on the DSP processor basically and then it is ready for running.
4.srt	00:38:16.019 --> 00:38:18.759	So, you will be seeing the pointer here.
4.srt	00:38:18.949 --> 00:38:23.949	So, here also to save the thing I have given the break pointer.
4.srt	00:38:23.949 --> 00:38:26.809	So, that we can have the control of it.
4.srt	00:38:26.809 --> 00:38:28.389	So, it will not be going back.
4.srt	00:38:28.610 --> 00:38:33.449	to original place or it may go anywhere else also.
4.srt	00:38:33.449 --> 00:38:35.449	So, we have run the thing.
4.srt	00:38:35.530 --> 00:38:47.099	So, you will be seeing that whatever the values that has modified the previous value what it was and then after the initialization you will be seeing that.
4.srt	00:38:47.460 --> 00:38:58.539	Some of them are in hex actually and some of them are in the here you are seeing the integer value the same thing where the location they have been stored these.
4.srt	00:38:59.039 --> 00:39:00.089	variables have been shown.
4.srt	00:39:00.489 --> 00:39:09.059	Now, what we will do is one of the other function what we will be looking at it because if I come out of it this tools is not going to be visible.
4.srt	00:39:09.559 --> 00:39:26.569	Either I can have a memory map file or I can see whatever values stored in the thing I can save the memory or before running it I want to load into memory some values I can do that or with some pattern I want to fill the memory I can do that.
4.srt	00:39:27.099 --> 00:39:42.279	And then real time operating system what we can use the thing and system analysis toolbox is also there somewhere if I want to use the hardware trace analyzer we can see that and now I am interested because I have generated a sine wave.
4.srt	00:39:42.739 --> 00:39:47.469	So, how does it look like either a sine wave or not what I want to check the thing ok.
4.srt	00:39:47.650 --> 00:39:53.980	So, since I have this is graph what I am function what it is available in the code composer studio.
4.srt	00:39:54.289 --> 00:40:00.759	So, we will be using that and here because I have taken it as a floating point.
4.srt	00:40:01.049 --> 00:40:10.829	So, I will be defining my this thing in data type as 32 bit floating point depending on whatever you want to define it you can do that.
4.srt	00:40:11.089 --> 00:40:15.449	So, now sampling rate is I have used is 8000.
4.srt	00:40:16.730 --> 00:40:21.489	And, then the start address what I want is I want to see the output here.
4.srt	00:40:21.839 --> 00:40:28.449	If you want to see any variable you can give the name of it, it will be showing you what it looks like.
4.srt	00:40:28.489 --> 00:40:31.210	So, you see that the sine wave has been generated here.
4.srt	00:40:31.210 --> 00:40:36.449	Now, I want to know at what frequency the sine wave has got generated.
4.srt	00:40:36.449 --> 00:40:42.699	So, what I can do is again I can go to tools and then here now graph I have a FFT map.
4.srt	00:40:42.779 --> 00:40:45.889	So, I can see the magnitude here.
4.srt	00:40:47.210 --> 00:40:54.719	So, we will be taking the theory also, but sometimes to see that what frequency I can use a built in function also.
4.srt	00:40:55.039 --> 00:41:16.449	So, here I will be putting it as 256 and then this is 32 bit floating point what we have it and then the sampling frequency at present is 8000 and then start address is output what I want to see ok.
4.srt	00:41:16.719 --> 00:41:27.189	So, and then here also if you want to have a more frame size you can choose the thing FFT order chosen in this case is 5 which is 2 power 5 is 32 is the frame size.
4.srt	00:41:27.549 --> 00:41:32.429	So, if I want to increase it to 8 it will be becoming 256 you can.
4.srt	00:41:32.690 --> 00:41:37.409	check the thing and window function what it is using at present is a rectangular window.
4.srt	00:41:37.699 --> 00:41:42.190	So, if you want to modify this functions you can do that ok.
4.srt	00:41:42.340 --> 00:41:47.519	So, you will be seeing that what we generated frequency was 1000 hertz.
4.srt	00:41:47.849 --> 00:41:51.199	So, you will be seeing the peak coming at 1000 hertz.
4.srt	00:41:51.559 --> 00:42:02.010	So, if you want to see you can move this cursor here and then exactly point to the center of it and you will be giving getting the exact value of the frequency what you have generated.
4.srt	00:42:07.500 --> 00:42:14.390	So, now, I will show you what is the thing is going to happen to our reconstruction because this has reconstructed if I change the sampling frequency.
4.srt	00:42:14.420 --> 00:42:24.340	For a simple case I will take it as 800 hertz is a sampling frequency what I am choosing whereas, my highest frequency component is 1000.
4.srt	00:42:24.880 --> 00:42:28.400	So, you may be guessing what is the output I am supposed to get.
4.srt	00:42:28.680 --> 00:42:33.980	So, hold on for a while and then we will see whether our theory and then practical goes hand in hand.
4.srt	00:42:39.180 --> 00:42:44.330	So, this is again I am recompiling and then loading directly onto the processor I am going to run the thing ok.
4.srt	00:42:44.670 --> 00:42:50.789	So, now we will see that go back to the tools again I will go to the graph.
4.srt	00:42:51.200 --> 00:42:55.730	So, I will see the single time graph again both are fit what we will be getting it.
4.srt	00:42:56.180 --> 00:43:11.120	So, this is a 32 bit floating point what I have the thing and then now the sampling frequency what I have used is 800 ok and start address for me again I want to see my output.
4.srt	00:43:11.539 --> 00:43:15.260	what is the thing I will be getting it out.
4.srt	00:43:15.880 --> 00:43:22.829	So, you will be seeing the compared to the previous one how the input frequency has been created.
4.srt	00:43:23.150 --> 00:43:39.010	Now, we will see it is FFT magnitude what output it has created ok. Coming to the graph we will do FFT magnitude again here it is 256 and then this is 32 bit floating point.
4.srt	00:43:44.110 --> 00:43:49.730	then sampling rate is 800 and then this is output.
4.srt	00:43:51.960 --> 00:43:58.710	So, if I want to change the thing I can make it 6 ok.
4.srt	00:44:00.139 --> 00:44:02.739	So, you will be seeing that it becomes 64.
4.srt	00:44:03.159 --> 00:44:15.010	Now, you will see that is it matching with theory I am supposed to get reconstructed signal as 200 hertz.
4.srt	00:44:15.599 --> 00:44:18.710	So, you are getting 1000 minus 800.
4.srt	00:44:19.079 --> 00:44:25.360	So, you are seeing that it is aliased version of the 1000 hertz is going to be 200 hertz.
4.srt	00:44:25.889 --> 00:44:39.579	So, this is how you can play around with your simulator or connecting the board even this code runs in the simulator one can check it and then you can get acquainted with the simulator or the board.
4.srt	00:44:39.659 --> 00:44:45.969	So, that more and more labs are going to be run based on it.
4.srt	00:44:46.210 --> 00:44:52.329	So, if you are comfortable in running few of the experiments it becomes easy for you to.
4.srt	00:44:52.650 --> 00:45:00.150	fiddle around with so many other real time interfaces and other things which we will be taking it in the next laboratory session.
4.srt	00:45:00.450 --> 00:45:00.829	Thank you.
42.srt	00:00:00.770 --> 00:00:26.579	Namaste, welcome back to real time digital signal processing course.
42.srt	00:00:26.579 --> 00:00:29.739	Today, we will discuss about graphic equalizer.
42.srt	00:00:32.390 --> 00:00:39.490	So, we had seen the demo, but again we will be demoing after completing the theory.
42.srt	00:00:39.859 --> 00:00:53.090	So, that previous class we saw that how to do echo cancellation and even generation in the previous class what we had seen the thing, why we have to cancel the echoes.
42.srt	00:01:02.079 --> 00:01:08.409	So, if it is required as a hobby you can generate the echoes and if you are not want the echoes which are generated by different sources, so you can do the cancellation.
42.srt	00:01:08.790 --> 00:01:12.250	So today what we will see is the graphic equalizer.
42.srt	00:01:12.890 --> 00:01:14.650	So, why do we need equalizers?
42.srt	00:01:14.980 --> 00:01:31.599	So, we know that we use in home sound systems, vehicle sound systems also, in musical instruments, amplifiers and processors, even in studios and even live concerts.
42.srt	00:01:33.219 --> 00:01:40.160	including our public address systems and then you can go on listing where we will be using the equalizers.
42.srt	00:01:40.670 --> 00:01:47.800	So, it is used to boost or cut certain parts of the audio frequency spectrum.
42.srt	00:01:48.400 --> 00:01:51.880	So, we changes the way the original audio sounds.
42.srt	00:01:52.719 --> 00:02:00.880	So, equalizers can be classified into four categories, one is tone control, the other one is graphic.
42.srt	00:02:01.469 --> 00:02:04.260	So, console and then parametric.
42.srt	00:02:05.280 --> 00:02:16.200	So, it is the graphic equalizer is a tool for independently adjusting the gain of multiple frequency regions in an audio signal.
42.srt	00:02:17.040 --> 00:02:33.270	So, the common graphic equalizer design can provide up to about 30 controls for manipulating the frequency response of each audio channel and structurally a graphic equalizer is set of filters.
42.srt	00:02:33.800 --> 00:02:36.280	So, if we are designing in the digital domain.
42.srt	00:02:37.210 --> 00:02:40.670	Each with a fixed center frequency and bandwidth.
42.srt	00:02:41.539 --> 00:02:54.650	The only user control is the command gain what it is provided or the amount of boost or cut in each frequency band which is often controlled with vertical sliders.
42.srt	00:02:55.290 --> 00:03:04.240	So, it is a very popular device for sound enhancement although it is more restricted than a parametric equalizer.
42.srt	00:03:05.219 --> 00:03:10.159	Available music players such as those available in mobile phones.
42.srt	00:03:10.639 --> 00:03:22.739	because, most of us use the thing usually have several preset settings for the graphic equalizer for different music styles such as pop, rock and then jazz.
42.srt	00:03:23.060 --> 00:03:30.289	So, one can investigate what are the things you needed for your music players.
42.srt	00:03:32.069 --> 00:03:42.329	So, continuing with the thing, so this can be implemented using either a cascade of equalizing filters or a parallel bank of bandpass filters.
42.srt	00:03:42.329 --> 00:03:44.620	So, we have discussed about the filters.
42.srt	00:03:45.099 --> 00:03:48.969	One of them you can consider in the cascade form or in the parallel form.
42.srt	00:03:49.719 --> 00:04:02.399	Bands in the graphic equalizers are two common designs are octave and one third octave graphic equalizers what we have it.
42.srt	00:04:02.939 --> 00:04:10.159	So, an octave is a musical interval which is defined by doubling in frequency.
42.srt	00:04:10.579 --> 00:04:17.179	So, octave graphic equalizer will have the ratio that is we call it as R is equal to 2 between.
42.srt	00:04:17.449 --> 00:04:18.409	each band.
42.srt	00:04:19.039 --> 00:04:33.239	So, in one third octave design, so each octave contains 3 bands which implies that R3 is equal to 2, R is given as 1.26.
42.srt	00:04:33.769 --> 00:04:46.539	So, starting at 1000 hertz that is 1 kilohertz and octave spacing would have geometric mean frequencies at 2 kilohertz.
42.srt	00:04:47.609 --> 00:04:50.759	4 kilohertz 8 and so on.
42.srt	00:04:51.309 --> 00:05:02.339	And in one third octave spacing would have filters centered at 1260 hertz 1587 hertz 2000 hertz and etcetera.
42.srt	00:05:02.339 --> 00:05:09.389	To call you back we generated musical notes Saragamapada Nisa.
42.srt	00:05:09.729 --> 00:05:13.429	So, if you remember that complete thing what we call it as one octave.
42.srt	00:05:19.259 --> 00:05:23.789	So, we started with the base frequency 240 hertz there and we went up to 480 hertz and different base what you can select.
42.srt	00:05:23.789 --> 00:05:34.369	I think music lovers will be knowing C C sharp and whatever their tone is going to be you can set at it and then you can go on adjusting your frequencies.
42.srt	00:05:34.559 --> 00:05:48.259	So, the number of bands is going to be determined by the spacing and the requirement to cover the entire audible spectrum what it is going to be considered.
42.srt	00:05:48.769 --> 00:05:53.009	So, what we call it is active graphic equalizers usually have.
42.srt	00:05:53.709 --> 00:06:02.009	10 bands ranging from about 31 hertz at the lowest to 16 kilohertz at the highest.
42.srt	00:06:02.579 --> 00:06:10.859	So, the third octave design usually have 30 bands ranging from 25 hertz to 20 kilohertz.
42.srt	00:06:11.239 --> 00:06:21.489	So, you will be seeing that how the difference of frequencies or bands what you have to select in your design part of it.
42.srt	00:06:23.169 --> 00:06:25.909	So, to show that octave frequency bands.
42.srt	00:06:26.289 --> 00:06:30.889	So, you can go to net and then you can see.
42.srt	00:06:31.459 --> 00:06:33.869	So, search for the thing you will be getting it.
42.srt	00:06:33.869 --> 00:06:41.219	Here whatever preferred octave frequency bands according to the ISO standard what it has been listed.
42.srt	00:06:41.619 --> 00:06:52.319	So, you will be seeing that lower frequency f 1 hertz is 22 to 11360 that is 11.36 kilo hertz what it is going.
42.srt	00:06:58.779 --> 00:07:01.529	So, in the geometric mean frequency that is u fc which is the cutoff frequency, centre frequency what we call it.
42.srt	00:07:01.919 --> 00:07:14.889	So, which varies between 31.5 hertz to 16 kilohertz in this and the upper frequency one can have is from 44 hertz to 22.72 kilohertz.
42.srt	00:07:15.589 --> 00:07:29.349	So, this is the table shows and then that is for complete one octave and if you say for one third octave frequency bands the ISO standard is given as this.
42.srt	00:07:30.369 --> 00:07:49.889	So, what you have is F1 and then you will be seeing little variation with the thing it varies from 22.4 to 562 what you can see it and your centre frequency is somewhere from 25 hertz to 630 hertz what it goes.
42.srt	00:07:50.089 --> 00:07:56.969	So, what it says is bold font represents the centre frequencies in this case.
42.srt	00:07:56.969 --> 00:08:00.519	So, because we said it is 30 bands what it has.
42.srt	00:08:01.299 --> 00:08:03.869	So, this is represented in one column.
42.srt	00:08:04.169 --> 00:08:21.359	So, in the next column you will be seeing the upper frequencies what it has it and then from the 500 and this thing 62 it goes from to 708 and then you will be seeing up to 17.78 kilohertz.
42.srt	00:08:21.359 --> 00:08:31.969	So, you totally you have 30 bands in it and these are the center frequencies what you will be providing for them and these are the upper frequencies.
42.srt	00:08:31.969 --> 00:08:35.219	So, for these frequencies these are the center.
42.srt	00:08:36.139 --> 00:08:43.549	and these are the upper frequency and for this set you will be seeing this as the center frequency and then upper frequency.
42.srt	00:08:44.209 --> 00:08:50.539	So, this is how synthetically you can generate your equalizers.
42.srt	00:08:51.119 --> 00:08:54.539	So, how to go about designing it?
42.srt	00:08:54.879 --> 00:08:58.659	So, in this case first we will consider the cascade part of it.
42.srt	00:08:59.099 --> 00:09:05.079	So, you want you can go to the theory and then see how the design is going to be done.
42.srt	00:09:05.529 --> 00:09:12.389	In this case we will consider we are going to give this is the input audio what it is going to be.
42.srt	00:09:12.729 --> 00:09:16.689	and this is the overall G 0 gain for the audio what we can give it.
42.srt	00:09:17.029 --> 00:09:29.679	And then for each band here it is 3 band or M bands what you are going to decide it can be 1 octave or 1 third octave what you can select.
42.srt	00:09:29.679 --> 00:09:39.429	So, if it is 1 octave it is 10 equalizes what you will have it and 1 third you know that 30 what you need it equalizes basically.
42.srt	00:09:39.429 --> 00:09:44.029	And for each one the gains can be varying from G 1.
42.srt	00:09:44.439 --> 00:09:46.449	G2 to Gm basically.
42.srt	00:09:46.929 --> 00:10:07.209	So, what it says is m is varying between 1 to m is the filter index receives as input the output of the previous band filter and finally, the last band we call it as H m of z produces the equalized output signal.
42.srt	00:10:08.019 --> 00:10:12.999	So, this is what how you provide to octave basically.
42.srt	00:10:13.349 --> 00:10:16.369	So, the band filters are biquad filters.
42.srt	00:10:16.819 --> 00:10:21.179	I think it should be something is ringing in your mind.
42.srt	00:10:21.519 --> 00:10:25.999	So, when we use the biquad basically in IAR filters.
42.srt	00:10:26.299 --> 00:10:39.219	So, as you will be seeing that it is a biquad section what we have chosen this is the input and this is plus and minus this is the feed backward path and this is the feed forward path.
42.srt	00:10:39.659 --> 00:10:47.769	So, if you want to have a B0 you can give the thing most of the time it is going to be 1 that is why it has been removed.
42.srt	00:10:48.579 --> 00:11:05.869	This is a b i of m because number of stages is going b 1 comma m, m will be varying between 1 to capital M. So, so many stages what you can do concatenation basically that is cascading what you can do.
42.srt	00:11:05.869 --> 00:11:15.929	This is a b 2 coefficient comma m and this is a 2 comma m and then this is a 1 comma m ok.
42.srt	00:11:16.359 --> 00:11:21.469	So, you will be seeing this is our output after adding it.
42.srt	00:11:22.089 --> 00:11:35.129	And, then because we know that our feedback coefficients are negative that is the reason why what you have put it as negative in this and these two getting added and then after that it is going to be subtracted.
42.srt	00:11:35.719 --> 00:11:48.569	So, if you remember the equation, so what we have it is I will write here y of n is equal to b naught into x of n plus b1 into x of n.
42.srt	00:11:53.649 --> 00:12:09.949	n minus 1 plus p 2 into x of n minus 2 and minus y 1 of n minus 1 minus y 2 of n minus 2.
42.srt	00:12:11.709 --> 00:12:21.039	Sorry, this is a 1 and this is a 2, a 2 into y of n minus 1 y of n minus 2.
42.srt	00:12:21.599 --> 00:12:25.859	So, this is the equation what we have it for the bike path section.
42.srt	00:12:28.719 --> 00:12:36.039	So, a 1 and a 2 are the bike the coefficients for the poles basically and then b 0 b 1 b 2 are the 0s.
42.srt	00:12:36.039 --> 00:12:40.279	So, this is what are biquad equations.
42.srt	00:12:40.329 --> 00:12:53.179	So, which is written in this way and then z minus 1 will be in the z domain the delay which is provided for x and then our y what we see it right.
42.srt	00:12:53.849 --> 00:13:04.009	So, what we can do is one filter is used for per band what it says.
42.srt	00:13:04.109 --> 00:13:07.419	So, that m is equal to 10 such.
42.srt	00:13:07.809 --> 00:13:11.339	Filters are needed for a standard 10 octave graphic equalizer.
42.srt	00:13:11.929 --> 00:13:30.209	So, each modified what filter which is named with ARFINIDIS band filter has its own linear gain gm what we call it and center frequency fc comma m for each this thing what it is defined.
42.srt	00:13:30.279 --> 00:13:40.419	So, now, coming to the thing first it is necessary to select the center frequencies fc comma m.
42.srt	00:13:40.829 --> 00:13:44.559	which are here set to the recommended octave center frequencies.
42.srt	00:13:44.929 --> 00:14:00.629	What it is given with previous slide what you have seen the thing that is these are the center frequencies mean frequencies what we have it for the 10 band same thing what it is going to be considered here in the case.
42.srt	00:14:00.899 --> 00:14:08.429	So, next one is 62.5 and then 125 hertz and then so on up to 16 kilohertz.
42.srt	00:14:08.429 --> 00:14:12.179	So, 10 band center frequencies what it has been.
42.srt	00:14:12.849 --> 00:14:19.489	So, now, we will see what are the magnitude response of an octave graphic equalizer.
42.srt	00:14:20.039 --> 00:14:26.919	So, you will be seeing that the thick line what it shows is the cascade structure.
42.srt	00:14:27.369 --> 00:14:41.289	So, you are seeing the this is the input and this is the output and this colored curves what it shows is 2 shelving and 8 band filters what it has been considered here.
42.srt	00:14:46.379 --> 00:14:47.329	So, you will be seeing that this is a low-pass filter after that what you have is a band pass filters.
42.srt	00:14:47.619 --> 00:14:51.569	So, each one represents the center frequency of each one of them.
42.srt	00:14:51.949 --> 00:14:58.559	So, we have it 1, 2, 3, 4, 5, 6, 7, 8, 9 and then 10.
42.srt	00:14:59.869 --> 00:15:11.589	So, you have what is it shows is 8 band filter with what we say Q is 1.41 of the cascade structure.
42.srt	00:15:11.589 --> 00:15:16.659	So, what it says is red circles command gains all at.
42.srt	00:15:17.759 --> 00:15:25.479	10 dB as we can see that all of them are at 10 dB and this is the frequency in hertz what we are going.
42.srt	00:15:25.519 --> 00:15:32.709	So, that is whatever in the previous one we had said that 31.5, 62.50.
42.srt	00:15:32.709 --> 00:15:45.109	So, you will be seeing they are the central frequencies what it has been chosen along the x axis and y axis will give us the magnitude of it.
42.srt	00:15:45.109 --> 00:15:47.719	So, the cascaded what it shows.
42.srt	00:15:48.669 --> 00:15:49.989	in the thick line here.
42.srt	00:15:50.759 --> 00:15:57.919	Now, how we can design the same thing in parallel that is what this figure shows.
42.srt	00:15:58.199 --> 00:16:18.939	So, we will be having the overall gain g naught here and then each one will have its own impulse response h 1 of z and they will be this thing multiplied with their gains in parallel and then you will be seeing that each one is getting added and then.
42.srt	00:16:19.299 --> 00:16:21.589	what will be getting get out.
42.srt	00:16:21.969 --> 00:16:35.889	So, what it says is here all bandpass filters receive the same input signal and the output is obtained as a sum of individual filter outputs that they are weighted by the command gains.
42.srt	00:16:36.269 --> 00:16:46.789	So, one has to think now whether we want to have the cascade graphic equalizer as it is shown here or the parallel.
42.srt	00:16:49.049 --> 00:17:03.819	think of it because we have seen even in IR filter design we said for our hardware because we are using DSP processor or if you want to implement in FPGA.
42.srt	00:17:04.319 --> 00:17:14.279	So, we said that multiplication overflow is taken care of whereas, the addition we are going to have a overflow in it.
42.srt	00:17:14.389 --> 00:17:20.629	So, we have to check every time if there is output is overflowing then we have to check.
42.srt	00:17:21.059 --> 00:17:25.989	scale them and then we will be taking care of all the overflows.
42.srt	00:17:25.989 --> 00:17:34.969	So, it is better to go with cascade section in hardware than the parallel structure although we have both the things.
42.srt	00:17:35.329 --> 00:17:51.479	So, if you are able to take care of whatever the overflow which is going to come from the addition in the input itself, then we can use the parallel section because we know that this is much faster compared to our cascade section.
42.srt	00:17:51.849 --> 00:18:07.240	So, what I will put it as this is parallelism what I can use it here, there I had to use the pipelining in between I had to put a what I will say is a buffer basically or a delay unit.
42.srt	00:18:07.240 --> 00:18:11.629	So, that each one will be pipeline structure what I can use.
42.srt	00:18:11.669 --> 00:18:21.919	So, you will be recollecting your pipelining and parallelism what we used in the theory here and then can go for.
42.srt	00:18:22.319 --> 00:18:23.789	implementation of it.
42.srt	00:18:24.209 --> 00:18:31.169	So, the next is we will take up as an example one can design a 3-pand equalizer.
42.srt	00:18:31.699 --> 00:18:52.079	So, it depends on some of that books gives that we can go with the 3-pand is enough that is what you will be having tone control was designed with frequencies of that is 200 hertz that is low shelf what you will be considering it and 1 kilohertz mid peak.
42.srt	00:18:52.509 --> 00:19:01.189	And, then here Q is taken as equal to 1 and 5 kilohertz what it says is this is the high shelf.
42.srt	00:19:01.239 --> 00:19:05.589	So, with this also you can design your graphic equalizer.
42.srt	00:19:05.889 --> 00:19:09.309	So, you will be seeing that what is it.
42.srt	00:19:09.479 --> 00:19:19.759	So, the dB what it is shown from here that is minus 12 to 12 dB what we you will be selecting it on different spaces.
42.srt	00:19:20.159 --> 00:19:24.069	And then this is your FC is your cutoff frequency.
42.srt	00:19:24.750 --> 00:19:36.829	And, then you are you call it as low filter shelving what you will have it and here cut off frequency fc gain g in dB what you will be providing it to the system.
42.srt	00:19:37.459 --> 00:19:56.709	And then the next one this is a low pass filter as we know and here it is a band pass filter that is middle frequency what we can call it as peak that is cut off frequency fc bandwidth fd gain g in dB what you will be taking it.
42.srt	00:19:56.759 --> 00:19:57.609	So, this is our.
42.srt	00:19:57.970 --> 00:20:04.980	cutoff frequency and this is the frequency range FD that is pass band region what you will be selecting it.
42.srt	00:20:05.470 --> 00:20:29.079	And the next one so on what you can design and next is the you are this thing multiple middle frequencies what you can see and then their peak and here your cutoff frequencies what you will be specifying with their gain as well as your band pass of this structure what it is shown here FD.
42.srt	00:20:29.759 --> 00:20:33.840	And, in the last what you will have is does a high pass filter.
42.srt	00:20:34.289 --> 00:20:51.529	So, which is H f which is given with cutoff frequency as usual f c and it is high filter shelving the last stage and cutoff frequency is f c and its gain is g in dB what it is given.
42.srt	00:20:52.029 --> 00:20:58.330	So, whatever dB you want to select you can select them and Y n is your output.
42.srt	00:20:58.809 --> 00:21:03.039	So, how we can decide design the thing all of us know that.
42.srt	00:21:03.400 --> 00:21:06.000	Audio file is given in the time domain.
42.srt	00:21:06.000 --> 00:21:14.590	So, x of t is our input which is coming from the it can be from the mic or audio system.
42.srt	00:21:14.590 --> 00:21:28.550	So, then we have to convert it into digital domain that is we will be using ADC depending on number of bits what we wanted we can select our ADC.
42.srt	00:21:29.080 --> 00:21:35.160	And after converting it into digital domain we will be getting x of n as our input.
42.srt	00:21:35.519 --> 00:21:43.220	which will be passing it through the equalizer and y of n is our output then what is it.
42.srt	00:21:43.470 --> 00:21:55.450	So, if I want to convert this back to that is our time domain then I have to use the DAC then y of t will be the output.
42.srt	00:22:05.509 --> 00:22:19.319	But I do not want to use this ADC and DAC, but I want to see that whatever I have stored it whether I can provide the equalizing filters designed for this equalizer filter 1, 2 and then M if it is whatever band you will be selecting it.
42.srt	00:22:19.670 --> 00:22:25.319	So, that is what the cascade section what you are seeing it which goes into your equalizer.
42.srt	00:22:25.860 --> 00:22:31.930	So, now, you will be seeing that in the market a 3 band equalizer is shown this way.
42.srt	00:22:31.930 --> 00:22:38.110	So, what is it you have a low frequency knob which you can adjust it.
42.srt	00:22:38.330 --> 00:22:38.400	it.
42.srt	00:22:39.049 --> 00:22:44.049	And then this is the mid frequency what you have it or middle one.
42.srt	00:22:44.450 --> 00:22:51.750	So, different one what you can select here one of it low or high whatever FD bandwidth what you want to have it.
42.srt	00:22:52.250 --> 00:22:55.860	And this is the high frequency what you will be selecting it.
42.srt	00:22:55.860 --> 00:23:03.549	So, you were seeing this is our low pass filter and this is what it is shown is the inverse of it.
42.srt	00:23:03.930 --> 00:23:09.580	So, that is band stop what you are seeing it and whatever frequencies you want to pass it.
42.srt	00:23:09.580 --> 00:23:11.850	So, you can put it as a band pass filter.
42.srt	00:23:12.250 --> 00:23:18.460	and then the other one is the high frequency filter what you are having it.
42.srt	00:23:18.600 --> 00:23:25.730	And some of the frequencies how you can adjust it what it is shown in this blue color.
42.srt	00:23:26.400 --> 00:23:32.700	So, this is the commercial which I have taken it from the net and then I am showing you how it can be designed.
42.srt	00:23:33.330 --> 00:23:43.390	So, this is completes our adaptive filter and that applications filter applications what we have considered.
42.srt	00:23:45.250 --> 00:23:56.990	for band pass filter, low pass filter and high pass filter how it can be used in scrambling, echo generation and cancelling and then in the equalizers.
42.srt	00:23:57.509 --> 00:24:16.880	So, in the next class we will be discussing about the speech coding techniques that is available in the literature and we will be considering one of the example how we can design both in MATLAB and then in code composer studio.
42.srt	00:24:19.299 --> 00:24:20.339	So, thank you.
42.srt	00:24:20.669 --> 00:24:27.569	So, happy learning for this material and then we will meet in the next class.
42.srt	00:24:27.569 --> 00:24:28.329	Thank you.
43.srt	00:00:01.219 --> 00:00:26.250	Welcome back to real time digital signal processing lab basically.
43.srt	00:00:26.550 --> 00:00:32.929	So we were discussing about the adaptive filters in the last class.
43.srt	00:00:33.280 --> 00:00:45.730	So, today we will see how we can use MATLAB first to generate different kinds of adaptive filters for different applications.
43.srt	00:00:46.119 --> 00:00:58.489	So, this is what we discussed two of the adaptive filters in the last class and today we will see first how we can use the adaptive system identification.
43.srt	00:00:59.039 --> 00:01:05.299	So, here it is a fourth order system was created using the unknown system.
43.srt	00:01:05.739 --> 00:01:18.780	in the MATLAB program and using the adaptive system identification program a seventh order system was initialized to 0 initially and the algorithm was performed.
43.srt	00:01:36.369 --> 00:01:37.799	So, in under 200 iterations the coefficients were determined with an overall error of 4.7269 to the power of 10 power minus 8 what it shows and the estimated coefficients values what we will be seeing it here.
43.srt	00:01:38.099 --> 00:01:43.399	So, we will go back to the MATLAB and then see whether we are going to get this results.
43.srt	00:01:43.549 --> 00:01:45.659	We will see the system identification.
43.srt	00:01:46.039 --> 00:01:51.029	So, this is one of the available codes to show the application.
43.srt	00:01:51.619 --> 00:01:57.369	So, you can use the book codes to do the thing.
43.srt	00:01:57.739 --> 00:02:00.819	This is written by Thomas Drumright.
43.srt	00:02:00.819 --> 00:02:06.979	It is you can see it is in 97 what it is written and still it can be used.
43.srt	00:02:08.159 --> 00:02:38.310	So, what the program does is it initializes input vector to 0 and then you have the mu is set to 0.1 that is convergence factor and then the length that is taken as 8 that is filter length and then the data value that is iteration number of iterations what it is selected is 200 and then input is a random number that is input white noise what it has been selected.
43.srt	00:02:39.909 --> 00:03:03.659	And, then mean square error is set to 0 and these are the initial input and initial coefficient filter coefficients basically the length of it what you will be take making it 0 w. And, you will be start calculating the that is unknown system which is given as unsystemed dot m in this case.
43.srt	00:03:04.020 --> 00:03:09.670	So, here you will be seeing this is the system coefficients what it is defined.
43.srt	00:03:10.240 --> 00:03:17.430	And, what the your system this thing identification has to converge to this.
43.srt	00:03:17.780 --> 00:03:23.300	So, W will be starting weight vector will be 0 and output will also be 0.
43.srt	00:03:23.730 --> 00:03:40.320	So, then you will be going on and then this is the desired signal what you have it and then error function you are trying to minimize that is the D minus Y, Y what you are considering with the X values.
43.srt	00:03:40.720 --> 00:03:43.300	and w is going to be updated as usual.
43.srt	00:03:43.810 --> 00:03:51.540	And then we will see that how it is going to converge to the required system and what is the value we will be getting it.
43.srt	00:03:52.350 --> 00:04:11.750	So, as you can see there will be little cut off if I increase the size of the font you will be losing some of the things on the top actually.
43.srt	00:04:12.100 --> 00:04:26.000	So, you will be seeing mean square error in between what it is high and then it is settling down to almost 200 it is almost it has become we can say it as nearer to 0.
43.srt	00:04:26.500 --> 00:04:34.879	So, that is what it shows for 200 iterations what it will be settling down and you will be seeing the values.
43.srt	00:04:43.199 --> 00:04:59.069	So, we said that you will be seeing that that this is the magnitude and this is the frequency response of the filter and you are seeing that whatever in the past band you are seeing this has a linear phase basically this is frequency versus phase what it has been plotted.
43.srt	00:04:59.500 --> 00:05:03.209	So, what we can do is we can close these two.
43.srt	00:05:15.430 --> 00:05:21.969	So, that we can go back and then see what was the initial value it was given and then how the estimated coefficients what we w that is system identification what you have done the thing.
43.srt	00:05:22.339 --> 00:05:28.329	So, it is given 1 minus 1.416, 5 minus 1.416 and then 1.
43.srt	00:05:28.329 --> 00:05:32.000	So, you will be seeing that this is what it has converged to.
43.srt	00:05:32.000 --> 00:05:40.409	So, you are able to identify what system you have given as input it is a band pass filter in this case.
43.srt	00:05:40.409 --> 00:05:43.149	So, the coefficient has merged with this.
43.srt	00:05:45.729 --> 00:05:53.399	Then going on to the next this thing this is the first application what we have seen it.
43.srt	00:05:53.399 --> 00:06:02.680	So, the next one what we will see is in the MATLAB how we can do the adaptive noise cancellation.
43.srt	00:06:03.110 --> 00:06:18.810	So, adaptive noise cancellation system was given an input of a noisy frequency varying that is sine wave after 1000 iteration you will be of the filter the noise is considerably reduced.
43.srt	00:06:19.099 --> 00:06:21.329	that is what it is written.
43.srt	00:06:21.689 --> 00:06:26.289	So, we will go back and then see noise cancellation in this case.
43.srt	00:06:26.289 --> 00:06:27.699	So, we will open this.
43.srt	00:06:28.179 --> 00:06:30.759	So, this is adaptive noise cancellation.
43.srt	00:06:31.259 --> 00:06:34.399	So, you will be seeing that mu is given as 0.01.
43.srt	00:06:34.399 --> 00:06:39.509	So, you can definitely expect that number of iterations is going to be more.
43.srt	00:06:39.509 --> 00:06:41.939	Here it is running up to 1000 iterations.
43.srt	00:06:41.939 --> 00:06:49.949	And then you have been given the input white noise is with 0.7 magnitude what it has been.
43.srt	00:06:50.779 --> 00:07:02.449	chosen and you will be generating the sine wave along with random noise and then we will see how the noise is going to get cancelled ok.
43.srt	00:07:02.610 --> 00:07:11.909	This is built in function sine wave generation and then you have your error function also which is going to be reduced.
43.srt	00:07:11.909 --> 00:07:14.329	So, the rest of the thing remains the same thing.
43.srt	00:07:14.329 --> 00:07:21.149	So, you will be displaying what is the error even the weight function you start from 0 and then you will be.
43.srt	00:07:24.209 --> 00:07:30.009	trying to adjust your weights based on your application.
43.srt	00:07:30.009 --> 00:07:31.189	So, we will run the thing.
43.srt	00:07:40.000 --> 00:07:45.069	So, you will be seeing that so many waveforms have got generated.
43.srt	00:07:45.800 --> 00:07:55.449	So, the figure 1 shows the in the time domain this is time and this is the noisy signal what we have it.
43.srt	00:07:56.029 --> 00:08:07.540	And we will see the next figure, this is figure 2, this is a time domain how does it look like a filter signal in the time domain.
43.srt	00:08:08.430 --> 00:08:21.939	So, the next one is what we have is figure 4 shows that this is the sine wave which was generated along with the noise basically.
43.srt	00:08:22.430 --> 00:08:26.240	So, this is in the frequency domain as you can see.
43.srt	00:08:26.650 --> 00:08:37.539	but naming has not been done here and this is the magnitude of it what you will be seeing on the y axis and x axis is in the frequency domain response.
43.srt	00:08:38.340 --> 00:08:55.259	And then the fifth one how the noise is introduced with the that is this is the noise signal in the frequency domain along with that is sine wave you have the noise present also.
43.srt	00:08:55.940 --> 00:08:57.730	So, now we will see.
43.srt	00:08:58.269 --> 00:09:04.850	Now, figure 6, you will be seeing that this is a frequency.
43.srt	00:09:05.309 --> 00:09:16.970	So, you are seeing that this shows I think this filter signal and this has got little bit exchange as you can see that here the noise is less after filtering.
43.srt	00:09:17.470 --> 00:09:25.679	So, the naming is little bit interchange that this is the noisy signal and then the filter signal is little less.
43.srt	00:09:25.679 --> 00:09:30.659	Sorry about it I done the mistake in y axis.
43.srt	00:09:31.269 --> 00:09:37.879	So, the next one is you will be seeing the error that is time versus mean square error.
43.srt	00:09:38.099 --> 00:09:43.989	So, you are seeing initially which was high and then which it has got considerably reduced.
43.srt	00:09:44.399 --> 00:09:48.509	So, this is how you would be doing the noise cancellation.
43.srt	00:09:48.959 --> 00:09:53.279	So, using adaptive filter.
43.srt	00:09:54.419 --> 00:09:57.969	So, the next one what we will see is.
43.srt	00:10:03.279 --> 00:10:21.429	After the noise cancellation, how your linear predictive coding is going to work ok. That is error signal from the linear predictive system basically what we have it.
43.srt	00:10:21.939 --> 00:10:30.339	That is system has a much smaller dynamic range in the frequency domain than does the original signal.
43.srt	00:10:30.669 --> 00:10:34.699	So, how this can be implemented what we look in using the.
43.srt	00:10:35.240 --> 00:10:35.750	MATLAB.
43.srt	00:10:39.019 --> 00:10:42.289	So, we will run the this thing.
43.srt	00:10:43.609 --> 00:11:02.909	What it has is you will be seeing that for the prediction the you will be seeing that convergence rate is very small and the filter length chosen is 100 in this case and the number of iterations as you can see it has gone up to 5000.
43.srt	00:11:02.909 --> 00:11:07.899	So, you will be seeing that the variation in iterations.
43.srt	00:11:08.219 --> 00:11:19.649	what it has been chosen from one application to the other application, it is increasing because it takes more time to predict the thing that is what it says.
43.srt	00:11:19.689 --> 00:11:22.989	This is a linear predictive coding what it is going to be.
43.srt	00:11:22.989 --> 00:11:29.299	It recursively calculated the coefficients of an unknown system.
43.srt	00:11:29.889 --> 00:11:43.539	The value mu's this thing specified the rate of convergence of the adaptive algorithm must be less than the smallest eigenvalues of the unknown transfer function for this adaptive filter to be.
43.srt	00:11:43.989 --> 00:11:45.489	properly conditioned.
43.srt	00:11:45.749 --> 00:11:54.059	So, for that you have to choose the lesser one and length is the order of the filter and then L i n is number of iterations to take place.
43.srt	00:11:54.819 --> 00:12:01.459	X is our input signal to the system, n 0, n 1 are the two independent noise sources in this case.
43.srt	00:12:02.659 --> 00:12:12.979	So, this is a sign which has this thing you are seeing that there are three sine waves what you are seeing in here.
43.srt	00:12:14.769 --> 00:12:17.279	with different frequencies what you have.
43.srt	00:12:17.399 --> 00:12:28.839	This is your signal S 1 what it has been given and then your N naught is the random noise white noise which is getting added with the signal.
43.srt	00:12:45.959 --> 00:12:47.979	Apply the adaptive algorithm what you will be doing it and x and w are initial input as well as the filter coefficients and you will be running the code for your this what is it multiple times.
43.srt	00:12:48.349 --> 00:12:56.539	So, you will be monitoring the mean square error what you will be setting it the J plus 1 will be set to the previous error.
43.srt	00:12:56.599 --> 00:13:06.079	And then your weight function is given with W z plus whatever the previous value with respect to updated.
43.srt	00:13:06.499 --> 00:13:16.399	This is how your W vector is getting updated and you will be seeing that these are the displays what you will be.
43.srt	00:13:16.799 --> 00:13:20.429	So, we will run and then see the algorithm how it is going to behave.
43.srt	00:13:20.459 --> 00:13:29.189	So, we will be seeing that what all the figures this is our input wave here also.
43.srt	00:13:29.189 --> 00:13:42.559	So, you will be seeing that S of t represents are in the time domain input wave that is time response of a noisy signal what we are considering it and then figure.
43.srt	00:13:47.259 --> 00:13:56.999	2 will be giving a filtered signal basically, how it is represented that is y of t in terms of time domain think.
43.srt	00:13:58.089 --> 00:14:08.179	And then figure 3 will represent time response of the error signal that is e of t what you are looking at random white noise how it is going to be.
43.srt	00:14:18.299 --> 00:14:19.339	And then next one is figure shows that how the error signal is reduced ok.
43.srt	00:14:19.779 --> 00:14:39.409	Somewhat at 100 it is coming down and then next one will be frequency response of an IC signal in the frequency domain what you are seeing it S of W what you are putting it with respect to weight vector what you are seeing the thing.
43.srt	00:14:40.139 --> 00:14:48.099	And then 6 will be whatever sign wave and then this is according to this we have done it.
43.srt	00:14:48.299 --> 00:15:02.969	So, you will be seeing that approximately we are able to achieve the this thing error signal how it is coming down and then your sine waves are what it is seen at the output it has adapted.
43.srt	00:15:02.969 --> 00:15:18.299	And this will be showing error along with the in the frequency domain how the error is much more compared to the previous one which has got.
43.srt	00:15:18.809 --> 00:15:20.319	out filtered out ok.
43.srt	00:15:20.389 --> 00:15:30.620	So, this is what after filtering and this is the before filtering how the noise was present in the input signal.
43.srt	00:15:30.679 --> 00:15:49.250	So, it is coding how LPC coding has been done to receive the our input basically correctly that is although there is a noise channel noise has been added as a white noise and the received signal is.
43.srt	00:15:49.539 --> 00:15:51.729	exactly what we have received.
43.srt	00:15:52.729 --> 00:16:01.399	And coming to the next application, so what we will be seeing with the MATLAB is adaptive inverse system.
43.srt	00:16:02.000 --> 00:16:15.299	So, that is demo will be showing the response of an unknown system and how the equalization can be done with the inverse system.
43.srt	00:16:15.769 --> 00:16:19.949	So, this is what the demo will look at it using.
43.srt	00:16:20.349 --> 00:16:24.849	So, we have the inverse system here.
43.srt	00:16:25.399 --> 00:16:36.289	So, we will run the thing that is calculated the coefficients of an unknown system, you specify the rate of convergence all the same thing.
43.srt	00:16:36.819 --> 00:16:44.829	So, what we have is here there is a unknown system to what it has been chosen for this application.
43.srt	00:16:45.279 --> 00:16:53.769	So, which has you will be seeing that this is the weight system coefficients what it is modified compared to the.
43.srt	00:16:54.159 --> 00:17:12.309	other unknown system dot m. So, this is the unknown system and then the output will be identifying the system basically it will be the inverse system how you can do the equalization to get the original system.
43.srt	00:17:12.309 --> 00:17:26.500	So, we will run the code sorry because that is a function which is called from here.
43.srt	00:17:26.889 --> 00:17:38.859	So, that is the reason why what you are getting the error it is telling that it does not have input arguments because I had to call this function from other source.
43.srt	00:17:39.179 --> 00:17:41.139	So, I would not be able to run it directly.
43.srt	00:17:41.139 --> 00:17:44.199	So, you will be seeing that will run from the inverse system.
43.srt	00:18:03.980 --> 00:18:14.779	So, here what it shows is we will get the detail of it and then come back to show the output here mu is chosen 0.005 and length of the filter chosen as 20 and the iteration is 5000 in this case.
43.srt	00:18:14.779 --> 00:18:32.579	So, you will be seeing that initial input vector what you have it and this is a Gaussian white noise what it has been added to our noisy signal and then you will be calculating your sine wave what you have it and the.
43.srt	00:19:07.789 --> 00:19:26.689	So, you will be adapting to your unknown system basically inverse of the system what I have to get it and then your weight vector as usual will be updated in this manner and then you will be performing your what is it frequency that is filtering what you will do it and this is the filter what it is being used you will be calling it is the response of the filter and then f is the frequency what it is being calculated you will be using the free Quincy Z with your weight vector W basically what it has and then 1 and then 512 what will be getting it and then you can do subplot and then it will be hold on and then rest of the thing what it will be giving you.
43.srt	00:19:26.689 --> 00:19:30.069	So, this is the filter one has to identify the thing.
43.srt	00:19:30.459 --> 00:19:38.069	So, you will be seeing the values what error you will be seeing that which is equal to 0.2848 what it has come down to.
43.srt	00:19:38.709 --> 00:19:50.349	And, you will be seeing that what is your answer for the thing what it has identified the unknown system that is inverse system.
43.srt	00:19:50.349 --> 00:20:03.739	So, this is the just hold on for a while I think or I will show from here you will be seeing that this is your inverse filter what it is working.
43.srt	00:20:04.169 --> 00:20:10.109	And, this is the response you will be seeing that of the original this thing.
43.srt	00:20:10.729 --> 00:20:39.499	filter what we have it and how you can that is equalize from the inverse system to the output level what you will be seeing and this is the noise which is getting added to your system this is in the frequency domain and this is also in the frequency domain how your error signal is going to that is noise is going to look at it.
43.srt	00:20:39.769 --> 00:20:44.319	So, from the noisy signal you can see that after your system.
43.srt	00:20:44.769 --> 00:20:54.809	has the what is it input basically what you have given the thing, the response of the system what you are looking at it.
43.srt	00:20:54.849 --> 00:21:08.169	So, you have identified from the noise also and then you are able to this was the original and you are able to correct it to the original and you are seeing your phase how does it look like.
43.srt	00:21:08.169 --> 00:21:15.949	Here in the original this is the phase of the system and in the recovered signal this is the phase of the.
43.srt	00:21:16.309 --> 00:21:16.809	signal.
43.srt	00:21:17.210 --> 00:21:28.529	So, this is how you will be applying your different applications that is adaptive filter in different fields of it.
43.srt	00:21:28.670 --> 00:21:33.930	So, that is the application of our adaptive filter.
43.srt	00:21:33.960 --> 00:21:40.750	So, now what we will look at it is we will go to equalizer what we discussed in the theory.
43.srt	00:21:48.070 --> 00:21:54.920	So, we one of the equalizer developed by our own student what we have seen in the last class.
43.srt	00:21:55.300 --> 00:22:00.370	We will see that how the MATLAB is has designed an equalizer.
43.srt	00:22:00.870 --> 00:22:10.670	So, we will see this is a my equalizer dot m anybody can download from the MATLAB website.
43.srt	00:22:11.850 --> 00:22:19.750	And then what all it is a new my equalizer or raises the existing single ton what it says.
43.srt	00:22:20.230 --> 00:22:36.220	And, H is the equalizer returns the handle to a new equalizer or the handle to the existing single turn and it will be calling this functions basically and this is a GUI ok.
43.srt	00:22:36.220 --> 00:22:43.080	So, it has other thing what you can see guide or whatever one of the thing what you can use it.
43.srt	00:22:43.510 --> 00:22:47.350	So, this was modified in 2008 which was available.
43.srt	00:22:47.930 --> 00:22:50.100	Some of when you download.
43.srt	00:22:50.230 --> 00:22:52.180	these things one has to be careful.
43.srt	00:22:52.560 --> 00:23:01.630	So, wherever wave read has been used in the latest MATLAB version it has been modified as audio read.
43.srt	00:23:01.800 --> 00:23:19.440	So, if you if it gives an error one has to modify it to audio read and then my play has to be changed based on the whatever 2020 B supports ok.
43.srt	00:23:23.170 --> 00:23:26.519	So, you will be using it to audio play instead of my play.
43.srt	00:23:26.920 --> 00:23:29.539	So, these are the modifications one has to do it.
43.srt	00:23:29.809 --> 00:23:32.559	So, we will run this file.
43.srt	00:23:37.230 --> 00:23:48.480	So, you are seeing that in this case by looking at it you must be able to identify how many control that is gain systems have been given.
43.srt	00:23:48.509 --> 00:23:52.830	It is a 5 band equalizer basically what you can see it.
43.srt	00:23:54.519 --> 00:24:03.750	and you are seeing that what they call it as C1, C2, C3, C4 and C5 are the 5 bands and what are the frequencies.
43.srt	00:24:03.750 --> 00:24:20.060	This is a low frequency and then this is band 4 to 8 kilohertz and this is 9 to 13 kilohertz what you can see and this is 13 to 17 kilohertz and this is the high frequency.
43.srt	00:24:24.870 --> 00:24:32.350	As you can see that the frequency is gone up to 44.1 kilohertz what it has been chosen for the audio and you have the 5 bands what it has been chosen.
43.srt	00:24:32.350 --> 00:24:42.000	So, we will see that we have all of them have been placed here knobs in the centre of it and this is the response what it is showing.
43.srt	00:24:42.190 --> 00:24:56.100	I think I may have to reduce the thing and then come back because all the control is at the bottom which I am unable to see the thing.
43.srt	00:24:56.710 --> 00:24:58.180	how we can do that.
43.srt	00:24:59.300 --> 00:25:14.090	So, by changing the resolution you will get back your what I will put it is the complete GUI will be shown otherwise some of it as you were seeing it the bottom portion was getting blocked.
43.srt	00:25:14.410 --> 00:25:28.850	So, now, we will see that load the whatever wave file which has come with the default what I will be taking it they call it as back 2 and then if you want to plot you can plot this is how the.
43.srt	00:25:29.440 --> 00:25:35.790	after equalization what you will be seeing it and we will vary and then see how it is going to look like ok.
43.srt	00:25:36.210 --> 00:26:00.750	So, we will play the thing now with the all of them are in equal positions ok. Only this is the length of it.
43.srt	00:26:01.150 --> 00:26:08.060	Now, what we will do is we will bring down the thing and then we will see plotting of it.
43.srt	00:26:09.040 --> 00:26:13.510	So, what you are seeing is almost low pass is what is it?
43.srt	00:26:14.110 --> 00:26:15.860	It is cut off ok.
43.srt	00:26:16.350 --> 00:26:19.980	The low frequency has come down to minus 16 dB.
43.srt	00:26:20.370 --> 00:26:24.000	So, this is the dB setting and these are all 0 dB.
43.srt	00:26:24.330 --> 00:26:29.810	So, if you want you can play and then here to this ok.
43.srt	00:26:33.260 --> 00:26:44.360	So, now, what we will do is whether we can go up to positive from 0 dB.
43.srt	00:26:44.360 --> 00:26:45.170	So, this is the 0 dB.
43.srt	00:26:45.630 --> 00:26:48.990	will increase the dB to 16 dB.
43.srt	00:26:48.990 --> 00:26:50.830	Now, we will try to plot it.
43.srt	00:26:51.480 --> 00:27:02.620	So, you are seeing that this is a low pass filter and rest of them this is at how much 16 dB as you can see the thing magnitude response.
43.srt	00:27:02.620 --> 00:27:08.400	So, it is low pass filter what it is happening rest of them are not that so we will try to play.
43.srt	00:27:23.410 --> 00:27:29.050	So, you can see how it became because more of low pass filter frequency is what it contains.
43.srt	00:27:29.480 --> 00:27:33.910	So, now, we will see the thing by increasing this to positive side.
43.srt	00:27:34.320 --> 00:27:36.090	So, we will plot the thing.
43.srt	00:27:36.660 --> 00:27:39.630	So, you are seeing that it is going in steps.
43.srt	00:27:40.030 --> 00:27:52.110	So, this I have given 10 dB, C to these frequencies whatever you are seeing it up to 20 kilohertz as I said 20.05 will give you 44.1 kilohertz is the sampling frequency.
43.srt	00:27:53.800 --> 00:27:57.740	pi by 2 whatever Fs by 2 what it is getting plotted.
43.srt	00:27:58.140 --> 00:28:01.870	So, you are seeing this is 16 dB and this is 10 dB.
43.srt	00:28:02.280 --> 00:28:17.500	So, hopefully it will not be so loud let us see.
43.srt	00:28:18.000 --> 00:28:20.440	We will go increasing this also.
43.srt	00:28:20.490 --> 00:28:23.820	So, we will put it as 6 dB.
43.srt	00:28:56.630 --> 00:29:06.020	then you can plot so you will be seeing almost in steps what we are incrementing it here and you can play the thing okay so you can see this plot again we have increased the other one and we'll do the other one little more than this one And, see how the plot looks like this is what I said you can keep playing with the thing this is gone up to 2 dB now here.
43.srt	00:29:06.410 --> 00:29:13.540	So, it is not any more 0 dB for the high frequency and then we will play the thing.
43.srt	00:29:14.470 --> 00:29:28.240	So, you can have your own music and then.
43.srt	00:29:29.710 --> 00:29:43.920	keep seeing it how it can vary what are the components present in it which one you want to highlight and which one you want to suppress as you would be seeing nowadays that most of you in mobile.
43.srt	00:29:43.920 --> 00:29:54.570	So, you will be having your own what is it audio basically for the whatever music you would be playing it only orchestra will be there voice will be yours.
43.srt	00:29:54.670 --> 00:30:02.870	So, voice of the original person is going to be separate and then you can have.
43.srt	00:30:03.400 --> 00:30:17.830	your voice inbuilt in that orchestra most of them you will be seeing single solo they will be playing without instrument these people will be using the orchestra part of it and then voice will be this.
43.srt	00:30:17.860 --> 00:30:24.930	So, this is how you can play with your music that is what I wanted to show.
43.srt	00:30:25.250 --> 00:30:32.840	So, in the next class what we will do is continuing with our application of adaptive filter.
43.srt	00:30:33.280 --> 00:30:34.810	So, we will be seeing.
43.srt	00:30:35.070 --> 00:30:45.940	in code composer studio same adaptive filter with different application what we have seen in the matlab we will be seeing in our board also.
43.srt	00:30:46.160 --> 00:30:46.630	Thank you.
57.srt	00:00:01.219 --> 00:00:26.039	Welcome back to real time digital signal processing course.
57.srt	00:00:26.469 --> 00:00:29.070	So hope you have enjoyed the course.
57.srt	00:00:30.940 --> 00:00:32.939	Today we will look at the summary of the course.
57.srt	00:00:34.179 --> 00:00:37.079	We started the course with introduction.
57.srt	00:00:37.490 --> 00:00:42.510	So, we know in real world all the input is in analog domain.
57.srt	00:00:42.909 --> 00:00:53.240	So, that is what we have seen here is time domain signal what we are taking it and then we are going to do the sampling using our ADC basically.
57.srt	00:00:53.240 --> 00:01:06.070	So, ADC can be either 8 bit or 12 bit or depending on the latest one sigma delta ADCs we can go up to 16 bit.
57.srt	00:01:06.329 --> 00:01:07.500	ADC conversion.
57.srt	00:01:07.549 --> 00:01:19.479	Then we will be converting it into digital signal X of n. So, then we are going to do the quantization because we know number of bits what we want to represent it.
57.srt	00:01:19.769 --> 00:01:26.119	So, in our case we have taken it as 16 bit basically in all our processor applications.
57.srt	00:01:26.500 --> 00:01:36.769	So, we can convert it into 16 bit and then do the quantization with respect to that and then we have to do encoding of this quantized signal into.
57.srt	00:01:37.319 --> 00:01:39.159	the number representation.
57.srt	00:01:39.379 --> 00:01:47.889	So, that is how we will get the digital output, but this constraint what we said was in the real time signal processing.
57.srt	00:01:47.919 --> 00:01:50.379	So, if I take my clock as this way.
57.srt	00:01:52.829 --> 00:02:04.099	So, we know that this is my time period what we are discussing about it or t is equal to 1 by fs is my sampling frequency.
57.srt	00:02:04.519 --> 00:02:07.219	So, for different sampling frequency.
57.srt	00:02:07.549 --> 00:02:12.030	frequencies, what should be a real time constraint one has to look at it.
57.srt	00:02:12.030 --> 00:02:19.459	So, the bottom table what it gives is different applications what we have in the real world basically.
57.srt	00:02:19.769 --> 00:02:32.259	One is the speech coding or decoding, one can use the ITU standard basically G dot 729 or 723 and the which requires a sampling frequency of 8 kilohertz.
57.srt	00:02:32.579 --> 00:02:36.560	So, we must be able to complete both decoding or sampling.
57.srt	00:02:37.739 --> 00:02:40.449	encoding within this time period.
57.srt	00:02:41.210 --> 00:02:47.509	So, and the time second in that is what we give it as capital T is equal to 125 microsecond.
57.srt	00:02:48.049 --> 00:02:54.439	And in the case of wide band telecommunication speech coding which uses G 72 or 72.2.
57.srt	00:02:54.719 --> 00:02:59.090	So, we know that the sampling frequency is 16 kilohertz.
57.srt	00:02:59.090 --> 00:03:07.889	So, our fs has to be 16 kilohertz and we must be able to finish our computation time in 62.5 microsecond time period.
57.srt	00:03:07.889 --> 00:03:14.000	And when you go for the high fidelity audio compression like MPEG.
57.srt	00:03:16.449 --> 00:03:23.079	2 or your AAC standard or MP3 standards or DOLB.
57.srt	00:03:23.399 --> 00:03:27.280	So, you know that they have operated 48 kilohertz.
57.srt	00:03:27.629 --> 00:03:42.120	So, within 20.833 microsecond I must be able to finish my sampling quantization encoding and even the computation of my signals and even outputting which has to be carried out.
57.srt	00:03:42.120 --> 00:03:46.409	So, that is what our real time constraint what we have put it.
57.srt	00:03:48.359 --> 00:03:55.379	The other way of looking at is it depends on application what we are choosing.
57.srt	00:03:55.849 --> 00:03:58.759	So, here only 3 what it is listed.
57.srt	00:03:58.759 --> 00:04:01.459	So, we have umpteen number of applications.
57.srt	00:04:01.919 --> 00:04:09.780	So, we have to define our system requirements in this case and develop the algorithms and perform simulation.
57.srt	00:04:10.769 --> 00:04:19.100	And then if we are using the DSP processor which DSP chip we have to select it we have to select it.
57.srt	00:04:19.519 --> 00:04:20.849	or the devices.
57.srt	00:04:21.089 --> 00:04:29.799	So, if you are having your own design either you can do your design in VLSI or in FPGA.
57.srt	00:04:30.279 --> 00:04:43.659	So, most of the application we want to try it on a field programmable gate arrays and if we have a requirement of many numbers basically then we can go in for the VLSI design.
57.srt	00:04:44.129 --> 00:04:53.009	So, the other two legs what we will be taking is software development is going to happen and then hardware development.
57.srt	00:04:53.339 --> 00:04:55.499	So, nowadays it is going to be.
57.srt	00:05:31.610 --> 00:05:32.819	what we call it as hardware and software co-design together they have to go hand in hand so that both the things match simultaneously otherwise all of us know that hardware multiple units come out and then we may not be accessing most of it because software is the must most costlier to develop basically so then usually we combine these to do the system integration and then check if it is going to satisfy our requirement or we may have to go back and select different algorithms for this application.
57.srt	00:05:33.139 --> 00:05:37.629	Then once everything is finalized then we will be doing the testing and debugging.
57.srt	00:05:38.029 --> 00:05:42.740	So, once the product is ready you can give it in the market.
57.srt	00:05:42.800 --> 00:05:49.439	So, different architectures what we went through in this course.
57.srt	00:05:49.740 --> 00:05:53.949	So, the first one was all of us know Von Neumann architecture.
57.srt	00:05:54.410 --> 00:05:58.930	So, we have the processor and then memory is single memory.
57.srt	00:05:59.220 --> 00:06:06.310	So, both address and data resides in the same memory and then we will be using the address and database to access this.
57.srt	00:06:06.620 --> 00:06:08.750	So, for our DSP applications.
57.srt	00:06:10.110 --> 00:06:16.639	Most of the applications we said that it is of this nature that is y of n is equal to sigma.
57.srt	00:06:17.040 --> 00:06:36.850	So, x of n minus k into h of k. So, this is our most of the applications what we said we need multiplication and then addition simultaneously and then we have to access 2 inputs at a time and then we may have to write 1 output.
57.srt	00:06:37.129 --> 00:06:41.269	So, for that reason so, Von Neumann architecture is not.
57.srt	00:06:41.550 --> 00:06:46.900	So, we said Harvard architecture was developed for this purpose.
57.srt	00:06:46.970 --> 00:06:47.910	So, what is this?
57.srt	00:06:47.910 --> 00:06:55.870	It has separate program memory and then data memory and even address and then data bus for them is separate.
57.srt	00:06:56.240 --> 00:06:58.730	So, in spite of developing the thing.
57.srt	00:06:58.760 --> 00:07:06.150	So, will be instruction fetch we can get it from the program memory, but data still we have one data memory.
57.srt	00:07:06.530 --> 00:07:12.190	So, if we keep on adding the hardware architecture is going to increase.
57.srt	00:07:12.460 --> 00:07:15.600	So, what it was decided because most of the.
57.srt	00:07:16.000 --> 00:07:28.540	If we are talking about the filter then we know that filter is designed much earlier in real time we will be using only those filter coefficients to pass it through our input.
57.srt	00:07:28.540 --> 00:07:45.440	So, this one can be stored in our program memory and both the and then input data is going to come into the data memory and then we can access them simultaneously.
57.srt	00:07:46.240 --> 00:07:54.170	And, then we can one more multiplication what we said was will go with the Braun multiplier.
57.srt	00:07:54.170 --> 00:07:55.950	So, which is a much faster.
57.srt	00:07:56.830 --> 00:08:03.380	So, we said that these are the two inputs for 4 bit what we drew our Braun multiplier.
57.srt	00:08:03.820 --> 00:08:10.590	So, in this case we are going to have an AND gate before the data comes into our Braun multiplier.
57.srt	00:08:17.350 --> 00:08:21.510	So, as you will be seeing that the longest part delay in this is going to be as you have seeing that from this path to the final output.
57.srt	00:08:21.950 --> 00:08:29.100	So, to reduce this also we can have pipelining in between stages ok.
57.srt	00:08:29.390 --> 00:08:34.670	So, that we looked into pipeline architecture later on.
57.srt	00:08:35.300 --> 00:08:47.350	So, and we know that we need shifting operations because we said that the input is going to be represented that is.
57.srt	00:08:47.580 --> 00:08:58.370	So, my x of n is the input which is going to be in between 1 and minus 1 and then 1 this is the range what I will be considering it.
57.srt	00:08:58.830 --> 00:09:04.230	So, what we have to do is it has to be shifted on the go.
57.srt	00:09:20.289 --> 00:09:23.750	So, most of the shifting operation we can use the barrel shifter either we can do a left shifter right shift even the output is exceeding certain limit then we have to do shifting of the thing before we feeding it to the next stages.
57.srt	00:09:23.750 --> 00:09:27.729	So, we can use the hardware barrel shifter.
57.srt	00:09:27.870 --> 00:09:33.569	So, which is going to do the shifting operation in 1 clock cycle.
57.srt	00:09:33.959 --> 00:09:47.620	So, if I want to shift 5 bits basically in normal cases in the sequential it will take 4 5 clock cycles whereas, using the barrel shifter I can finish it in 1 clock cycle.
57.srt	00:09:47.939 --> 00:09:50.069	So, that is what we saw the thing.
57.srt	00:09:50.549 --> 00:09:53.459	Next, is coming to the memory architecture.
57.srt	00:09:53.779 --> 00:10:08.909	So, how we are going to have the memory because we as far as possible we want to have a latency of accessing our data writing into the memory or reading from the memory or storing has to be minimized.
57.srt	00:10:09.319 --> 00:10:16.639	But the architecture defines that we cannot have whatever our wish.
57.srt	00:10:16.639 --> 00:10:23.369	So, based on the things so what we have is we will be having along with the CPU some of the registers.
57.srt	00:10:23.849 --> 00:10:24.939	will be having it.
57.srt	00:10:24.939 --> 00:10:38.319	So, they are the fastest one as you can look at it that is what we discussed it and we will have some this thing L1 and L2 memory which are little away from the CPU, but they are much closer.
57.srt	00:10:38.679 --> 00:10:43.389	So, their access is minimized and then we have larger memories down the lane.
57.srt	00:10:43.389 --> 00:10:46.819	So, this triangle gives you how will the access time is going to be.
57.srt	00:10:46.819 --> 00:11:04.779	So, the least one you will be seeing that our keyboard mouse and other things here even some of the tape readers what we had it earlier and then we will be seeing that ROM and then our removal devices and other things will be.
57.srt	00:11:05.169 --> 00:11:07.219	much slower compared to this.
57.srt	00:11:07.559 --> 00:11:11.209	This is how the memory hierarchy we went through in the class.
57.srt	00:11:11.629 --> 00:11:21.559	So, then we said that for increasing the speed of our computation we can go with pipelining and parallel architecture.
57.srt	00:11:21.949 --> 00:11:35.679	So, our intention was to get one within one clock cycle we have to get the whatever the input clock or output should be available in the same clock cycle.
57.srt	00:11:36.019 --> 00:11:41.169	So, every clock cycle I want to have the output whatever my computation is going to be.
57.srt	00:11:41.589 --> 00:11:46.589	So, one of the way of looking at is we can have a instruction pipeline.
57.srt	00:11:46.919 --> 00:11:50.479	So, most of the DSP processors have.
57.srt	00:11:51.849 --> 00:11:53.669	5 stages of pipeline.
57.srt	00:11:54.159 --> 00:12:01.049	So, that when the first stage is instruction 1 what it is happening.
57.srt	00:12:01.569 --> 00:12:06.579	So, later on when instruction 1 moves to step 2 basically.
57.srt	00:12:06.929 --> 00:12:09.869	So, the next instruction can be fetched.
57.srt	00:12:10.319 --> 00:12:14.859	So, when instruction 1 is getting decoded in step 2.
57.srt	00:12:15.229 --> 00:12:21.759	So, in the next stage you are going to access your data basically.
57.srt	00:12:22.109 --> 00:12:35.129	That is instruction 1 moves to get the data in the third clock cycle and then you will be passing the decoding of instruction 2 is happening and then you are trying to fetch instruction 3.
57.srt	00:12:35.719 --> 00:12:40.079	And then in step 4 and 5, I can have the execution.
57.srt	00:12:40.629 --> 00:12:45.379	So, most of the time it is step 5 is our execution.
57.srt	00:12:45.409 --> 00:12:53.819	Execution can be from one clock cycle to multiple clock cycles it may take depending on the hardware what we are going to use it.
57.srt	00:12:54.079 --> 00:12:57.009	So, most of the DSP processor we know that.
57.srt	00:12:57.349 --> 00:13:14.259	that our add is going to be in one clock cycle what I can fetch the I can complete my execution whereas, my multiply mpy operation is going to take two clock cycles.
57.srt	00:13:14.489 --> 00:13:28.049	Whereas, my this thing what is it we have a load and then store architecture what we said it is going to take four clock cycles.
57.srt	00:13:28.289 --> 00:13:50.039	And, branches in all this discrete processor 6 7 what I have considered that is DSK 6 7 1 3 and then 6 7 4 8 LCDK board from the TI they take branching of 5 clock cycles.
57.srt	00:13:50.109 --> 00:13:58.169	So, these are the computation that is execution times what we need it in this.
57.srt	00:13:58.579 --> 00:14:04.559	So, these are basically a load and store architecture what we call it.
57.srt	00:14:04.619 --> 00:14:08.729	So, we know how much clock cycle each instruction is going to take.
57.srt	00:14:08.729 --> 00:14:15.419	Some of the instruction I will come in a while, we may not know how much clock cycles.
57.srt	00:14:15.449 --> 00:14:20.609	Then we call them as this thing complex instruction cycle.
57.srt	00:14:20.609 --> 00:14:23.349	You would have heard of risk and risk.
57.srt	00:14:29.789 --> 00:14:48.809	So, DSP processor most of the time 80 percent it is going to use is a RISC architecture and 20 percent for our circular buffering and then what we call it as FFT operation we have to bit reversal has to happen they use CISC architecture for that.
57.srt	00:14:48.990 --> 00:14:52.589	And this is pipelining what we call it and then in the parallel operation.
57.srt	00:14:52.689 --> 00:14:57.709	So, we said that our DSP processor has a.
57.srt	00:15:02.329 --> 00:15:05.039	2 functional units in them.
57.srt	00:15:05.509 --> 00:15:19.979	So, parallely I can do my operations that is this has 4 functional blocks within each side there are 2 sides and then 4 functional blocks in each side.
57.srt	00:15:20.239 --> 00:15:22.279	So, if I operate them in parallel.
57.srt	00:15:22.279 --> 00:15:28.359	So, 8 functions what I can operate in parallel and each is 32 bit.
57.srt	00:15:33.869 --> 00:15:37.009	So, we have a data width of 256 bits for this get the complete instruction in 1 clock cycle.
57.srt	00:15:37.399 --> 00:15:45.169	So, we said that when we do 2 this thing sides of it we can do them in parallel.
57.srt	00:15:45.249 --> 00:16:04.849	So, how the delay is going to be here if it was taking for 8 clock cycles here you will be seeing that within 40 what I can finish one side of it the other side and then finally, the output from both the sides I have to add them up and give my.
57.srt	00:16:05.179 --> 00:16:06.719	y of n output.
57.srt	00:16:07.009 --> 00:16:17.869	Although we say that 2 units are there I should be completing within half the clock cycle of the original one, but you will be seeing that there will be some delay.
57.srt	00:16:17.869 --> 00:16:24.149	So, we will not be getting exactly that the computation done in half the clock cycle.
57.srt	00:16:24.839 --> 00:16:34.909	So, the next one was our number system what we discussed that is we said that we can represent floating point and then.
57.srt	00:16:36.199 --> 00:16:38.169	fixed point number system.
57.srt	00:16:38.769 --> 00:16:41.869	So, all of you know about the floating point.
57.srt	00:16:42.009 --> 00:16:45.329	So, just I will put one of the slide with respect to that.
57.srt	00:16:45.699 --> 00:17:01.109	So, what was the fixed point signed integer representation we said the number can be represented between minus 2 to the power of n minus 1 to 2 to the power of n minus 1 and how it is going to represent it.
57.srt	00:17:07.049 --> 00:17:17.879	So, we are will be considering that is minus s dot 2 to the power of n minus 1 and we are not giving any bit for our binary point representation.
57.srt	00:17:17.989 --> 00:17:27.029	So, we will be considering b n minus 1 2 to the power of n minus 2 to the power b 0 to 2 power 0.
57.srt	00:17:27.029 --> 00:17:33.759	The most negative value what I can represent with this number system is minus 2 to the power of n minus 1.
57.srt	00:17:34.179 --> 00:17:36.509	So, in because we have considered.
57.srt	00:17:37.769 --> 00:17:41.469	n is equal to 16 bit in our processor.
57.srt	00:17:42.139 --> 00:17:56.480	So, it the most negative value what I can represent with representation is 0x800 in hex basically or we call it as minus 32768 is the value in decimal what I can represent.
57.srt	00:17:56.480 --> 00:18:11.199	And the most positive value in this format is 2 to the power of n minus 1 minus 1 what I can have although we put minus 1 to 1.
57.srt	00:18:11.480 --> 00:18:13.169	So, I would not be able to represent.
57.srt	00:18:13.549 --> 00:18:15.039	plus 1 in this format.
57.srt	00:18:15.039 --> 00:18:22.009	So, the maximum what I can represent is 0 x 7 f f in hex.
57.srt	00:18:22.009 --> 00:18:32.689	So, which comes out to be plus 3 2 7 6 7 is the maximum value what I can represent with this number system.
57.srt	00:18:32.969 --> 00:18:43.909	So, you are seeing that different format what we considered in our representation that is Q 15 format means that it is 0.15.
57.srt	00:18:45.659 --> 00:19:00.219	and the largest value as you can see the thing and the least negative value is minus 1 and the precision what I am going to get it with respect to this number system is the as it is given.
57.srt	00:19:00.719 --> 00:19:10.249	So, like that we can go last one is the integer representation that is a Q15.0 format or Q0 format what we call it.
57.srt	00:19:10.249 --> 00:19:14.859	So, in that case the number in decimal what I will be representing.
57.srt	00:19:15.909 --> 00:19:19.709	is 3 to 7 6 7 to minus 3 to 7 6 8.
57.srt	00:19:20.029 --> 00:19:30.879	So, the precision is going to be 1 between the 2 bits that is LSB bit and the next bit that what I will have precision is 1.
57.srt	00:19:31.309 --> 00:19:38.609	So, as we know that we need high precision for most of our speech or audio processing.
57.srt	00:19:49.489 --> 00:19:59.339	So, Q 15 format what will be using it in our application and we know that the multiplication is going to have what is it 30 bits it represents because both are in Q15 format both inputs that is 16 bit memory what I have taken the thing.
57.srt	00:19:59.769 --> 00:20:10.329	So, when I multiply it so, we will be getting 2 sign bits basically from both the thing depending on if both are positive these two will be positive.
57.srt	00:20:10.599 --> 00:20:13.319	So, if one is negative one is positive.
57.srt	00:20:13.319 --> 00:20:19.459	So, it is going to be both are going to be negative and then both are negative then we will be having positive.
57.srt	00:20:20.299 --> 00:20:22.209	in the sign bit representation.
57.srt	00:20:22.209 --> 00:20:37.889	So, we call this is a extension of the sign bit and we will be discarding this and then we will be taking the 15 bits that is MSB bits from our output and we will be storing it in the memory.
57.srt	00:20:38.169 --> 00:20:41.609	This we call it as truncation when I am doing it.
57.srt	00:20:41.959 --> 00:20:50.189	So, if I know that my most of the values are in this higher 16 bits.
57.srt	00:20:50.709 --> 00:20:58.679	And, then exponents are represented with the 8 bits we said it is a biased what I will be representing them with.
57.srt	00:20:58.679 --> 00:21:14.179	And, then the fractional is 23 bits and then we know that there is a binary point here for our fractional representation which does not require any bits for it.
57.srt	00:21:14.629 --> 00:21:20.459	And, what is the representation it is minus 1 to the power of s into 2 to the power of s.
57.srt	00:21:20.829 --> 00:21:36.529	E minus my exponent minus bias into 1 plus because we assume that there is a 1 value before our point and then I will be representing this 23 bits for the fractional representation.
57.srt	00:21:36.909 --> 00:21:40.429	So, we call this is a bias.
57.srt	00:21:40.709 --> 00:21:43.929	So, that is what happens to my negative numbers.
57.srt	00:21:43.989 --> 00:21:50.239	I can have exponent both positive and then E can be both positive and then negative.
57.srt	00:21:52.009 --> 00:21:53.899	So, how I will be representing it?
57.srt	00:21:54.159 --> 00:21:57.699	So, that is how we have the bias what we have given the thing.
57.srt	00:21:58.059 --> 00:22:08.629	So, what we have is this is minus 127 to plus 128 is the number what I can represent with 8 bits in sign format.
57.srt	00:22:08.989 --> 00:22:12.319	So, what we do is instead of this representation.
57.srt	00:22:12.629 --> 00:22:22.809	So, we shift this one to 0 here which is equivalent to minus 127 and this one will be shifting up to 256.
57.srt	00:22:23.099 --> 00:22:30.479	So, that is how we will be having exponent minus bias whatever x is 7 bit what I have given the thing.
57.srt	00:22:30.769 --> 00:22:47.679	So, which will be computing it and we went on to discuss about some of the problems both in fixed point multiplication addition and then the floating point addition and multiplication how we have considered it.
57.srt	00:22:47.959 --> 00:22:58.829	So, most of the architecture as we know that multiplication is going to be multiply the fractional bits in floating point and add the exponent basically.
57.srt	00:23:00.499 --> 00:23:02.069	to get the result.
57.srt	00:23:02.419 --> 00:23:15.029	So, but whereas, the addition if you are doing the addition of 2 numbers then you have to bring them into the same exponent and then add them up.
57.srt	00:23:15.309 --> 00:23:19.839	So, what we say is in 6713 is a floating point processor.
57.srt	00:23:20.179 --> 00:23:30.639	So, which takes approximately if it has to do maximum adjustment it will take 10 clock cycle to do addition.
57.srt	00:23:31.569 --> 00:23:42.699	As you can see in the fixed point processors, it takes only one or two clock cycles, so one clock cycle to do the addition and two clock cycle to do the multiplication.
57.srt	00:23:43.179 --> 00:23:56.239	So, whereas, 6713 is a floating point processor, 6748 is a dual processor that is I can do either fixed point operations or floating point operations.
57.srt	00:23:56.529 --> 00:24:00.739	Both can be incorporated in the thing if we are writing our code in.
57.srt	00:24:00.969 --> 00:24:01.819	assembly.
57.srt	00:24:02.419 --> 00:24:15.399	So, coming to the thing we said that why we need pipelining and parallelism although I have we considered it for a low power applications basically.
57.srt	00:24:15.729 --> 00:24:31.969	So, we know that a typical computation time what we said was this is my T p is my computation time and then T naught is for whatever I O operations what I have it together it should be less than or equal to T.
57.srt	00:24:32.409 --> 00:24:43.049	So, most of the applications we say TP has to be approximately what we call it as 40 percent only the time what I will be getting it.
57.srt	00:24:43.379 --> 00:24:50.129	So, the rest of the things goes in getting the data in and then adjusting it and then sending the data out.
57.srt	00:24:50.579 --> 00:25:01.929	So, some cases if you are completely knowing about this operation we can make it as 50 percent and 50 percent time what is allocated for your.
57.srt	00:25:02.359 --> 00:25:06.329	computation as well as your I O operations.
57.srt	00:25:06.819 --> 00:25:16.449	So, then we said this is the parallelism if there are no dependencies then I can use the parallelism.
57.srt	00:25:16.999 --> 00:25:23.249	And then if this thing we took an example of water pipe how the water is going to flow.
57.srt	00:25:23.479 --> 00:25:29.009	So, we will be seeing that the pipelining architecture is going to go in this way.
57.srt	00:25:33.599 --> 00:25:40.919	So, what are the pipelining hazards So, if the complete pipe is full ok what we call it if it is full and at the starting itself I get a branch basically.
57.srt	00:25:41.469 --> 00:25:50.759	So, if the code is not properly written if I have a branch lot of branching in between.
57.srt	00:25:50.979 --> 00:25:59.259	So, then what happens whatever which has come into the pipe which has to be flushed and then you at the branching place again you have to.
57.srt	00:26:04.679 --> 00:26:11.749	put your pipe and then you have to go with the instructions which are following it.
57.srt	00:26:12.039 --> 00:26:32.859	And if you it so happens that if again if it happens after one this thing you are going to branch it then you will be seeing that whatever you have designed for getting the speed you may not achieve it may work at a lesser speed than in the sequential code basically.
57.srt	00:26:33.099 --> 00:26:36.029	So, one has to take it such that.
57.srt	00:26:36.489 --> 00:26:48.179	the branches are avoided as far as possible or usually what we do in the assembly program is we do the delayed of it.
57.srt	00:26:48.589 --> 00:26:59.149	That is we will have the branch here, but we will be putting some of the instructions which can be operated because as I was mentioning it may take branching takes 5 clock cycles.
57.srt	00:26:59.679 --> 00:27:04.879	Before that if there are no dependencies if I can operate the those clock cycles.
57.srt	00:27:04.879 --> 00:27:06.139	So, I will be saving those.
57.srt	00:27:06.539 --> 00:27:09.579	5 clock cycles by the time the branch is going to happen.
57.srt	00:27:09.579 --> 00:27:13.989	So, that my flushing of the pipe is going to be reduced.
57.srt	00:27:14.519 --> 00:27:19.569	So, and then how we are going to write our code in basically.
57.srt	00:27:19.959 --> 00:27:40.239	So, most of the thing we said we will have it C programming, most of our applications what we discussed was both in MATLAB and then in the DSP processor only we concentrated on the C programming we did not have time to do assembly programming those who are interested you can go through the text books and then see.
57.srt	00:27:40.879 --> 00:27:43.819	and then work on the assembly programming.
57.srt	00:27:44.309 --> 00:27:59.929	So, we have the compiler there and we have the compiler options also for branching and other things how we can minimize optimization one can do it up to 3 optimizations you can have it.
57.srt	00:28:00.179 --> 00:28:04.479	So, they give it as O 1, O 2 and then O 3 basically.
57.srt	00:28:04.829 --> 00:28:11.109	So, for different loop optimization we can incorporate and then use it.
57.srt	00:28:11.719 --> 00:28:20.819	So, we generate the machine code here in our case we said it is a co file what we are going to generate it for our boards.
57.srt	00:28:20.819 --> 00:28:37.399	And then we will be linking with the libraries and then loading on to the board and then we will be doing the execution and data input data is going to be given from codec if it is we are considering the real time.
57.srt	00:28:37.769 --> 00:28:42.909	If it is non real time it can be stored in memory and then it can be used.
57.srt	00:28:43.379 --> 00:28:52.389	And then if we are working on the real time thing output goes out of the board or you can store it in the memory for further usage.
57.srt	00:28:53.049 --> 00:29:00.029	So, then we said that how we can use this pipelining and then parallelism for the low power.
57.srt	00:29:00.469 --> 00:29:03.759	So, for that we discussed about little on the cut set.
57.srt	00:29:04.129 --> 00:29:11.289	How we are going to have the pipelining architecture developed from the existing one.
57.srt	00:29:11.619 --> 00:29:15.199	So, we said that the longest path delay.
57.srt	00:29:15.579 --> 00:29:20.039	is the time taken to compute our output.
57.srt	00:29:20.489 --> 00:29:26.719	So, in this case it is going to take 4 unit of time.
57.srt	00:29:27.129 --> 00:29:30.859	So, what we are going to do is I am going to put a cut set.
57.srt	00:29:31.179 --> 00:29:40.179	So, we said that it is only in the feed forward path what we had the cut sets and then as it shows there is an error.
57.srt	00:29:40.209 --> 00:29:46.899	So, we have to put a delay line or a buffer what we are going to put it since you are cutting this line also.
57.srt	00:29:47.309 --> 00:29:49.029	So, you have to put a delay.
57.srt	00:29:49.279 --> 00:29:53.969	So, all the lines wherever you have cut the thing you will be having the delay.
57.srt	00:29:54.429 --> 00:29:59.979	So, that is how in the FIR filter this is what the example what we took it.
57.srt	00:30:00.399 --> 00:30:08.099	So, which was taking one multiplication and then two clock cycles for our addition.
57.srt	00:30:08.549 --> 00:30:18.449	So, how we can reduce one clock cycle for multiplication and one clock cycle for addition by putting the feed forward cut set here.
57.srt	00:30:18.779 --> 00:30:21.269	and introducing the delay.
57.srt	00:30:21.469 --> 00:30:46.109	So, what is the disadvantage of it is we will be adding the hardware to this structure and the first output is going to be delayed by 1 clock cycle in this case and later on we will be getting every 1 by I will put it as t multiply plus t naught I will be getting my output from this structure.
57.srt	00:30:46.779 --> 00:30:49.139	So, we said that can we.
57.srt	00:30:49.479 --> 00:31:01.009	avoid this cut set by doing modification to our structure itself we said that transpose the filter structure.
57.srt	00:31:01.289 --> 00:31:13.489	So, this is how we did the filter transpose structure that is input and output were reversed and even all the whatever you had the feed forward one you have reversed them.
57.srt	00:31:13.849 --> 00:31:18.029	So, by doing that so, we call this is a broadcast structure.
57.srt	00:31:18.489 --> 00:31:22.469	So, X of n is broadcast to all the legs basically.
57.srt	00:31:22.789 --> 00:31:36.789	And, you will be having the delay in it and then you will be multiplying in this case each this thing node you will be seeing the delay is one multiplication and one addition what you will be getting the output.
57.srt	00:31:37.319 --> 00:31:48.319	So, then we went on to say why pipelining there are restriction to the thing because as I have already said because of the pipeline hazard.
57.srt	00:31:48.599 --> 00:31:56.439	So, we may not have more than 3 to 4 cut set at the most of the time we will have only 2 to 3. .
57.srt	00:31:56.909 --> 00:31:59.209	that is a maximum not even the fourth one ok.
57.srt	00:31:59.439 --> 00:32:18.549	So, beyond that how we can want to have what is it speed or in the case of you are considering the computation time or from the power point of view both the pipeline or parallelism we is going to reduce this the power consumption.
57.srt	00:32:18.929 --> 00:32:25.269	So, you will be seeing that how we can convert from serial to parallel structure and then parallel to serial.
57.srt	00:32:25.269 --> 00:32:28.989	So, we said the critical path in this case is the communication.
57.srt	00:32:29.379 --> 00:32:33.639	If communication between the 2 units.
57.srt	00:32:34.019 --> 00:32:40.689	becomes much more than the computation it is better to go for parallel architecture.
57.srt	00:32:41.219 --> 00:32:44.209	So, that is the restriction.
57.srt	00:32:44.479 --> 00:32:49.079	So, what is the power basically this is the propagation delay what we have put it.
57.srt	00:32:49.339 --> 00:32:59.069	So, which is going to have the charge capacitors and are the input voltage is V naught and then this is directly proportional.
57.srt	00:33:11.329 --> 00:33:14.099	So, we are putting the constant k in the this thing here basically and then we have V t is the threshold above which are transistors are going to switch on.
57.srt	00:33:14.499 --> 00:33:37.229	As we know that most of the TTL transistors you know that 0.8 volts is the cut off point above that what you will be taking it as on and then below that is going to be off and then if they are operating at 5 volts.
57.srt	00:33:40.609 --> 00:33:48.799	So, the power consumption is as you can see it is directionally proportional to the capacitors that are being used in the computation.
57.srt	00:33:49.219 --> 00:33:57.789	And you will be seeing that it is the one which is proportional to square of your input voltage.
57.srt	00:33:58.129 --> 00:34:09.849	So, whether we can operate it sub optimal voltage because which is the dominant we will call it as the unit in our power consumption.
57.srt	00:34:10.129 --> 00:34:12.619	So, we will we can reduce our power.
57.srt	00:34:13.079 --> 00:34:17.359	quite considerably and it is directly proportional to frequency.
57.srt	00:34:17.359 --> 00:34:36.669	So, if I want to operate at higher frequencies we will be going with parallelism or pipelining, but if I want to operate at the same frequency, but at reduced power consumption then I can go with red optimal what is it input voltage what we can operate.
57.srt	00:34:36.959 --> 00:34:42.499	So, the equation what it was given for the sequential one is given by this.
57.srt	00:34:43.029 --> 00:34:54.369	equation that is C charge into V naught divided by k into V naught minus V t whole squared and then f is given by 1 by T sequential that is the frequency of operation.
57.srt	00:34:54.819 --> 00:35:04.439	So, how we reduce the power by pipelining that is M stages of pipeline what we will be considering it by substituting in equations.
57.srt	00:35:04.689 --> 00:35:13.029	So, this is what we do the left hand side and right hand side will be putting it.
57.srt	00:35:13.679 --> 00:35:17.449	along with the sequential what we are considering our pipeline 1.
57.srt	00:35:17.919 --> 00:35:24.789	And then we will be assuming beta is the value by which I can reduce my operating voltage.
57.srt	00:35:25.169 --> 00:35:47.159	So, we will be considering calculating this beta and then we went on to show that in the sequential 1 the whatever our P reference takes 12 units of time whereas, in the case of pipeline without reducing F0.
57.srt	00:35:47.499 --> 00:35:48.769	So, we can operate it.
57.srt	00:35:48.959 --> 00:35:54.809	2 times the p reference and the clock period is going to be reduced to 6 unit of time.
57.srt	00:35:55.289 --> 00:36:10.649	So, if we use the reduced voltage that was reduced to 0.364 times the p reference basically, but I am operating at the same frequency as the original one.
57.srt	00:36:10.649 --> 00:36:18.669	So, then we consider both parallel and pipeline how we are going to consider the power consumption assumption.
57.srt	00:36:19.669 --> 00:36:22.729	with respect to propagation delay we calculated.
57.srt	00:36:22.729 --> 00:36:39.549	So, we have the L t sequential will be equal to t parallel what we will be having it and then based on our pipeline as we can see that it is t sequential is equal to t pipeline what we will be calculating it.
57.srt	00:36:39.549 --> 00:36:48.279	So, the equations have been propagation delays have been given in this and we will be solving L and then m values and we can combine both.
57.srt	00:36:50.609 --> 00:36:59.189	So, what is it pipeline and parallelism to get L by M will be the operating voltage of our circuits.
57.srt	00:36:59.189 --> 00:37:04.089	So, later on we went on to define our filters.
57.srt	00:37:04.329 --> 00:37:27.909	So, we said the common filter what you can see this is original signal and then you have multiple components which got have added with it and whether we can do low pass filtering to get one of them and then or do the high pass filter to get the multiple of the thing or I can select one of them to do the band pass filter.
57.srt	00:37:28.329 --> 00:37:30.259	or I can do the notch filters.
57.srt	00:37:30.259 --> 00:37:37.449	So, that I will be eliminating these two and then I will be trying to get one of them from the thing.
57.srt	00:37:37.479 --> 00:37:42.609	This is what we discussed and then we went on to discuss about FIR filter.
57.srt	00:37:42.609 --> 00:37:51.399	How FIR filter can be used in the linear phase response only a normal FIR filter is not a linear phase.
57.srt	00:38:01.919 --> 00:38:07.069	How do we represent the magnitude and then phase of the signal is given here that is magnitude of h of omega into e power j phi omega, where our phi of omega is nothing, but minus omega into n naught.
57.srt	00:38:07.509 --> 00:38:24.249	When we are going to achieve this linear phases when the we consider the symmetric coefficients basically that is h of n is plus or minus h of m minus 1 minus n, n will be going from 0 to m minus 1, m is the order of the filter.
57.srt	00:38:24.529 --> 00:38:55.329	So, we discussed about how we can design our FIR filter in our digital domain using hamming, Hanning window, hamming window and then Blackman window with different responses depending on what you want the peak that is minus 20 log delta whatever the cutoff frequency what you want to have it, whether you need it 21 dB down the lane or minus 44 dB or up to 74 dB what Blackman can give.
57.srt	00:38:55.779 --> 00:38:57.529	And then we said that main lobe is.
57.srt	00:38:57.529 --> 00:39:01.249	Going to be the smallest one for rectangular window.
57.srt	00:39:01.619 --> 00:39:09.059	And then as you will be seeing that black man has the next lowest one and then it will be same for both Hanning and then Hamming.
57.srt	00:39:09.449 --> 00:39:24.079	So as one comments here energy neither can be created or demolished basically what we say.
57.srt	00:39:24.559 --> 00:39:29.829	So, how we are going to distribute the energies in the windowing thing.
57.srt	00:39:30.189 --> 00:39:33.409	So if you distribute more energy in the windowing.
57.srt	00:39:33.639 --> 00:39:57.999	what you will see that in the main lobe then the side lobes is going to be reduced basically you what you will have it or so the main lobe has what you say narrow basically then you will be seeing that peak side lobes what you will be having it and then you have to have one of them compromise on the thing.
57.srt	00:40:05.219 --> 00:40:23.439	So, the what are the design stages for our filters basically so we are going to start We will be specifying some of the performance and then we will be doing the filter coefficients calculation using the MATLAB what we said either it can be a FIR filter or IR filter and then we have to define our realization structure what we wanted.
57.srt	00:40:23.439 --> 00:40:36.769	So, whether we want the linear phase for FIR filter or IR filter cascading section and then we will be looking at the finite word length effects analysis and solution.
57.srt	00:40:37.259 --> 00:40:45.599	And later on we will be porting them on to the hardware and our software implementation and then we will be going with the testing.
57.srt	00:40:45.899 --> 00:40:50.979	So, any of the stage if we are not satisfied the thing.
57.srt	00:40:51.069 --> 00:41:05.479	So, you will be going back to change the either the structure or you can calculate your filter coefficients by doing little bit narrowing or widening the thing and then.
57.srt	00:41:07.009 --> 00:41:12.349	Or you have to go back to specify your thing modify that itself.
57.srt	00:41:12.659 --> 00:41:20.139	So, you will be doing all this redesign if none of them satisfy you may have to go back finally, to this and then come down.
57.srt	00:41:20.819 --> 00:41:29.419	And then we went on to say what are the errors that are creeping in our digital signal processing or using the digital signal processors.
57.srt	00:41:29.779 --> 00:41:37.019	So, one is the ADC quantization error and then we had the coefficient quantization error and we looked at it.
57.srt	00:41:37.409 --> 00:41:47.159	and then there is a overflow error from our signal processors and then finally, when we are representing at the output we will have the round off error.
57.srt	00:41:47.799 --> 00:41:53.919	So, we said in IR filter from the FIR filter we went on to design our IR filter.
57.srt	00:41:54.329 --> 00:42:01.069	So, we said direct 1 form and direct 2 form what are the advantages and disadvantages basically.
57.srt	00:42:01.069 --> 00:42:08.329	So, our storage is minimized in this and whereas, here it is twice in this case.
57.srt	00:42:08.849 --> 00:42:16.519	And the problem with respect to these two is here if there are positive and negative values.
57.srt	00:42:16.519 --> 00:42:20.619	So, because you have only one summation unit here.
57.srt	00:42:20.939 --> 00:42:26.659	So, it may get nullified whereas, in the direct form 2 cascade section.
57.srt	00:42:26.939 --> 00:42:35.479	So, both negative also is getting added and then here it is the positive addition what it is going to happen.
57.srt	00:42:35.819 --> 00:42:40.359	So, all of us know that multiplication is not going to cause overflow, but.
57.srt	00:42:40.919 --> 00:42:44.359	addition can causes overflowing this case.
57.srt	00:42:44.659 --> 00:42:49.209	So, this is one of the disadvantage what we have to bear with our direct to form.
57.srt	00:42:49.729 --> 00:43:12.669	And we went on to say that our coefficient as in case of FIR filter we can represent it in Q15 format, but in the case of IR filter it is not possible to represent it because the maximum and then minimum value what will be getting is minus 2 to 2.
57.srt	00:43:13.049 --> 00:43:15.169	So, that is what we went on to.
57.srt	00:43:15.669 --> 00:43:18.409	with this triangle basically.
57.srt	00:43:18.409 --> 00:43:25.519	So, we have to represent coefficients in Q13 format for all our IR filter applications.
57.srt	00:43:25.889 --> 00:43:35.409	And we said that the how you are going to combine your most of the time we have the complex conjugate poles basically and zeros will also be occurring.
57.srt	00:43:35.609 --> 00:43:42.679	How we can combine them that is the which is from the 0 which is farthest.
57.srt	00:43:47.499 --> 00:44:01.019	in the pole positions which is going to be combined with the nearest 0s in the nearest to the 0 basically and then so on what you will be applying it.
57.srt	00:44:01.329 --> 00:44:09.009	So, that when we disturbance in the thing it is going to be minimized.
57.srt	00:44:09.459 --> 00:44:14.839	So, this has one has to work it has been over the years one has worked out.
57.srt	00:44:15.389 --> 00:44:19.029	And we know that in IR filter we will be designing our.
57.srt	00:44:19.879 --> 00:44:25.759	filter in using the ah analog domain and we will be doing the transformation.
57.srt	00:44:25.759 --> 00:44:43.499	So, we know that most of them are Butterworth filter what we will use it or Chebyshev 1 and then 2 basically and then the elliptic filter what we can design using ah in the ah analog domain.
57.srt	00:44:43.839 --> 00:44:49.769	So, this has a we know that it has a narrowed steep of what we discussed it.
57.srt	00:44:50.089 --> 00:45:21.669	And, here is this thing what Chebyshev 1 has a little ripple and then flat response and then Chebyshev 2 is you will have a ripple in the pass band and then the flat response and elliptic will have both ripple in pass band and then stop band and then we know that this is the lowest order filter what we can design and we went on to design a sign generator in the oscillatory mode and the same oscillatory mode can be.
57.srt	00:45:22.119 --> 00:45:31.919	design for the quadrature oscillator both you will be getting sine and then cosine output basically that was the application.
57.srt	00:45:31.959 --> 00:45:39.649	And then we went on to say that how the scaling is one of the important one in the case of IR filter.
57.srt	00:45:40.019 --> 00:45:46.369	So, either we can have L1 norm or L2 norm or L infinity norm.
57.srt	00:45:46.729 --> 00:45:56.519	So, we said that for hand calculation and other things we can use our pole positions A1 A2 coefficients to calculate our L2 norm.
57.srt	00:46:00.019 --> 00:46:15.569	So, and then L infinity we will we have to calculate the Fourier transform and then maximum of the value what we have to take it and then went on to show that our L2 norm is the minimum what we can calculate which is less than L infinity which is less than L1 ok.
57.srt	00:46:15.799 --> 00:46:21.529	So, we say that f of k is the impulse response from the input output of first adder.
57.srt	00:46:22.069 --> 00:46:30.839	So, that is w of 1 what we take it that the magnitude of it and you have to do summation and then calculate your scaling factor in this.
57.srt	00:46:31.289 --> 00:46:44.109	So, later on we went on to discuss about adaptive filters, I thought filters I will complete it and then go to a my DFT and then FFT and then DCT we can combine the thing.
57.srt	00:46:44.159 --> 00:46:59.499	So, we discussed about autocorrelations little bit on cross correlation and we went on to see little bit on random variables how to calculate our mean and variance and then we said that why do we need the adaptive filters.
57.srt	00:46:59.739 --> 00:47:01.769	So, if we have the.
57.srt	00:47:02.069 --> 00:47:11.349	output and then the noise is known then you can design either FIR or IR filters where you do not know the noise you have to adapt it to the scenario.
57.srt	00:47:11.689 --> 00:47:15.969	So, then in that case it is better to go with adaptive filters.
57.srt	00:47:16.219 --> 00:47:18.489	So, this is the adaptive algorithm.
57.srt	00:47:18.489 --> 00:47:25.029	So, these are the digital filter which weights can be adjusted based on my error function.
57.srt	00:47:25.329 --> 00:47:32.429	If I know the desired signal, so my output is going to be subtracted and try to minimize on the error.
57.srt	00:47:32.819 --> 00:47:34.599	and then adjust my weights.
57.srt	00:47:34.859 --> 00:47:44.879	These are the equations what we considered and we went on to show that it needs 2L addition and then 2L plus 1 multiplications to do my adaptive filter.
57.srt	00:47:45.539 --> 00:47:50.529	So, the practical applications few of it what we discussed only I have listed 3 here.
57.srt	00:47:50.919 --> 00:48:03.579	So, that is one is adaptive system identification if I unknown system what I have it whether I can predict what is that system is using this.
57.srt	00:48:03.909 --> 00:48:12.509	structure basically and then computing my error function minimizing on it I will be trying to know what is this unknown system.
57.srt	00:48:12.959 --> 00:48:16.759	Later on we said that adaptive prediction what I can do it.
57.srt	00:48:17.059 --> 00:48:31.159	So, by delaying my input itself whether I can know what kind of this thing prediction I can do my system is going to be that is what I am looking at.
57.srt	00:48:31.689 --> 00:48:32.969	This is one of the.
57.srt	00:49:12.909 --> 00:49:15.639	advantage of using noise cancellation in most of the speech if you are not in the closed environment where noise is not creeping in then you will be seeing in the public address system and other things so you will be having two mics or this is the signal what you are taking the source and noise is coming from here so whether you can predict this noise what it can be and then feed it into the system and see whether this noise is going to be subtracted from wherever you have your speech plus noise which is going in as an input so that I can adaptively cancel the noise.
57.srt	00:49:15.679 --> 00:49:26.519	Most of the application as you can see that in the engine noise most of the time in the aeroplanes or in the cars which is going to be cancelled out.
57.srt	00:49:27.129 --> 00:49:32.409	So, the other filter applications what we see was in the scrambling.
57.srt	00:49:32.889 --> 00:49:39.029	So, if you want to scramble your speech and then protect it or your audio or whatever may be the thing.
57.srt	00:49:39.349 --> 00:49:48.899	So, we took an example of 3 kilohertz input signal low pass filter and then 3.3 kilohertz as my this thing sign generator what I have taken.
57.srt	00:49:48.899 --> 00:49:50.659	I will be adding them.
57.srt	00:49:51.199 --> 00:49:58.379	sorry I will be multiplying these two signals and use the low pass filter with 3 kilohertz.
57.srt	00:49:58.809 --> 00:50:08.839	This can be replaced with your input speech or audio if it is within the thing you have to take care of your filter design here and then output is going to be a scrambled one.
57.srt	00:50:08.839 --> 00:50:17.149	Same output I can feed it to the input and then do this operation I will be getting my clean speech so that way you will be protecting.
57.srt	00:50:22.729 --> 00:50:29.309	your own one way of what you will call it as safeguarding your voice basically.
57.srt	00:50:29.689 --> 00:50:38.899	The other one we said that echo we did the creation and then how we can cancel the echo which is getting created.
57.srt	00:50:39.189 --> 00:50:48.479	So, multiple of the it can be a single echo or it can be multiple of them if it is got reflected we said it is a reverberation.
57.srt	00:50:48.849 --> 00:50:58.159	So, how we can create them how you can cancel it that is what some of the using are FER and then IR filters what we saw the example.
57.srt	00:50:58.239 --> 00:51:01.049	Next one was using the graphic equalizer.
57.srt	00:51:01.559 --> 00:51:10.609	using different equalization techniques, different filters it can be low pass, band pass or high pass filters.
57.srt	00:51:10.899 --> 00:51:17.959	You can either allow your audio to pass through or only the instrument to pass through.
57.srt	00:51:18.329 --> 00:51:22.869	So, most of the application you can use it in normal life.
57.srt	00:51:23.279 --> 00:51:32.579	So, next we went on to discuss about the speech coding techniques whether we had the waveform coders or coders.
57.srt	00:51:32.909 --> 00:51:39.899	and you can see that what kind of applications they use which are the bands what it is going to be used.
57.srt	00:51:40.219 --> 00:52:02.469	And one of the example what we took was one of the students project to show that LPC coding how it can be done both analysis and synthesis and then reconstruct your voice at the receiving gate almost equivalent we will not say same, but at least it is going to match with whatever voice it was getting generated.
57.srt	00:52:05.509 --> 00:52:09.379	We went on to why we have to go for discrete Fourier transform.
57.srt	00:52:09.819 --> 00:52:28.519	So, in the time domain we know that some of the frequencies component that are present in our input signal may not be clearer better to go into the other domain other transform domain to see that whether we can look at what is the thing happening to the signal.
57.srt	00:52:28.809 --> 00:52:32.049	So, as we said if the sampling frequency is not met.
57.srt	00:52:32.359 --> 00:52:36.189	So, we will be seeing that there will be a overlap of the thing.
57.srt	00:52:36.519 --> 00:52:41.069	So, whatever the frequencies so, we will be accounting for the aliasing.
57.srt	00:52:41.439 --> 00:52:55.019	So, we intended to have some frequency at the output, but we are getting some other frequency then definitely we know that in the Fourier transform which frequency we are getting it how it has got aliased and then you can avoid it in the.
57.srt	00:52:55.499 --> 00:53:07.449	time domain for that or your sampling frequency what you have to increase more than twice of that whatever Shannon sampling theorem says.
57.srt	00:53:07.829 --> 00:53:17.459	So, we know that the equation what we have is with respect to it is a complex equation that is e power minus j both real and imaginary parts are there.
57.srt	00:53:17.459 --> 00:53:20.839	And we went on to say that our coefficients can be represented.
57.srt	00:53:25.759 --> 00:53:35.659	in this manner and then how in the unit circle how your coefficients that is weight factors are represented is shown with that.
57.srt	00:53:35.659 --> 00:53:49.319	Then we said we can calculate our application of our DFT was to find out the magnitude spectrum and then how the phase is going to look at it.
57.srt	00:53:49.419 --> 00:54:02.239	So, we went on in the DSK board also to implement the same thing and some comparison we did the thing DFT if it is order of n squared is our complex multiplication which can be reduced to n by 2 log 2.
57.srt	00:54:02.879 --> 00:54:15.209	n complex multiplication in the case of FFT and we showed we have shown that how it is going to be the ratio for different order of the input basically.
57.srt	00:54:15.399 --> 00:54:31.489	And then we went on to say that our decimation in time and decimation in frequency to develop our butterfly structure to get our FFT as it is shown and then we said that how.
57.srt	00:54:32.899 --> 00:54:37.569	our computation in hardware can be for the bit reversal.
57.srt	00:54:37.979 --> 00:54:51.819	So, if it is input is bit reversed output we said it is in bit reversed format what we are going to have it sorry in line output.
57.srt	00:54:51.909 --> 00:54:57.069	If input is bit reverse in line then output is going to be bit reversed.
57.srt	00:54:57.319 --> 00:55:06.249	So, how we are going to access it as we discussed in the hardware we can do the reverse addition to calculate our bit reversal.
57.srt	00:55:06.559 --> 00:55:07.479	of the value.
57.srt	00:55:07.869 --> 00:55:21.139	So, that we need not have to spend on the algorithm if you go and look at the book you will be getting what complex we you have to do the reversal of it which will be taking lot of time.
57.srt	00:55:21.139 --> 00:55:29.179	Whereas, in the hardware we did the reverse addition so that we can immediately get our output and then we went on to show that.
57.srt	00:55:29.539 --> 00:55:38.469	So, how many this thing butterflies are groups and how many twiddle factors are required at each step.
57.srt	00:55:38.539 --> 00:55:42.189	stage because we have log 2 end stages.
57.srt	00:55:42.429 --> 00:55:49.409	So, we went on to say what are the twiddle factors that are going to be present in each stages.
57.srt	00:55:50.129 --> 00:55:56.099	So, we went on to discuss about finite word length effects in FFT also.
57.srt	00:55:56.099 --> 00:56:13.079	So, we know that signal to noise ratio is given by this equation that is it is directly proportional to number of bits and inversely proportional to the order of your FFT what you are going to consider and then these are the errors what we considered in FFT also.
57.srt	00:56:14.589 --> 00:56:28.009	And, later on for a lengthy signal how we can work on using a overlap add and then overlap same method to implement the same using RFFT.
57.srt	00:56:28.239 --> 00:56:36.349	So, then we went on to discuss about discrete cosine transform that is little on image processing what we did the thing.
57.srt	00:56:36.579 --> 00:56:43.229	So, how the DC value is going to be maximum in case of discrete cosine transform.
57.srt	00:56:43.719 --> 00:56:48.599	And then where are the low frequencies present and medium and then high frequencies.
57.srt	00:56:48.959 --> 00:56:56.699	So, because of our human visual system so, we may not be able to view this high frequencies so, we can.
57.srt	00:56:57.119 --> 00:57:00.619	eliminated and then go for the compression basically.
57.srt	00:57:01.009 --> 00:57:10.069	And then went on to say that our JPEG uses this DCT or compression technique to implement it.
57.srt	00:57:10.069 --> 00:57:24.529	So, you will be seeing that different colors how it is represented in the RGB domain and we know that it needs maximum word length and then number of bits are much more required in this case.
57.srt	00:57:24.849 --> 00:57:39.709	So, how we can go from one domain to the other here also in the YUV format as you will be seeing that it is represented in only here and then illuminance what we will be having it in the Y.
57.srt	00:57:39.709 --> 00:57:44.339	And then what we said was the color space conversion.
57.srt	00:57:45.939 --> 00:57:54.469	will be doing it into that is illumination and then chrominance and then both CR and then BR what will be taking it.
57.srt	00:57:54.469 --> 00:58:02.949	And then we can do the subsampling in the chrominance subspace basically and apply the discrete cosine transform.
57.srt	00:58:03.039 --> 00:58:05.789	Later on go on to do the quantization.
57.srt	00:58:06.409 --> 00:58:16.519	So, we use different quantization matrix to see that how much information we can discard.
57.srt	00:58:16.519 --> 00:58:26.419	Later on we went on to do in the DCT run length coding and in the inverse DCT it is going to use the Hoffman coding to get back R.
57.srt	00:58:27.119 --> 00:58:27.639	value.
57.srt	00:58:28.119 --> 00:58:54.089	Later on we went on to use butterfly structure to show that the order of multiplicate for the 8 bit 8 by 8 bit 1D or DCT needs 64 multiplications and 63 additions which we can be reduced using the butterfly structures to 13 multiplication and then 27 additions.
57.srt	00:58:54.519 --> 00:58:59.139	So, that is one of the technique what we used it.
57.srt	00:58:59.569 --> 00:59:00.259	to show this.
57.srt	00:59:00.259 --> 00:59:04.269	So, you will be seeing cos and sin function what it is going to be used here.
57.srt	00:59:05.029 --> 00:59:13.309	So, to wind up we have lot of people to be acknowledged few of them what I have listed here.
57.srt	00:59:13.750 --> 00:59:29.799	One is a Professor L.Uman and the NPTEL coordinator for allowing me to take up this course and then a Professor T.V Prabhakar who is the one who initiated me to give this NPTEL course and then initial.
57.srt	01:00:03.360 --> 01:00:15.539	he looked into my all the course contents and other thing he said it is very good and then you can go ahead and then professor n j rov was the mentor i should ask once i have given everything i was supposed to give my lectures he sat with me and then said these are the things what you can do it so final tuning and everything done was done by professor n j rov and then i cannot forget to acknowledge all NPTEL office people that is Avinash, Dipali, Gurraj Maya, Kavitha, Naidu, Navin, Vidya and then Sushma if I have forgotten any other names these are the ones I could remember.
57.srt	01:00:15.810 --> 01:00:28.289	Sorry I try to acknowledge everyone and bearing with me my lunch hour recording and other things they had to forego or little bit fine tune their lunches and other things.
57.srt	01:00:28.690 --> 01:00:34.140	And then I am very grateful to my reviewers of the course because those are the ones they said.
57.srt	01:00:34.510 --> 01:00:40.250	your course content is too much you may not be able to finish it in 12 weeks.
57.srt	01:01:06.690 --> 01:01:09.280	So, better to fine tune it and then it has to be fine tuned and then it has taken the stage and first of all I have to tell that IIT Madras for giving me permission to do this course for NPTEL and Swayam government organization who is I think doing all the everything and putting all questions and everything.
57.srt	01:01:10.010 --> 01:01:21.599	And whatever the support required from MATLAB because they were the first one to contact me saying that what are the tool boxes you needed for the students to use it.
57.srt	01:01:21.969 --> 01:01:34.530	So, definitely I have to acknowledge them for continuously in touch with them what are the things I need it and then providing online MATLAB for all of you to do the thing.
57.srt	01:01:34.920 --> 01:01:43.239	Later on I took the permission of Code Composer Studio although it is there online and those students who want to use their.
57.srt	01:01:43.730 --> 01:02:02.000	kids DSK 6713 in their colleges they can use that and then I have used the LCDK 6748 board as I was mentioning both it is fixed point and then floating point board for all my real time applications.
57.srt	01:02:02.519 --> 01:02:17.210	And this is would not have happened to show all the exercises what I have shown without my students who took DSP system design and real time digital signal processing course with me so far.
57.srt	01:02:17.889 --> 01:02:26.149	And then some of the books I have referred few of them what I have listed it is list may little bit go more actually.
57.srt	01:02:26.549 --> 01:02:37.919	The first one is SANE and then core real time digital signal processing fundamentals implementation and applications from V-LAY that is 2013 version what I am using it.
57.srt	01:02:37.919 --> 01:02:49.169	And if occur for my fixed point implementation and scaling and other things what I have referred from this book.
57.srt	01:02:49.169 --> 01:02:56.199	And the DENALDRY you would have seen some of the examples I was running from this book.
57.srt	01:02:57.209 --> 01:03:09.019	which uses both OMAP L138 and then for the 6 LCDK 6748 is the subset of this experimenter kit from John Ville which is the 2021 version.
57.srt	01:03:09.539 --> 01:03:20.769	And one more what I have used pipelining and parallel processing chapter from Keshav K. Pari on VLSI digital signal processing book.
57.srt	01:03:27.459 --> 01:03:37.009	So if I have forgotten and first of all I have to thank Thank you all for taking this course and then it is going well and if I am little bit delayed in answering your questions please bear with me.
57.srt	01:03:37.889 --> 01:03:39.819	Thanks to one and all.
57.srt	01:03:40.299 --> 01:03:47.649	So, happy listening and then working with respect to all lab experiments.
57.srt	01:03:47.929 --> 01:03:48.339	Thank you.
5.srt	00:00:01.219 --> 00:00:24.010	Welcome back to real time signal processing.
5.srt	00:00:24.250 --> 00:00:28.339	So, today we will discuss about the number system.
5.srt	00:00:28.940 --> 00:00:32.840	Just to give a recap of the what we covered in the last class.
5.srt	00:00:33.409 --> 00:00:37.859	First, we did sampling theorem, some DSP hardware basics what we looked into.
5.srt	00:00:37.909 --> 00:00:44.869	So, in this class we will see number system, its needs and then benefits in programming.
5.srt	00:00:44.869 --> 00:01:00.789	Although you may think that it is a primary class section, but we will see that how it is beneficial for implementing it in hardware that is what we will be looking it today.
5.srt	00:01:01.250 --> 00:01:04.780	So, first we will see what are the number formats available.
5.srt	00:01:05.250 --> 00:01:15.160	So, we know in DSP signals are represented as discrete sets of numbers from the input stage along through intermediate stages to the output.
5.srt	00:01:15.580 --> 00:01:28.570	So, all the stages have to be in the discrete format and all the applications of DSP like filters, FFT coefficients to be represented also as numbers.
5.srt	00:01:28.830 --> 00:01:35.969	So, there are two formats popularly available in DSP processors.
5.srt	00:01:36.440 --> 00:01:41.640	one is the fixed point format, the other one is the floating point format.
5.srt	00:01:42.010 --> 00:01:51.430	Most of you might have used the floating point format, still we will see how to represent that in DSP process we will look into the thing.
5.srt	00:01:52.130 --> 00:01:57.660	So, coming to the fixed point format, so we know that it is the simplest scheme.
5.srt	00:01:58.060 --> 00:02:05.270	So, we represent the number as integer or fraction using fixed number of bits.
5.srt	00:02:05.640 --> 00:02:09.290	So, we know that an n bit fixed point signed integer.
5.srt	00:02:09.879 --> 00:02:14.549	as we mention it again it is a signed integer what I am representing.
5.srt	00:02:14.989 --> 00:02:26.059	So, the representation will be from minus 2 power n minus 1 to 2 power n minus 1 and we know x is the number what we are representing.
5.srt	00:02:26.059 --> 00:02:40.319	So, which is given by so, minus s dot here s represents the sign bit of the number if it is equal to 0 it is positive number and if it is minus 1.
5.srt	00:02:40.739 --> 00:02:45.599	it if it is equal to 1 it is a negative number.
5.srt	00:02:46.189 --> 00:02:59.430	So, the first number will be minus s into 2 power n minus 1 and then the next number will be its magnitude is b n minus 2 what we will take it into 2 power n minus 2 and so on.
5.srt	00:02:59.819 --> 00:03:07.719	In the last we have b 1 into 2 power 1 and then plus b naught into 2 power 0.
5.srt	00:03:08.329 --> 00:03:10.930	So, all of us know that.
5.srt	00:03:11.280 --> 00:03:14.569	what is the range this number format can take.
5.srt	00:03:15.049 --> 00:03:26.479	So, we will see the most negative value in this format is x is given by minus s into 2 power n minus 1 to b 0 into 2 power 0.
5.srt	00:03:26.949 --> 00:03:30.789	So, if we know the negative bit is equal to 1.
5.srt	00:03:31.209 --> 00:03:39.179	So, if we substitute s is equal to 1 it is minus 1 into 2 power n minus 1 and rest of the bit is going to be 0s.
5.srt	00:03:39.620 --> 00:03:43.899	So, this is equivalent to minus 2 power n minus 1.
5.srt	00:03:44.319 --> 00:03:47.279	So, which is represented in binary format as.
5.srt	00:03:47.509 --> 00:03:50.469	1 followed by all 0s.
5.srt	00:03:51.159 --> 00:04:01.149	And then if we use 16 bit representation for this number, then the binary format for most negative number is going to be 0x800 in hex.
5.srt	00:04:01.729 --> 00:04:12.229	And then the most positive value in this format what it can take is minus s into 2 power n minus 1.
5.srt	00:04:12.419 --> 00:04:16.589	So, this is a number what we have represented as earlier.
5.srt	00:04:17.109 --> 00:04:21.259	And then we know the sign bit is going to be 0 for positive numbers.
5.srt	00:04:21.589 --> 00:04:26.519	So, x is represented as 0 minus 0 into 2 power n minus 1.
5.srt	00:04:27.899 --> 00:04:32.629	And we consider all the rest of the bits later as 1.
5.srt	00:04:33.310 --> 00:04:40.789	Then it becomes the number representation is equivalent to 2 power n minus 1 minus 1.
5.srt	00:04:41.279 --> 00:04:58.219	So, in the binary format it is going to be 0 because it is a positive number and rest of the numbers magnitude is represented as 1 in all through in 16 bit format the maximum value is given as 0x78.
5.srt	00:04:58.479 --> 00:05:00.819	f f f in hex.
5.srt	00:05:01.199 --> 00:05:05.739	We know the number representation hexadecimal I think most of you would have covered the thing.
5.srt	00:05:06.219 --> 00:05:11.989	So, f is the maximum number which gives us the 15 as the value for it.
5.srt	00:05:12.599 --> 00:05:17.560	So, the next one so, we have to represent this number in the integer format.
5.srt	00:05:17.909 --> 00:05:33.129	So, we know that in when I n is equal to 4 the value what I can represent in integer format is minus 2 power n minus 1 less than or equal to x less than or equal to 2 power n minus 1 minus 1.
5.srt	00:05:33.689 --> 00:05:36.509	So, in this we have substituted n is equal to 4.
5.srt	00:05:36.860 --> 00:05:39.829	So, if we substitute in the next line.
5.srt	00:05:39.949 --> 00:05:48.509	So, we know that minus 2 to the power of 4 minus 1 to 2 power 4 minus 1 minus 1.
5.srt	00:05:48.509 --> 00:05:58.579	So, the range is going to be minus 2 power 3 to 2 power 3 minus 1 which is nothing, but minus 8 less than or equal to x less than or equal to 7.
5.srt	00:05:58.949 --> 00:06:03.189	So, in this case we know that x belongs to minus 8.
5.srt	00:06:03.509 --> 00:06:16.600	minus 7, minus 6, minus 5 so on and then the positive side it is 0, 1 to 6 what we and then the last one is 7 in this slide.
5.srt	00:06:16.600 --> 00:06:24.840	So, we will see that how to represent our number x is equal to minus 3.
5.srt	00:06:26.550 --> 00:06:30.000	So, that this is the integer format.
5.srt	00:06:30.300 --> 00:06:33.800	So, we said x is equal to minus 3 how we can represent.
5.srt	00:06:34.189 --> 00:06:36.960	So, we know that this is a negative number.
5.srt	00:06:37.439 --> 00:06:46.580	So, s will be equal to 1 and then we know that when I divide 3 by 2 I will be getting 1.
5.srt	00:06:47.040 --> 00:07:02.480	So, the digit what it will be is 1 into 2 power 1 plus 1 will give me plus 3 and then since we are using the 4 bit representation this bit is going to be 0.
5.srt	00:07:02.830 --> 00:07:09.490	So, the number what I can represent in binary is 1 which gives the negative value and 011 is.
5.srt	00:07:09.710 --> 00:07:18.490	So, coming to why we have to go for the fixed point fractional format, we will see it in a while.
5.srt	00:07:18.490 --> 00:07:21.610	First we will discuss what is this number system.
5.srt	00:07:22.290 --> 00:07:36.210	So, the n bit fixed point signed fraction representation, we say that the number x can be represented between minus 1 to 1 minus 2 to the power of minus n minus 1.
5.srt	00:07:36.600 --> 00:07:42.000	So, n is the number of bits what we will be using as normal notion.
5.srt	00:07:42.790 --> 00:07:44.620	So, if I represent this.
5.srt	00:07:45.360 --> 00:07:47.360	in the open format.
5.srt	00:07:47.360 --> 00:07:57.730	So, x will be minus s into 2 power 0 plus b minus 1 into 2 power minus 1, b minus 2 into 2 power minus 2 and so on.
5.srt	00:07:58.130 --> 00:08:04.560	And then the last number will be represented as b minus n minus 1 into 2 power minus n minus 1.
5.srt	00:08:05.180 --> 00:08:08.480	So, here again s represents sign of the number.
5.srt	00:08:08.880 --> 00:08:13.740	If it is equal to 0, it is positive and if it is equal to 1, it is a negative number.
5.srt	00:08:14.530 --> 00:08:18.620	So, we will see how a fractional format can be represented.
5.srt	00:08:18.970 --> 00:08:23.800	So, that is the most negative value how we did for the integer format.
5.srt	00:08:23.800 --> 00:08:25.690	So, we will see for the fractional format.
5.srt	00:08:26.100 --> 00:08:33.530	The most negative number, so will be represented as s is equal to minus 1 and then rest of them are going to be 0s.
5.srt	00:08:33.850 --> 00:08:36.930	So, which is going to be equivalent to minus 1.
5.srt	00:08:37.439 --> 00:08:45.239	and this is represented as our regular thing 1 all 0s which is 0x800 format.
5.srt	00:08:45.239 --> 00:08:54.269	And then what is the most negative value that can be represented in this format what we will see the thing.
5.srt	00:08:54.269 --> 00:09:01.609	So, we have s is equal to 0 and rest of the values are going to be 1.
5.srt	00:09:02.179 --> 00:09:07.859	So, it is represented as 1 minus 2 to the power of minus s.
5.srt	00:09:08.190 --> 00:09:09.480	n minus 1.
5.srt	00:09:09.910 --> 00:09:22.320	So, in the binary format we will be representing as 0, the point is whatever is not given any place bit value is given for the decimal value.
5.srt	00:09:22.320 --> 00:09:41.890	So, it will be 0 point all 1s or in the processor it will be taking it as 0 1 1 1 1, but the notation for as is equal to 1 minus 2 power minus n minus 1 will be the largest value what I can represent in this format.
5.srt	00:09:42.640 --> 00:09:49.850	So, we will see what will be the granularity of this, why we have to go for the point fractional format.
5.srt	00:09:50.310 --> 00:09:52.930	So, which is given as this way.
5.srt	00:09:53.290 --> 00:09:56.500	So, minus n to power 0 what I have it.
5.srt	00:09:56.850 --> 00:10:09.550	So, in the resolution in this case is going to be 2 power minus n minus 1 will be my granularity what I can have from this representation.
5.srt	00:10:10.210 --> 00:10:12.620	So, coming with the example.
5.srt	00:10:12.690 --> 00:10:18.940	So, we will see n is equal to 4 what are the numbers I can represent in the fractional format.
5.srt	00:10:19.340 --> 00:10:20.970	So, which is minus 1.
5.srt	00:10:21.470 --> 00:10:24.950	than or equal to 1 minus 2 power minus n minus 1.
5.srt	00:10:24.950 --> 00:10:27.850	So, we are substituting n is equal to 4 here.
5.srt	00:10:28.200 --> 00:10:40.470	So, which comes out as minus 1 to 1 minus 2 power minus 3 which is nothing, but x should be less than or equal to 7 by 8 that is what we have to represent.
5.srt	00:10:40.800 --> 00:10:46.470	Then what are the x values it will be taking from minus 1 to plus 7 by 8.
5.srt	00:10:46.980 --> 00:10:51.780	In what we call it as the smallest value will be minus 1.
5.srt	00:10:51.970 --> 00:11:19.060	then next will be minus 7 by 8 and so on minus 3 by 4 and then minus 5 by 8 you may be wondering why I have got minus 3 by 4 just check 7 into 2 is going to be 14, 14 by 16 what you will be doing it or you will be adding minus 7 by 8 plus minus 7 by 8 will be giving you this value when you simplify the value of it.
5.srt	00:11:19.360 --> 00:11:22.490	So, like this you will be going on representing till.
5.srt	00:11:22.850 --> 00:11:33.550	So, and then later on the positive side what you will be representing it as 1 by 8 and so on the last number will be 7 by 8.
5.srt	00:11:34.300 --> 00:11:42.990	As you can see that how many values you have represented in the negative side and then how many values are represented on the positive side.
5.srt	00:11:43.240 --> 00:11:49.480	As you will be seeing that it has 2, 4, 6 and 8.
5.srt	00:11:49.640 --> 00:11:57.920	So, that is what the values what you will represent it as on the negative side and positive side you will be seeing that.
5.srt	00:11:58.150 --> 00:11:59.500	it will be 7.
5.srt	00:12:00.300 --> 00:12:11.120	As we have we know that 2 power minus 4 minus 1 is going to be 1 minus this is going to be 7 in that case magnitude of it.
5.srt	00:12:11.430 --> 00:12:27.460	So, we will see that what is the smallest precision measurement I can have with n is equal to 4 which is nothing, but 1 by 8 which is coming from 1 by 2 power n minus 1 what we said it in the previous slide.
5.srt	00:12:28.110 --> 00:12:29.330	So, moving on.
5.srt	00:12:29.660 --> 00:12:35.270	So, how I can represent the number x is equal to 3 by 4.
5.srt	00:12:36.040 --> 00:12:40.280	So, we will see in the fractional format how we are going to represent it.
5.srt	00:12:40.760 --> 00:13:00.190	So, we know that minus s into 2 power 0 this is the representation what we are considering for the fractional format and then we have to substitute as 3 by 4 which is equal to 0 into 2 power 0 plus 1 into 2 power minus 1 which is nothing, but.
5.srt	00:13:00.520 --> 00:13:06.350	0.5 and then the next number is going to be plus 1 into 2 power minus 2 which is 0.25.
5.srt	00:13:06.350 --> 00:13:12.030	We all know that 3 by 4 in the fractional representation is 0.75.
5.srt	00:13:12.030 --> 00:13:19.740	So, 0.5 is given by this weight and then the next bit will be representing 0.25.
5.srt	00:13:19.960 --> 00:13:22.600	So, 0.5 plus 0.25 will be 0.75.
5.srt	00:13:22.600 --> 00:13:26.090	So, the binary representation is 0, 1, 1, 0.
5.srt	00:13:26.090 --> 00:13:31.890	Since it is a positive value, we have put it as 0 and then we have.
5.srt	00:13:35.840 --> 00:14:01.820	These two are the representation the last bit is going to be 0 ok. Coming with the fixed point format and then how we are representing it all of us know that even the integer representation is a fixed point number system, but where is the point actually you will be seeing that we usually discard this it comes at the end of the number.
5.srt	00:14:02.180 --> 00:14:06.840	So, the decimal point will be at the end of whatever number you have considered.
5.srt	00:14:07.310 --> 00:14:17.340	And then the same you will be seeing it in the fixed point format I have the sign bit and immediately there is this thing what we assume is a decimal point.
5.srt	00:14:18.010 --> 00:14:31.610	So, this since it does not have any bit allocation for it to say for my rest of the numbers we assume that it represented immediately after our sign bit.
5.srt	00:14:31.610 --> 00:14:37.000	So, the next numbers what we will be representing is b minus 1.
5.srt	00:14:37.540 --> 00:14:53.860	and till b minus n minus 1 whereas, in the case of integer you will be seeing that sign bit will be having the n minus 1 place and then later on it will be b n minus 1 will be its magnitude and so on till b naught.
5.srt	00:14:55.960 --> 00:14:59.860	So, coming to next what is the fixed point format.
5.srt	00:15:00.240 --> 00:15:04.680	So, why we have to use the fractional representation of numbers.
5.srt	00:15:05.140 --> 00:15:08.880	This is what we will see the thing all of us know that.
5.srt	00:15:09.340 --> 00:15:17.430	Any multiplication of integer numbers will result in overflow and may wrap around to result in bit error.
5.srt	00:15:18.060 --> 00:15:21.690	So, hold on for a while we will see that how it can happen.
5.srt	00:15:22.080 --> 00:15:30.980	So, for an n is equal to 4 the representation what we have is minus 8 x can be represent between minus 8 to 7.
5.srt	00:15:31.420 --> 00:15:35.910	So, consider the multiplication of 3 into minus 4.
5.srt	00:15:36.360 --> 00:15:39.770	So, the result has to be minus 12 all of us know.
5.srt	00:15:40.190 --> 00:15:44.680	So, you will wonder why I am talking about the primary class multiplication.
5.srt	00:15:45.160 --> 00:15:51.570	So, but as we can see that the range what I can represent is between minus 8 to 7.
5.srt	00:15:51.720 --> 00:15:55.870	So, minus 12 is outside the range ok.
5.srt	00:15:56.220 --> 00:16:01.390	So, the same thing if I represent in the fractional representation.
5.srt	00:16:01.800 --> 00:16:04.350	So, I assume n is equal to 4.
5.srt	00:16:04.770 --> 00:16:08.900	So, then what I will be having is the representation in this format.
5.srt	00:16:09.300 --> 00:16:13.640	So, how can I do that basically whether can I bring this one in this format.
5.srt	00:16:13.940 --> 00:16:15.270	So, that I will not be.
5.srt	00:16:15.930 --> 00:16:17.720	outside the range of it.
5.srt	00:16:18.100 --> 00:16:32.800	So, for that what we will do is we will how we can represent this 3 by 8 into x into minus half which is equal to minus 3 by 16.
5.srt	00:16:33.220 --> 00:16:36.190	So, what did we do can you check the thing here.
5.srt	00:16:36.630 --> 00:16:40.530	So, we have because n is equal to 4 format I have taken the thing.
5.srt	00:16:40.880 --> 00:16:46.550	So, the number what I can represent is 8 basically.
5.srt	00:16:48.670 --> 00:16:57.730	So, I have divided the 3 by number 3 by 8 the same thing what I did was minus 4 by 8 I have done it ok.
5.srt	00:16:57.950 --> 00:17:01.670	So, which is nothing, but minus half.
5.srt	00:17:02.020 --> 00:17:18.010	So, when I multiply these two number the result is going to be minus 3 by 16 which is nothing, but I can represent it in this format minus 1 by 16 minus 2 by 16 then what happens to the number in the binary format.
5.srt	00:17:18.370 --> 00:17:19.770	So, we result in.
5.srt	00:17:20.360 --> 00:17:25.950	We know that it should be a negative number.
5.srt	00:17:26.290 --> 00:17:40.890	So, initially what we will put it is plus value what we will be giving the thing 001, 1 by 16 what we have it and then the next one is 2 by 16 is 1 and 00.
5.srt	00:17:41.250 --> 00:17:47.830	So, which is equivalent because this is a positive number what I have represented I have not represented the negative value.
5.srt	00:17:48.140 --> 00:17:51.019	Here I will be considering the.
5.srt	00:17:51.600 --> 00:17:53.600	2's complement of this number.
5.srt	00:17:54.120 --> 00:18:01.480	When I take that 2's complement I will be the number what will be represented is 1.110100.
5.srt	00:18:01.930 --> 00:18:08.220	So, that is what it says is we will be having a 2's complement format.
5.srt	00:18:08.220 --> 00:18:15.780	So, what we say is it is outside possible precision what we say the thing.
5.srt	00:18:23.050 --> 00:18:29.760	So, in this case what we do is we will be discarding one of the 2's 0s here and then the lower values we can discard and then take only the 4 bits.
5.srt	00:18:30.060 --> 00:18:35.810	So, that is what we say the LSBs will be discarded instead of overflow error.
5.srt	00:18:36.370 --> 00:18:39.920	So, that is what the thing what is the trade off in this case?
5.srt	00:18:40.420 --> 00:18:45.050	Trade off is overflow error for rounding error what we have to consider.
5.srt	00:18:45.640 --> 00:18:51.880	What is the value represented can you tell me the thing in this case ok.
5.srt	00:18:53.450 --> 00:19:03.090	So, now So, we know that we have a tradeoff between overflow and then rounding error what it is coming in can I work on it to avoid these things.
5.srt	00:19:03.410 --> 00:19:10.540	So, we say how to increase range of number represented by integer format first we will consider it.
5.srt	00:19:10.960 --> 00:19:18.360	So, we can say that because my multiplication is going to cause me twice that of the number bits what I needed.
5.srt	00:19:18.620 --> 00:19:24.140	So, whether I can increase the number of bits n to 2 n. So, this will increase.
5.srt	00:19:24.770 --> 00:19:27.250	the range of numbers substantially.
5.srt	00:19:27.630 --> 00:19:37.060	So, for n is equal to 4 my representation is between minus 4 to 3 when I increase by 2 times this n then n becomes 8.
5.srt	00:19:37.560 --> 00:19:50.250	So, the range of numbers what I will be representing is minus 2 power 8 minus 1 less than or equal to 2 power 8 minus 1 minus 1.
5.srt	00:19:50.330 --> 00:19:54.220	So, which is equivalent to minus 128.
5.srt	00:19:54.730 --> 00:19:58.720	than or equal to x which is less than or equal to 127.
5.srt	00:19:59.190 --> 00:20:03.260	So, what will be the consequence of doubling the size of this number?
5.srt	00:20:04.080 --> 00:20:13.650	One is a storage has to double because I have to instead of 4 bit numbers I will be storing them as 8 bit.
5.srt	00:20:13.650 --> 00:20:16.000	This is a smaller example what we have taken.
5.srt	00:20:16.370 --> 00:20:18.820	So, this is not the scenario in real time.
5.srt	00:20:18.820 --> 00:20:24.390	So, real time most of the numbers will be 16 bit what we can represent in hardware.
5.srt	00:20:24.900 --> 00:20:25.840	most of the things.
5.srt	00:20:26.260 --> 00:20:40.450	I think all of you will be using the number format as int as 32 bit, long is 64 bit and then a long and then longer double precision what we will be using is 64 bit.
5.srt	00:20:40.850 --> 00:20:44.530	But you will be seeing that how the consequence is going to be in a while.
5.srt	00:20:45.080 --> 00:20:47.420	So, the storage is going to double.
5.srt	00:20:47.480 --> 00:20:49.740	So, my hardware has to increase.
5.srt	00:20:50.080 --> 00:20:53.490	So, what we are discussing is the real time signal processing.
5.srt	00:20:53.870 --> 00:21:00.710	So, real time capabilities is going to come down whether we can do that or not we will see when we take up some examples.
5.srt	00:21:01.150 --> 00:21:06.570	and then we may need double the size of axis using original data bus.
5.srt	00:21:06.890 --> 00:21:20.790	When we take up the architecture we will see that by increasing this how my bus width is going to increase and then how it can increase the hardware as well as how it can slow down.
5.srt	00:21:21.080 --> 00:21:31.820	And one more thing you have increased it to 2 n, but if I store this value and then use it with my 4 bit value next I will be getting it as 12 bit.
5.srt	00:21:32.120 --> 00:21:35.920	Can I go on increasing in this fashion forever?
5.srt	00:21:36.530 --> 00:21:44.750	It is going to be a what I will say is no end for it for this increasing of the numbers.
5.srt	00:21:45.040 --> 00:21:47.090	So, hence we have to restrict the thing.
5.srt	00:21:47.620 --> 00:21:52.370	So, that is the reason why what we use the fractional fixed point representation.
5.srt	00:21:52.880 --> 00:22:03.430	So, it is what we call it as equivalent to scaling and then usually the fractional number representation is going to be represented in Q format.
5.srt	00:22:04.019 --> 00:22:11.509	So, what is that Q represent is quantity of fractional bits I will be using in my implementation.
5.srt	00:22:12.200 --> 00:22:18.900	The number flowing following the Q indicates the number of bits that are used for the fractional representation.
5.srt	00:22:19.370 --> 00:22:32.860	As I represent as Q 15, I know it is a 16 bit DSP chip basically the resolution of the fractional will be 2 to the power of minus 15.
5.srt	00:22:33.420 --> 00:22:35.120	So, or it can be.
5.srt	00:22:35.740 --> 00:22:40.819	30.518 into e power minus 6 in decimal value what I can represent.
5.srt	00:22:40.819 --> 00:22:43.559	So, what are the things here?
5.srt	00:22:43.559 --> 00:22:49.819	Q 15 means I will be scaling the number by 15 that is 1 by 2 to the power of 15.
5.srt	00:22:49.819 --> 00:23:02.930	And then once again Q 15 means either I can scale by this division or I can do the shifting because all one shift right operation is going to be divided by 2.
5.srt	00:23:03.029 --> 00:23:05.450	So, I can shift right by 15 times.
5.srt	00:23:05.450 --> 00:23:08.640	So, that I will be resulting in the value of it.
5.srt	00:23:08.670 --> 00:23:16.019	So, how will be incorporating when I take up the architecture will be coming back to this number how I can do this shifting.
5.srt	00:23:16.019 --> 00:23:18.930	Otherwise each shifting will be costing as.
5.srt	00:23:20.289 --> 00:23:21.289	every clock cycle.
5.srt	00:23:21.289 --> 00:23:34.839	So, I need 15 clock cycles to shift if I have want to do 15 bit right shift, but we will be doing it in 1 clock cycle we will look into this in the architecture when I take it up.
5.srt	00:23:34.839 --> 00:23:40.440	So, now, as an example how we are going to represent 0.625 in memory.
5.srt	00:23:40.440 --> 00:23:46.279	The first one is we can use the truncation method 1 what we call it.
5.srt	00:23:46.279 --> 00:23:49.259	So, we will be calling it as an integer value.
5.srt	00:23:50.240 --> 00:23:57.330	So, which is nothing, but 0.2625 into 2 power 15 what I am multiplying it.
5.srt	00:23:57.330 --> 00:24:07.440	The resulting integer values 8601.6 in the truncation we will be truncating that whatever number coming out of the decimal point.
5.srt	00:24:07.440 --> 00:24:10.009	So, it will be represented as 8601.
5.srt	00:24:10.009 --> 00:24:19.600	So, you will be seeing in the 15 bit format this is how in the binary 15 bit binary format is this one.
5.srt	00:24:20.710 --> 00:24:23.220	And, in the second case we can do the rounding.
5.srt	00:24:23.990 --> 00:24:25.289	So, what we will be doing?
5.srt	00:24:25.620 --> 00:24:30.610	So, we will be adding 0.5 into the result what we are getting it.
5.srt	00:24:30.610 --> 00:24:38.710	So, then we will be discarding the normal way or whatever number comes out of the decimal point.
5.srt	00:24:38.710 --> 00:24:44.720	So, which will be 8602 here the binary representation what you will be seeing.
5.srt	00:24:44.720 --> 00:24:46.750	So, you have added 0.5.
5.srt	00:24:46.750 --> 00:24:50.400	So, the number has gone to plus 1 in this case.
5.srt	00:24:50.400 --> 00:24:53.350	So, it will be 10 the rest of the numbers remains same.
5.srt	00:24:53.630 --> 00:24:56.460	So, this is the positive number what we have represented.
5.srt	00:24:58.629 --> 00:25:04.919	So, whether you want to go for truncation or rounding which one is better.
5.srt	00:25:05.329 --> 00:25:07.419	So, we will see what happens with the truncation.
5.srt	00:25:08.009 --> 00:25:15.440	So, in this case the magnitude of the truncated number always less than or equal to the original value.
5.srt	00:25:16.220 --> 00:25:22.730	So, that is we will be seeing that it is consistently downward bias what I am going to have it.
5.srt	00:25:23.159 --> 00:25:28.509	Whereas, in the rounding what happens magnitude of rounded number could be smaller or.
5.srt	00:25:28.999 --> 00:25:30.849	greater than the original value.
5.srt	00:25:31.329 --> 00:25:44.529	So, then what happens to the thing error tends to be minimized that is positive and negative bias is what I am going to have it and popular technique is rounding to the nearest integer.
5.srt	00:25:44.529 --> 00:25:57.529	So, we will be seeing in hardware when I have to do rounding then I have to add 0.5 to the whatever the number what it is resulting in and then to the.
5.srt	00:25:59.219 --> 00:26:02.109	it to the nearest value.
5.srt	00:26:02.449 --> 00:26:06.809	So, there is additional addition is going to happen.
5.srt	00:26:07.209 --> 00:26:10.979	So, which will be costing us again extra clock cycle.
5.srt	00:26:11.369 --> 00:26:27.699	So, the simplest one will be a truncation, but if you are not able to get the required result, then you have to go for the rounding and then have the additional whatever clock cycle that is going to result from it.
5.srt	00:26:28.019 --> 00:26:30.429	So, as you can see INTO51.2.
5.srt	00:26:30.429 --> 00:26:40.149	So, we know that it is truncate or we call it as floor it is 251, it is not going to cause any damage to the number represented.
5.srt	00:26:43.469 --> 00:26:49.399	Whereas, if it is rounding also it will be resulting in the same value sorry rounding is you are adding 0.5.
5.srt	00:26:49.399 --> 00:26:51.459	So, it becomes 251.7.
5.srt	00:26:51.509 --> 00:26:56.159	So, which is going to be rounded to 252.
5.srt	00:27:14.250 --> 00:27:25.149	So, we call it as rounder it is going to be seal value what you will be considering in normal number representation or I can have a round nearest one more distinct function defined 251.2 which is going to be So, you will be seeing that truncation and round to nearest almost it is matching whereas, rounding has increased the value of the number ok.
5.srt	00:27:25.429 --> 00:27:33.389	So, we will see that general fixed point representation how we can do that is given by Coe and then Gann for 16 bit numbers.
5.srt	00:27:33.849 --> 00:27:39.909	So, if it is a unsigned integer and then how it is going to be represented in the signed integer format.
5.srt	00:27:40.569 --> 00:27:44.669	The smallest value for unsigned integer is 0.
5.srt	00:27:45.149 --> 00:27:50.819	And, then the largest value it is going to be 1111.
5.srt	00:27:51.359 --> 00:27:53.289	So, it is going to be 15.
5.srt	00:27:53.909 --> 00:28:00.239	And then unsigned fractional number what I will be having it is smallest is 0.
5.srt	00:28:00.889 --> 00:28:07.029	And then the largest value what I can have is 1111 which is 0.9375.
5.srt	00:28:07.449 --> 00:28:12.649	When I come to the signed representation, so the first.
5.srt	00:28:15.539 --> 00:28:17.379	value is 0.
5.srt	00:28:17.749 --> 00:28:18.749	So, all the 3.
5.srt	00:28:18.749 --> 00:28:25.139	So, this is plus 7 and then the least negative value is 1 0 0 which is minus 8.
5.srt	00:28:25.719 --> 00:28:41.839	And in the sign fractional the number representation we know that 0.1111 which is nothing, but plus 0.875 will be the maximum value and then least negative value 1.00 which is minus 1.
5.srt	00:28:41.839 --> 00:28:46.429	In this case we have taken number of bits equal to 4.
5.srt	00:28:47.599 --> 00:28:59.979	So, you can increase it to second bit sorry 16 bit and see what will be the minimum and then maximum value what you can represent with this you can look at it.
5.srt	00:29:00.369 --> 00:29:18.499	So, the minimum value will be 0 and then the maximum value will be 65536 in this case to power 16 what you will be having it to power 16 minus 1 will be the value and then in this case.
5.srt	00:29:18.889 --> 00:29:35.759	It is going to be 7 f f f positive number will be 32767 and negative number is going to be minus 32768 and same way you can calculate in the unsigned and then signed values.
5.srt	00:29:36.259 --> 00:29:41.309	So, coming to the general fixed point representation.
5.srt	00:29:41.649 --> 00:29:48.959	So, we will be seeing what are the dynamic range and precision of 16 bit numbers for different Q formats.
5.srt	00:29:48.959 --> 00:29:51.739	This also taken from Co and then Gan.
5.srt	00:29:52.129 --> 00:29:53.889	So, you will be seeing the first one.
5.srt	00:29:54.209 --> 00:30:01.989	As we said Q representation will give me how many bits are represent fractional bits represented.
5.srt	00:30:02.479 --> 00:30:04.709	to the right of it whatever represented.
5.srt	00:30:04.709 --> 00:30:05.749	Here if I give 0.15.
5.srt	00:30:05.749 --> 00:30:33.259	So, I know that all the 15 bits are represented as the this thing of fractional number the maximum that is largest positive value what I can represent is 0.999 what you will be going on and then representing it and then the least negative value is going to be 1 and precision what I want to have it is represented with.
5.srt	00:30:35.069 --> 00:30:36.729	this number ok.
5.srt	00:30:36.979 --> 00:30:43.779	Same thing if I want to allocate 1 bit to the integer here 0 bits I have included to the integer.
5.srt	00:30:44.049 --> 00:31:01.339	Here I want to include 1 bit to the integer and 14 bits are for the fractional number then my range largest value will be 1.999 to 2 that is least negative value I can have it is minus 2 and this is the precision what I will have.
5.srt	00:31:01.339 --> 00:31:09.079	And then but I do not want to represent any fractional number I want to have it as an integer then I will be.
5.srt	00:31:09.589 --> 00:31:17.499	calling it as Q 15.0 then I know that the 15 bits are represented as my fractional number.
5.srt	00:31:18.369 --> 00:31:23.859	The value what I will be representing is 32767 to minus 32768.
5.srt	00:31:23.859 --> 00:31:28.369	So, the precision in this case is going to be 1.00.
5.srt	00:31:28.479 --> 00:31:38.989	So, it depends on what precision you want to have for your application based on it you will be taking your number system.
5.srt	00:31:38.989 --> 00:31:44.259	You may be wondering why I have to discuss about this number system.
5.srt	00:31:45.669 --> 00:31:56.769	As you know that in the present scenario FPGA is mostly used for most of the applications because of low power.
5.srt	00:31:57.189 --> 00:32:11.299	So, whether when I am writing my own code all of you know that in C you will be representing it as hash define you will be doing it, int or float or double or whatever number, but when you are using in the hardware.
5.srt	00:32:11.619 --> 00:32:16.749	So, you have to be careful whether I can save my resources save my power.
5.srt	00:32:17.239 --> 00:32:19.849	So, that is what one has to look at it.
5.srt	00:32:20.099 --> 00:32:26.199	So, when you have to do that you have to play around your fixed point representation of the number.
5.srt	00:32:26.489 --> 00:32:31.309	So, that you know for what application you are using it, what is the dynamic range.
5.srt	00:32:31.569 --> 00:32:34.809	I have not discussed yet here in the dynamic range in this case.
5.srt	00:32:34.809 --> 00:32:39.789	So, we will be discussing it later and then what is the precision what I want to have it.
5.srt	00:32:40.229 --> 00:32:43.899	So, coming to few examples what we will take it.
5.srt	00:32:44.139 --> 00:32:49.479	How we are going to do all of you may be wondering why I have to do addition of 2 numbers.
5.srt	00:32:49.849 --> 00:32:52.189	So, here I am going to do it in binary.
5.srt	00:32:52.469 --> 00:32:56.049	So, you will be seeing the binary number is given in this way.
5.srt	00:33:02.809 --> 00:33:09.629	So, when I add these 2 numbers so, what is the thing is going to happen I will be getting So, you will be seeing that it will if you add the thing just to show you that how you will be adding it.
5.srt	00:33:09.629 --> 00:33:14.379	This will be from right to left what the addition is going to happen.
5.srt	00:33:14.379 --> 00:33:23.139	This is 0 when I add 1 plus 1 0 which will be carry and then you will be getting 1 here and then you will be adding this way further.
5.srt	00:33:23.439 --> 00:33:32.539	So, when you come to the last one you will see that this is 1 plus 1 is 0 and when I put 1 here so, it will be 1 plus 1 is going to be 0.
5.srt	00:33:32.769 --> 00:33:42.199	2 power minus 7 and then the last one will be your 2 power minus 10 minus 11 and then the 2 power minus 13.
5.srt	00:33:42.619 --> 00:33:49.489	So, when I add this number the value in decimal what I will be achieving is 0.40024.
5.srt	00:33:49.729 --> 00:33:59.399	So, this is how the addition is going to happen in our hardware and coming to the multiplication what is the thing is going to happen ok.
5.srt	00:34:00.579 --> 00:34:03.719	So, I have to multiply 0.5 and 0.25 in.
5.srt	00:34:05.099 --> 00:34:07.939	What I say is q 3 format.
5.srt	00:34:08.349 --> 00:34:15.859	So, that means, to say that I have 4 bits it is in the signed format what I am going to do the multiplication.
5.srt	00:34:16.169 --> 00:34:19.959	So, 1 bit for sign and 3 bits are going to be for my fraction.
5.srt	00:34:20.349 --> 00:34:24.829	So, 0.5 I know that 0.2 power minus 1 is 0.5.
5.srt	00:34:24.829 --> 00:34:36.569	So, the other 2 numbers are 0 0 and 0.25, 0.010 what I will be considering that this is 2 power minus 2 it is 1 by 4 which is 0.25.
5.srt	00:34:36.569 --> 00:34:38.619	So, I want to do this multiplication.
5.srt	00:34:38.619 --> 00:34:43.519	I have taken the simple so that I am not doing any truncation or rounding in this case.
5.srt	00:34:43.519 --> 00:34:50.019	So, which can be represented in binary format that value what I have taken the thing.
5.srt	00:34:51.519 --> 00:34:54.230	So, I will be multiplying 0.100 into 0.010.
5.srt	00:34:54.690 --> 00:34:59.949	So, will be bit by bit multiplication is going to happen.
5.srt	00:34:59.949 --> 00:35:03.369	So, you will be seeing that one after the other.
5.srt	00:35:03.369 --> 00:35:07.719	Then what is the how we are going to calculate the final value?
5.srt	00:35:07.719 --> 00:35:16.750	All of you know that it is going to be numbers have to be added that is what we have been taught in our primary also.
5.srt	00:35:22.889 --> 00:35:42.329	Then we will be adding it and then what we are going to do is because my format what I have input and output is in Q3 format only I can represent 4 bits the LSB bits I will be discarding which is shown in blue here all three zeros are going to be discarded result is going to be 0.001 which is nothing, but 0.125.
5.srt	00:35:42.719 --> 00:35:47.909	So, you will be seeing 0.5 multiplied by 0.25 will be resulting in 0.125 in decimal.
5.srt	00:35:57.279 --> 00:36:03.429	So, you will be seeing that how fast the calculator or your computer gives, but what goes on is this one in the inside your hardware.
5.srt	00:36:04.379 --> 00:36:08.039	So, how this can be done faster and other things we will see in the architecture.
5.srt	00:36:08.730 --> 00:36:15.519	So, now, what we say is what is this is point format and then size what we have to look at it.
5.srt	00:36:15.980 --> 00:36:22.319	So, which format will compromise between precision, overflow and then storage needs.
5.srt	00:36:29.190 --> 00:36:34.420	So, one method we said we can increase the number of bits, the other way of doing it the floating point number which will give me all this solution.
5.srt	00:36:34.619 --> 00:36:37.539	So, how it is going to give me the thing?
5.srt	00:36:38.000 --> 00:36:47.769	So, we will say that suitable for computations where large number of bits in fixed point format would be required to store intermediate and final results.
5.srt	00:36:48.269 --> 00:36:56.039	And the algorithms that need summation of large number of products in that case we will be using the floating point number.
5.srt	00:36:56.440 --> 00:37:02.429	So, if x is going to be represented in floating point format as x is equal to x.
5.srt	00:37:02.980 --> 00:37:05.560	Mx into e power x.
5.srt	00:37:05.740 --> 00:37:10.210	So, this we call it as mantissa and this we call it as exponent.
5.srt	00:37:10.210 --> 00:37:15.140	This is a non-standard format we will see the IEEE format what it is the standard has defined.
5.srt	00:37:15.140 --> 00:37:26.539	So, in this case when I do the multiplication of 2 floating point numbers we know that it is Mx into e power x and then y is given by My into e power y.
5.srt	00:37:26.580 --> 00:37:34.090	So, we know that we multiply the mantissa and then the add the exponents to get the result.
5.srt	00:37:35.370 --> 00:37:49.510	So, floating point unit should have a as you can see to do the multiplication and do the addition for the multiplier for the mantissa and an adder for your exponent.
5.srt	00:37:49.510 --> 00:37:52.970	This is the architecture definition what you are getting from the floating point.
5.srt	00:37:53.620 --> 00:38:07.670	So, the numbers of adders should be normalized before addition that is the exponent of the number should be same for adding it is not as simple as my multiplication.
5.srt	00:38:07.980 --> 00:38:41.640	So, when I come to IEEE format representation we call it as IEEE 754 which is defined in 1985 this thing format for single precision that is 32 bit floating point number is represented as x is equal to minus 1 to the power of s into 2 into e minus bias into 1 plus f. So, here s, e and f are all unsigned fixed point format, s will be representing your sign bit.
5.srt	00:38:42.120 --> 00:38:48.810	E will be representing exponent biased and then f is the significant in this case.
5.srt	00:38:49.000 --> 00:38:58.760	And we say that this is the implied binary point here also will not be allocating any bits to the decimal point.
5.srt	00:38:58.760 --> 00:39:11.990	So, you will be seeing that the significant is represented with 23 bits whereas, exponent is with 8 bits and sign bit is with 1 bit if it is 0.
5.srt	00:39:12.290 --> 00:39:19.620	it is going to be positive significant and if it is 1 negative significant.
5.srt	00:39:20.390 --> 00:39:28.410	So, you will be now wondering why exponent is biased because why I can exponent also can represent it in positive and negative.
5.srt	00:39:28.820 --> 00:39:31.740	So, I am not allocating any bit for the thing.
5.srt	00:39:32.010 --> 00:39:40.830	So, we will be doing the biasing so that to avoid this positive or negative number representation for the exponent.
5.srt	00:39:41.250 --> 00:39:47.790	So, we will see as an this thing example here which is nothing, but minus 1 to the power of s.
5.srt	00:39:48.160 --> 00:39:57.040	into 2 to the power of e minus bias into 1 plus f. So, we know that f is the magnitude fraction of the mantissa.
5.srt	00:39:57.470 --> 00:40:00.020	So, in determining the full mantissa value.
5.srt	00:40:00.480 --> 00:40:13.580	So, IEEE format specified that 1 is placed immediately before the implied binary point 1 dot format that is why you will be adding 1 to the whatever you have the fraction here.
5.srt	00:40:14.230 --> 00:40:16.260	So, e is the biased exponent.
5.srt	00:40:16.650 --> 00:40:22.720	So, the bias make sure that the exponent is signed to represent both the small and then large numbers.
5.srt	00:40:23.120 --> 00:40:26.370	So, two's complement complex for comparison.
5.srt	00:40:26.760 --> 00:40:37.450	So, the bias is set to be 127 that is largest positive number represented by 8 bits with which is equivalent to 2 power 8 minus 1.
5.srt	00:40:38.140 --> 00:40:42.840	So, s is the sign of the fractional part of the number.
5.srt	00:40:43.650 --> 00:40:47.440	So, as an example how we are going to represent we will see the thing.
5.srt	00:40:47.790 --> 00:40:53.770	Find the decimal equivalent of the floating point binary number with bias 2 power 3 minus 1 which is 7.
5.srt	00:40:54.190 --> 00:40:58.960	So, you will be seeing this is the number what you have been given in binary format.
5.srt	00:40:59.300 --> 00:41:04.580	So, we know that sign bit is 1 in this case and bias have been given as 7.
5.srt	00:41:04.850 --> 00:41:05.870	So, I will be using.
5.srt	00:41:06.210 --> 00:41:08.600	4 bits for my exponent.
5.srt	00:41:08.880 --> 00:41:13.050	So, which is 0 1 1 0 and rest of them are fractional bits.
5.srt	00:41:13.240 --> 00:41:16.830	So, which is nothing, but 3 0s triple 1 0 0.
5.srt	00:41:17.110 --> 00:41:39.070	So, when I represent it fraction part 0 into 2 power minus 1 and then all the 3 of them are 0s and the next number will be 1 into 2 power minus 4 and then you will be seeing 1 and rest of them 0s, which is nothing, but 0.109375 is f value and then experiment we will see the thing.
5.srt	00:41:40.170 --> 00:41:48.790	0 into 2 power 3 and then 1 into 2 power 2 and then 1 into 2 power 1 and 0 into 2 power 0 which is equivalent to 6.
5.srt	00:41:49.060 --> 00:41:54.240	So, when I put it in its format we know that sin is 1.
5.srt	00:41:54.240 --> 00:42:02.100	So, it is a negative number minus 1 into what we have is because f plus 1 what I have to do it.
5.srt	00:42:02.100 --> 00:42:13.650	So, it is 1.109375 into 2 power exponent minus bias, bias we have is 7, 6 minus 1 is 2 power minus 1.
5.srt	00:42:13.740 --> 00:42:16.420	So, this is divided by 2.
5.srt	00:42:17.420 --> 00:42:22.800	which is equivalent to minus 0.5546875 is the value what I can represent.
5.srt	00:42:22.800 --> 00:42:30.070	So, we will see little bit on the DSP architecture and we will be taking a detailed one in the next class.
5.srt	00:42:30.070 --> 00:42:33.790	So, what we have is as you can see here.
5.srt	00:42:33.790 --> 00:42:40.870	So, I have for the floating point DSK6713 processor what I have considered here.
5.srt	00:42:40.870 --> 00:42:48.070	So, you have the integer or floating point multiplier here and then I have a integer floating point.
5.srt	00:42:49.400 --> 00:43:04.720	ALU addition and then we have some extended precision registers and we have some address generator 0 and 1 in this and then we have some auxiliary registers and some control registers.
5.srt	00:43:04.720 --> 00:43:20.250	So, these are the compiler what you would be feeding in and this is the data bus which is data bus is 32 bit long and then the address bus is.
5.srt	00:43:21.360 --> 00:43:32.500	24 bit and then we have something we call it as program cache and this is the RAM what we have it which is 1 k into 32 bit each.
5.srt	00:43:32.850 --> 00:43:50.240	So, RAM block 1 what we have it 1 k into 32 bit here and then the ROM for storing our coefficients and everything which is 4 k into 32 bit and some of the peripherals what you will be seeing connected here through the peripheral bus.
5.srt	00:43:51.520 --> 00:44:03.110	Then we have the like any other microprocessor 8085 would have studied the thing I have the DMA controller which will be generating address generator and control registers.
5.srt	00:44:03.110 --> 00:44:08.460	So, directly I will be able to take from the memory and then load into the hardware.
5.srt	00:44:09.100 --> 00:44:18.330	So, coming to recap what we have done in this classes we discussed about the number system.
5.srt	00:44:18.870 --> 00:44:21.720	So, as in to see that.
5.srt	00:44:22.210 --> 00:44:26.070	whether you have understood or not the fixed and floating point.
5.srt	00:44:26.470 --> 00:44:33.710	So, I have given two assignments here, please work it out and then I will be showing you how we can compute this one.
5.srt	00:44:34.170 --> 00:44:46.880	One is first one is add these two numbers, here it is non IEEE standard format what I have given the thing, exponent is given as 4 and mantissa is 5 bits and bias is given as 7.
5.srt	00:44:47.260 --> 00:44:50.740	So, these are the two numbers one has to add.
5.srt	00:44:51.210 --> 00:44:58.520	So, please keep it in mind we did the multiplication it was very simple we have multiplied mantissa and then added the exponent.
5.srt	00:44:58.890 --> 00:45:08.340	In this case you will be seeing the exponents are different you have to bring it to one format I will see that which format you will choose it whether the.
5.srt	00:45:08.770 --> 00:45:17.070	higher one or the lower one and then we will discuss why which one is better to choose the thing in the next class.
5.srt	00:45:17.470 --> 00:45:22.120	The second assignment what I have given is minus 0.75 by minus 0.375.
5.srt	00:45:22.120 --> 00:45:27.010	So, we did the simple positive number multiplication.
5.srt	00:45:27.010 --> 00:45:33.000	So, I want it is going to be a trick to do multiplication of 2 negative numbers.
5.srt	00:45:33.620 --> 00:45:37.680	I know the result is going to be positive.
5.srt	00:45:37.680 --> 00:45:44.630	So, you can trick me by removing the minus sign, but I want you to keep this minus sign and then do in the 2's complement.
5.srt	00:45:44.630 --> 00:45:47.520	So, that using the 4 bit.
5.srt	00:45:48.850 --> 00:45:58.740	for both input and output and what will be the result whether it is going to be correct or not what I want to you to try it out.
5.srt	00:45:58.770 --> 00:46:04.630	So, that you can play with me in the number system in this fashion ok.
5.srt	00:46:04.840 --> 00:46:07.960	So, with that we will end this today's class.
5.srt	00:46:08.240 --> 00:46:18.510	So, in the next class we will be taking architecture of DSP that is we will be using DSP synonymally for signal processing as well as.
5.srt	00:46:18.810 --> 00:46:23.570	processor part 1 what will be taking up in the next class.
5.srt	00:46:23.570 --> 00:46:37.740	Because this number system will help us to see that what should be our architecture for designing it although I have shown you one DSP architecture we will see how we will be going about to build it.
5.srt	00:46:37.920 --> 00:46:45.590	So, those who are interested in building on their own DSP processor you can use FPGA to build it.
5.srt	00:46:46.060 --> 00:46:46.430	Thank you.
1.srt	00:00:01.219 --> 00:00:22.649	Welcome to real time signal processing course.
1.srt	00:00:22.699 --> 00:00:23.989	This is three credit course.
1.srt	00:00:23.989 --> 00:00:29.320	This is I am Dr. Jain Rithna, principal research scientist.
1.srt	00:00:30.809 --> 00:00:34.299	from electrical engineering department Indian Institute of Science.
1.srt	00:00:34.759 --> 00:00:38.159	So, I have been working in I A C from 1982.
1.srt	00:00:38.429 --> 00:00:41.009	So, this is my 40th year basically.
1.srt	00:00:41.590 --> 00:01:05.039	I have been teaching this DSP system design, real time systems, real time signal processing and sensor networks in I A C. The real time signal processing course is meant for college faculties, students and corporate people who wish to dirty their hands what I will put it that is dirtying their hands in real time signal processing.
1.srt	00:01:05.620 --> 00:01:13.329	So, the course covers following topics basics of signal processing, processor architecture.
1.srt	00:01:13.900 --> 00:01:20.019	Next we will be discussing about digital filters like IAR, FIR and adaptive filters.
1.srt	00:01:20.159 --> 00:01:29.710	Continuing with this we would like to know the spectrum of the real time signals using FFT and then DCT.
1.srt	00:01:29.870 --> 00:01:38.299	The complete course is centered around TI Texas Instruments DSK6713 board.
1.srt	00:01:38.820 --> 00:01:55.969	to generate synthetic music, remove noise from the signal knowing their spectrum and then how we can an unknown noise can be removed from the signals to improve the signal to noise ratio will be demonstrated.
1.srt	00:01:56.599 --> 00:02:05.189	The course also demonstrates how to generate echo synthetically, create reverberations etc.
1.srt	00:02:05.790 --> 00:02:09.129	So, come and then play with me with signals.
1.srt	00:02:09.449 --> 00:02:11.609	after learning the theory.
1.srt	00:02:12.399 --> 00:02:16.399	Thank you and welcome to this real time signal processing course.
53.srt	00:00:01.219 --> 00:00:24.379	Welcome back to Real-Time Digital Signal Processing Lab basically.
53.srt	00:00:24.379 --> 00:00:28.199	So last class we had a problem with the.
53.srt	00:00:31.789 --> 00:00:34.579	loading into the thing.
53.srt	00:00:34.950 --> 00:00:39.630	So, today I will show you how you if there is any problem how you can load it.
53.srt	00:00:39.980 --> 00:00:43.880	So, we are discussing about the adaptive filters in non real time.
53.srt	00:00:44.329 --> 00:00:59.429	So, these are the equations that is updation of the weights here and error calculation and then the output calculation is here and this is our LMS algorithm which will be running it in non real time.
53.srt	00:00:59.870 --> 00:01:03.189	So, these are the parameters what we have it that is.
53.srt	00:01:03.820 --> 00:01:17.939	2 cos 2 pi nf by fs is are this thing desired signal and the input is chosen as a sign of signal itself that is 2 pi n f by fs ok.
53.srt	00:01:18.250 --> 00:01:25.030	So, here f is equal to 1 kilohertz and sampling frequency chosen is 8 kilohertz.
53.srt	00:01:25.469 --> 00:01:35.530	So, adaptation rate of mu is going to be set with 0.01 and order of the filter is 21 and we know within 60 iterations.
53.srt	00:01:40.849 --> 00:01:45.899	So, the system will converge error is going to come down and then output will be equivalent to input.
53.srt	00:01:46.289 --> 00:01:49.429	So, this will be the desired plot what you can see it.
53.srt	00:01:49.429 --> 00:01:52.109	So, this is going to happen in non real time.
53.srt	00:01:52.589 --> 00:01:58.819	So, we can change the adaptation or convergence rate and then see how it is going to behave.
53.srt	00:01:59.250 --> 00:02:02.739	So, what we will do is we will go to the code composer studio.
53.srt	00:02:03.099 --> 00:02:07.000	As I said there was a problem in the previous class what we had it.
53.srt	00:02:13.939 --> 00:02:16.689	So, all the directories if you go into the thing I have loaded all the labs thing in ah in my D drive basically.
53.srt	00:02:17.089 --> 00:02:23.449	So, that is in ah CCS 9 what I have all the files basically running.
53.srt	00:02:23.479 --> 00:02:28.269	So, this is my working ah workspace basically for the code composer studio.
53.srt	00:02:28.659 --> 00:02:33.009	So, yesterday I was seeing this and then I was ah having a little problem.
53.srt	00:02:33.399 --> 00:02:45.539	So, what I did was so, go to the file if you are by mistake all the complete workspace is cleared you can go and then ah you will be opening the projects from the file system.
53.srt	00:02:45.969 --> 00:02:48.459	So, if you give this directory.
53.srt	00:02:48.659 --> 00:03:02.120	automatically all the files gets reinstated in the directory as you can see here I am having from the day 1 whatever demos I have been doing it is available here.
53.srt	00:03:02.550 --> 00:03:06.009	So, this is how you can get back all your directories and then you can run.
53.srt	00:03:06.039 --> 00:03:11.259	So, this is a non real time what the demo is going to be.
53.srt	00:03:11.259 --> 00:03:14.270	So, what we have in this is a main.c file what we have it.
53.srt	00:03:18.950 --> 00:03:30.460	as it is pointed out this is the desired signal what we want is to cause 2 pi into t into 1000 by fs, f we said it is 1 kilohertz.
53.srt	00:03:30.840 --> 00:03:37.379	So, the noise signal given as a sign that is 2 star pi t 1000 by fs.
53.srt	00:03:37.800 --> 00:03:45.260	So, this noise signal has to be eliminated and then we should be getting the desired size signal at the output.
53.srt	00:03:45.510 --> 00:03:47.510	So, we will see how we are going to get the thing.
53.srt	00:03:47.510 --> 00:03:50.439	So, this is desired and I have a y out and then.
53.srt	00:03:50.940 --> 00:03:51.820	error signal.
53.srt	00:03:51.820 --> 00:03:58.680	So, fine in this case the W as we said the weight function.
53.srt	00:03:58.840 --> 00:04:23.069	So, it is assigned to 0 initially even the x 0 will be getting the first noise signal here new noise sample and D will be our desired signal and Y is going to be 0 and the variable that is a filter output what we will be calculating Y plus that is whatever weight you have computed into X of i.
53.srt	00:04:24.090 --> 00:04:40.530	And error is computed as d minus i desired signal minus y output and you will be updating your weight w of i with w of i plus mu into error basically what you have computed here into input that is x of i.
53.srt	00:04:40.530 --> 00:04:46.250	So, in this case mu is assumed as 0.01 in this case that is what the initial.
53.srt	00:04:46.250 --> 00:05:04.440	So, you can change it to 0.02 next and then see the convergence will be faster and in MATLAB pi value automatically takes, but here in code composer studio in C file you have to define your pi value also.
53.srt	00:05:08.680 --> 00:05:13.630	So, it is defined up to 7 decimal places whatever length you want to define your pi you can define it.
53.srt	00:05:14.050 --> 00:05:25.130	And sampling frequency we said 8000 order of the filter is 21 and then are the number of iterations is chosen as 60.
53.srt	00:05:25.850 --> 00:05:42.650	So, we will be calculating the update the error function and the delay because x also has to be further this thing delay line has to be input line also has to be updated this is how we will be updating the delay line.
53.srt	00:05:43.470 --> 00:05:56.230	And, we will be putting last desired of t will be equal to d and then our y out will be y and then error function will be e. And then once it is done you can call it as done.
53.srt	00:05:56.260 --> 00:06:02.510	So, what we do is because as we said the return function the handle is written elsewhere it is not in this memory.
53.srt	00:06:02.730 --> 00:06:08.110	So, we will put a break point here and then since it has been tested.
53.srt	00:06:08.260 --> 00:06:12.200	So, we will what we will do is we will directly go for.
53.srt	00:06:15.030 --> 00:06:24.450	So, you will be seeing that if there are errors it will ask you whether with errors it has to go for the debug since no errors.
53.srt	00:06:24.740 --> 00:06:26.110	So, it will go for the debug.
53.srt	00:06:26.420 --> 00:06:33.450	So, now, I have as you can see the handle is in the main the flower bracket where it is flashing.
53.srt	00:06:33.450 --> 00:06:35.220	So, it is ready to run with the thing.
53.srt	00:06:35.730 --> 00:06:38.590	So, I have put the breakpoint as I said.
53.srt	00:06:38.820 --> 00:06:44.460	So, we will run this code and then you will see it is going to run up to printf.
53.srt	00:06:46.600 --> 00:06:48.810	So, that will not have any error.
53.srt	00:06:49.220 --> 00:06:58.720	So, you will be seeing that the sum of the values what it has got changed and where location if you want to check in the variables what we have the values here.
53.srt	00:06:59.410 --> 00:07:08.340	So, now what we will do is we have to plot that is what we have in the thing output what we have to see it.
53.srt	00:07:08.340 --> 00:07:19.620	So, what are the thing this is the desired signal what it should look like and this is the adapted signal and this is the error you will be seeing it is initially high and then it is coming down.
53.srt	00:07:20.070 --> 00:07:22.690	So, we will observe whether we have got these results.
53.srt	00:07:23.880 --> 00:07:28.380	go to tools and then we will put the graph single time.
53.srt	00:07:30.840 --> 00:07:36.630	What we want is iterations is 60 and all of them have been declared as float.
53.srt	00:07:43.260 --> 00:07:46.800	So, we will it is a single precision 32 bit floating point.
53.srt	00:07:47.610 --> 00:07:50.750	So, the first one will be calling it as desired.
53.srt	00:08:02.650 --> 00:08:04.410	So, you are seeing this is a cos what we have it.
53.srt	00:08:04.900 --> 00:08:10.480	So, now, again we will plot the other one single time.
53.srt	00:08:11.570 --> 00:08:13.100	So, this also 60.
53.srt	00:08:15.540 --> 00:08:28.790	Same thing it is a floating point what it has been chosen here floating point and start address is going to be I will call it as y out is what we want to have the thing.
53.srt	00:08:28.790 --> 00:08:31.460	So, I will give y out.
53.srt	00:08:35.129 --> 00:08:40.830	So, you will be seeing that initially it is low and then after that it will settles down.
53.srt	00:08:41.279 --> 00:08:44.259	So, now, we will see how the error is going to look like.
53.srt	00:08:47.769 --> 00:09:03.049	Again graph single time I will give this also 60 iterations and this also declared as float floating point and start address will be error function what I want to plot it.
53.srt	00:09:04.950 --> 00:09:14.500	So, you will be seeing that initially error is very high you are seeing it and then later on it is coming down.
53.srt	00:09:14.580 --> 00:09:24.700	So, it is 60 samples is enough to get your desired output that is what it is shown here it is there and then you are settling down.
53.srt	00:09:24.700 --> 00:09:28.070	So, it has whatever the desired signal.
53.srt	00:09:28.529 --> 00:09:30.540	So, what you are getting at the output.
53.srt	00:09:30.540 --> 00:09:32.909	So, you will be seeing this is the desired signal.
53.srt	00:09:33.279 --> 00:09:37.980	So, what we are trying to achieve initially we had the noise as sign.
53.srt	00:09:38.009 --> 00:09:40.610	So, which comes out as the cosine here.
53.srt	00:09:40.610 --> 00:09:45.519	So, that is the desired signal this is the output.
53.srt	00:09:45.519 --> 00:09:48.950	This is one of the demo what we had the thing.
53.srt	00:09:49.519 --> 00:09:58.570	So, we will stop here and what is the next demo we will be taking in our code composer studio.
53.srt	00:09:59.250 --> 00:10:04.019	So, this is adaptive filter for sinusoidal noise calculation.
53.srt	00:10:04.470 --> 00:10:09.110	So, here it is the adaptive noise, interrupt driven what we will be doing it.
53.srt	00:10:09.540 --> 00:10:23.540	So, what happens here is the same thing signal frequency is 2500 watt it is chosen with an added undesired sine wave signal noise frequency which is 1200 hertz.
53.srt	00:10:24.159 --> 00:10:35.649	So, one of the two inputs to our board basically here to the noise cancellation structure and then present the signal plus noise from the primary.
53.srt	00:10:36.320 --> 00:10:51.330	A cosine wave that is reference noise with a frequency of noise frequency that is what we have chosen 1200 hertz represent the reference noise signal and is the input to end coefficient adaptive FIR filter in this case.
53.srt	00:10:52.620 --> 00:11:01.500	We want to remove this as a noise and then it will be removing the noise from the signal and you will be hearing only one tone.
53.srt	00:11:02.230 --> 00:11:08.800	So, signal reference noise is strongly correlated with signal-signal noise, but not with the desired signal.
53.srt	00:11:10.320 --> 00:11:20.870	At each sampling instant the output of adaptive FIF filter is calculated and its n weights are updated and the contents of the delay line x are going to be shifted.
53.srt	00:11:21.350 --> 00:11:27.270	So, same way we will be calculating the error signal is overall desired output of the adaptive structure.
53.srt	00:11:27.890 --> 00:11:39.610	So, it consists of desired signal and additive noise from the primary sensor that is signal plus signal noise is included from which the adaptive filter output y n has been subtracted.
53.srt	00:11:40.220 --> 00:11:55.150	And, our input signal used in this examples are generated with the program and both the input signal plus noise and the output signal are output via the AIC 3106 codec on right and left channels respectively.
53.srt	00:11:56.010 --> 00:12:00.220	This is how what will be running the thing.
53.srt	00:12:00.810 --> 00:12:04.470	So, you will be putting the demo here.
53.srt	00:12:04.870 --> 00:12:16.040	So, what happens here is signal what we have it, the undesired 1200 hertz sinusoidal component of the output signal error is gradually is going to be reduced.
53.srt	00:12:16.780 --> 00:12:20.960	while the desired 2500 hertz signal is going to remain ok.
53.srt	00:12:21.390 --> 00:12:28.180	So, to faster rate of adaptation your beta or your mu can be changed.
53.srt	00:12:28.360 --> 00:12:32.970	It is too large the adaptation process may become unstable.
53.srt	00:12:33.180 --> 00:12:46.740	So, this is your signal and this is the reference noise what you will be generating it and putting it and you will be hearing that line out right and then left what you can hear the.
53.srt	00:12:47.390 --> 00:12:48.970	errors separately ok.
53.srt	00:12:49.440 --> 00:12:58.150	So, if you have a separation of left and right you can independently look at your CRO also and then see that.
53.srt	00:12:58.840 --> 00:13:02.900	So, what we will do is we will go for the demo.
53.srt	00:13:02.930 --> 00:13:05.830	What I need is the adaptive noise interrupt driven.
53.srt	00:13:08.400 --> 00:13:11.760	So, I have the thing already built in.
53.srt	00:13:12.140 --> 00:13:15.020	So, if I click on it becomes a active debug.
53.srt	00:13:15.760 --> 00:13:17.220	So, we will see that.
53.srt	00:13:17.560 --> 00:13:22.590	So, this is the interim driven what we have it.
53.srt	00:13:22.920 --> 00:13:41.490	So, we will be getting the data on the right and left channel and then you will be it uses the delay adaptation what you have it and in this case we will be using the GPU I will get input from left channel or right channel.
53.srt	00:13:41.540 --> 00:13:44.950	So, you can use the dip value 0 then.
53.srt	00:13:49.790 --> 00:13:52.060	it is going to output fixed out.
53.srt	00:13:52.560 --> 00:13:57.650	So, if it is otherwise if it is 1 it is going to put adaptive out ok.
53.srt	00:13:57.820 --> 00:14:06.200	So, what we will do is we will run the thing, we will compile it, debug it and then run.
53.srt	00:14:17.020 --> 00:14:19.540	I can close all these things.
53.srt	00:14:23.019 --> 00:14:27.320	So, I will run the thing initially you may not hear the both the sounds.
53.srt	00:14:31.110 --> 00:14:39.259	You are hearing the noise that is what the thing.
53.srt	00:14:40.850 --> 00:14:51.379	By changing the depth switch we can hear the clear sign away basically.
53.srt	00:14:53.020 --> 00:15:16.170	So, what I will do is I will show you by a graph basically what is the thing we have it out type will have adapt out hopefully it will plot it some will plot some 200 samples.
53.srt	00:15:37.210 --> 00:15:55.300	So, it is in this case it is showing your So, that is the error what it is coming out of our this thing audio signal ok. By dip switch I have not taken the thing you can experiment it by changing the GPIO dip switch.
53.srt	00:15:55.700 --> 00:15:58.250	So, you can hear the other sound.
53.srt	00:15:58.280 --> 00:16:08.960	So, the next one what we will continue with the thing is adaptive FIR filter for system identification.
53.srt	00:16:09.400 --> 00:16:12.440	of a fixed FIR filter as an unknown system.
53.srt	00:16:13.000 --> 00:16:23.500	So, what is it here also you have a dip switch basically, is to select either FIR out the output from the fixed unknown FIR filter or adaptive FIR out.
53.srt	00:16:24.010 --> 00:16:30.680	So, the output from this FIR filter what you will be getting it as a output.
53.srt	00:16:31.250 --> 00:16:39.020	Return to the right channel of line out on the kit and what you have to do is the error signal is always return to the.
53.srt	00:16:39.400 --> 00:16:41.210	left channel of line out.
53.srt	00:16:41.630 --> 00:16:48.860	So, that is what you will be one of the thing what you can select, but your left channel always error what it will be coming.
53.srt	00:16:48.860 --> 00:16:57.280	So, this is a unknown system you are trying to identify by adapting the weight for the FIR filter.
53.srt	00:16:57.410 --> 00:17:08.230	So, it uses a band pass filter that is 55 dot coefficient that is 55 coefficient FIR band stop filter centered at.
53.srt	00:17:10.640 --> 00:17:25.170	So, you can change the number of weights coefficients from 60 to 40 and verified slight degradation is going to happen in the identification process.
53.srt	00:17:25.600 --> 00:17:29.150	So, we will see the thing using CCS.
53.srt	00:17:30.640 --> 00:17:43.470	This is the system identification.
53.srt	00:17:44.070 --> 00:17:54.720	So, you have the system id interrupt dot c is the code what I will do is I will show you this code.
53.srt	00:18:00.860 --> 00:18:16.250	So, here the weight is that is w length is 256 and then the beta value or mu is 10 into e power minus 12 the learning rate has been selected and you will be getting the left sample.
53.srt	00:18:16.330 --> 00:18:31.240	I am unable to change the dip switch in this case, you can try it yourself and then see that you will be getting the output correctly.
53.srt	00:18:31.280 --> 00:18:46.220	So, the next one what we will have is the same thing there are different this thing what is it fixed FIR as an unknown system with weights of an adaptive filter initialized as FIR band pass filter in this case.
53.srt	00:18:46.680 --> 00:18:56.230	So, that is IDFIR init coefficients dot H what it will be using it and then what is coming out of the left sample ok.
53.srt	00:18:58.360 --> 00:19:05.840	This is the adaptive filter output left sample you are having the left sample and to the LDAC what it is going.
53.srt	00:19:15.050 --> 00:19:20.880	One thing I forgot to give the thing is it is going to read from the ADC.
53.srt	00:19:21.470 --> 00:19:23.430	And, then this is the DAC output.
53.srt	00:19:23.720 --> 00:19:29.990	So, what I have to provide is one of the sine wave what I have to provide it as an input.
53.srt	00:19:30.490 --> 00:19:45.619	So, for running this test signals it is given some of the test signals will be known some of the tones are there.
53.srt	00:19:45.650 --> 00:19:55.730	So, I can provide the sine 1000 this is a sound input to the system.
53.srt	00:19:57.740 --> 00:20:21.369	We will be seeing that it is continuously running.
53.srt	00:20:21.369 --> 00:20:25.339	So we will see whether the left sample has come or not in this case.
53.srt	00:20:27.080 --> 00:20:30.730	So, the input is coming.
53.srt	00:20:30.730 --> 00:21:00.350	So, because I am taking left sample and then I am outputting it whether it has adapted or not one has to look at it because there is a problem at the so, this is the noise what you have it.
53.srt	00:21:01.619 --> 00:21:04.869	So, you are outputting the noise in this case basically.
53.srt	00:21:05.289 --> 00:21:10.079	So, you will hear the noise anyway already you have heard it.
53.srt	00:21:10.079 --> 00:21:21.400	So, I am showing that what is the output happening ok.
53.srt	00:21:22.049 --> 00:21:26.700	So, the noise is coming out of the thing so once it is .
53.srt	00:21:53.660 --> 00:22:01.940	I will push this little down so that I can output my either filter output what we can output it.
53.srt	00:22:01.940 --> 00:22:04.740	This is how you will be changing the thing.
53.srt	00:22:04.740 --> 00:22:09.970	So, if I are out what I want to put the thing.
53.srt	00:22:09.970 --> 00:22:35.800	So we will do debug and then see whether I am getting the.
53.srt	00:22:40.509 --> 00:22:44.769	So, as you can see I have a phase j this thing error in the thing.
53.srt	00:22:45.340 --> 00:22:49.920	So, unless I solve this there is no point in line 27 what it says.
53.srt	00:22:49.920 --> 00:22:54.490	So, I have to come out of the debug mode I will go to the thing.
53.srt	00:22:55.430 --> 00:23:04.420	As you can see I have not removed it was 0 what it was taking.
53.srt	00:23:04.420 --> 00:23:06.330	So, there was a mismatch in the thing.
53.srt	00:23:07.030 --> 00:23:10.140	So, I have to correct the error and then recompile it.
53.srt	00:23:12.930 --> 00:23:16.880	So, when there is a error do not go and then load it on to the board.
53.srt	00:23:39.130 --> 00:23:42.740	As you can see that there is little error in the whatever the FIA filter what it is getting adapted to that is filter coefficients trying to remove this noise and then I should clean sine wave, but still there is an error.
53.srt	00:23:42.740 --> 00:23:47.079	So, this order is may not be sufficient for it.
53.srt	00:23:47.079 --> 00:23:50.769	So, you may have to go to higher order to remove the noise from the thing.
53.srt	00:23:51.650 --> 00:23:55.640	So, it is a little bit reduced, but it is still getting overlapped.
53.srt	00:23:55.640 --> 00:23:58.750	So, you have to fine tune and then work on it.
53.srt	00:23:59.119 --> 00:24:12.420	So, what is the next application what we will see using this thing in the board that is idea of fixed IAR as an unknown system in this case.
53.srt	00:24:12.789 --> 00:24:15.039	So, earlier we have seen it as FIR.
53.srt	00:24:15.599 --> 00:24:23.930	So, this is the pseudo random generation what you are doing it, IR filter through which you are passing and then looking into the thing.
53.srt	00:24:24.519 --> 00:24:41.930	So, here it is used as elliptic dot coefficient what it is going to be used for this purpose, the filter length that is because we know that it has to be one of the thing either I can use Chebyshev or Butterworth.
53.srt	00:24:46.389 --> 00:24:47.339	or elliptic.
53.srt	00:24:47.849 --> 00:24:55.250	Elliptic has the minimum what we have seen in the class is that it has both ripple in the pass band and then stop band.
53.srt	00:24:55.730 --> 00:24:59.029	So, which has a very minimum order for the thing.
53.srt	00:24:59.500 --> 00:25:02.819	So, we will go and then see whether we can work on this.
53.srt	00:25:03.259 --> 00:25:05.889	So, this is IAR.
53.srt	00:25:06.599 --> 00:25:08.929	So, I have adaptive IAR here.
53.srt	00:25:09.599 --> 00:25:16.099	So, we will make this is a active debug directory and then I will close the C file and open.
53.srt	00:25:16.299 --> 00:25:18.789	IAR adaptation.
53.srt	00:25:18.789 --> 00:25:24.399	So, you will be seeing that elliptic dot coefficient what it needs the thing when I open it.
53.srt	00:25:24.829 --> 00:25:35.489	So, you will be seeing that number of sections what it has is 3 that is numerator sections are 2 basically as you can see the thing and then denominator what you have it.
53.srt	00:25:35.979 --> 00:25:48.069	So, number of sections what we have it is that is second order this is the numerator the denominator of the first section and numerator and then denominator of the last section.
53.srt	00:25:48.469 --> 00:25:50.029	first section what we have it.
53.srt	00:25:50.969 --> 00:26:07.889	That is number of sections what it has is 3 b order is 2 sections what we have it that is fourth order filter first is the second order second stage is the second order section what we have it.
53.srt	00:26:07.889 --> 00:26:13.569	So, these are the b coefficients and these are the a coefficients what we have it.
53.srt	00:26:13.569 --> 00:26:17.869	So, when we run the thing we will build the thing.
53.srt	00:26:19.599 --> 00:26:31.529	what you are seeing the thing almost it is getting the noise it is not completely eliminated with fourth order what you are seeing it.
53.srt	00:26:31.599 --> 00:26:42.939	So you are using the update adaptive FAR filter coefficients in this case, delay line what you are doing it.
53.srt	00:26:42.939 --> 00:26:50.269	So still the noise is left out so it needs further training and then.
53.srt	00:26:50.299 --> 00:26:53.470	the order of the filter is very low in this case.
53.srt	00:26:53.470 --> 00:26:57.099	So, it is unable to adapt itself to the noise.
53.srt	00:26:57.509 --> 00:27:14.859	So, this example because I said it is audio wave file what we generated in the last class because it needs longer time to adapt itself.
53.srt	00:27:15.230 --> 00:27:20.190	So, it was taking longer time that is why I shown this demo in the last class.
53.srt	00:27:20.409 --> 00:27:22.970	So, this completes the adaptive.
53.srt	00:27:24.480 --> 00:27:33.719	filter up what I will say for different applications how we are going to run it using the board in real time.
53.srt	00:27:34.019 --> 00:27:45.219	So, whatever data how system ID identification it happened and how the noise is going to be cancelled and it can be non real time or real time what you can give the thing.
53.srt	00:27:45.659 --> 00:27:55.209	So, one more way of doing it is you can give separately the noise in one channel here it is mixed and then sent it as an.
53.srt	00:27:55.650 --> 00:27:56.660	input to the system.
53.srt	00:27:57.039 --> 00:28:02.960	So, one of them can be mic input the other one can be line input what you can give and then mix and then match.
53.srt	00:28:03.240 --> 00:28:04.759	So, that is what I was telling.
53.srt	00:28:04.759 --> 00:28:12.529	So, you can play around this board the way you want to give the input and then what you want to hear at the output.
53.srt	00:28:13.049 --> 00:28:17.359	So, thank you for listening to this lab.
47.srt	00:00:01.219 --> 00:00:25.940	Welcome back to real time digital signal processing lab.
47.srt	00:00:31.309 --> 00:00:37.479	So in the previous class we discussed about the Today, we will be seeing the demo of the linear predictive coding for speech synthesis.
47.srt	00:00:37.750 --> 00:00:54.390	So, welcome back and then we will see little bit of theory and then we will go for the demo both on MATLAB as well as in the board actually that is DSK board.
47.srt	00:00:55.000 --> 00:01:01.859	So, first the introduction because to give the feel of LPC what we discussed in the theory.
47.srt	00:01:02.450 --> 00:01:11.700	So, this is linear predictive coding is widely used in speech coding, synthesis, speaker recognition and for speech storage.
47.srt	00:01:12.210 --> 00:01:20.390	So, these methods provide extremely accurate estimates of speech parameters and does it efficiently.
47.srt	00:01:20.760 --> 00:01:30.710	So, the basic idea here is to closely approximate the speech sample as a linear combination of past samples.
47.srt	00:01:31.030 --> 00:01:33.560	So, as you can see in the equation.
47.srt	00:01:33.969 --> 00:01:51.890	So, what we have is S of n is the present sample for that this thing k is going 1 to p a k are the coefficients S of n minus k. So, for some values of p a k and then S will be predicting the thing.
47.srt	00:01:52.129 --> 00:02:04.070	So, coming to the architecture for both analysis and synthesis our speech is what is shown in the figure here.
47.srt	00:02:05.359 --> 00:02:17.569	So, we have the input speech we can select depending on which speech we want to have the thing and we have the digital filter that is FIR filter.
47.srt	00:02:18.370 --> 00:02:31.860	So, which is going to do the pre emphasis on the thing and this can be directly given as input to our moving average filter which is shown as lattice moving average filter.
47.srt	00:02:32.300 --> 00:02:37.730	So, one can go to the net and then check what is moving average filter.
47.srt	00:02:38.170 --> 00:02:39.740	So, as an input.
47.srt	00:02:40.150 --> 00:02:46.960	So, the other way is what you are going to give to overlap analysis window what it goes into the section.
47.srt	00:02:47.189 --> 00:02:52.930	So, next is it is passed through the hamming window.
47.srt	00:02:53.590 --> 00:03:02.850	So, this is the FIR filter what we are going to design and then we are going to check for the autocorrelation basically.
47.srt	00:03:03.290 --> 00:03:05.470	So, we have discussed the correlation.
47.srt	00:03:05.470 --> 00:03:10.490	So, here it is going to correlate with whether it is going to match with the present scenario.
47.srt	00:03:11.090 --> 00:03:23.530	and it uses the Levinson Durbin algorithm to predict the coefficients basically and this is given as input our lattice moving average filter.
47.srt	00:03:23.530 --> 00:03:38.700	So, we are going to do time varying analysis basically over the fiber net what it can be connected here we will be doing both analysis is this equation and synthesis is this part.
47.srt	00:03:38.780 --> 00:03:41.520	So, we will be incorporating both of it.
47.srt	00:03:45.129 --> 00:03:46.409	and then see the demo.
47.srt	00:03:46.719 --> 00:03:57.259	Otherwise in the normal case this will be becoming a channel and you will be sending it out and then at the synthesis part that is at the receiving part.
47.srt	00:03:57.349 --> 00:04:08.150	So, we have to depredict the thing that is we have to run the lattice filter this which is time varying moving average filter here.
47.srt	00:04:08.730 --> 00:04:14.890	So, analysis receiver what it is going to have and then the output is connected to.
47.srt	00:04:15.830 --> 00:04:19.900	our de-emphasis and then output is going to be predicted.
47.srt	00:04:20.110 --> 00:04:25.980	So, whatever input speech which is there which should be coming out.
47.srt	00:04:25.980 --> 00:04:32.290	So, what is the how it has been implemented little details have been given here.
47.srt	00:04:32.290 --> 00:04:40.550	So, first is because it is a speech which has to be segmented and taking the windows of it.
47.srt	00:04:40.550 --> 00:04:46.310	So, the speech signal is divided into overlapping segments for further computation.
47.srt	00:04:48.589 --> 00:05:01.759	So, the parameters used in this test scenario is window is the hamming window and window length chosen as 80 and window overlap is 40.
47.srt	00:05:02.389 --> 00:05:11.649	So, as you can see this is the speech signal which is a input signal and we will be considering the overlapping window.
47.srt	00:05:12.290 --> 00:05:18.069	So, you will be seeing that this is the window length and this is the hop length.
47.srt	00:05:18.290 --> 00:05:22.360	what it is called and this is the overlap length.
47.srt	00:05:22.850 --> 00:05:32.960	So, approximately you can take it as 50 percent of overlap what it has happened as you can see here it is given as 40.
47.srt	00:05:33.410 --> 00:05:41.920	So, that is what the overlap length what will be taken and these are the segments as you can see in this window length.
47.srt	00:05:42.350 --> 00:05:46.480	So, we will be cutting this pitch into smaller segments.
47.srt	00:05:46.879 --> 00:05:49.270	So, and so on and then till the.
47.srt	00:05:49.470 --> 00:05:53.270	end of the speech and processing is going to happen.
47.srt	00:05:53.949 --> 00:05:57.610	So, coming to the next is the autocorrelation.
47.srt	00:05:58.030 --> 00:06:12.000	So, what we have to do it on this windowed signal that is this is done to minimize the expected value of squared error between the predicted signal and the true signal value.
47.srt	00:06:12.689 --> 00:06:19.699	So, it is computed using equation as you know Rxx is the autocorrelation coefficient.
47.srt	00:06:20.870 --> 00:06:37.699	of k is given by m is equal to minus infinity to infinity x of m into x of m minus k. And the parameter for the autocorrelation function is the lag is taken as 9 in this case.
47.srt	00:06:38.399 --> 00:06:44.930	So, next is the Levinson Durbin algorithm for linear predictive coding what we have to use the thing.
47.srt	00:06:45.480 --> 00:06:51.480	So, the equations of the Levinson Durbin recursion basically it is a recursive algorithm.
47.srt	00:06:51.939 --> 00:06:58.319	which are used to compute the corresponding reflection coefficients and LPC parameters.
47.srt	00:06:58.710 --> 00:07:19.360	So, the equations you will be seeing that given by A2 as you will be seeing up to E. So, this is your expected value of 0 which is given by phi of 0 and K i is calculated with this equation.
47.srt	00:07:19.879 --> 00:07:25.550	So, for this thing is 1 less than or equal to i which is less than or equal to pi.
47.srt	00:07:25.750 --> 00:07:38.430	P ok. And then A i of i is given by this thing constant K i and then after substituting in the equation.
47.srt	00:07:38.430 --> 00:07:45.689	So, for j will be going between 1 to i minus 1 this is the recursion what will be doing it.
47.srt	00:07:46.040 --> 00:07:50.860	So, expected value of i is calculated with this equation.
47.srt	00:07:51.629 --> 00:07:58.830	And then the updation alpha j is given by alpha j p between.
47.srt	00:07:59.389 --> 00:08:05.850	J between 1 and then P that is the final solution what it is given.
47.srt	00:08:05.850 --> 00:08:07.189	So, when it matches.
47.srt	00:08:07.610 --> 00:08:13.649	So, the parameter is number of LPC coefficients chosen as 10 in this case.
47.srt	00:08:14.250 --> 00:08:20.569	So, coming to the analysis filter here it is FIR filter B is being used.
47.srt	00:08:21.199 --> 00:08:29.300	Uses the LPC coefficients as filter weights and this filtering removes formants from speech signal.
47.srt	00:08:29.679 --> 00:08:36.449	And, the remaining signal after the subtraction of filtered model signal is called residue.
47.srt	00:08:36.840 --> 00:08:37.889	So, what is it?
47.srt	00:08:38.100 --> 00:08:42.240	Y of n is equal to a naught into a naught plus a 1.
47.srt	00:08:42.600 --> 00:08:46.090	You may be wondering why a coefficients has been chosen.
47.srt	00:08:46.090 --> 00:08:53.079	Usually we choose a coefficients for poles and then b coefficients for 0s basically.
47.srt	00:08:53.139 --> 00:08:58.840	In this case you can see that a coefficients have been used for.
47.srt	00:09:02.049 --> 00:09:18.029	So, you will be having A naught plus as you can see this is Y naught is A naught plus A 1 into X of n minus 1 is the input plus A 2 into X of n minus 2 plus A 3 into X of n minus 3.
47.srt	00:09:18.539 --> 00:09:35.149	And in time domain is expressed in this fashion and in the Z domain as you can see H of Z is given by A naught plus A 1 into Z minus 1 plus A 2 into Z minus 2 plus A 3 into Z minus 3.
47.srt	00:09:35.899 --> 00:09:38.109	And, filter length chosen is 10.
47.srt	00:09:38.249 --> 00:10:11.879	So, you will be seeing x of n is the input these are the coefficients and then you are delaying the signal and you the other coefficients a 1 into x of n minus 1 or a 1 into z minus 1 what it is going to be coming from this length basically and you will be adding with your a naught and then you will be getting the y of n this is the filter structure what it shows that how it is getting calculated.
47.srt	00:10:12.569 --> 00:10:16.859	Now, in the synthesis part of it, it is the IR filter.
47.srt	00:10:17.219 --> 00:10:23.099	So, now, it must be triggering because the coefficients we have to keep the same a naught a 1 a 2 a 3.
47.srt	00:10:23.559 --> 00:10:28.699	So, here it is IR filter whereas, in the analysis we use the FIR filter.
47.srt	00:10:28.789 --> 00:10:39.499	Speed signal by reversing the analysis filter using the residue and LPC coefficients to recreate our formats.
47.srt	00:10:40.009 --> 00:10:42.369	So, we will be using the all-pole model.
47.srt	00:10:43.419 --> 00:10:48.269	of filter has the ability to describe most type of speech signals quite well.
47.srt	00:10:48.779 --> 00:11:04.359	So, whatever 0s in the analysis part now they become poles in the synthesis part as you will be seeing it here that is a reason why it was named as A coefficients.
47.srt	00:11:04.669 --> 00:11:10.239	So, you will be seeing that impulse response H of z is given by Y of z by X of z.
47.srt	00:11:10.919 --> 00:11:13.199	So, which is given by some constant.
47.srt	00:11:13.539 --> 00:11:43.039	G divided by 1 minus k is equal to 1 to p or a k p into z minus k. So, y of n is given as if we write in the time domain it is going to be G into z of n plus k is equal to 1 to p a k of p y of n minus k. So, these are the feedback path and even here it is parameter what is it filter order is chosen as 10.
47.srt	00:11:43.799 --> 00:11:46.689	equivalent to our analysis part.
47.srt	00:11:47.189 --> 00:12:13.730	So, coming to this the where all the LPC coding is going to be used applications what you will be seeing it in the speech compression example as GSM standard and then speech encryption in the voice codec also example is electronic music you can use the LPC coding and tonal analysis of musical instruments.
47.srt	00:12:14.079 --> 00:12:16.829	you can use and even in the speaker recognition.
47.srt	00:12:17.359 --> 00:12:33.229	So, these are the references to create the files what it has been used ok. Now, we will first see the demo in the MATLAB and then go to the hardware to check the thing.
47.srt	00:12:34.069 --> 00:12:49.839	So, first I will show you the LPC or this thing DSP because this student has chosen as the project to implement it in the course as I say students will be taking as a mini project or they can use it as an assignment.
47.srt	00:12:50.250 --> 00:12:51.959	So, what is it?
47.srt	00:12:52.309 --> 00:13:02.759	Frame size what it is chosen 40 as theory says frame length is 80 and LPC coefficient number is chosen as 10.
47.srt	00:13:03.230 --> 00:13:05.720	So, what is this part is going to do?
47.srt	00:13:06.079 --> 00:13:12.379	System object to read from an audio file and determine the files audio sampling rate.
47.srt	00:13:12.850 --> 00:13:16.049	So, when you are using it you may not know the thing.
47.srt	00:13:16.439 --> 00:13:23.589	So, what we will do is first we will read one of the file and then we will test it on the other two also.
47.srt	00:13:24.090 --> 00:13:25.419	So, this is a Kannada.
47.srt	00:13:25.419 --> 00:13:28.259	So, hold on what we are going to get through this.
47.srt	00:13:28.610 --> 00:13:38.230	It is a M4 this thing format students own voice is recorded and then it is stored in the MP4 format.
47.srt	00:13:38.639 --> 00:13:49.909	So, we will be taking input as we have to do the resample whatever the sampling rate may be the thing what we need is a 16 kilohertz.
47.srt	00:13:50.529 --> 00:13:56.389	So, input with 16 kilohertz and then sampling frequency what we want is resample.
47.srt	00:13:57.000 --> 00:13:58.639	for 16 kilohertz.
47.srt	00:13:58.669 --> 00:14:02.909	So, F s is going to be defined with 16 kilohertz here.
47.srt	00:14:03.579 --> 00:14:21.490	And then you will be starting and then some of the specific length of speech segment as 80 and then you have to do this zero padding to align on our this thing what is that length of it and then now you will be making some of the variables 0.
47.srt	00:14:21.750 --> 00:14:28.370	So, you will be creating a buffer system object and set its properties at that.
47.srt	00:14:28.779 --> 00:14:35.539	You get an output of twice the length of the frame size with an overlap length of frame size.
47.srt	00:14:35.909 --> 00:14:42.949	So, you what you want to have is although you are selecting 80 samples, 40 of them have to be overlapped.
47.srt	00:14:43.250 --> 00:14:55.829	So, that is why you will be choosing the buffer length twice that of it and then in that there will be 40 right side and 40 left side overlap will be there.
47.srt	00:14:56.590 --> 00:15:03.009	So, this is the signal buffer what you are defining with twice that length.
47.srt	00:15:03.790 --> 00:15:09.399	Next is each frame of a input signal is windowed using a Hamming window.
47.srt	00:15:09.850 --> 00:15:16.710	So, you will be calling DSP dot window which is given with Hamming window.
47.srt	00:15:17.389 --> 00:15:23.180	So, the 10th order autocorrelation coefficients are found using this equations.
47.srt	00:15:23.180 --> 00:15:34.430	So, you will be calling the function again DSP dot autocorrelator and then what is the maximum lag source.
47.srt	00:15:34.830 --> 00:15:43.759	property and then lag and LPAC your coefficient minus 1 and then scaling and biased or the input of this.
47.srt	00:15:44.080 --> 00:15:54.990	So, you will be this section what it does is calculates the reflection coefficients from the autocorrelation results using the LPC spectrum.
47.srt	00:15:54.990 --> 00:16:01.960	So, you will be calling the Levinson solver to get the coefficients as you are doing it.
47.srt	00:16:02.360 --> 00:16:06.009	So, then you will be creating an FIR digital filter.
47.srt	00:16:06.470 --> 00:16:09.009	used for our adaptive purpose.
47.srt	00:16:09.660 --> 00:16:18.810	In the analysis case also create two all pole digital filter system objects used for synthesis.
47.srt	00:16:18.810 --> 00:16:23.780	So, you have to create the filters both for analysis and then synthesis.
47.srt	00:16:24.310 --> 00:16:37.100	So, this is the analysis filter which is FIR filter which is declared and then you will be seeing that it is a moving average lattice filter which is being used and then you will be getting the coefficient.
47.srt	00:16:37.340 --> 00:16:37.790	here.
47.srt	00:16:38.180 --> 00:16:52.350	And in the synthesis filter it is all pole filter what you are designing it you will be giving the structure and then lattice all pole value basically that is auto regression what you will be setting it.
47.srt	00:16:52.720 --> 00:16:57.800	So, how you are going to play the thing it is going to be written audio writer.
47.srt	00:16:57.840 --> 00:17:00.790	So, you will be writing into the audio device or writer.
47.srt	00:17:01.590 --> 00:17:03.759	So, whatever the sample rate.
47.srt	00:17:08.620 --> 00:17:11.509	So, which is selected as FS in this case ok.
47.srt	00:17:12.019 --> 00:17:23.519	So, main code where LPC analysis and synthesis of the input audio signal using instantiations done whatever you have set it ok.
47.srt	00:17:23.519 --> 00:17:29.680	So, the loop stops when we reach the end of the input file.
47.srt	00:17:29.850 --> 00:17:37.280	So, which is detected by the audio file reader as a system object.
47.srt	00:17:37.660 --> 00:17:43.590	So, you will be seeing that frame size and then length of input minus 2 star.
47.srt	00:17:44.080 --> 00:18:12.259	frame size and then taking input in segmentation you will be taking it and then window each segment and then perform the autocorrelation here what you are doing it then calculate the Levinson Durbin algorithm in this place and then synthesis filter is IR filter basically what it is being used and then you will be writing in this thing and then you can play output audio.
47.srt	00:18:14.720 --> 00:18:21.310	So, writer what you are doing it and you will be after everything you have to close the thing.
47.srt	00:18:21.920 --> 00:18:25.170	So, you will be releasing the audio writer part of it.
47.srt	00:18:25.530 --> 00:18:42.450	So, we will as I said this is the first file what has been taken for reading and we will see the after synthesis sorry analysis and synthesis what output you would be getting it ok.
47.srt	00:18:42.870 --> 00:18:44.240	So, we will run the thing.
47.srt	00:18:47.550 --> 00:18:50.940	Were you able to hear it?
47.srt	00:18:50.940 --> 00:18:57.540	So the selected one is telling Namaskara.
47.srt	00:18:57.930 --> 00:18:59.930	So we can see once again running it.
47.srt	00:18:59.930 --> 00:19:01.400	Namaskara.
47.srt	00:19:16.030 --> 00:19:20.240	So, what we will see is we will run the other part of it.
47.srt	00:19:22.500 --> 00:19:30.060	So, we will open something what it has been stored wave file.
47.srt	00:19:30.720 --> 00:19:32.010	So, we will run this.
47.srt	00:19:34.000 --> 00:19:35.150	Good evening.
47.srt	00:19:36.410 --> 00:19:38.710	Did you hear the thing again I will play it.
47.srt	00:19:40.960 --> 00:19:42.130	Good evening.
47.srt	00:19:43.340 --> 00:19:44.600	So, this is one more.
47.srt	00:19:46.360 --> 00:19:50.870	As I said we can play with whatever your voice you want to have the thing.
47.srt	00:19:50.990 --> 00:19:52.019	So, we will see this one.
47.srt	00:19:52.019 --> 00:20:04.910	So, we can play the original and then see how it is going to look like.
47.srt	00:20:04.910 --> 00:20:15.170	So, now what I will do is this is from the MATLAB what we have.
47.srt	00:20:18.160 --> 00:20:30.869	So, I can show you how it is going to be from the original way file whatever is it and then what we were able to reconstruct.
47.srt	00:20:58.789 --> 00:21:00.710	So, it takes a little.
47.srt	00:21:01.259 --> 00:21:03.599	Time to play through the this thing.
47.srt	00:21:07.430 --> 00:21:16.269	This was the original.
47.srt	00:21:16.879 --> 00:21:28.619	So, what I will play here is from the this thing what is it analysis and then synthesis LPC coding what we have done the thing.
47.srt	00:21:28.950 --> 00:21:31.210	So, you would be seeing that there is a little.
47.srt	00:21:31.299 --> 00:21:35.609	difference with the original just you will hear the thing again.
47.srt	00:21:37.099 --> 00:21:42.789	But still it has a little meaning in the thing.
47.srt	00:21:43.240 --> 00:21:49.450	So, as you know LPC coding is 64 kilobits per second what we are going to have it.
47.srt	00:21:49.839 --> 00:21:58.919	So, the original voice in all the thing what you can hear it from this place.
47.srt	00:22:03.619 --> 00:22:05.699	play the other one original.
47.srt	00:22:05.769 --> 00:22:11.959	Good evening, good evening, good evening, good evening, good evening, good evening, good evening.
47.srt	00:22:11.999 --> 00:22:21.429	So, as you can see this is a female voice now we have to take mean score of opinion ok here.
47.srt	00:22:21.429 --> 00:22:23.399	So, what is it going to be?
47.srt	00:22:23.399 --> 00:22:33.959	So, you will be hearing this good evening how it is going to be it has got reconstructed through our LPC coding.
47.srt	00:22:37.799 --> 00:22:38.969	Good evening.
47.srt	00:22:41.759 --> 00:22:42.909	Good evening.
47.srt	00:22:43.649 --> 00:22:46.169	So, this is what what you heard ok.
47.srt	00:22:46.589 --> 00:22:51.379	So, there is a difference between the voice pitch and other things.
47.srt	00:22:51.379 --> 00:23:03.269	So, you have to move on to the other standards and other things and see whether we are going to get the correctly ok. That is what what you have to do it and then Matlab.
47.srt	00:23:04.099 --> 00:23:04.769	Namaskara.
47.srt	00:23:05.609 --> 00:23:08.989	This is the original voice.
47.srt	00:23:08.989 --> 00:23:17.969	So, you will be seeing that after you have already heard once again I am playing with the original and then the reconstructed.
47.srt	00:23:17.969 --> 00:23:29.139	Still it was able to do the thing with the some of the functions.
47.srt	00:23:29.259 --> 00:23:31.089	So, you can.
47.srt	00:23:37.389 --> 00:23:39.359	recreate much more.
47.srt	00:23:39.799 --> 00:23:53.629	So, before moving on to our demonstration in the code composer studio just I thought I will show you one of the application of our filter.
47.srt	00:23:53.919 --> 00:24:11.839	So, here it is usually we call it as a multirate signal processing which those who are interested can look into the thing when I want to convert my CD quality that is 44.1 kilohertz.
47.srt	00:24:14.179 --> 00:24:20.509	file to a midi quality what we call it as 48 kilohertz.
47.srt	00:24:20.869 --> 00:24:27.289	So, this is the input audio rate and then output audio we want it at 48 kilohertz.
47.srt	00:24:27.289 --> 00:24:31.799	So, how we are going to do it is going to be in stages what we will be reconstructing.
47.srt	00:24:32.129 --> 00:24:45.739	So, we will be having some filters in between when we are up sampling it and then we will be using the FFT that is audio and then FFT what it will be coming.
47.srt	00:24:46.259 --> 00:24:50.289	And then we will run and see this is one of the application of a filter.
47.srt	00:24:50.629 --> 00:24:55.509	So, here it is going to happen in three stages basically.
47.srt	00:24:55.769 --> 00:25:11.199	So, some of the filter you will be seeing it used here it is for decimation and then interpolation and then these are the two ones will be configuring to two the other one will be last one will be this one.
47.srt	00:25:11.589 --> 00:25:15.939	There will be three stages of it and we will see that each stage.
47.srt	00:25:17.679 --> 00:25:21.039	how it is going to run with the thing.
47.srt	00:25:21.789 --> 00:25:24.329	So, we will run this algorithm.
47.srt	00:25:25.629 --> 00:25:28.149	So, and then see.
47.srt	00:25:51.039 --> 00:25:53.439	So, what happened?
47.srt	00:25:54.459 --> 00:25:59.469	So, you will be seeing that if I make it maximize on the thing.
47.srt	00:26:00.059 --> 00:26:10.139	So, you will be seeing here these are the three stages through the filter what it has got passed.
47.srt	00:26:10.219 --> 00:26:21.189	So, from 44.1 what will be going to 48 kilo Hertz which is depicted with respect to this.
47.srt	00:26:21.259 --> 00:26:24.349	So, you will be seeing that initially it.
47.srt	00:26:24.690 --> 00:26:27.630	the red one was at 44.1 kilohertz.
47.srt	00:26:27.630 --> 00:26:39.500	Then based on our this thing both decimation and interpolation together will be converting in three stages to 48 kilohertz.
47.srt	00:26:39.640 --> 00:26:52.690	So, you will be seeing this is the black is the first stage and then green is what it is going to be second stage and this will be third stage what waveform it is going to look like.
47.srt	00:26:56.450 --> 00:26:58.509	So, as you heard from signal this is a sine wave ok.
47.srt	00:26:58.919 --> 00:27:04.669	There is no difference between your stages from one to the other one.
47.srt	00:27:04.990 --> 00:27:09.680	So, without compromising on any input data.
47.srt	00:27:10.930 --> 00:27:16.740	So, we can reconstruct from one frequency to the other frequency.
47.srt	00:27:16.740 --> 00:27:19.460	So, those who are interested so, this code will be up.
47.srt	00:27:19.460 --> 00:27:33.009	So, you can look into the thing and then see that if you want to do from one why do you why do you want to convert it into one frequency at this frequency because as you we are seeing it.
47.srt	00:27:34.099 --> 00:27:46.989	are speech is at 8 kilohertz and then from 8 kilohertz narrowband speech to wideband if I want to convert it from 8 to 16 kilohertz what I have to convert.
47.srt	00:27:46.989 --> 00:27:52.079	So, this requires multirate processing basically.
47.srt	00:27:52.499 --> 00:27:58.109	So, those who are interested as a beyond this course material you can go through and then get it.
47.srt	00:27:58.559 --> 00:28:01.409	So, we will stop the MATLAB demo here.
47.srt	00:28:01.799 --> 00:28:03.969	So, we will.
47.srt	00:28:04.189 --> 00:28:08.669	go into the code composer studio and then check the demo of LPC coding.
47.srt	00:28:09.859 --> 00:28:15.609	We will see how to proceed using the code composer studio.
47.srt	00:28:16.109 --> 00:28:34.019	So, this is the synthesis using LPC as it has been named and then we need some include files, Ivo files and some math library and then because we are going to use the codec in this case input and then output codec.
47.srt	00:28:34.680 --> 00:28:39.380	So, we need this AC3106 init dot h is our codec.
47.srt	00:28:39.460 --> 00:28:48.500	So, we will be including the hamming window as even in the FIR filter when I was demonstrating.
47.srt	00:28:48.809 --> 00:28:54.990	Usually we create using the MATLAB and all our filter coefficients and then keep it.
47.srt	00:28:55.170 --> 00:28:56.930	So, you can see here.
47.srt	00:29:05.029 --> 00:29:07.079	hamming dot h what I will open.
47.srt	00:29:07.470 --> 00:29:19.039	So, if this is the 80 order what it has been chosen ok ham 80 and these are the coefficients in fixed point format what you have taken.
47.srt	00:29:19.379 --> 00:29:28.049	So, fixed point format basically equivalent to what it represents in our board is integer format.
47.srt	00:29:35.859 --> 00:29:41.029	So, you will be seeing 80 coefficients what it has been stored here and which is used a scamming window coefficients basically this is the scaled version of it.
47.srt	00:29:41.569 --> 00:29:53.359	And here also again the overlap is defined with 40 length and then the frame length is defined with 80 that is twice that of it.
47.srt	00:29:53.729 --> 00:30:01.949	So, you can include this thing speech samples what it is being stored fine.
47.srt	00:30:02.229 --> 00:30:08.079	So, initially I have taken Kannada 2 dot hedge and we have the.
47.srt	00:30:08.599 --> 00:30:09.720	other H files.
47.srt	00:30:09.720 --> 00:30:23.379	So, we will see how does it look like because you will be seeing that total length is 19520.
47.srt	00:30:23.500 --> 00:30:37.480	So, this is the total length of the speech files what we have it and this is how what it has got stored with respect to what I will say is in the fixed point format.
47.srt	00:30:37.529 --> 00:30:41.589	So, you can see all of them are.
47.srt	00:30:44.579 --> 00:30:46.059	So, the first one.
47.srt	00:30:46.059 --> 00:30:48.549	So, after that what it is going to do?
47.srt	00:30:48.549 --> 00:31:01.889	So, we have to define some data section, when we want to have in particular data place will define as hash pragma that what we want this final output in the dot output.
47.srt	00:31:01.889 --> 00:31:10.669	So, that is store the output in external memory and we want the input to be.
47.srt	00:31:14.960 --> 00:31:23.129	also in the external memory then we will be putting it this way because it is length input and output are more.
47.srt	00:31:23.470 --> 00:31:27.619	So, the internal memory is less in the case.
47.srt	00:31:27.619 --> 00:31:33.349	So, we want to store it in external memory and you will be initializing basically.
47.srt	00:31:33.799 --> 00:31:45.710	So, to show that print is to debug basically in between if you are unable to get the output usually because this is a C code.
47.srt	00:31:45.710 --> 00:31:46.680	So, in between to debug it.
47.srt	00:31:47.049 --> 00:31:53.089	So, you give print commands and then see whether it is matching with MATLAB.
47.srt	00:31:53.299 --> 00:32:06.669	First usually all the codes are written in MATLAB and then tested that it is working because we prove it there sometimes we have the built in functions in MATLAB for all these things.
47.srt	00:32:06.990 --> 00:32:16.029	So, when we try it out and then it is working then usually sometimes we may not use the built in function we will write our own code.
47.srt	00:32:16.259 --> 00:32:25.990	So, that the code can be mapped into our code composer studio or any hardware for that matter even if you are designing your.
47.srt	00:32:26.219 --> 00:32:30.389	thing in FPGA usually in the MATLAB we test the thing.
47.srt	00:32:30.500 --> 00:32:47.119	So, algorithm or in using the python code one can write their own algorithm then will be going into or transfer it to our whatever hardware which supports the languages.
47.srt	00:32:47.459 --> 00:32:54.959	Usually in FPGA we use the Xilinx board basically there we use both.
47.srt	00:32:58.109 --> 00:33:10.200	VHDL as well as Verilog combinations to implement it even sometimes C will be front end and then back end will be VHDL coding what we will be doing it.
47.srt	00:33:10.460 --> 00:33:29.569	So, here also you will be seeing the front end in C I will as I promised one assembly program I will show you that how the coding length is going to reduce and then how you can predict what is the time it is going to take in later lab demonstration.
47.srt	00:33:31.119 --> 00:33:33.259	So, this is the interrupt driven.
47.srt	00:34:01.880 --> 00:34:02.430	So, usually here it is used is interrupt 4 actually and then you are getting some input sample and then you want to put it in some dummy like dummy file we say here dummy variable what it is going to be put and then we will be taking it out ok. And if the index is less than the total then you have to modify your input.
47.srt	00:34:03.250 --> 00:34:10.490	And then you will be making it 0 because your window length is less and then your input length is more.
47.srt	00:34:10.860 --> 00:34:19.539	So, you will be what I call it as circular buff of what you will be putting it and then taking into that area.
47.srt	00:34:19.630 --> 00:34:29.159	So, next is this is the segmentation function input into frames of size whatever length it has been specified.
47.srt	00:34:32.369 --> 00:34:35.099	So, from the start what it is going to do?
47.srt	00:34:36.659 --> 00:34:42.909	So, you will be allocating some memory basically and then you will be starting.
47.srt	00:34:42.909 --> 00:34:59.219	So, you will be bifurcating your input wave and then if you want to print it that signal loop and other things what you can print it so that it is entered into the loop ok. Then now comes the window function.
47.srt	00:34:59.670 --> 00:35:02.920	So, this multiplies the segment with hamming window.
47.srt	00:35:03.400 --> 00:35:17.130	So, you are seeing that here it is doing the hamming within the loop and then converting result from you can see Q format what it is shown.
47.srt	00:35:17.489 --> 00:35:22.989	So, because the multiplication is going to result with Q 30 format.
47.srt	00:35:23.320 --> 00:35:26.519	So, result has to be in the Q 15 format.
47.srt	00:35:26.519 --> 00:35:33.769	So, you are seeing that it is getting shifted by this thing 16 bits.
47.srt	00:35:34.340 --> 00:35:53.620	And, then here because we have two what we call it as sign bits that is why one left shift is going to happen and then later on 16 bits and then will be storing that in our this thing basically output which is going to show that whether it is coming or not ok.
47.srt	00:35:54.130 --> 00:36:01.100	So, then what it is going next one is your autocorrelation function which is being implemented in C as you can see.
47.srt	00:36:01.519 --> 00:36:03.930	So, this is X correlation.
47.srt	00:36:04.179 --> 00:36:07.460	what although it named as cross correlation.
47.srt	00:36:07.460 --> 00:36:17.099	So, you will be using same data so, that it can be for two different data set input or it can be the same input what you can provide.
47.srt	00:36:17.099 --> 00:36:23.449	So, you will be initializing your correlation 0 and then you will be looping till your frame length minus i.
47.srt	00:36:23.449 --> 00:36:26.840	So, that index does not spill over in this case.
47.srt	00:36:35.650 --> 00:36:40.569	So, you are doing the same basically what is it only to the size of your data.
47.srt	00:36:40.630 --> 00:36:47.599	And then you will be returning from this function and then next is the LPC function what it is defined here.
47.srt	00:36:47.980 --> 00:36:55.559	It uses the Levinson Durbin algorithm and then it is going to calculate your LPC coefficients from autocorrelated segment.
47.srt	00:36:56.190 --> 00:37:04.489	And you will be defining some of the variables and then allocating some memory here and then what are the loop functions.
47.srt	00:37:04.799 --> 00:37:11.069	You will be seeing that some of the K and E and then alpha what it is being defined in the equation.
47.srt	00:37:11.490 --> 00:37:21.329	which has to be incorporated and then you will be iterating with this thing i is equal to 1 to order as iteration is going to variable ok.
47.srt	00:37:21.860 --> 00:37:30.500	So, you will be seeing that whether it has entered into this for debugging purposes what you will be seeing in between printf statements.
47.srt	00:37:30.500 --> 00:37:40.090	Now this will be to the order you will be looping this is the start step 1 here.
47.srt	00:37:40.570 --> 00:37:42.800	So, you are calculating your sum.
47.srt	00:37:43.260 --> 00:38:13.809	and then k value and reference value and then you will be calculating your modifying your alpha and then you will be using it in your equation basically in the Levinson Durbin equation and you will be trying to minimize your error basically and then E of i and then you will be resetting your alpha value and other things and then you will be.
47.srt	00:38:14.200 --> 00:38:39.200	freeing all your memory here ok. And this is the residual function what it is being computed here FIR filter to calculate residual signal from windowed signal and LPC coefficients ok. Numerator size minus number of filter coefficients is equal to our number of LPC coefficients what it is getting generated.
47.srt	00:38:39.670 --> 00:38:42.960	So, this is the function what you will be writing it.
47.srt	00:38:45.940 --> 00:38:51.130	So, then You will be summing it up and then to check whether it is doing it correctly you will be printing it.
47.srt	00:38:51.610 --> 00:38:55.900	Then next for the synthesis you have to run your IR filter.
47.srt	00:38:56.550 --> 00:39:06.640	So, it is a all pull synthesize your speech from whatever you have done the analysis part of it and then you will be reconstructing it.
47.srt	00:39:06.670 --> 00:39:12.380	So, this is length here also IR filter length is 10 what it has been considered.
47.srt	00:39:15.530 --> 00:39:21.820	And then you will do your equation and then next is the buffering function.
47.srt	00:39:21.820 --> 00:39:33.230	So, you want to accumulate because only for 80 samples what you are doing it and then you are doing it in concatenation that is there is a overlap and other things.
47.srt	00:39:33.650 --> 00:39:41.130	So, you have to reconstruct your signal with removal of overlap basically.
47.srt	00:39:41.160 --> 00:39:44.370	So, you will be defragment and then.
47.srt	00:39:45.440 --> 00:39:48.100	put it in the concatenation using this function.
47.srt	00:39:48.500 --> 00:39:57.050	So, finally, you are all those are the functions which are defined and then main function what will be seeing it here ok.
47.srt	00:39:57.430 --> 00:40:17.310	So, all your outputs and then have been defined with 0 and then the loop what you will be giving it that is I trace for every speed segment length here it is 80 and overlap what we have taken is 40 and every overlapping speed segment is going to be windowed.
47.srt	00:40:17.660 --> 00:40:28.139	and do the autocorrelation later and calculate your LPC parameters and calculate the residual signal calculating using the FAR.
47.srt	00:40:28.139 --> 00:40:34.150	So, you will be doing the synthesis through IAR and output the accumulation based on overlap.
47.srt	00:40:34.820 --> 00:40:39.180	So, you will be seeing that these are the ones how you are going to free.
47.srt	00:40:39.400 --> 00:40:48.769	And since we are using 3106 here L138 we have to initialize the interrupt service routine.
47.srt	00:40:48.769 --> 00:40:55.200	So, we have to say what is the sampling rate we are providing it to the.
47.srt	00:40:55.470 --> 00:41:06.010	ADC, it is 16 kilohertz even DAC is at the same thing ok. And gains what usually it is going to be 0 dB what will be providing it.
47.srt	00:41:06.560 --> 00:41:12.020	And then input to this is going to be from LCDK line input.
47.srt	00:41:12.630 --> 00:41:30.050	So, even the output as here it supports both mic and then line input mic is we have a differential input whereas, line will have both left channel and then right channel input what we can take it.
47.srt	00:41:30.080 --> 00:41:33.500	So, that is how we will be working on one of the channel.
47.srt	00:41:33.890 --> 00:41:42.020	Or if you have two signals we can work on left and then right channel if it has been separately given and then we will be looping back.
47.srt	00:41:42.430 --> 00:41:49.060	So, now, what we will do is if you are doing it for the first time this code it will take little time basically.
47.srt	00:41:49.350 --> 00:41:56.730	So, since I have already compiled and then done the thing directly I can go and then do the debugging part of it.
47.srt	00:41:57.300 --> 00:42:01.340	So, you will be seeing that it has build has finished.
47.srt	00:42:01.930 --> 00:42:08.170	So, the memory map what you are seeing it how it is getting mapped into the boards memory.
47.srt	00:42:08.630 --> 00:42:13.080	And, then the code has to go and then load it on to the board.
47.srt	00:42:13.810 --> 00:42:21.840	So, you will be seeing that the pointer you will be seeing in the C code.
47.srt	00:42:21.840 --> 00:42:29.670	So, it has come to the main function where it is pointing to our program counter basically.
47.srt	00:42:31.250 --> 00:42:36.860	So, it is now ready for the debugging is happened.
47.srt	00:42:37.450 --> 00:42:41.320	So, I can.
47.srt	00:42:41.570 --> 00:42:43.080	this memory map.
47.srt	00:42:43.610 --> 00:42:47.800	So, you will be seeing so that your debug is going to be seen ok.
47.srt	00:42:48.220 --> 00:42:52.680	So, it has entered the main function here in the main.
47.srt	00:42:53.080 --> 00:43:02.630	So, which is what we call in its you can see the code both in C as well as mixed assembly I will show you in a while.
47.srt	00:43:02.630 --> 00:43:14.100	And this is where the entry point for the board basically C underscore int 00 this is the input what entry point.
47.srt	00:43:14.320 --> 00:43:18.200	it has reached the thing that is what it shows the thing.
47.srt	00:43:19.030 --> 00:43:31.160	And then these are the what it says is we have used the ECDIS 110 USB debug cable for connecting it to the board.
47.srt	00:43:31.710 --> 00:43:37.880	So, we will run and then I will you will be hearing the synthesized output from the board.
47.srt	00:43:40.330 --> 00:43:41.040	Now it's got a.
47.srt	00:43:42.770 --> 00:43:43.480	Now it's got a.
47.srt	00:43:45.210 --> 00:43:45.900	Now it's got a.
47.srt	00:43:47.690 --> 00:44:01.550	So, as you can hear that I am going to close my debugger as I did in the other example still the code is running on the board as you can hear it.
47.srt	00:44:01.830 --> 00:44:05.740	So, unless I reset it will be continuously running.
47.srt	00:44:05.740 --> 00:44:15.930	So, I can disconnect from the debugger as you heard the thing I can disconnect from my this thing system and it can run directly.
47.srt	00:44:16.160 --> 00:44:20.120	as an input and output this thing system unit.
47.srt	00:44:20.680 --> 00:44:28.550	So, we will see with other example how it is going to be depicted that is input voice signal.
47.srt	00:44:28.550 --> 00:44:39.020	Here I will take out from the this thing comment and then I will comment the other one.
47.srt	00:44:39.020 --> 00:44:44.920	So, it this it can be both in C and then C plus plus.
47.srt	00:44:48.750 --> 00:45:00.810	So, once I have done the modification I had to do this is going to do debug and then say any errors are present since I do not have any errors in the things.
47.srt	00:45:00.810 --> 00:45:04.870	So, what I will be doing is I can directly go into the debug mode.
47.srt	00:45:06.070 --> 00:45:19.780	So, it will debug and then as you can see there are warnings the section which was specified it says it has not taken the things.
47.srt	00:45:19.780 --> 00:45:22.030	So, some dot h files have to be given.
47.srt	00:45:22.610 --> 00:45:33.860	So, but still it is running so, we sometimes if it does not run some of the warnings you cannot ignore you have to check with the thing.
47.srt	00:45:34.810 --> 00:45:44.540	As you can see that it has become a male voice from the female voice.
47.srt	00:45:44.540 --> 00:45:53.660	So, the last one we will see whether you would be able to hear from the board or not.
47.srt	00:45:58.420 --> 00:46:09.870	I will be saving it and then I can give.
47.srt	00:46:09.950 --> 00:46:22.680	So, to give different this thing we can create a gel file and from there we can provide different sections so that while running itself I can modify it.
47.srt	00:46:22.680 --> 00:46:26.280	Otherwise I have to do debug and then.
47.srt	00:46:26.530 --> 00:46:27.490	the thing ok.
47.srt	00:46:27.490 --> 00:46:58.849	So, here it is you are able to at least hear the female voice, but for the good one of the voice almost getting I think swallowed or something it is coming out as a god in name ok. We have seen the LPC speech coding basically both in MATLAB and then.
47.srt	00:46:59.400 --> 00:47:02.639	in code composer studio using 6748 board.
47.srt	00:47:02.679 --> 00:47:17.670	So, we will see other examples of scrambler echo and equalizer in the code using code composer studio on the 6748 board in the next class.
47.srt	00:47:18.069 --> 00:47:18.519	Thank you.
46.srt	00:00:00.340 --> 00:00:26.420	Namaste, welcome back to real time digital signal processing course.
46.srt	00:00:26.710 --> 00:00:30.859	So, we are discussing about the speech coding, why do we need it.
46.srt	00:00:31.229 --> 00:00:34.829	So, today we are going to continue with the speech coding.
46.srt	00:00:35.229 --> 00:00:48.629	So, in the last class we discussed about the OCODERs and then how the GSM model look like and then today we will look at our this thing code excited linear predictor encoder.
46.srt	00:00:48.799 --> 00:00:58.289	So, how the graphical representation of kelp encoder is look like.
46.srt	00:00:58.570 --> 00:01:01.320	So, what we have is a speech input.
46.srt	00:01:01.809 --> 00:01:05.819	And, then here it is error weighting and then minimization.
46.srt	00:01:06.370 --> 00:01:18.859	So, that is whatever error which is going to be generated from this is going to be try to minimize this error from the thing.
46.srt	00:01:19.319 --> 00:01:28.650	And, this minimized error is fed into our excitation code book and the same error minimized error is going to be transmitted.
46.srt	00:01:28.650 --> 00:01:29.239	So, in this case.
46.srt	00:01:33.540 --> 00:01:40.370	And here is our this thing speech input from the linear predictive filter.
46.srt	00:01:40.770 --> 00:01:46.049	So, which is going to be subtracted from the thing and you will be generating the error.
46.srt	00:01:46.609 --> 00:01:49.230	So, which is going to be minimized ok.
46.srt	00:01:49.500 --> 00:02:00.290	So, the same input is going to go into our coefficient determination basically and then even the gain determination is going to happen from the speech input.
46.srt	00:02:00.840 --> 00:02:03.760	Then these are the LPC coefficients.
46.srt	00:02:04.290 --> 00:02:25.620	which will be going into our linear predictive filter and will be for this the input is going to come from the gain and this filter output is fed as the subtractive for our this to generate minimize our error.
46.srt	00:02:26.300 --> 00:02:34.629	Then our to the coding thing what we have this LPC coefficients goes as the input our mixer.
46.srt	00:02:35.390 --> 00:02:59.310	And, even the gain factor is given to this mixer and then all these three get mixed that is error here earlier only normal error was given here we are going to do the minimization of it that is fed into our mixer mix it and then this is our kelp output.
46.srt	00:02:59.900 --> 00:03:05.159	So, that is how code excited linear predictor is going to work.
46.srt	00:03:06.260 --> 00:03:13.640	So, coming with the this thing coders that is general kelp architecture looks like this.
46.srt	00:03:13.730 --> 00:03:20.160	So, what we will have is encoder is the one from the sender side.
46.srt	00:03:20.160 --> 00:03:35.060	So, we have the code book and we will be feeding in to this the perspital error is what is coming from the weighting filter and based on it you will be calculating your gain is your output.
46.srt	00:03:40.310 --> 00:03:49.860	And, then what we have is a fine structure that is the pitch what is calculated whether it is voiced or unvoiced.
46.srt	00:03:50.230 --> 00:03:57.030	So, we will be taking in the unvoiced case pitch and then we will be feeding it to the long delay correlation filter.
46.srt	00:03:57.620 --> 00:04:10.360	So, this is the pitch lag what the parameter which is coming out and from the code book you will be having the optimum code word what you will be generating and from the gain you will be putting it to the gain.
46.srt	00:04:10.900 --> 00:04:24.980	And, then the next one is our spectral envelope basically how we are going to look at it that is short delay correlation filter what we are going to provide the thing.
46.srt	00:04:25.410 --> 00:04:29.370	So, to get our LPC parameters.
46.srt	00:04:29.780 --> 00:04:43.380	So, these are the four that is even the code word and then the gain pitch lag and then LPC parameters are passed through this is our channel as you can see the thing.
46.srt	00:04:43.840 --> 00:04:46.850	transmission channel which goes through the channel.
46.srt	00:04:47.410 --> 00:04:55.350	So, the other one is we have the reference of the original speech and what is calculated.
46.srt	00:04:55.750 --> 00:04:58.420	So, we will be doing the subtraction of the thing.
46.srt	00:04:58.840 --> 00:05:14.260	So, we will have the objective error which is going to be fed into our waiting block and then we will be calculating the perpetual error and then we will be feeding it into our code book.
46.srt	00:05:14.580 --> 00:05:16.510	So, what happens at the decoder?
46.srt	00:05:17.050 --> 00:05:22.140	So, we have the optimum excitation which has come from the encoder.
46.srt	00:05:22.140 --> 00:05:48.340	So, we will be providing the gain basically whatever decided at the encoder also and we will be doing this pitch this one pitch synthesis filter what we are going to extract our pitch lag and we have the LPC synthesis filter there it was LPC analysis filter we will use the synthesis filter here.
46.srt	00:05:49.190 --> 00:05:55.120	And, then combining the thing so, we will be creating our output speech.
46.srt	00:05:55.470 --> 00:06:12.730	So, you may be wondering how these are the things is going to happen in the lab we will see that how these can be generated and then we will be as an application LPC coding will take it up and then how it creates the synthetic speech in the lab.
46.srt	00:06:12.900 --> 00:06:17.420	Now, what is it?
46.srt	00:06:20.550 --> 00:06:48.870	So, what it says is NATDMA IS 54 speech coder that is if we are using the sub band code book approach termed vector sum excited LPC that is we self see what it is going to be named in that case what is the thing is going to happen this is our I that is code book 1 and then this is a Y1 is the output.
46.srt	00:06:51.680 --> 00:07:14.690	So, what we have is the Y1 is goes as input and then comes out and then we are having a code book what is input to that is part of L2 L actually and this is our Y2 and then gain whatever you are putting into the think system these are the gains Y1 Y2 Y3 are the gains and then this is the code book 3.
46.srt	00:07:15.110 --> 00:07:19.540	So, you have the H parameter and beta is the gain for this.
46.srt	00:07:19.950 --> 00:07:23.590	So, these are the filter coefficients what it are going to be generated.
46.srt	00:07:24.040 --> 00:07:40.360	Then, you will be seeing that all the from the sub band you will be adding them up and then going to give it as LPC synthesis filter it is going to be passed and this are the output.
46.srt	00:07:40.750 --> 00:07:51.110	So, the filter coefficients which are been calculated will be going into our output for combination.
46.srt	00:07:51.790 --> 00:07:55.230	So, how we are going to evaluate the speech coders?
46.srt	00:07:55.850 --> 00:08:13.540	So, that these are the basis one is qualitative comparison what we are going to do it that is based on subjective procedures in ITU what it says is RECP 830 that is in the page 830 it has been specified.
46.srt	00:08:13.540 --> 00:08:18.190	So, based on it one has to do the qualitative comparison.
46.srt	00:08:18.390 --> 00:08:26.670	That is subjective is you will be putting various subjects basically.
46.srt	00:08:28.270 --> 00:08:44.770	To hear these voices and that as we said mean opinion score is going to be taken from each one and then say that how much has said that it is quality is good or bad or based on it what we have to calculate.
46.srt	00:08:45.060 --> 00:08:57.850	As we can see that mean opinion score how it is going to be graded if somebody gives excellent which has the value 5 and 4 for the good.
46.srt	00:08:58.230 --> 00:09:02.590	And, fair has 3 and 2 is poor and then 1 is bad.
46.srt	00:09:03.060 --> 00:09:18.610	This is the MOS one is going to have the thing based on it you would be subjecting different subjects to assess the quality of the speech based on this parameters.
46.srt	00:09:19.230 --> 00:09:27.960	So, the other one is major procedures that are going to be followed which are the ones that is absolute category rating.
46.srt	00:09:28.690 --> 00:09:37.600	That is subjects listen to samples and rank them on an absolute scale result is a mean opinion score.
46.srt	00:09:37.629 --> 00:09:46.050	That is in this case only they listen to the output and then qualitatively they compare the thing.
46.srt	00:09:46.460 --> 00:09:58.379	But here they have to do the absolute basically that is here the original and the synthetic speech what is being generated both of them they have to be able to.
46.srt	00:09:58.820 --> 00:10:04.860	absolutely compare and then give the mean opinion square sorry mean opinion score for that.
46.srt	00:10:05.360 --> 00:10:12.850	So, that is what it says is comparison of mean opinion score that is CMOS what it says.
46.srt	00:10:13.259 --> 00:10:29.730	So, it is much better has the value 3 better is 2 slightly better is 1 about the same is going to have 0 and slightly worse is minus 1 and worse you will be taking it as minus 2 and much worse is minus 3.
46.srt	00:10:30.139 --> 00:10:32.240	So, these are the scores basically.
46.srt	00:10:32.639 --> 00:10:55.389	So, what does it how the comparison category rating is going to be generated based on this that is subject listen to coded samples and original uncoded sample PCM or analog basically any one of them because we know that PCM is very good that two are compared on a relative scale.
46.srt	00:10:56.080 --> 00:11:00.080	So, result is a comparison mean opinion score which is based on this.
46.srt	00:11:01.780 --> 00:11:03.500	what the subjects will be giving.
46.srt	00:11:03.879 --> 00:11:13.830	So, these are the procedures one will be following in comparison or evaluating speech coders.
46.srt	00:11:14.530 --> 00:11:19.470	So, further how it is going to be evaluated.
46.srt	00:11:20.090 --> 00:11:33.020	So, based on mean opinion score for clear channel environment that we call it as no errors in the channel, result vary a little with language and speaker gender.
46.srt	00:11:33.629 --> 00:11:38.670	So, as we know the accents from one person to the other one it is going to vary.
46.srt	00:11:39.100 --> 00:11:42.870	So, based on it one has to do that analysis.
46.srt	00:11:43.190 --> 00:12:00.770	So, you can see that the standard what it is given whether PCM standard or CT2 or DECT or TDMA or GSM or Q-KELP quantized KELP what we call it and then this thing LPC coding.
46.srt	00:12:00.770 --> 00:12:03.210	So, quantized KELP you will be seeing that hybrid.
46.srt	00:12:04.480 --> 00:12:18.400	RALPC it can use or hybrid kelp what it can use and then LPC will be using the vocoder technology and we saw that the ITUG.729 is going to use hybrid kelp.
46.srt	00:12:18.480 --> 00:12:22.950	So, what are the bit rates for these standards basically.
46.srt	00:12:23.660 --> 00:12:25.190	So, we know that PCM is the waveform based.
46.srt	00:12:25.190 --> 00:12:29.850	So, which is going to have 64 kilobits per second.
46.srt	00:12:29.990 --> 00:12:31.300	So, what was the that is.
46.srt	00:12:35.720 --> 00:12:41.050	MO is value which is given is 4.3 for this.
46.srt	00:12:41.200 --> 00:12:53.000	Whereas, our adaptive which is going to use differential PCM which we said it is 32 kilobit per second.
46.srt	00:12:53.000 --> 00:12:57.460	So, the mean opinion score you can see is 4.1.
46.srt	00:12:57.670 --> 00:13:05.840	Whereas, it says DECT is the ADPCM what it is going to use at 32 kilobits per second.
46.srt	00:13:07.140 --> 00:13:19.440	So, this also has 4.1 whereas, our TDMA technology that is hybrid V cell PCM you can see that the bit rate is 8 kilobits per second.
46.srt	00:13:19.440 --> 00:13:22.900	So, which has MOS of 3.
46.srt	00:13:22.900 --> 00:13:29.810	So, whether you can as you will be seeing that the transmission rate is very low in this.
46.srt	00:13:29.870 --> 00:13:35.820	So, whether with this degradation you can accept this.
46.srt	00:13:40.600 --> 00:13:43.940	where in your application not much is required.
46.srt	00:13:43.940 --> 00:13:47.990	So, you can use it so that you can save on the channel basically.
46.srt	00:13:48.820 --> 00:14:02.370	Whereas, GSM as you can see which is the lowest what you can see 1.3 kilobits per second which is going to use our hybrid model that is REL PCM basically.
46.srt	00:14:02.450 --> 00:14:07.230	So, which gives the M O S score that mean opinion score of 3.54.
46.srt	00:14:11.010 --> 00:14:25.280	So, that is the thing GSM is much more popular and then quantized kelp you will be seeing hybrid basically kelp what it is going to use which is at 14.4 kilobits per second.
46.srt	00:14:25.280 --> 00:14:30.590	So, the mean opinion score you can see it is varying between 3.4 to 4.0.
46.srt	00:14:30.740 --> 00:14:39.340	So, it has a better quality and then hybrid kelp which runs at 9.6 kilobits per second.
46.srt	00:14:41.620 --> 00:14:45.360	which has at the minimum that is what it is shown at 3.4.
46.srt	00:14:45.360 --> 00:14:53.730	And our LPC which uses a vocoder speech coding techniques which has 2.4 kilobit per second.
46.srt	00:14:53.830 --> 00:14:59.790	So, the you can see very low mean opinion score what it has.
46.srt	00:14:59.790 --> 00:15:06.350	And G dot 729 which uses the hybrid kelp which is at 8 kilobits per second.
46.srt	00:15:06.420 --> 00:15:08.830	So, which has 3.9 score.
46.srt	00:15:12.750 --> 00:15:20.780	compared to our this thing what is it TDMA hybrid which has 3 at 8 kilobit per second.
46.srt	00:15:21.220 --> 00:15:30.840	So, depending on the thing so, you can select that is as you can see that even the gender is going to matter.
46.srt	00:15:31.330 --> 00:15:41.940	So, if it is a male voice and female voice so, we will see in the lab how it is going to vary and then you can decide on it what.
46.srt	00:15:42.980 --> 00:15:46.070	you want to select for your coding techniques.
46.srt	00:15:46.980 --> 00:15:54.940	So, continuing on the evaluation types of environments recommended for testing coder quality.
46.srt	00:15:55.970 --> 00:16:03.380	So, on what should be our environment on which you will be testing this quality.
46.srt	00:16:04.010 --> 00:16:08.330	It says clean channel no background noise.
46.srt	00:16:08.930 --> 00:16:14.460	So, you have to provide this so that you can evaluate it.
46.srt	00:16:14.820 --> 00:16:20.650	The other one is vehicle that is emulate car background noise.
46.srt	00:16:21.180 --> 00:16:35.820	So, if you are using the thing, so you will be seeing that you have to emulate the car background noise and then you have to hear these speeches for giving mean opinion score.
46.srt	00:16:36.430 --> 00:16:43.500	The other one is if you are considering the street then emulate pedestrian environment.
46.srt	00:16:43.960 --> 00:16:47.440	So, when the pedestrian is walking on the street.
46.srt	00:16:47.820 --> 00:16:49.640	what are the noises will be present.
46.srt	00:16:49.640 --> 00:16:55.790	So, you will be using that to get the evaluation from the subjects.
46.srt	00:16:56.460 --> 00:17:08.410	The other one what it says is HOT that is emulate background noise in office environment that is voice band interference what you are going to do that.
46.srt	00:17:09.340 --> 00:17:21.320	So, consider environment above for cases of what is it perfect channel no transmission errors random channel errors what you can consider.
46.srt	00:17:21.789 --> 00:17:35.529	And, bursty channel errors so, when you are want to check the channel errors which you have want to consider and then see what will be the mean opinion score given by the subjects.
46.srt	00:17:36.059 --> 00:17:54.460	So, you may consider repeated encoding or decoding that is you will be seeing that mobile to mobile call one you can have it and then say that what is the because you are putting it in the clean environment and then simmers that is emulating these things.
46.srt	00:17:54.909 --> 00:18:01.339	and then you are asking the person to give his mean opinion score you are not within the chamber.
46.srt	00:18:01.659 --> 00:18:02.669	So, you are outside.
46.srt	00:18:02.720 --> 00:18:10.579	So, then you will be having the finishing the thing you can ask them to give the score for that ok.
46.srt	00:18:11.049 --> 00:18:15.190	So, how you are going to do the codex selection?
46.srt	00:18:16.029 --> 00:18:25.859	So, you we know that for cellular need to consider basically quality, complexity, delay and compression rate.
46.srt	00:18:26.359 --> 00:18:37.039	So, these are the standards which are available ITU that is international for telecommunication standards.
46.srt	00:18:37.690 --> 00:18:41.309	G dot 711 is 64 kilobits per second.
46.srt	00:18:41.779 --> 00:18:51.910	So, in this case coding delay is going to be 0 and even the decoding delay is 0, but we say the complexity of this is low.
46.srt	00:18:56.569 --> 00:19:15.269	Whereas, G dot 729 which has 8 kilo bits per second and the delay is 15 millisecond and then decoding delay is 7.5 millisecond sorry coding delay is 15 milliseconds and decoding delay is 7.5 millisecond and the complexity of the code is medium in this case.
46.srt	00:19:15.269 --> 00:19:21.480	If you use G dot 723 the versions are A and B what you have it.
46.srt	00:19:21.480 --> 00:19:28.529	So, that is it can run at 6.4 this thing kilo bits per second or 5.3 kilo bits per second.
46.srt	00:19:30.279 --> 00:19:39.529	Then the coding delay is 35.5 millisecond and decoding delay is 18.75 millisecond and the complexity is high.
46.srt	00:19:39.529 --> 00:19:51.359	So, one has to accept which you want to have the this thing coding techniques you want to use in your work basically.
46.srt	00:19:52.189 --> 00:20:01.059	So, if you do not want to have any delay then you can use this G dot 7 11.
46.srt	00:20:03.429 --> 00:20:11.979	So, we know that what are the 3G standards specified that is two competing 3G standards.
46.srt	00:20:12.409 --> 00:20:16.799	Both standards use multimode kelp vocoders in them.
46.srt	00:20:17.439 --> 00:20:27.099	So, that is 3GPP that is CDMA 2000 and 3GPP UMTC what we have the thing.
46.srt	00:20:27.529 --> 00:20:32.919	So, here it is multimode rate set in this case.
46.srt	00:20:33.199 --> 00:20:38.049	Here it is AMR NB multirate what it will be using it.
46.srt	00:20:38.559 --> 00:20:49.699	So, here it is going to be variable bitrate O coder and source control of bitrate and channel coding treats all bits in this case equally.
46.srt	00:20:50.129 --> 00:21:05.029	Whereas, you will be seeing that it is the fixed rate O coder what it uses and voice activity detection is going to be discontinuous transmission network control of coder rate what we are going to consider.
46.srt	00:21:05.529 --> 00:21:14.259	and then Taylor's channel coding to speech coder what the standard uses in the 3G.
46.srt	00:21:15.169 --> 00:21:22.519	So, what is it because as you know that wherever silence is required.
46.srt	00:21:22.899 --> 00:21:31.579	So, we can use that and then you have we have to put that silence also in our speech basically.
46.srt	00:21:32.209 --> 00:21:35.459	So, if the silence is not required.
46.srt	00:21:36.209 --> 00:21:40.309	compressed we know that it will be taking more number of bits.
46.srt	00:21:40.729 --> 00:21:52.029	So, much of a conversation is silence what it says is according to the standard approximately 40 percent is going to be the silence zone.
46.srt	00:21:52.569 --> 00:21:59.039	So, we need not have to transmit that, but it has to be incorporated in the receiving end.
46.srt	00:21:59.589 --> 00:22:08.369	So, what it says is it is going to do voice activity detector VAD that is hardware to detect silence period quickly.
46.srt	00:22:08.899 --> 00:22:11.799	So, you are building the thing in the hardware.
46.srt	00:22:12.319 --> 00:22:19.689	So, we are going to use variable bit rate coders basically to reduce bit rate when silence.
46.srt	00:22:19.909 --> 00:22:27.869	So, I need not because I need not have to transmit this and say only that it is from this to this the silence zone.
46.srt	00:22:28.429 --> 00:22:42.049	So, how we are going to take care of the discontinuous transmission which is called DTX ok. Stop transmitting frames and second minimal number of frames to keep connection.
46.srt	00:22:42.339 --> 00:22:42.669	up.
46.srt	00:22:43.579 --> 00:22:53.579	And what the other one is comfort noise generator that is CNG that is synthesized background noise avoids did you hang up.
46.srt	00:22:54.419 --> 00:23:05.639	So, that is how you will be having the noise generator and a random noise or reproduce speakers ambient background to cancel it out.
46.srt	00:23:06.019 --> 00:23:14.169	So, for example, in the GSM codec and popular voice over IP which uses G dot 723.
46.srt	00:23:14.609 --> 00:23:32.089	1 codec has what is it all the 3 of them that is our voice activity detector and then discontinuous transmission and the comfort noise generator which have been combined and then supports the thing.
46.srt	00:23:32.859 --> 00:23:41.759	So, in the CDMA 1 and then CDMA 2000 codec use variable bit rate approach.
46.srt	00:23:42.399 --> 00:23:44.559	So, that is what we will be using it.
46.srt	00:23:44.859 --> 00:23:48.619	So, you can see that how the silence compression can be done.
46.srt	00:23:49.119 --> 00:23:54.349	This is what you are seeing the A 1 this is the speech signal what we have it.
46.srt	00:23:54.700 --> 00:23:59.440	So, you are seeing the here are voiced or unvoiced what we have it.
46.srt	00:23:59.859 --> 00:24:02.210	In between you will be seeing the silence zone.
46.srt	00:24:02.240 --> 00:24:07.740	Here also it is a maximum silence zone what you are incorporating after that it is the silence zone.
46.srt	00:24:08.440 --> 00:24:15.200	And then how this thing B 1 is going to look at it that is variable rate.
46.srt	00:24:15.870 --> 00:24:17.650	coding what you will be doing it.
46.srt	00:24:18.059 --> 00:24:27.650	So, you need not have to you can transmit as 0 here wherever the silence zone is there and you can see here also.
46.srt	00:24:28.170 --> 00:24:48.490	And then the other places what you can say that it is that is a variable rate basically that is b 1 which is number of bits are going to be very less for these places and then when there is a signal you will be using the high bit rate.
46.srt	00:24:49.110 --> 00:24:54.800	So, that you can get the value of the output.
46.srt	00:24:54.890 --> 00:24:57.600	So, that is how you will be having the variable rate there.
46.srt	00:24:58.280 --> 00:25:09.060	So, that you can avoid the silence zone with minimal bits and how the pulse is going to be generated that is kilobits per second.
46.srt	00:25:09.460 --> 00:25:17.280	So, you will be seeing that this is a peak after that because this is a silence zone as you can see maximum silence what we have it.
46.srt	00:25:17.730 --> 00:25:18.610	So, which.
46.srt	00:25:18.970 --> 00:25:25.180	goes down and then again you what you will be having it and then down.
46.srt	00:25:25.509 --> 00:25:37.000	So, this is fixed rate with what you have is this thing VAD and then DTX incorporated in the sample speed signal how it is going to go about it.
46.srt	00:25:37.000 --> 00:25:52.330	So, the next one is what we have is the voice coding that is basic voice coding approaches as we have seen that it can be waveform or vocoders or hybrid vocoders what you can use it.
46.srt	00:25:52.779 --> 00:25:56.120	So, how we are going to do evaluation of vocoder quality.
46.srt	00:25:56.549 --> 00:26:16.630	So, we have to see that code book based vocoders use in new technology and we know that in 3 GBP and then ITU recently standardized a that is AMR wide band KELP basically and then input in this case is 50 hertz to 7000 hertz.
46.srt	00:26:16.720 --> 00:26:29.180	So, we are moving from narrow band to wide band signal as you can see rather than 300 to 3400 this was the telephony standard.
46.srt	00:26:29.609 --> 00:26:36.180	and this is the new standard what we have it in 16 kilohertz range of current systems.
46.srt	00:26:36.210 --> 00:26:42.809	So, more natural quality speech that is slightly higher bit rate what we have to account for.
46.srt	00:26:43.299 --> 00:26:47.319	So, this covers our speech coding.
46.srt	00:26:47.720 --> 00:26:53.119	So, the application of speech coding what we will look in the next class.
46.srt	00:26:53.569 --> 00:26:56.779	Happy learning and thank you for listening to this lecture.
52.srt	00:00:01.219 --> 00:00:25.589	Welcome back to real time digital signal processing course.
52.srt	00:00:25.890 --> 00:00:29.609	So in the last class we are discussing about the discrete cosine transform.
52.srt	00:00:29.609 --> 00:00:30.750	So we will continue.
52.srt	00:00:31.239 --> 00:00:33.679	Today also on the discrete cosine transform.
52.srt	00:00:34.140 --> 00:00:52.230	So, in the DCT 3 we covered little on quantization and then how we are going to have the quantization matrix 2 that is eliminate the lower part of the coefficients that is AC coefficients in DCT matrix.
52.srt	00:00:52.689 --> 00:01:02.159	And later on how we did the run length coding and then in the process of recovering we will be using the Huffman coding.
52.srt	00:01:02.500 --> 00:01:05.109	These are the things what we considered in the last class.
52.srt	00:01:05.420 --> 00:01:11.359	So, today we will see how we are going to consider the DCT implementation in.
52.srt	00:01:11.799 --> 00:01:17.829	So, one of the application we said it is in JPEG applications.
52.srt	00:01:18.159 --> 00:01:41.939	So, that is in the analysis program that will be running on the that is our UW parallel computing labs cluster has the thing and then potential uses are in the in this lab what they use is for the application is in the agriculture that is webcam is go images can be analyzed for fruit.
52.srt	00:01:42.369 --> 00:01:49.789	that is ready to be harvested and workers can then save time by only going to areas that have fruit.
52.srt	00:01:50.200 --> 00:02:01.079	This is one of the examples or application what it is given in the web basically and the other application what they use it is in the parking.
52.srt	00:02:01.500 --> 00:02:02.650	So what is that?
52.srt	00:02:02.679 --> 00:02:11.960	It is webcams can be placed in a parking garage and their images can be used to identify areas with open spaces.
52.srt	00:02:12.370 --> 00:02:22.050	So this is one of the example in the parking lot you can identify if there is any empty space then you can go and park your vehicles there.
52.srt	00:02:57.110 --> 00:03:01.969	The other one is the web search what is that images can be found over the web that are similar to an input image and images can be analyzed then stored as keywords to be used in searches so all we usually type the basically for web searching and if you are interested in some part of the images if you have liked the thing so you want to see that similar ones then you can keep that as a reference and then you can find out how many of them are available.
52.srt	00:03:02.039 --> 00:03:13.170	As an example in some of the applications if you want to run your machine learning algorithm you need lot of images of that variety.
52.srt	00:03:13.170 --> 00:03:22.060	So, it is in that case it helps us to give up search for the typical those images.
52.srt	00:03:22.060 --> 00:03:26.020	So, as you can see in the agriculture.
52.srt	00:03:30.380 --> 00:03:37.969	So, that is how you are going to sort the image according to amount of red as compared to a baseline photo.
52.srt	00:03:38.560 --> 00:03:43.840	So, you will be seeing that whether you want to segregate them.
52.srt	00:03:43.840 --> 00:03:53.430	So, that is based on the red if it is intensity is more you want to have it as first and later on the next one and then which has the minimum.
52.srt	00:03:53.689 --> 00:03:55.070	So, this is one of it.
52.srt	00:03:55.070 --> 00:04:00.439	So, this will show that some of the ripe fruits if you want to go and then pluck it.
52.srt	00:04:00.500 --> 00:04:04.350	So, you can concentrate on these area to pluck them.
52.srt	00:04:04.840 --> 00:04:12.180	So, little whatever later on you know that how long it will take for this tree to get more ripened one.
52.srt	00:04:13.379 --> 00:04:18.000	And, then here you are not seeing any red in the thing.
52.srt	00:04:18.000 --> 00:04:20.959	So, you know that fruits are not ready in the thing.
52.srt	00:04:21.370 --> 00:04:31.300	So, you can predict also and then see only those places what you can go and then pluck it so that you will be saving some of the time of farmers.
52.srt	00:04:31.389 --> 00:04:39.600	So, the we know that this is how we have introduced our DCT that is discrete cosine transform.
52.srt	00:04:40.129 --> 00:04:43.620	So, we know that it is going to store the cosine waves.
52.srt	00:04:43.939 --> 00:04:49.599	them to a set of coefficients what we have given the values here.
52.srt	00:04:50.180 --> 00:04:53.789	And we know that JPEG uses an 8 by 8 DCT.
52.srt	00:04:53.789 --> 00:05:04.459	So this thing what we will call it as 8 by 8 reference image basically basis function what we call it.
52.srt	00:05:04.709 --> 00:05:14.500	So we will be having 8 by 8 basis function to find out our we will call it as coefficients.
52.srt	00:05:15.769 --> 00:05:19.479	So, visual band as a wave what it is shown here.
52.srt	00:05:19.779 --> 00:05:27.089	So, this is from Wikipedia source what you will you can go for more detailed one in that to see it.
52.srt	00:05:27.589 --> 00:05:30.029	So, now coming to the human vision.
52.srt	00:05:30.449 --> 00:05:39.619	So, what is it we said already in the previous class the better detect differences in light and dark than in color images.
52.srt	00:05:40.039 --> 00:05:42.769	As you have this is a RGB image.
52.srt	00:05:43.049 --> 00:05:45.499	So, we have a red green and then blue.
52.srt	00:05:45.809 --> 00:05:50.229	So, if you bifurcate them as luminance as we discussed in the last class.
52.srt	00:05:50.229 --> 00:05:51.639	So, you will be seeing that you are.
52.srt	00:05:52.069 --> 00:06:01.629	able to identify the person in that is Y component and then chrominance that is Cb and Cr they are little faded.
52.srt	00:06:01.629 --> 00:06:06.899	So what we said was we can do the compression in this domain.
52.srt	00:06:07.329 --> 00:06:17.769	So that is what it is given luminance and Cb and Cr are the chrominance values and can be sub sampled first basically.
52.srt	00:06:17.769 --> 00:06:19.769	So what is the sub sampling we are going to do it.
52.srt	00:06:19.769 --> 00:06:25.339	So we are going to keep the chrominance Y0, Y1, Y2, Y3 as it is that is.
52.srt	00:06:26.599 --> 00:06:30.949	And, then we can do 2 by 2 that is a chroma subsampling.
52.srt	00:06:30.949 --> 00:06:39.609	So, how we are going to do average is Cp and Cn value to save space basically.
52.srt	00:06:40.039 --> 00:06:50.049	Common sampling ratios are 2 by 1 in the horizontal or we can have 2 by 2 both horizontal and then vertical ok.
52.srt	00:06:50.519 --> 00:06:56.369	So, what we say is cheap cameras that is webcams mostly use this.
52.srt	00:06:56.939 --> 00:07:00.989	2 by 2 standard sub sampling basically.
52.srt	00:07:00.989 --> 00:07:01.639	So, these are the CBCR.
52.srt	00:07:02.039 --> 00:07:06.809	So, you will be sub sampling to either 2 by 1 or 2 by 2.
52.srt	00:07:07.189 --> 00:07:13.779	So, as it says webcams convert it into 2 by 2 for chip cameras.
52.srt	00:07:14.069 --> 00:07:19.679	So, what is that that is what it says is JPEG minimum coded unit.
52.srt	00:07:20.119 --> 00:07:25.899	So, this is the smallest amount of data that can be coded in a given JPEG.
52.srt	00:07:26.419 --> 00:07:30.739	So, how do you say that that is size is going to depend on sub sampling.
52.srt	00:07:31.179 --> 00:07:32.999	So, if we are doing 2 by 1.
52.srt	00:07:33.209 --> 00:07:38.939	then it is 16 pixel by 8 pixel what has to be stored.
52.srt	00:07:39.569 --> 00:07:46.659	So if you are considering 2 by 2 then it is going to be 16 pixel by 16 pixel what you will be taking it.
52.srt	00:07:46.659 --> 00:07:54.279	So this is a image taken from NASA what it is projected to show that how the subsampling can be done.
52.srt	00:07:54.779 --> 00:08:01.439	So to give you a JPEG the steps that are involved in summary.
52.srt	00:08:01.809 --> 00:08:05.079	So first what we do is a color space conversion.
52.srt	00:08:05.539 --> 00:08:20.049	So, from RGB we will be converting it into luminance, chrominance and the YC, BCR basically and then we will be doing this chrominance subsampling is going to happen.
52.srt	00:08:20.629 --> 00:08:23.159	Then later on we are going to do the DCT.
52.srt	00:08:23.479 --> 00:08:31.929	So, we know that just the DCT is not going to give us the reduced size of the image.
52.srt	00:08:32.389 --> 00:08:34.829	Later on we will go for the quantization.
52.srt	00:08:35.079 --> 00:08:45.259	So, as we said in the previous class quantization we can use P is equal to 1, 2 or 4 depending on how many values you want to store it.
52.srt	00:08:45.569 --> 00:08:50.209	So, that is decides the quantization, how much you want to have it.
52.srt	00:08:50.469 --> 00:08:52.249	One has to be careful that.
52.srt	00:08:52.249 --> 00:08:52.889	So, that is the quantization.
52.srt	00:08:53.329 --> 00:08:53.999	near the edges.
52.srt	00:08:54.029 --> 00:08:57.889	So, we may lose the information.
52.srt	00:08:58.309 --> 00:09:03.319	So, one has to look into that when you are doing the quantization.
52.srt	00:09:03.819 --> 00:09:11.549	Then once the quantization is done, so we will be in the DCT we will be going for the run length coding.
52.srt	00:09:11.549 --> 00:09:15.299	In the IDCT because we have to reconstruct the image.
52.srt	00:09:15.329 --> 00:09:20.999	So, we will go for the Huffman coding what we had discussed in the last classes.
52.srt	00:09:24.219 --> 00:09:44.759	And then the reverse process is going to happen that is whatever the quantized signal has to be re quantized and then IDCT what we will be doing it and then we will go for the chrominance subsampling in the reverse direction and then we will convert from YCRBR to RGB image and then we will be displaying it.
52.srt	00:09:45.109 --> 00:09:49.159	So this is how JPEG in summary looks like.
52.srt	00:09:49.589 --> 00:09:54.049	So now we will see that how we are going to implement this in hardware.
52.srt	00:09:54.709 --> 00:10:03.599	So to give again a flavor of what is DCT and IDCT the code has been given that is one dimensional what we are considering it.
52.srt	00:10:03.999 --> 00:10:10.049	So we have E of k into n is equal to 0 to n minus 1 X of n into cos.
52.srt	00:10:10.549 --> 00:10:23.239	2n plus 1 pi k divided by 2n, n is we can choose it as 8 by 8 or it will be the size of the image what we are considering.
52.srt	00:10:23.849 --> 00:10:35.499	So, if it is we are using it in the direct DCT form, k will be going 0 to n minus 1 that is our image size n by n what we have considered here.
52.srt	00:10:35.969 --> 00:10:41.409	So, in the reverse process IDCT we consider 2 by n.
52.srt	00:10:41.809 --> 00:10:52.069	instead of multiplying by root 2 by n in both the cases we consider only in the IDCT form 2 by n. So, this will be going from 0 to n minus 1.
52.srt	00:10:52.069 --> 00:11:03.639	So, it will be E of k into x of k what you have computed and cos 2 n plus 1 pi k divided by n and n will be varying between 0 to n minus 1 in this case.
52.srt	00:11:04.059 --> 00:11:11.809	And our constant E of k is given by 1 by root 2 if k is equal to 0 and it is going to be 1 for.
52.srt	00:11:12.269 --> 00:11:17.859	1 by root 2 into x of 1 so on 1 by root 2 into x of 3.
52.srt	00:11:17.859 --> 00:11:25.849	So, all the x 0 to x 3 has to be summed and then we have to multiply by root 2 to get x of 0.
52.srt	00:11:26.269 --> 00:11:35.459	To get x of 1 so we will expand the thing this equation by substituting n is equal to 0 to 3 in this case.
52.srt	00:11:35.939 --> 00:11:42.449	So, which is going to be x of 0 into cos pi by 8 and x of 1 into cos 2 pi by 8.
52.srt	00:11:42.609 --> 00:11:48.999	plus x of 2 into cos 3 pi by 8 plus x of 3 into cos 7 pi by 8.
52.srt	00:11:49.269 --> 00:11:56.929	So, we are substituting n is equal to 0 to 3 in this assuming r k is equal to 1.
52.srt	00:11:57.319 --> 00:12:04.209	So, now, what we call all these are cos functions what we have we call it as coefficients.
52.srt	00:12:04.529 --> 00:12:12.329	So, if you want you can expand x of 2 and x of 3 also to get 0 to 3 coefficients.
52.srt	00:12:14.609 --> 00:12:19.569	So, here this is x of 3 what you have to expand it and then write down those coefficients.
52.srt	00:12:19.939 --> 00:12:27.949	So, now coming to in the matrix form if we substitute these values as we have got it expanded 1.
52.srt	00:12:28.409 --> 00:12:30.359	So, we will see how it is going to look like.
52.srt	00:12:30.699 --> 00:12:39.749	So, my capital X of 0, X of 1, X of 2, X of 3 are written here and we know that the first coefficients is going to be 1 by root 2.
52.srt	00:12:40.199 --> 00:12:44.799	So, which is going to be multiplied by X of 0, X of 1, X of 2 into X of 3.
52.srt	00:12:44.939 --> 00:12:54.509	3 as a input and then the next second row is going to be pi by 8, 3 pi by 8, 5 pi by 8.
52.srt	00:12:54.589 --> 00:12:59.349	So, you will be adding 2 pi for all the things.
52.srt	00:12:59.349 --> 00:13:01.889	So, the last one will be cos 7 pi by 8.
52.srt	00:13:02.479 --> 00:13:11.119	So, you will be seeing in the third row it is going to start from 2 pi by 8 and then you are going to add this thing what is that 4 pi to this.
52.srt	00:13:16.699 --> 00:13:19.249	So, you get it as 6 4 is 10 pi and then 14 pi.
52.srt	00:13:19.889 --> 00:13:27.569	So, because that is multiplication what we have it 2 into 2 because x of 2 what we are doing it 2 into 2 is 4.
52.srt	00:13:28.099 --> 00:13:31.269	So, it will be plus 4 pi.
52.srt	00:13:31.269 --> 00:13:34.219	So, it is going to be 6 pi same as that.
52.srt	00:13:34.549 --> 00:13:44.299	Now, the next one is cos 3 pi by 8 and then you will be adding 6 pi to that.
52.srt	00:13:44.749 --> 00:13:47.079	So, 3 into 2 is 6.
52.srt	00:13:47.179 --> 00:13:49.859	So, it will be 9 pi by 8 and so on.
52.srt	00:13:51.779 --> 00:13:55.289	So, now, we because we know that we can simplify thus.
52.srt	00:13:55.599 --> 00:13:59.879	So, when you write the after simplification.
52.srt	00:14:00.219 --> 00:14:01.969	So, what we are going to get it.
52.srt	00:14:02.419 --> 00:14:12.929	So, in terms of negative what you will be representing because you will be doing 2 pi plus 4 pi.
52.srt	00:14:13.169 --> 00:14:16.269	So, which is nothing but minus cos 2 pi by 8.
52.srt	00:14:17.059 --> 00:14:23.729	So, by substituting all this these are the coefficients what we will get it.
52.srt	00:14:24.099 --> 00:14:30.129	So, we say whether it is symmetric or asymmetric rows what we are going to have it fine.
52.srt	00:14:30.439 --> 00:14:34.809	So, now coming further continuing with the matrix form.
52.srt	00:14:34.839 --> 00:14:41.939	So, we will represent we call this is a c 2 coefficients what we can represent for 1 by root 2.
52.srt	00:14:42.569 --> 00:14:50.169	So, the next one is pi by 8 is c 1 coefficient, 3 pi by 8 is c 3 coefficient.
52.srt	00:14:50.629 --> 00:14:54.359	Now we can represent this is minus c 3 and then.
52.srt	00:14:54.779 --> 00:14:56.249	this is minus c 1.
52.srt	00:14:57.149 --> 00:15:08.519	So, the next stage is going to be c 2 coefficients cos 2 pi by 8 and then minus c 2 minus c 2 and then c 2.
52.srt	00:15:09.239 --> 00:15:16.249	So, the same way the last row what we can represent it as c 3 minus c 1 c 1 and then minus c 3.
52.srt	00:15:16.679 --> 00:15:21.769	So, we will know that 4 point DCT needs 4 coefficients.
52.srt	00:15:22.109 --> 00:15:27.369	So, that is c 1 to c 3 n minus 1 coefficients.
52.srt	00:15:27.669 --> 00:15:40.059	that is what it is going to be used it is shown here n minus 1 is 3 coefficients that is c 1 c 2 c 3 what we need to represent our coefficients here ok.
52.srt	00:15:40.299 --> 00:15:46.619	So, the some of the new variables how we can modify the thing is.
52.srt	00:15:47.049 --> 00:15:54.669	So, what we have is here we know that it is c 2 this is x of 0 and we have rewritten the thing.
52.srt	00:15:55.089 --> 00:15:58.669	Now, what is our x of 0 we have to sum up.
52.srt	00:15:59.019 --> 00:16:15.299	all this and multiply by C2 and same way what we will be doing for X of 1 is it is X of 0 minus X of 3 into C1 plus X of 1 minus X of 2 into C3.
52.srt	00:16:15.739 --> 00:16:24.849	Because we will be combining this C1 and then this C1 and this C3 and this C3 so that our number of multiplication is going to reduce.
52.srt	00:16:25.179 --> 00:16:32.109	So it will be X0 minus X3 we will subtract this and multiply with one coefficient same way for the other thing.
52.srt	00:16:32.109 --> 00:16:37.629	So you will be seeing for X2 and X3 the same way you can combine them.
52.srt	00:16:38.179 --> 00:16:39.729	So, now what happens?
52.srt	00:16:40.219 --> 00:16:50.999	So, we will write it as from what we have is original we need because it is a 4 by 4 matrix we need 6 multiplication.
52.srt	00:16:51.319 --> 00:17:04.109	So, what we can reduce this one to 6 multiplications what you are seeing it that is 1, 2, 3, 4, 5 and then 6.
52.srt	00:17:04.229 --> 00:17:08.419	So, we have reduced from 16 multiplications to.
52.srt	00:17:08.879 --> 00:17:14.789	6 multiplications, but addition is going to remain the same.
52.srt	00:17:15.279 --> 00:17:19.339	So, now we will see intermediate products how we will be representing it.
52.srt	00:17:19.639 --> 00:17:25.829	We call it as X of 0 is given by P0 plus P1 into Rc2.
52.srt	00:17:26.389 --> 00:17:44.939	So, what is P0 which is going to be X0 plus X3 and then M0 that is because we are calculating the negative part of it X0 minus X3 and P1 will be X of 1 plus X of 2 and M1 is represented as X of 1 minus X of 2.
52.srt	00:17:45.309 --> 00:17:56.139	Then we will be reordering thus we will be seeing X of 0 is given by this equation X of 1, X of 2, X of 3 in terms of P0 M0.
52.srt	00:17:56.619 --> 00:17:59.049	P1 and M1 is given by this equation.
52.srt	00:17:59.679 --> 00:18:03.259	So, how we are going to represent in the butterfly form?
52.srt	00:18:03.779 --> 00:18:25.029	So, we know that X0 and then X3 is going to be minus, first one is X0, we are going to take this one X3 to this X0 plus X3 is my P0 output and the later on X0 minus X3 will be my M0.
52.srt	00:18:25.579 --> 00:18:28.759	Same way we will put it for X1 and then X2.
52.srt	00:18:29.239 --> 00:18:39.789	So, that is x1 plus x2 will be P1 and x1 minus x2 will be my M1 here.
52.srt	00:18:41.109 --> 00:18:42.609	So, what is happened here?
52.srt	00:18:43.249 --> 00:18:47.069	We have the reversed input order just like our DFT.
52.srt	00:18:47.499 --> 00:18:52.389	So, we are having x0, x3, x1 and then x2 right.
52.srt	00:18:52.729 --> 00:18:57.789	So, coming to the second stage what is the thing is going to happen?
52.srt	00:18:58.649 --> 00:19:02.609	So, we have P0 and M0 and P1 and then M1.
52.srt	00:19:03.039 --> 00:19:08.049	So, next stage is we have X0 is P0 plus P1 into C2.
52.srt	00:19:09.099 --> 00:19:18.519	So, we will be multiplying with C2 coefficients in the last stage after adding with P0 M0 we will be getting X0.
52.srt	00:19:18.999 --> 00:19:26.559	So, the next one is what we have is X of 1 is M0 into C1 plus M1 into C3.
52.srt	00:19:26.949 --> 00:19:33.929	So, you have to have a M0 with C1 coefficient and then M1 with C3.
52.srt	00:19:34.189 --> 00:19:35.729	C3 coefficient.
52.srt	00:19:36.359 --> 00:19:39.119	So, this is what you will be C3 coefficient.
52.srt	00:19:39.219 --> 00:19:43.729	So, you multiply both of them add them you will be getting your x1.
52.srt	00:19:44.239 --> 00:19:47.819	Now, x2 is what p0 minus p1 into C2.
52.srt	00:19:48.939 --> 00:20:03.459	You are taking p0 here minus what you are going to do p1 multiplied by C2 will be given output as x2 and x3 we know that m0 into C3 minus m1 into C1.
52.srt	00:20:06.199 --> 00:20:14.229	So, what we have m0 into So, what we have is here it is multiplied by C3 here and then M1 is multiplied by C1.
52.srt	00:20:14.759 --> 00:20:20.239	So, after the this is a subtraction that is minus what we have it.
52.srt	00:20:20.649 --> 00:20:23.619	So, we will be getting x of 3 as the output.
52.srt	00:20:24.289 --> 00:20:28.149	This is how we can write our butterfly structure.
52.srt	00:20:29.519 --> 00:20:35.319	So, the final thing what we have 4 point DCT is given by this complete butterfly structure.
52.srt	00:20:35.939 --> 00:20:39.169	x0, x3, x1 and x2 are the inputs.
52.srt	00:20:39.619 --> 00:20:51.209	So, we will be getting actually input is going to be small x0, x3, x1 and then x2.
52.srt	00:20:51.689 --> 00:21:01.379	Output is going to be capital X0, X1, X2, X3 in line with our FFT what it is shown by combining these two butterflies.
52.srt	00:21:11.719 --> 00:21:14.379	So, intermediate you will be seeing that P0, M0, P1, M1 and this is the output you will be seeing there in order x0, x1, x2, x3 and in input has got reversed in this case.
52.srt	00:21:15.009 --> 00:21:22.449	So, now extending the same thing from 4 point to 8 point how we did with respect to DFT.
52.srt	00:21:22.819 --> 00:21:25.619	So, we will do it for 8 point DCT.
52.srt	00:21:25.990 --> 00:21:42.399	So, you will be seeing that input that is output is capital X0 to X7 input is small x0 to x7 what we have it in terms of coefficients you will be seeing that from a C2 because it is a.
52.srt	00:21:42.960 --> 00:21:47.579	n by 2 what we are going to have it that is 8 by 2 is 4.
52.srt	00:21:47.869 --> 00:21:52.210	So, the first row is going to be c 4 coefficients you will be having it.
52.srt	00:21:52.639 --> 00:22:00.589	After that you will have c 1, c 3, c 5, c 7, c 9, c 11, c 13 and then c 15.
52.srt	00:22:00.930 --> 00:22:04.240	So, you will be writing this way fine.
52.srt	00:22:04.509 --> 00:22:14.210	So, all the coefficients you can write it in this fashion and then later on as we see the symmetry thing what you will be looking into the thing.
52.srt	00:22:16.059 --> 00:22:24.880	So, we will be reorganizing my you will be seeing that my C10 is going to be minus C6.
52.srt	00:22:25.039 --> 00:22:29.340	So, how many coefficients I needed here can you guess it?
52.srt	00:22:29.660 --> 00:22:35.299	We said in 4.33 coefficients in 8 point we need only 7 coefficients.
52.srt	00:22:35.299 --> 00:22:39.549	So, that is C1 to C7 what we are supposed to have it.
52.srt	00:22:39.549 --> 00:22:44.900	So, we have to organize in that manner when we do that you can see the simplified matrix.
52.srt	00:22:45.789 --> 00:22:47.630	what it is given in this case.
52.srt	00:22:48.100 --> 00:22:56.309	And then you will be seeing that these are the outputs and multiplied with x 0 to x 7 in order.
52.srt	00:22:56.700 --> 00:23:00.759	So, how we are going to represent this in a matrix form.
52.srt	00:23:00.870 --> 00:23:14.180	So, one of the famous thing is what they call it as ACF and then BDEG coefficients form to put it in FPG.
52.srt	00:23:16.829 --> 00:23:32.909	So, you can use the butterfly structure last will I will be showing it otherwise most of the FPGA implementation use this format that is we call it as instead of x0 output will be y0, y2, y4, y6.
52.srt	00:23:33.259 --> 00:23:40.669	So, this is our DCT or E1 coefficients what we are going to combine with the coefficients ACF ok.
52.srt	00:23:40.759 --> 00:23:48.690	So, that is what for the E1 and you will be adding x0 plus x7.
52.srt	00:23:49.319 --> 00:23:56.539	x1 plus x6 and x2 plus x5 and then x3 plus x4 and these are the odd coefficients bottom.
52.srt	00:23:56.539 --> 00:24:03.319	So you can put them in bottom y1 y3 y5 and then y7.
52.srt	00:24:03.609 --> 00:24:15.950	So they need BDEG coefficients to compute and the input of this will be x0 minus x7 and x1 minus x6 so on and this one.
52.srt	00:24:16.419 --> 00:24:21.029	So now to compute with these coefficients back okay IDCT.
52.srt	00:24:21.430 --> 00:24:31.410	So, how you will be using in the that is y0 to y0, y1, y2, y3 what you will be calculating it.
52.srt	00:24:31.750 --> 00:24:53.279	So, you will be using the ACF coefficient in the top portion, but you will be seeing that input is going to be that is bit reversed that is x0, x2, x4, x6 not completely bit reversed in this case even anyway what you will be considering it here same as our FFT.
52.srt	00:24:53.640 --> 00:25:03.650	So, here it will be x1, x3, x5 and then x7 what will be using the thing and then when you multiply with this BDEG coefficients and add them.
52.srt	00:25:03.840 --> 00:25:07.350	up you will be getting the y 0 to y 3.
52.srt	00:25:07.750 --> 00:25:20.000	Then what you are going to do is do the same thing, but you have to subtract with this BDEG coefficients which are getting multiplied with odd numbers.
52.srt	00:25:20.000 --> 00:25:26.150	So, you will be getting the higher that is y 7 that is y 4 to y 7.
52.srt	00:25:26.150 --> 00:25:28.910	So, you will be seeing that it has come in the reverse order.
52.srt	00:25:29.600 --> 00:25:34.039	So, y 7 will be first and then y 4 will be coming later on.
52.srt	00:25:34.450 --> 00:25:37.809	So, this is how you would be reconstructing with the same.
52.srt	00:25:38.019 --> 00:25:44.269	coefficients both in DCT what you will be using it and then in the inverse DCT also.
52.srt	00:25:44.730 --> 00:25:47.180	How we are going to do that?
52.srt	00:25:47.690 --> 00:25:55.509	So, you will be putting that is if you are putting 8 bit 1D DCT when you are putting in this format.
52.srt	00:25:55.950 --> 00:26:09.180	So, that is y is equal to our matrix A into X the matrix with coefficients whatever we have discussed in the previous one that is ACF and then BDEG.
52.srt	00:26:09.500 --> 00:26:10.920	So, you will be seeing that.
52.srt	00:26:11.210 --> 00:26:32.710	all these are a coefficients and these are b, d, e, g minus g minus e minus d and minus b and then the rest of the coefficients are getting filled like this you can go back and then cross verify it and then which are what are the are a, b, c, d, f, g coefficients.
52.srt	00:26:32.740 --> 00:26:47.430	So, it is nothing but root 2 pi n. So, a is cos pi by 4, b is going to be cos pi by 16 and c is this one cos pi by 8 and then g is going to be cos 7 pi by.
52.srt	00:26:47.630 --> 00:26:51.230	So, this is for the 8 by 8 matrix.
52.srt	00:26:51.230 --> 00:26:54.619	So, you can substitute it will be much faster and then computation.
52.srt	00:26:55.150 --> 00:27:07.609	So, the symmetrical property of that is what the DCT coefficients what you have seen the thing IDCT after adding it DCT part what we said by multiplying it what will be getting it.
52.srt	00:27:07.609 --> 00:27:17.569	So, the same thing again it is shown that how from IDCT DCT or DCT to IDCT what you will be traversing with the same type of coefficients.
52.srt	00:27:18.079 --> 00:27:22.430	So, how the architecture in FBGA is going to look like.
52.srt	00:27:22.769 --> 00:27:24.910	So, this will be x is the input.
52.srt	00:27:25.109 --> 00:27:48.049	that is we call it as data recorder unit and then we will be having the ACF matrix vector multiplier and the other one is BDEG matrix vector multiplier and then we are going to have the inverse data recorder unit basically that is output is going to be z coming out of it and then what is z.
52.srt	00:27:48.160 --> 00:27:56.180	So the same data you will be doing the transpose the memory and then get it as y and feed it in the reverse direction.
52.srt	00:28:03.980 --> 00:28:08.009	So this is our ACF matrix and this is our BDEG matrix so you will be you can go from Y to X or X to Z.
52.srt	00:28:08.360 --> 00:28:14.720	So, this will be transposing and then putting it as input and then will be working it out.
52.srt	00:28:15.000 --> 00:28:19.080	So, this is how the hardware implementation is going to happen in FPGA.
52.srt	00:28:19.519 --> 00:28:22.420	This is data recorder unit in the thing.
52.srt	00:28:22.740 --> 00:28:34.700	So, you will have the transpose of memory and you have the ACF matrix vector multiplier input will be coming to here and this output is going to be given to our draw.
52.srt	00:28:35.170 --> 00:28:48.210	inverse data recorder unit here and we will be doing the transpose and then we will be getting the BDEG matrix vector multiplier and then we can feed it in and then we will be taking the output from here.
52.srt	00:28:48.510 --> 00:29:01.570	So, if we are using it in the DCT you can use it in one direction and then if I want to have the IDCT the same hardware is going to be used in the reverse direction as we pointed out in the thing.
52.srt	00:29:02.190 --> 00:29:06.990	So, to give you a flavor of how the 8 point DCT.
52.srt	00:29:07.450 --> 00:29:14.500	I want you to work it out how much we have reduced in the 1DCT with the butterfly structure.
52.srt	00:29:14.900 --> 00:29:28.990	So, you will be seeing that these are the stages what we are going to have it S1, S2, S3 and S4 compared to log2n stages in FFT.
52.srt	00:29:29.320 --> 00:29:40.480	So, we will be having log2n plus 1 for 8 point as you can see there is Sy stage also will be coming in the outside part of it.
52.srt	00:29:41.080 --> 00:30:03.310	So, this is our X0 and then you will be combining with minus S7 input A and B what you will be showing it as a matrix 4 point what you can take it and then put it across this is the even side this is the odd part of it.
52.srt	00:30:03.570 --> 00:30:11.350	So, I want you to work it out so that the output is going to be V0, V4.
52.srt	00:30:11.790 --> 00:30:13.130	V2, V6.
52.srt	00:30:13.510 --> 00:30:21.240	So, input is in order output is going to be in the bit reversal format what you will be getting it.
52.srt	00:30:22.070 --> 00:30:28.860	The odd side you will be seeing that it is V1, V5, V3 and V7 and these are the sine and cos function.
52.srt	00:30:28.940 --> 00:30:36.830	So, if those are interested in this paper I will be uploading it in the thing how they have reduced number of multiplications and additions.
52.srt	00:30:37.330 --> 00:30:42.070	So, that it comes to.
52.srt	00:30:44.260 --> 00:30:54.540	13 multiplications in this case one more paper reduces from 13 multiplications to 11 multiplications with 27 additions along with that.
52.srt	00:30:54.930 --> 00:31:12.950	So this is how you can implement it in hardware that is butterfly structure with cos and sin functions what it has been given and then you can see that to the normal DCT output whether this output for the 8 point what you will be getting it.
52.srt	00:31:15.540 --> 00:31:21.810	gives the complete summary of the DCT in hardware.
52.srt	00:31:22.240 --> 00:31:26.460	So, have a happy learning and then thank you.
52.srt	00:31:26.740 --> 00:31:29.490	Hopefully you have enjoyed this course.
52.srt	00:31:29.790 --> 00:31:48.400	So, we will do the summary of the complete course in the next class what all we covered it and then we will discuss how we can implement it in hardware and then how we have done our labs and other sessions based on the theory part of it to verify our outputs.
52.srt	00:31:48.710 --> 00:31:49.100	Thank you.
44.srt	00:00:01.219 --> 00:00:24.620	Welcome back to real time digital signal processing course.
44.srt	00:00:24.620 --> 00:00:29.839	So today we will discuss about speech coding the first part of it.
44.srt	00:00:32.070 --> 00:00:37.109	So, in the last class to give a recap of the class.
44.srt	00:00:37.480 --> 00:00:40.510	So, we discussed about the graphic equalizer.
44.srt	00:00:41.020 --> 00:00:43.020	Why do we need the graphic equalizer?
44.srt	00:00:43.020 --> 00:00:59.290	So, we said that in different applications even wearing your mobile phones when you are using it so you can make the audio equalize so that whichever part of it you can hear.
44.srt	00:01:04.739 --> 00:01:29.909	Even in your music systems you can use the graphic equalization to get clear cut voice if you want it or if you want to suppress and only have only musical instruments you can have the thing and then use your voice for recording and other purposes as we said that is the application one can use.
44.srt	00:01:30.329 --> 00:01:42.729	So, for that we will be using the graphic equalizer and then if you want to completely block the outside noise also noise cancellation what you can do that.
44.srt	00:01:44.169 --> 00:01:52.310	So, today we will see little bit on speech coding, why do we need it and then what is the advantage of it.
44.srt	00:01:52.829 --> 00:01:53.859	So, what is it?
44.srt	00:01:54.229 --> 00:02:02.389	We know that digital speech which convert analog speech to digital form and then transmit digitally.
44.srt	00:02:03.089 --> 00:02:17.990	So, applications of digital transmission we know that noises whatever channel noise is added we can do the cancellation what we have seen it in the previous classes.
44.srt	00:02:18.950 --> 00:02:28.200	And, then even the storage as we know that we can compress the speech and then keep it and whenever we want to do the thing.
44.srt	00:02:28.200 --> 00:02:32.350	So, we can decompress and then use it.
44.srt	00:02:32.790 --> 00:02:48.830	So, the applications what we will be seeing in this case is as you are seeing the thing first one is in the telephony that is basically in cellular wired and then internet voice over IP we need.
44.srt	00:02:49.979 --> 00:02:54.979	speech conversion and in the speech the speech storage.
44.srt	00:02:55.349 --> 00:02:58.849	So, that is automated call centers.
44.srt	00:02:59.240 --> 00:03:04.159	So, you can record the voices and then you will be playing it.
44.srt	00:03:04.159 --> 00:03:21.210	So, most of you may be receiving it in the automated through your mobile that these are the facilities available or why do not you register and other things voice messages will be coming in your mobiles.
44.srt	00:03:21.739 --> 00:03:29.659	and in the high fidelity recording or voice what we need the thing speech coding.
44.srt	00:03:30.629 --> 00:03:38.049	And next one is all of us know that it is text to speech that is machine generated speech.
44.srt	00:03:38.459 --> 00:04:02.409	So, we will be seeing that for the physically disabled people and then the challenged people who are unable to hear the thing whether we can play them from the text whatever the materials we have most of it we have in the text form whether we can convert it to speech and then they can if they are.
44.srt	00:04:02.799 --> 00:04:04.879	auditory system is good.
44.srt	00:04:04.879 --> 00:04:08.069	So, they can hear the thing and then they can understand.
44.srt	00:04:08.459 --> 00:04:14.929	So, this is one more application what we will be seeing one can work on.
44.srt	00:04:15.379 --> 00:04:17.099	So, what are the issues?
44.srt	00:04:17.389 --> 00:04:25.279	So, one of the issue what we say when we are transmitting or whatever we need the efficient use of bandwidth.
44.srt	00:04:25.279 --> 00:04:35.899	That is we can compress to lower bit rate per user so, that we can cover more users in this particular bandwidth.
44.srt	00:04:36.819 --> 00:04:39.909	And, then we have to look at the speech quality.
44.srt	00:04:40.509 --> 00:04:48.819	So, want what we say is tall grade or better quality in a specific transmission environment.
44.srt	00:04:49.259 --> 00:04:54.730	So, environment is noise is bad, but still we want to have a better quality in the thing.
44.srt	00:04:55.219 --> 00:05:00.069	So, the other one environment itself plays an important role.
44.srt	00:05:00.610 --> 00:05:04.949	So, that is what we call it as bit error rate basically.
44.srt	00:05:05.430 --> 00:05:09.980	So, how many bits we want to transmit or whether we can.
44.srt	00:05:10.509 --> 00:05:18.480	send lesser number of bits and then how much packet lost is going to be one of the challenges one has to look at it.
44.srt	00:05:18.480 --> 00:05:24.970	And then if they are out of order the packets are out of order and then what is the delay.
44.srt	00:05:24.970 --> 00:05:28.949	So, these are the issues when we are transmitting directly.
44.srt	00:05:29.000 --> 00:05:43.670	So, by coding and then we can account for all this losses that is environment losses then we will be able to reconstruct our code at the receiving end properly.
44.srt	00:05:44.189 --> 00:05:58.410	The other issue one has to look at it is hardware complexity that is the speed basically both coding at the sending end and decoding at the receiving end will have a delay.
44.srt	00:05:58.500 --> 00:06:05.850	So, which is going to be defined by what is the hardware you are going to use it.
44.srt	00:06:06.149 --> 00:06:10.730	So, if you are using the software so, we will be seeing that delay will be much more.
44.srt	00:06:10.730 --> 00:06:14.509	So, if we have the codecs basically then we will be having.
44.srt	00:06:14.720 --> 00:06:15.600	much speed.
44.srt	00:06:16.210 --> 00:06:22.560	Then computation requirement and power consumption always one has to keep it in mind.
44.srt	00:06:22.990 --> 00:06:33.140	So, power consumption in most of the handheld devices which is an important criteria and we should not be foregoing the computation basically.
44.srt	00:06:33.140 --> 00:06:39.860	So, we have to cater to whatever the coding techniques we are going to use it.
44.srt	00:06:39.860 --> 00:06:43.180	So, one has to be supported in your hardware.
44.srt	00:06:45.510 --> 00:06:48.440	How we are going to do the processing of speech?
44.srt	00:06:49.030 --> 00:07:12.090	So, we say that in speech coding in wireless systems all this thing 1G systems have analog speech transmission in that and we know that in 2G and 3G systems have digital speech and what is the type of source coding we are going to have it which is going to vary.
44.srt	00:07:12.090 --> 00:07:13.960	So, we will see it in a while now.
44.srt	00:07:14.660 --> 00:07:17.880	So, what is the motivation for digital speech?
44.srt	00:07:18.450 --> 00:07:28.590	So, we want to increase the system capacity as we discussed in the previous slide and then whether is it possible to compress the speech.
44.srt	00:07:28.730 --> 00:07:33.870	So, if it is possible we want to compress and then storage is one of the thing.
44.srt	00:07:34.350 --> 00:07:42.730	The other one as we said even the transmission multiple users can be compressed speech of them can be transmitted in the single line.
44.srt	00:07:43.320 --> 00:07:49.140	And then what is the quality or bandwidth tradeoffs can be made depending on.
44.srt	00:07:49.400 --> 00:07:52.110	are this thing speech.
44.srt	00:07:52.900 --> 00:08:16.950	So, how to improve the quality of speech that is usually will be having the error control coding that is ECC what we call it and possible and as we discussed in the last class even the equalization what we can do using different techniques and then many more what we can use it to improve the quality of speech.
44.srt	00:08:17.900 --> 00:08:22.840	And then how to improve security as encryption possible for privacy.
44.srt	00:08:23.270 --> 00:08:43.030	So, one of the example we said scrambling, where I can scramble my speed signal and then this is the way one can do the encryption or you can do in multiple ways and then at the receiving end whether we can do the decrypted speed signal what we can do it.
44.srt	00:08:43.030 --> 00:08:55.560	So, and then at the same time we have to keep it in mind that reduced cost and operations and maintenance what we have to be considering it because most of the units.
44.srt	00:08:56.009 --> 00:09:02.509	for majority usage we need this parameter to be considered.
44.srt	00:09:03.610 --> 00:09:18.389	Coming to the distinct communication system in wireless mode what it shows in this diagram is we have the source place and we are going to do that encoding basically there.
44.srt	00:09:18.570 --> 00:09:27.450	And then after that we are going to encode the channel also and then use the modulator to.
44.srt	00:09:28.049 --> 00:09:32.490	generate the signal and pass it through channel.
44.srt	00:09:32.809 --> 00:09:35.950	So, if we know the channel, so we will be encoding that also.
44.srt	00:09:36.470 --> 00:09:42.259	And then in the receiving place we are going to do the demodulation.
44.srt	00:09:42.629 --> 00:09:48.399	So, it is corresponding to whatever modulated modulation technique what one has used it.
44.srt	00:09:49.110 --> 00:09:55.919	And then we will go with the channel decoder and then we will be doing the source decoding.
44.srt	00:09:56.799 --> 00:09:59.370	And last is our destination.
44.srt	00:09:59.569 --> 00:10:08.649	So, that is receiving this is from the sending end to this is at the receiving end how the wireless communication system looks like.
44.srt	00:10:09.750 --> 00:10:12.699	What is the characteristics of speech basically?
44.srt	00:10:13.159 --> 00:10:21.120	So, we call it as bandwidth most of energy between 20 hertz to about 7 kilohertz.
44.srt	00:10:21.699 --> 00:10:29.649	So, and then we know that human ear basically sensitive to energy between 50 hertz to 4 kilohertz.
44.srt	00:10:30.179 --> 00:10:38.279	So, that is the reason why what earlier narrowband speech was 8 kilohertz sampling rate what we were using it.
44.srt	00:10:38.710 --> 00:10:45.279	For all now mobile communications we know that the bandwidth what it is going to be covered is in this range.
44.srt	00:10:45.629 --> 00:10:51.320	So, we will be going with the wideband speech which is 16 kilohertz basically.
44.srt	00:10:51.620 --> 00:11:01.169	So, you will be seeing that what is the auditory which is given by this curve based on the things.
44.srt	00:11:01.169 --> 00:11:04.789	So, narrowband and then wideband will be using based on it.
44.srt	00:11:05.329 --> 00:11:08.220	So, the next one is based on the time signal.
44.srt	00:11:08.629 --> 00:11:15.970	So, we say that it is highly correlated and then the speech is short term stationary.
44.srt	00:11:16.639 --> 00:11:22.649	So, for a while we can consider it as it is stationary and then we can process the signal.
44.srt	00:11:23.399 --> 00:11:32.480	So, we classify the speech into 4 categories what we call it as one is voiced basically.
44.srt	00:11:32.899 --> 00:11:34.809	So, we say created by.
44.srt	00:11:35.209 --> 00:11:41.750	air pass through vocal cords example like ha we you will be seeing that.
44.srt	00:11:42.149 --> 00:11:47.929	So, you are seeing the speech how our mouth is going to be considered.
44.srt	00:11:48.230 --> 00:12:05.740	So, we have the lips here and then this thing what is it teeth is here and our oral cavity and this is the nasal cavity what we call it as and then some of the other pharynx and then esophagus what we will be having.
44.srt	00:12:05.740 --> 00:12:09.699	So, this is the vocal folds what we have it.
44.srt	00:12:10.110 --> 00:12:20.970	which will be vibrating and the other one what we call it as unvoiced that is created by air through mouth and then lips.
44.srt	00:12:21.379 --> 00:12:33.309	So, example S F so, you can feel that when you are pronouncing it how the air is passing through your mouth as well as through the lips.
44.srt	00:12:33.740 --> 00:12:42.440	The other one is mixed or transitional or in between what we call it and the other part of it is silence.
44.srt	00:12:42.799 --> 00:12:50.600	So, if nobody is speaking or whatever so, we say that that is the silence zone.
44.srt	00:12:50.960 --> 00:12:55.669	So, these are the four categories one can classify the speech in two.
44.srt	00:12:56.440 --> 00:12:59.250	Now what are the characteristics of speech?
44.srt	00:12:59.779 --> 00:13:14.710	So, we said voice signals are produced when the vocal cords vibrate during the pronunciation of a phoneme what we call it and unvoiced signals by contrast do not entail the use of the vocal cords.
44.srt	00:13:15.029 --> 00:13:18.100	So, as an example so, you can see that.
44.srt	00:13:18.430 --> 00:13:26.379	utterance of 2 what you do the thing and this you call it as the this thing.
44.srt	00:13:26.800 --> 00:13:41.610	So, you will be seeing that consonant when we are pronouncing 2 t this is how the phoneme is going to be generated slash t and then u w the consonant slash t is the unvoiced speech.
44.srt	00:13:41.860 --> 00:13:49.450	So, this is the duration where you will be having it as unvoiced and then look like a noise as you can make out here.
44.srt	00:13:50.000 --> 00:13:58.980	So, then what happens while the vowel u w ok, voice speech is characterized by the strong fundamental frequency.
44.srt	00:13:58.980 --> 00:14:02.610	So, you will be seeing that which is coming with the thing.
44.srt	00:14:02.930 --> 00:14:13.740	So, you can use MATLAB to generate this, this is a time versus amplitude what is given when you when we take up in the lab the example.
44.srt	00:14:13.740 --> 00:14:19.580	So, we will see that how when a voice signal of 2 is given how the.
44.srt	00:14:20.870 --> 00:14:22.730	samples are generated.
44.srt	00:14:22.810 --> 00:14:27.730	So, you can see the same thing in the frequency domain this is what it is shown in the time domain.
44.srt	00:14:28.550 --> 00:14:31.650	So, now, we will come to the digital speech.
44.srt	00:14:32.040 --> 00:14:38.650	So, we say that speech coder why we need it device that converts speech to digital.
44.srt	00:14:39.240 --> 00:14:48.190	So, we will be seeing that it can speech coding is bifurcated into it can be waveform coders or O coders.
44.srt	00:14:48.500 --> 00:14:53.310	So, in this case you are seeing the span how it is varying.
44.srt	00:14:53.860 --> 00:15:07.900	So, you will be seeing the broadcast quality what you are seeing from 64 to 200 here and then the tall quality what you will see from 16 to 64 what it is going to be.
44.srt	00:15:08.310 --> 00:15:22.220	So, this one comes in the waveform coding basically and communication what you can see is from 4 point sorry in between that 5 to 9.6 or little more than that what you have the thing.
44.srt	00:15:26.030 --> 00:15:35.380	And this is the synthetic quality what we can generate the speech from here to here using O coders.
44.srt	00:15:35.380 --> 00:15:46.290	So, O coders are spanning between 1.0 to 16 in this case as whereas, our waveform coders are spanning between 4.8 to 200.
44.srt	00:15:46.290 --> 00:15:54.320	And when you want to use both of them, so you can generate the hybrid coders basically in this domain.
44.srt	00:15:54.320 --> 00:15:58.520	So, what we say is that is waveform coders.
44.srt	00:16:00.070 --> 00:16:08.160	They convert any analog signal to digital form whereas, vocoders that is we call it as parametric coders basically.
44.srt	00:16:08.540 --> 00:16:21.540	It is try to exploit special properties of speech signal to reduce bit rate and then it will be building the model of speech that is transmit parameters of model basically.
44.srt	00:16:22.400 --> 00:16:30.140	And whereas, the hybrid coders combine features of both waveform and then vocoders and then speech coders are generated.
44.srt	00:16:31.750 --> 00:16:37.560	So, what are the quality of speech with various coder is shown in this diagram.
44.srt	00:16:38.400 --> 00:16:41.350	So, usually what we do is mean opinion score.
44.srt	00:16:41.400 --> 00:17:01.790	So, it is a subjective measure of quality that is we put we generate the speech and then we will call the persons to evaluate whether they are able to identify the voice whether it is male voice or female voice and then what it has been sentence has been uttered.
44.srt	00:17:06.660 --> 00:17:23.230	if it is sentence generation and then we will say that what is the opinion of them then we will be calculating the mean opinion score from different characteristics of the people when they evaluate the thing.
44.srt	00:17:23.259 --> 00:17:31.450	So, the other one is trade off in quality versus data rate versus complexity what it is going to be shown.
44.srt	00:17:31.730 --> 00:17:39.170	So, you have seen here that general speech quality versus transmission rate has been plotted.
44.srt	00:17:40.099 --> 00:17:48.359	this is the x axis whereas, of here it is MOS is our mean opinions core is put the thing.
44.srt	00:17:48.980 --> 00:18:02.029	So, you will be seeing that synthetic quality is the data rate goes with 8 kilobit per second to 64 kilobit per second that is what you have seen in the previous one also.
44.srt	00:18:02.640 --> 00:18:08.160	And then you will be putting the source coding is on this side of the line.
44.srt	00:18:08.619 --> 00:18:11.690	So, and then the waveform coding goes.
44.srt	00:18:12.049 --> 00:18:15.159	beyond a 16 kilo bit per second.
44.srt	00:18:15.579 --> 00:18:33.799	So, you will be seeing that synthetic quality is at the bottom and then communication quality just spans between the two of them and the tall quality and broadcast quality has as we have seen in the previous slide also it is going into the waveform coding.
44.srt	00:18:42.440 --> 00:18:46.720	So, you will be seeing that beyond what we can have is 16 kilo bit per second whereas, the hybrid So, you will be between that synthetic and then communication.
44.srt	00:18:46.720 --> 00:18:56.129	So, it lies in this domain and you will be seeing that mean opinions code is very high for our broadcast quality.
44.srt	00:18:56.359 --> 00:19:05.700	And then we will be seeing that it is low for our synthetic quality of speech what it is getting generated.
44.srt	00:19:06.639 --> 00:19:12.169	So, you will be seeing that how to select your now coders.
44.srt	00:19:12.819 --> 00:19:23.289	So, we say that waveform coders what we call it as PCM pulse code modulation all of you would have heard the thing.
44.srt	00:19:23.769 --> 00:19:32.240	So, this is the waveform coders what it does basically convert any analog signal to digital basically A to D converter.
44.srt	00:19:32.740 --> 00:19:44.329	One has to use to do the conversion of speech and analog signal sampled as we know that it should be more than twice the highest frequency component.
44.srt	00:19:44.990 --> 00:19:49.750	Then, what we are going to do is we are going to do the quantization into n bit samples.
44.srt	00:19:49.750 --> 00:20:04.089	So, when we had taken the number system we have seen how many the number of bits what I am going to represent my input signal even the speech coding is going to have the same thing.
44.srt	00:20:04.089 --> 00:20:12.419	So, you are seeing what we want to represent is in a linear way, but what we are going to depending on the number of bits.
44.srt	00:20:12.730 --> 00:20:15.399	So, you will be seeing that it will be.
44.srt	00:20:15.990 --> 00:20:25.779	the nearest value what will be representing it which is the error what we have taken is minus delta by 2 to plus delta by 2.
44.srt	00:20:25.990 --> 00:20:31.180	So, that is what the error what will be getting in representation.
44.srt	00:20:31.829 --> 00:20:35.079	So, n bit samples what we are going to represent it.
44.srt	00:20:35.569 --> 00:20:47.420	Then uniform quantization what we have seen the thing and example is here what will be taking is pulse code modulation and the band limit speech for this is less than.
44.srt	00:20:47.619 --> 00:20:49.039	4000 hertz.
44.srt	00:20:49.579 --> 00:20:56.640	So, pass speech through plus either a mu log compander or a log compander.
44.srt	00:20:56.910 --> 00:21:02.430	So, for more details you can refer to the textbook for what are the companding it is going to happen.
44.srt	00:21:03.089 --> 00:21:10.819	And here the sample is what we will be taking at 8 kilohertz and usually it is 8 bit samples.
44.srt	00:21:11.269 --> 00:21:19.690	Then what we have is a 64 kilobits per second what we can represent and this is a digital rate.
44.srt	00:21:19.879 --> 00:21:26.690	that is digital sample output rate what we are going to get from this representation.
44.srt	00:21:26.690 --> 00:21:33.009	So, as you will be seeing that it is 8 into 8 is 64 kilo bit per second what we will be getting it.
44.srt	00:21:33.500 --> 00:21:36.259	And how is the characteristic of this?
44.srt	00:21:36.629 --> 00:21:51.789	The quality is very high and then we know that complexity for pulse code modulation is low and bit rate as we can see that it is high and in this case it is delay is going to be low.
44.srt	00:21:52.319 --> 00:21:55.689	And, robustness of this is high.
44.srt	00:21:56.659 --> 00:22:25.069	So, coming to that is PCM speech coding system with analog companding then digital conversion the standard the what we will be seeing is that is international telecommunication standard ITU which is G 700 standard basis for speech coding in our PSTN in 60s at you can see in the.
44.srt	00:22:25.659 --> 00:22:28.999	are digital lines whatever telephones what we have it.
44.srt	00:22:28.999 --> 00:22:31.439	N60s is given by this.
44.srt	00:22:32.209 --> 00:22:44.199	So, you will be seeing that this is an analog input what we have is a band pass filter, then we will have the analog compressor here and then sample and then hold circuit.
44.srt	00:22:44.949 --> 00:22:55.389	So, which is going to use the mu log compander and then what the output we will be getting it.
44.srt	00:22:55.639 --> 00:23:00.169	is pulse amplitude modulated time basically what we will get.
44.srt	00:23:00.169 --> 00:23:14.499	And then we will do the conversion analog to digital conversion which it is known as pulse code modulation here and we will be putting it in the transmission medium digital to analog conversion what we have to do it.
44.srt	00:23:14.499 --> 00:23:22.479	And then here again analog modulation you will have it this is the whole circuit.
44.srt	00:23:22.479 --> 00:23:23.659	So, and then.
44.srt	00:23:26.039 --> 00:23:32.159	You have the analog expander and then use a band pass filter to get the analog output.
44.srt	00:23:32.289 --> 00:23:39.259	So, the mu lock expander was used for this purpose fine.
44.srt	00:23:39.619 --> 00:23:56.409	So, what are the companding techniques one has ok. What it says is analog compander emphasizes small values and deemphasizes large values in order to equalize a signal to noise ratio across the samples.
44.srt	00:23:57.299 --> 00:24:01.779	reverse the mapping at the receiver with an expander.
44.srt	00:24:01.779 --> 00:24:06.639	So, one is compander the other one is expander at the receiving end.
44.srt	00:24:07.029 --> 00:24:26.539	So, the thing is given as f of s basically that is sign of s. So, the natural logarithm what will be using it 1 plus mu of s because mu law compander is being used and then divided by ln into 1 plus mu.
44.srt	00:24:26.959 --> 00:24:32.069	So, what is the mu law companding how it is going to look like is shown in this figure.
44.srt	00:24:32.559 --> 00:24:34.069	So, we have the input.
44.srt	00:24:34.479 --> 00:24:36.229	And, this is the output.
44.srt	00:24:36.589 --> 00:24:40.859	So, 0 is no compression is done.
44.srt	00:24:40.859 --> 00:24:44.059	So, you are seeing it is a linear what it is getting passed.
44.srt	00:24:44.459 --> 00:24:46.389	And, then f mu is equal to 5.
44.srt	00:24:46.729 --> 00:24:49.909	So, this is how the companding is going to happen.
44.srt	00:24:50.409 --> 00:24:51.979	And, then f mu is 55.
44.srt	00:24:51.979 --> 00:24:57.219	So, you will be seeing that it is the companding is going to be in this way.
44.srt	00:24:57.259 --> 00:25:03.599	So, that is what the frequency what you will be generating and then sending it out.
44.srt	00:25:06.469 --> 00:25:13.689	So, now, coming to pulse code modulation speech coding, this is digitally companded PCM system.
44.srt	00:25:14.139 --> 00:25:18.609	The standard for this in ITU is G.711 standard.
44.srt	00:25:18.609 --> 00:25:20.469	So, what it has?
44.srt	00:25:20.469 --> 00:25:26.329	So, better quality speech than analog companding as in the previous case.
44.srt	00:25:26.329 --> 00:25:28.199	So, we will see how it is going to be the thing.
44.srt	00:25:28.199 --> 00:25:37.019	And you can modify this PCM coding to differential PCM which is known as DPCM.
44.srt	00:25:38.429 --> 00:25:46.889	to reduce bit rate from 64 kilobit per second which was in PCM to 32 kilobit per second.
44.srt	00:25:47.819 --> 00:26:06.739	So, since the change is small between sample transmit one sample in this case, then on transmit difference between samples use 4 bits to quantize and adaptively adjust range of quantizer that is it is going to improve the quality.
44.srt	00:26:06.999 --> 00:26:11.669	So, what you will be when you are doing adaptation, so DPCM is going to be.
44.srt	00:26:13.129 --> 00:26:17.899	named as ADPCM which has the standard G dot 7 to 6.
44.srt	00:26:18.059 --> 00:26:26.079	So, you can see from G 700, 711 and then 7 to 6 for the ADA PCM.
44.srt	00:26:26.369 --> 00:26:31.269	So, what we have here for the this thing PCM transmitter.
44.srt	00:26:31.269 --> 00:26:43.819	So, you know that it is analog input, you will be band pass filter what you will be using it to eliminate what is the kilohertz what we need it.
44.srt	00:26:44.679 --> 00:26:54.779	If it is in the 8 kilohertz, we know that it is between 50 hertz to 4 kilohertz that is what the samples what we are interested in.
44.srt	00:26:55.149 --> 00:26:58.369	So, that is the reason why what we have the bandpass filter here.
44.srt	00:26:59.009 --> 00:27:06.559	And then do the sample and hold a circuit basically, we call it as a PCM transmitter.
44.srt	00:27:06.919 --> 00:27:11.859	So, again a PAM and then you will be converting analog to digital form.
44.srt	00:27:12.329 --> 00:27:16.129	And what we have is the linear PCM what will be.
44.srt	00:27:16.519 --> 00:27:20.959	taking the output and we will use the digital compression here.
44.srt	00:27:21.489 --> 00:27:29.589	So, this compressed a PCM is going to be transmitted through the transmission medium basically.
44.srt	00:27:29.969 --> 00:27:35.259	Then this is going to be our receiver part which is going to be in the reverse direction as you can see.
44.srt	00:27:35.669 --> 00:27:46.499	So, we will be expanding the thing from compressor will be expander is going to be used here and then this again it is a linear PCM what it is going to be used and then.
44.srt	00:27:46.979 --> 00:28:04.899	will be converting into digital to analog converter and then this will be analog modulation whatever we had the thing and then we will be having the whole circuit and then convert it into or using the band pass filter.
44.srt	00:28:05.249 --> 00:28:07.889	So, we will get back our analog output.
44.srt	00:28:08.169 --> 00:28:13.789	So, this is the transmission as you can see PCM transmitter and then PCM receiver.
44.srt	00:28:13.789 --> 00:28:21.779	So, these are the blocks which are present in the transmitter and then these are the receiver blocks which is going to work on it.
44.srt	00:28:22.379 --> 00:28:37.499	So, coming to what is the this thing are differential PCM speech coding how it is going to be because what we said is from 64 kilobits per second we are reducing it to 32 kilobit per second how it is going to have.
44.srt	00:28:37.829 --> 00:28:46.969	So, we said that it is going to be what is it transmit is going to be one sample that is since the change is small between the sample.
44.srt	00:28:47.029 --> 00:28:54.349	So, we will use transmit one sample and then transmit difference between the samples what it is going to be.
44.srt	00:28:54.709 --> 00:28:57.339	So, we will be using only 4 bits to.
44.srt	00:28:57.919 --> 00:28:59.539	do the quantization.
44.srt	00:28:59.869 --> 00:29:01.859	So, how does the figure look like?
44.srt	00:29:02.199 --> 00:29:12.749	Here it is the analog input, here it is going to be a low pass filter and then what you are going to have is here there is a differentiator basically.
44.srt	00:29:13.309 --> 00:29:16.909	So, that is a summer basically this is positive and negative.
44.srt	00:29:16.909 --> 00:29:27.279	So, you will be taking the difference between that two and then you will be doing the analog to digital converter and encoded different samples what you will be.
44.srt	00:29:27.719 --> 00:29:29.919	sending it out for transmission.
44.srt	00:29:30.489 --> 00:29:48.479	And the same thing what you are going to do is you can convert it into digital to analog converter and then put the integrator and then accumulated signal level what you will be subtracting from this and then the rest of the signals are passed through this.
44.srt	00:29:48.479 --> 00:29:50.889	So, what happens at the receiver actually?
44.srt	00:29:50.939 --> 00:29:56.659	So, it has to be same replica in the reverse way what it is going to work.
44.srt	00:29:59.269 --> 00:30:29.799	So, you have a low pass filter which receives the thing sorry this is the DPCM signal what it is coming and then you are going to take it to the to the digital to analog converter and then you are passing it through the integrator in this case and then you will be adding the signals from the hold and circuit.
44.srt	00:30:30.019 --> 00:30:40.719	to check that the difference between the signals and then reconstruct it and then which is getting passed through the low pass filter and then we will be getting the analog output.
44.srt	00:30:41.099 --> 00:30:47.689	So, this is how our differential pulse code modulated speech transmission and receiver looks like.
44.srt	00:30:47.689 --> 00:30:53.419	The other way of doing is we can do the sub band speech coding.
44.srt	00:30:53.569 --> 00:30:53.869	So, what is it?
44.srt	00:30:53.869 --> 00:30:59.339	We are going to partition signal into non-overlapping frequency bands.
44.srt	00:31:03.599 --> 00:31:07.439	And, then use different A to D quantizer for each band.
44.srt	00:31:08.089 --> 00:31:10.979	So, we will be seeing that as an example.
44.srt	00:31:11.139 --> 00:31:13.169	So, if we have 3 sub bands.
44.srt	00:31:13.669 --> 00:31:21.249	So, we know that this is 5.6 kilo Hertz and 12 kilo Hertz and 13.6 kilo Hertz here.
44.srt	00:31:21.249 --> 00:31:28.449	So, sorry it is in the 3 bands what you will be having it.
44.srt	00:31:28.449 --> 00:31:34.929	So, then you can reduce from 32 kilobit per second in the DPCM to 31.2.
44.srt	00:31:36.189 --> 00:31:37.449	2 kilo bit per second.
44.srt	00:31:37.979 --> 00:31:39.159	So, what is it?
44.srt	00:31:39.499 --> 00:31:43.259	The range is band there are these are the 3 bands what you have it.
44.srt	00:31:43.629 --> 00:31:53.239	So, you will be having 50 to 700, you will be using only 4 encoding bits because most of the signals are present in the thing.
44.srt	00:31:53.239 --> 00:32:06.169	So, you will be giving more number of bits in this range and lesser 1 bit less in 700 to 2000 range and we know that not much information is here.
44.srt	00:32:06.169 --> 00:32:07.699	So, only it is going to be.
44.srt	00:32:08.259 --> 00:32:08.869	with 2 bits.
44.srt	00:32:09.059 --> 00:32:12.899	So, that this is how total what it is going to be generated.
44.srt	00:32:13.029 --> 00:32:14.479	So, what happens to this?
44.srt	00:32:14.479 --> 00:32:35.999	So, here it is going to be this thing so many kilobits per second what we have to transmit in this frequency range basically and this is the kilobit per second and this is in the third band what we have to do it total will be generating 31.2 kilobits per second.
44.srt	00:32:35.999 --> 00:32:39.769	So, how does it this is going to be looking like?
44.srt	00:32:40.549 --> 00:32:46.009	So, as you can see the name itself says that we are going to have 3 bands.
44.srt	00:32:46.459 --> 00:33:05.939	So, we will be using band pass filter in the first stage to pass only 50 to 700 hertz and then the second one is band pass filter in the range 700 to 2000 hertz and the third range is going to be 2000 to 3400 hertz.
44.srt	00:33:06.429 --> 00:33:13.089	These are the 3 bands and we need A to T gun converters in all the 3 bands.
44.srt	00:33:13.609 --> 00:33:18.729	Then, later on mix them and send it through the channel encoder.
44.srt	00:33:19.429 --> 00:33:26.409	So, this is how subband speech coding is going to happen and in the decoder part of it you will be reconstructing.
44.srt	00:33:26.949 --> 00:33:34.289	So, we will see little more on the vocoders and speech coders in the next class.
44.srt	00:33:34.799 --> 00:33:35.369	Thank you.
50.srt	00:00:01.219 --> 00:00:25.379	Welcome back to real time digital signal processing lab actually.
50.srt	00:00:25.379 --> 00:00:31.969	In the last class we discussed adaptive filters in MATLAB.
50.srt	00:00:32.579 --> 00:00:36.359	Today, we will discuss about adaptive filters in Code Composer Studio.
50.srt	00:00:36.950 --> 00:00:53.340	So, we will see that one of the thing what I will do is because the we have one of the experiment that is FIR filter noise cancellation using external inputs.
50.srt	00:00:54.350 --> 00:01:01.620	This is from the book Real-time Digital Signal Processing by Ronald Ray what I have taken the thing.
50.srt	00:01:01.620 --> 00:01:05.120	So, which has the adaptive noise that is a.
50.srt	00:01:05.709 --> 00:01:08.019	2 in IR interrupt driven.
50.srt	00:01:08.560 --> 00:01:13.670	So, that is left gets the noise and then the right channel gets the signal.
50.srt	00:01:14.219 --> 00:01:22.710	So, using the IR filter the interrupt driven what it the demo is because the adaptive value for this is very low.
50.srt	00:01:22.710 --> 00:01:33.129	So, you will be hearing most of the type noise and voice is going to be very little heard in the thing because it has taken little time.
50.srt	00:01:33.129 --> 00:01:37.710	So, I thought I will demo this experiment first and then go back to.
50.srt	00:01:38.030 --> 00:01:39.159	other experiments.
50.srt	00:01:39.480 --> 00:01:41.090	So, what is it in this case?
50.srt	00:01:41.090 --> 00:02:07.509	A desired signal and a reference noise signal to the input to left and right channels respectively what we are going to put it in and a stereo 3 sample jack, a 5 3.5 mm jack what we will be using for inputting from the laptop to the board that is the plug in dual RCA jack plug cable will be used in this case.
50.srt	00:02:09.150 --> 00:02:21.500	And, a test input signal speech noise dot wave is fed through this jack and this may be played through a sound card and input the kit via stereo 3.5 M jack.
50.srt	00:02:21.500 --> 00:02:32.170	So, in our case we are using my music basically and this is the speech noise what we will be feeding into the board.
50.srt	00:02:32.170 --> 00:02:39.319	So, we will build and we will be running this program and test it using this wave file.
50.srt	00:02:40.260 --> 00:02:50.410	So, this adaptation will be taking place the output on the left channel of line out should gradually change from speech plus noise to speech only.
50.srt	00:02:50.950 --> 00:02:57.680	And it has to be adjusted with the volume at which you play the file speech noise dot wave ok.
50.srt	00:02:58.150 --> 00:03:05.010	If the input signals are too quiet then the adaptation may be very slow that is what the thing.
50.srt	00:03:05.010 --> 00:03:07.020	So, one has to look into these things.
50.srt	00:03:08.440 --> 00:03:09.760	Moving to the next slide.
50.srt	00:03:10.210 --> 00:03:20.140	So, we will see that this is the adaptation thing what it is being real time setup.
50.srt	00:03:20.590 --> 00:03:38.820	So, line in gets the right that is signal and line in left jack gets the reference noise and you are using the IR filter here whose weights are going to be controlled using the adaptive filter.
50.srt	00:03:39.260 --> 00:03:42.860	So, you will have the signal plus noise what it is going to come.
50.srt	00:03:43.260 --> 00:03:52.270	which is going to come out as line out R and the error signal which is coming out of left channel will be output.
50.srt	00:03:53.070 --> 00:04:03.980	And this is how you can look at the what I will say is weights basically how they are getting adjusted.
50.srt	00:04:04.480 --> 00:04:09.270	So, from 0 how they will be going up what we will look at the thing.
50.srt	00:04:09.580 --> 00:04:15.240	So, coming to our code composer studio this is the file what we have it.
50.srt	00:04:15.900 --> 00:04:19.870	So, that is adaptive to in IAR.
50.srt	00:04:20.340 --> 00:04:27.230	So, what we have is this is the it uses a bilinear dot coefficient.
50.srt	00:04:27.660 --> 00:04:30.140	So, if I open the coefficient thing.
50.srt	00:04:30.650 --> 00:04:38.050	So, you will be seeing that and then that is poles and zeros have been taken in this fashion.
50.srt	00:04:38.050 --> 00:04:41.610	This is a third order filter what it has been used.
50.srt	00:04:42.240 --> 00:04:49.950	Using MATLAB and the cutoff frequency what it uses is a Chebyshev low pass filter.
50.srt	00:04:50.620 --> 00:04:55.360	with 2B pass band ripple and cut off frequency of 1500 hertz.
50.srt	00:04:55.710 --> 00:05:16.960	So, when you design in the MATLAB, so you will be getting the filters that is type 1 as I was discussing in IR filter class that Chebyshev 1 will have a ripple in the pass band and then it has a steep cut off in the stop band.
50.srt	00:05:17.230 --> 00:05:21.480	So, the ripple what in the pass band is used 2 dB basically.
50.srt	00:05:27.199 --> 00:05:29.430	And these are the coefficients taken from the MATLAB and then it will be using in our a real time implementation.
50.srt	00:05:29.430 --> 00:05:32.100	So, you are seeing that this has been loaded.
50.srt	00:05:32.889 --> 00:05:42.089	And then the this thing beta whatever this is the learning rate in this case it can be alpha beta one each one uses their own notation.
50.srt	00:05:42.410 --> 00:05:48.529	So, what it is a very slow adaptation what it is been taken 1 e power minus 12 ok.
50.srt	00:05:49.019 --> 00:05:57.170	So, and then the length of number of adaptive filter weights what it is chosen is 128 and then you will be.
50.srt	00:05:59.000 --> 00:06:10.009	making variable weights and then your n and then number of sections what you will be taking it with 2 basically because you need both a and b coefficients.
50.srt	00:06:10.009 --> 00:06:23.009	So, then you will be what you are going to get is reference noise you will be getting from the left channel and then the signal is going to be getting from the right channel.
50.srt	00:06:23.490 --> 00:06:28.079	So, that is how it has been recorded and then stored in the thing.
50.srt	00:06:28.519 --> 00:06:44.500	So, we are going to have these two mixed which is coming into our board and then this is you will be inputting reference noise and then you are doing the filtering here basically.
50.srt	00:06:45.449 --> 00:06:56.079	You are calculating your Y n output and you are updating your coefficients W n and then you are putting input Y n ok.
50.srt	00:06:56.419 --> 00:06:58.669	So, this is signal noise.
50.srt	00:06:58.870 --> 00:07:01.670	has both y n plus signal.
50.srt	00:07:02.300 --> 00:07:19.410	So, then you are making it y of n is 0 and then you have the reference noise here and then you will be computing your error basically signal noise minus y n. So, you are trying to reduce this error.
50.srt	00:07:19.990 --> 00:07:27.580	So, and then you are calculating your weights n plus 1 weights basically here using this equation.
50.srt	00:07:28.009 --> 00:07:32.930	This is your mu adaptation parameter which is named here as beta.
50.srt	00:07:33.600 --> 00:07:41.370	And, you will be updating your XFI with the previous values new one will be coming from the input signal.
50.srt	00:07:41.829 --> 00:07:47.710	And output what it is going is both left and right channel has been put with error.
50.srt	00:07:48.180 --> 00:07:51.840	Error has to reduce and then slow down.
50.srt	00:07:52.139 --> 00:07:59.730	So, because if I rerun the code again so, it will be having lot of noise in the thing.
50.srt	00:08:00.060 --> 00:08:03.780	What I will do is because it has already been run for some time.
50.srt	00:08:04.100 --> 00:08:07.759	So, if you want you can change your beta value and then look at it.
50.srt	00:08:08.090 --> 00:08:16.290	So, I had stopped the thing I will be playing it and you will be hearing little voice and there will be little error it will take longer time to adapt.
50.srt	00:08:16.400 --> 00:08:55.900	So, still you are hearing the It will take longer time to adapt actually, still you are hearing the voice in between.
50.srt	00:08:56.260 --> 00:08:57.880	noise in this case.
50.srt	00:08:57.880 --> 00:09:04.410	So, as you will be seeing that I have removed the thing from running basically.
50.srt	00:09:04.410 --> 00:09:13.450	So, from the code composer studio still the input is going into the board and then it is running.
50.srt	00:09:14.070 --> 00:09:18.170	Only when I reset the board you will not hear anything.
50.srt	00:09:18.460 --> 00:09:23.550	So, this is the first experiment because it has lot of noise initially.
50.srt	00:09:23.590 --> 00:09:26.990	So, now little bit of speech is coming it takes longer time.
50.srt	00:09:26.990 --> 00:09:29.750	So, what you can do with.
50.srt	00:09:30.070 --> 00:09:38.180	the your codes basically you can play around with little more on your adaptation by changing the thing.
50.srt	00:09:38.180 --> 00:09:46.260	So, one of the thing what I can do is I can make it 0.001 in this case.
50.srt	00:09:46.260 --> 00:09:48.340	Let us see what is the thing is going to happen.
50.srt	00:09:48.900 --> 00:09:51.770	I can store it and then I have to do recompilation again.
50.srt	00:09:51.770 --> 00:10:08.790	So, it is telling that whether I have to stop the debug session as you can see that here the diagram.
50.srt	00:10:12.470 --> 00:10:15.450	So, what I will do is I will stop the thing.
50.srt	00:10:27.130 --> 00:10:29.580	Memory was not getting cleared actually.
50.srt	00:10:30.210 --> 00:10:39.430	So, let us see it is some memory block it has still a reading error.
50.srt	00:10:39.460 --> 00:10:42.940	Let us see whether it is going to run.
50.srt	00:10:46.430 --> 00:10:47.570	I will be playing the thing.
50.srt	00:10:50.750 --> 00:11:03.000	In these cases in what you have to do is you may have to restart your board by unplugging it and plugging in.
50.srt	00:11:03.879 --> 00:11:11.660	So, all the software reset what I have switch is there I have given the reset command still it is not working.
50.srt	00:11:11.759 --> 00:11:15.050	In that what we do is we unplug and then plug the.
50.srt	00:11:15.780 --> 00:11:16.210	board.
50.srt	00:11:16.210 --> 00:11:19.780	So, that the complete memory is going to be erased.
50.srt	00:11:20.160 --> 00:11:22.810	So, this is one of the thing one has to do it.
50.srt	00:11:23.210 --> 00:11:32.690	So, just we will see whether it is going to have any effect on because I have a re-plugged my power point.
50.srt	00:11:48.730 --> 00:12:07.870	So, even if this occurs one has to take care is that no other go you have to reboot the system for the timing let me see whether I can figure it out without doing that with different experiment whether I can come up with the thing.
50.srt	00:12:08.020 --> 00:12:14.040	So, I can close this project and then restart the thing.
50.srt	00:12:14.040 --> 00:12:29.560	So, the other experiment what I will do is the first experiment will look at it.
50.srt	00:12:29.970 --> 00:12:35.920	weight does not need the real time this is the non real time what we will see it.
50.srt	00:12:36.440 --> 00:12:43.200	So, what we have is this is the adaptive filter LMS algorithm as a C program.
50.srt	00:12:43.720 --> 00:12:51.880	So, it illustrate the following steps what is it for the adaptation process using the adaptive structure as shown here ok.
50.srt	00:12:52.230 --> 00:12:54.880	This is our weight normal adaptive filter.
50.srt	00:12:55.250 --> 00:12:58.100	So, I have the LMS algorithm in this case.
50.srt	00:12:58.490 --> 00:13:01.570	So, why weights are started with 0.
50.srt	00:13:01.900 --> 00:13:15.800	y of n what I will be getting the output and then this is the desired signal what I have given the thing and then we will be subtracting error we are trying to minimize this is fed to our LMS algorithm to adjust our weights.
50.srt	00:13:16.130 --> 00:13:32.090	So, this is the equation what we will be doing it that is y of n is nothing, but w transpose n into x of n and then a of n is nothing, but d of n minus y of n and our weight update w L of n plus 1 is.
50.srt	00:13:32.510 --> 00:13:36.580	given by this mu is the adaptive step one has to follow.
50.srt	00:13:36.950 --> 00:13:42.700	So, L will be going from 0 to order of the filter L minus 1.
50.srt	00:13:43.860 --> 00:13:51.570	So, by one repeat the adaptive process for the next sampling rate what we are going to do the thing.
50.srt	00:13:51.880 --> 00:13:57.500	So, how we are going to show the even all of you with simulator you can run this algorithm.
50.srt	00:13:57.500 --> 00:14:01.390	So, how we are going to show that filter structure.
50.srt	00:14:03.950 --> 00:14:40.260	The desired signal is chosen to be 2 cos 2 n mu into f divided by fs what we have it sorry this should have been pi basically sorry I cannot correct the thing pi into f is the frequency what you wanted and then fs and the input to the adaptive filter is here also it is sin 2 n pi into f by fs where the this is the signal frequency f is equal to 1 kilohertz has been chosen and sampling frequency f is equal to 8 kilohertz.
50.srt	00:14:41.440 --> 00:14:56.400	The adaptation rate mu, so that is filter order n you can change it from that is assumed as 0.01 and then 21 is the order of the filter, number of samples chosen as 60.
50.srt	00:14:56.400 --> 00:15:02.630	So, if we will 0 to small n is this thing 60 samples.
50.srt	00:15:02.630 --> 00:15:11.310	So, we can plot this desired output that is output y output and error using T.
50.srt	00:15:11.870 --> 00:15:16.770	tools in this case graph and then single time in the code composer studio.
50.srt	00:15:17.160 --> 00:15:24.020	So, within a 60 sample instance the filter output converges to the desired cosine signal.
50.srt	00:15:24.520 --> 00:15:33.550	So, you can change the convergence rate that is 0.02 from 0.01 and verify faster rate of adaptation and convergence ok.
50.srt	00:15:33.550 --> 00:15:41.440	So, we will see the demo what the book gives.
50.srt	00:15:42.600 --> 00:15:43.430	are the blocks.
50.srt	00:15:43.520 --> 00:16:03.830	So, what we will do is we will go to this thing, code composer studio and what I will do is I will remove because I wanted to show you how you can use the same thing to run your codes basically.
50.srt	00:16:04.310 --> 00:16:13.760	So, I can remove, these are the files what I have to remove from this, I will delete them.
50.srt	00:16:16.190 --> 00:16:32.170	And, then I can add from the code basically I have stored in D directory in this case wherever in your laptop you are computer you can store wherever you want to have the thing.
50.srt	00:16:32.710 --> 00:16:38.100	So, we will see that these are the LCDK book files what I have taken the thing.
50.srt	00:16:38.670 --> 00:16:41.400	So, in this case this is from the chapter 6.
50.srt	00:16:41.510 --> 00:16:44.840	So, we will be seeing that this is the first code.
50.srt	00:16:45.900 --> 00:16:54.930	So, I will copy this c file into my directory or I can input this project from here also ok.
50.srt	00:16:55.220 --> 00:16:57.130	So, one of the thing one can do it.
50.srt	00:16:57.130 --> 00:16:59.610	So, we will import it and then put it here.
50.srt	00:17:00.150 --> 00:17:10.060	I can do the paste and then I will be do first I can do the compilation to see that I have any error ok.
50.srt	00:17:10.060 --> 00:17:11.270	I know this is about google.
50.srt	00:17:20.290 --> 00:17:20.550	Ok.
50.srt	00:17:20.550 --> 00:17:20.670	I'm sorry.
50.srt	00:17:21.000 --> 00:17:29.320	So, there is a little problem in the thing because this is on a simulator what it is going to run on.
50.srt	00:17:29.850 --> 00:17:34.480	So, what we have to do is I can import the project.
50.srt	00:17:36.590 --> 00:17:41.100	So, what I want is the CCS project.
50.srt	00:17:41.570 --> 00:17:42.790	So, I will put it as next.
50.srt	00:17:42.990 --> 00:17:46.180	I will browse from this folder.
50.srt	00:17:46.220 --> 00:18:03.840	I have imported it.
50.srt	00:18:05.520 --> 00:18:09.820	This has become my active this thing directory basically.
50.srt	00:18:10.160 --> 00:18:14.420	Let me see whether I am going to avoid errors in the thing.
50.srt	00:18:14.420 --> 00:18:14.570	Okay.
50.srt	00:18:14.570 --> 00:18:44.600	So, you will be seeing the errors what are the things listed.
50.srt	00:18:50.400 --> 00:18:59.340	Here, it is telling that what it wants is V2CC XML active what it has the thing.
50.srt	00:19:00.000 --> 00:19:14.460	So, I had to open this, I had to remove this because what I have for the board is sorry, recent update.
50.srt	00:19:16.020 --> 00:19:21.150	I can create a new ok, what I want is the target configuration file.
50.srt	00:19:21.700 --> 00:19:25.180	So, I will be calling it as new target configuration.
50.srt	00:19:25.900 --> 00:19:45.350	So, in this case what I have is USB debug probe what I have it, Texas instrument we have to check on the thing XTS110 what I have it on the board, USB debug probe what I have it.
50.srt	00:19:45.690 --> 00:19:52.620	So, one has to be careful when you are doing it real time which is the debug port what you are connecting to ok.
50.srt	00:19:52.780 --> 00:19:56.100	So, here it is what I have is LCDK6748 port.
50.srt	00:19:56.100 --> 00:20:06.460	So, I will save this configuration.
50.srt	00:20:06.460 --> 00:20:13.810	So, those who have first time they will be doing the lab can discuss that.
50.srt	00:20:16.470 --> 00:20:20.110	how it has to be done I will be giving the procedures and everything.
50.srt	00:20:20.760 --> 00:20:26.570	So, now, we will see whether by doing the this thing compilation whether my error is going to go.
50.srt	00:20:27.290 --> 00:20:47.940	There are some of the errors which is coming in what I will do is I will fix up in the next class and then come back and then tell you what were the problems with it because suddenly what happened is my active directory got crashed and then I have to redo the thing some of the errors it takes little time.
50.srt	00:20:48.250 --> 00:20:51.990	So, which I will fix it and then I will be coming back in the next class.
50.srt	00:20:51.990 --> 00:20:52.510	Thank you.
2.srt	00:00:00.910 --> 00:00:23.230	Good morning.
2.srt	00:00:23.809 --> 00:00:28.420	So in this course, we will be covering real time digital signal processing.
2.srt	00:00:28.859 --> 00:00:30.250	So we will see first.
2.srt	00:00:30.429 --> 00:00:32.480	What is the need for this course?
2.srt	00:00:33.420 --> 00:00:40.909	Ability to collect data and then we are going to analyze it and then see how we can do the modification in real time.
2.srt	00:00:41.600 --> 00:00:47.070	So, whatever data collected we will be analyzing it and then we will be processing.
2.srt	00:00:47.730 --> 00:00:53.189	So, all in one location and in one machine we call it as hardware.
2.srt	00:00:53.730 --> 00:01:01.530	So, the platforms for this machine can be either through software that is we can use PC MATLAB.
2.srt	00:01:02.120 --> 00:01:08.170	the software or using lab viewer, code composer studio these are the things what we will be using it.
2.srt	00:01:08.580 --> 00:01:21.070	The advantage if we do it in the software is flexibility, it is resilient to all conditions and then all of us know that it is very easy to use that.
2.srt	00:01:22.200 --> 00:01:34.100	The disadvantage part of it is because the all softwares we know that it is expensive and then it is slow in nature and then we need platform like PC.
2.srt	00:01:34.680 --> 00:01:39.240	And, then additional hardware to collect the data from the software.
2.srt	00:01:39.950 --> 00:01:44.689	So, the next one what we can use is the firmware or hardware basically.
2.srt	00:01:44.689 --> 00:01:49.129	In this case we will be calling it as DSPs.
2.srt	00:01:49.629 --> 00:01:58.840	So, the advantage of using this firmware or hardware is speed, cost and then practicality.
2.srt	00:01:59.200 --> 00:02:06.909	So, we know that most of the DSPs were manufactured by TI analog devices and then other companies are there in this.
2.srt	00:02:07.430 --> 00:02:17.560	The other advantage is embedded code basically to run your DSPs which we call it as firmware.
2.srt	00:02:18.260 --> 00:02:22.060	So, the signals both collected and then processed by DSPs.
2.srt	00:02:22.060 --> 00:02:36.810	The advantage of using this hardware or firmware is faster and less expensive compared to software and then it is more flexible and easier to use than the hardware.
2.srt	00:02:36.930 --> 00:02:43.129	So, in this case we will be discussing the hardware in a little while.
2.srt	00:02:43.830 --> 00:02:48.729	The disadvantage in this case is also it is going to be slower compared to hardware.
2.srt	00:02:49.300 --> 00:03:04.289	So, the complete we use the solution to use the hardware is basically either field programmable gate arrays that is FPGA or we can go for digital circuits that is basically VLSI design what we can do the thing.
2.srt	00:03:04.860 --> 00:03:17.449	The advantage in this case is because all of us know hardware uses or FPGAs use less power consumption wherever the application is there or we have.
2.srt	00:03:17.859 --> 00:03:24.289	more number of units which have to come out then better to go for complete hardware design.
2.srt	00:03:24.989 --> 00:03:33.719	And then it is going to be fast in running of your algorithms or any application.
2.srt	00:03:34.129 --> 00:03:43.669	So, as an example FPGAs we know that Xilinx, Altira and then now recently Intel is coming with the FPGAs.
2.srt	00:03:44.289 --> 00:03:48.250	The disadvantage in hardware is because it is fragile.
2.srt	00:03:51.409 --> 00:04:05.369	we call it and then it is difficult to use because people should know how to design to the core level and then you should know the knowledge of architecture basically.
2.srt	00:04:05.369 --> 00:04:10.079	So, whether you are using the CMOS architecture or NMOS architecture.
2.srt	00:04:10.379 --> 00:04:14.399	So, you should know core level how to design your circuits.
2.srt	00:04:14.899 --> 00:04:20.930	So, the other level of it is what we can have is system level processors.
2.srt	00:04:21.149 --> 00:04:22.899	what we call it.
2.srt	00:04:23.250 --> 00:04:31.800	So, when we have high volume requirement then we go for the system of course processor design.
2.srt	00:04:32.519 --> 00:04:44.920	So, in the present lectures that is in real time signal processing it is designed to enable the teachers and engineering who are in that program.
2.srt	00:04:45.019 --> 00:04:51.639	And then facilitate the students to become good signal processing.
2.srt	00:04:51.849 --> 00:04:52.719	engineers.
2.srt	00:04:53.279 --> 00:04:58.899	And then this enables students to have hands on experience on the real time signal processing.
2.srt	00:04:59.589 --> 00:05:04.300	The course contains both the theory as well as lab component.
2.srt	00:05:04.829 --> 00:05:09.209	The course is going to be offered in three modules what we call it.
2.srt	00:05:09.579 --> 00:05:14.069	The first module M1 we call signal analysis and filters.
2.srt	00:05:14.459 --> 00:05:18.819	And then the second module will be covering frequency domain analysis.
2.srt	00:05:19.230 --> 00:05:29.159	And then the third module covers applications of some of the real time nature architectures and other things what we will be considering in the real time signal processing.
2.srt	00:05:29.699 --> 00:05:46.819	And, then we have each module will be consisting of one credit and then each module is offered in about 60 units of about half an hour video of lectures which have lab sessions also.
2.srt	00:05:47.480 --> 00:05:59.819	So, we are going to have weekly assignments and laboratory implementations because most of the colleges have DSK 6713 board.
2.srt	00:06:00.129 --> 00:06:00.680	hardware.
2.srt	00:06:01.050 --> 00:06:07.500	So, they can use them in the college or we are going to provide hardware interface.
2.srt	00:06:07.689 --> 00:06:15.310	So, those who want to do it remotely can be used the hardware which is available in our lab.
2.srt	00:06:15.910 --> 00:06:18.510	So, how this course is going to be useful?
2.srt	00:06:19.110 --> 00:06:26.790	It can be for working or aspiring faculty or faculties in engineering colleges.
2.srt	00:06:27.129 --> 00:06:32.940	So, because they will be having little difficulty in interfacing the board and then running some of the experiments.
2.srt	00:06:32.940 --> 00:06:34.100	So, it will help.
2.srt	00:06:34.560 --> 00:06:38.140	all of these people and then even the graduate students.
2.srt	00:06:38.440 --> 00:06:44.760	So, they want to develop some signal processing algorithms in hardware it will be of help to them.
2.srt	00:06:45.650 --> 00:06:56.650	Companies who wish to develop real time signal processing algorithms because we will be covering not just C programming or any other languages.
2.srt	00:06:56.720 --> 00:07:00.380	So, we will be little bit going deeper into the core level design.
2.srt	00:07:00.480 --> 00:07:03.000	So, that people will.
2.srt	00:07:06.070 --> 00:07:11.930	get the hands on information how it has to be coded in the higher level languages also.
2.srt	00:07:12.650 --> 00:07:18.930	And then companies can be can use it for training and then upskilling their employees.
2.srt	00:07:19.800 --> 00:07:24.960	So, what will be the course outcomes that is what we will be seeing in this slide.
2.srt	00:07:25.600 --> 00:07:29.970	At the end of this course that is three modules what we are covering it.
2.srt	00:07:30.440 --> 00:07:34.570	The learner should be able to that is basically module 1.
2.srt	00:07:34.920 --> 00:07:37.160	So, which you will be seeing the sub modules.
2.srt	00:07:37.680 --> 00:07:44.990	Understand DSP elements including your DSP functional blocks, DSP hardware options we will be discussing.
2.srt	00:07:45.680 --> 00:07:55.160	Fixed point and floating point DSP devices and what is the advantage of using fixed point number system compared to floating point.
2.srt	00:07:55.760 --> 00:07:59.190	Real time constraints what we will be discussing about it.
2.srt	00:07:59.190 --> 00:08:04.580	Some of the algorithms what we will be covering will be covered in this course and software development process.
2.srt	00:08:07.879 --> 00:08:17.550	So, this will take us somewhere around 3 hours to complete this module and then followed by what we will have is the lab 1.
2.srt	00:08:18.180 --> 00:08:24.850	So, use of code composer studio in simulator mode initially we will start for DSK6713.
2.srt	00:08:24.850 --> 00:08:32.810	So, the software is simulator software is going to be provided and then you can run few examples those who are unable to access the hardware board.
2.srt	00:08:32.810 --> 00:08:36.720	So, initially we will.
2.srt	00:08:39.120 --> 00:08:40.330	to in simulator mode.
2.srt	00:08:41.379 --> 00:09:01.649	So, the next this thing course outcome what we will be seeing it design low pass high pass band stop and band pass the FIR filters using windowing, handing or hamming or we will be using the case window.
2.srt	00:09:02.389 --> 00:09:09.990	And then same thing what we will be designing using Butterworth or Chebyshev 1 and then 2.
2.srt	00:09:10.610 --> 00:09:17.830	IER filters in cascade mode using initially MATLAB FDA toolbox.
2.srt	00:09:17.830 --> 00:09:23.430	I think it will be renamed as filter design toolbox in the latest versions.
2.srt	00:09:23.430 --> 00:09:31.889	So, whatever version is there students can use that because it is available in the net.
2.srt	00:09:32.639 --> 00:09:44.620	So, we are going to accompany this lab session with how to use the FDA toolbox to design these filters, how we are going to specify the specifications.
2.srt	00:09:45.059 --> 00:09:50.279	and then how we will be using these filter coefficients because the design is going to happen using MATLAB.
2.srt	00:09:50.829 --> 00:10:17.139	And then we will use this filter coefficients to your FIR filtering it can be real time FIR filter what we will be using it in either initially we can do it in the simulator, later on we can compare with the MATLAB code how it is going to work whether it is in a similar fashion or not later on we will be using the hardware to design the same thing.
2.srt	00:10:17.369 --> 00:10:32.809	So, input will be using some noise signal with the original signal and we will see how the filter is going to perform in its best way to get us noise removed from the input signal.
2.srt	00:10:33.219 --> 00:10:44.189	So, the third module what will course outcome is going to be design of our FIR and IR filters that is basically we will be taking care of quantization effects.
2.srt	00:10:47.509 --> 00:10:59.789	Because, in the analog mode we know that we do not have any quantization problems creeping in, but when we come to digital domain we know that quantization is going to play a havoc in so many other cases.
2.srt	00:11:00.169 --> 00:11:07.179	So, we will be seeing that how this effects are going to modify the filter characteristic.
2.srt	00:11:07.289 --> 00:11:14.119	So, that we will be able to check that whether we are in the permitted flavor or not.
2.srt	00:11:14.119 --> 00:11:21.169	So, the same thing we will be implementing in the lab with.
2.srt	00:11:21.370 --> 00:11:33.889	the low pass filter using C code using that DSK6713 board and real time scenario as I was mentioning in the previous outcome also.
2.srt	00:11:34.179 --> 00:11:39.949	Here what we are going to use is the speed signal corrupted with some noise.
2.srt	00:11:40.240 --> 00:11:55.049	So, that is going to be fed into the board and then we will see these filters how it is going to remove the all of us know that noise is high frequency component which is present in the low frequency component.
2.srt	00:11:55.509 --> 00:12:07.620	which is going to be removed and then we will be seeing the whatever the speakers what he want speech is going to be clean speech what it will be coming out of it.
2.srt	00:12:07.909 --> 00:12:14.069	So, we will because it is going to take little interfacing and other things what we have to discuss in hardware.
2.srt	00:12:14.500 --> 00:12:17.889	So, we will be taking around 2 hours to discuss about it.
2.srt	00:12:20.389 --> 00:12:29.490	So, coming to this we saw that we had signal analysis and then filters in the module 1.
2.srt	00:12:29.680 --> 00:12:32.420	two course outcomes are going to be as follows.
2.srt	00:12:32.950 --> 00:12:39.529	So, how first we will be determining the characteristics of signal spectrum using a radix II FFT.
2.srt	00:12:39.670 --> 00:12:46.170	And then we are going to apply it for long signals using overlap add and save methods.
2.srt	00:12:46.200 --> 00:12:54.909	And we will be using the DFT comparison with respect to FFT how it is going to be faster.
2.srt	00:12:55.670 --> 00:13:02.190	And then we will have the because we know that when we are in the digital domain.
2.srt	00:13:02.990 --> 00:13:25.759	We said that how the quantization is going to affect in the filters same way how in doing our frequency domain analysis and then comparing design part of it how quantization and even the scaling of inputs how it will be affecting the signals and how we are going to take care of it is going to be discussed in this module.
2.srt	00:13:26.350 --> 00:13:34.909	So, the accompanying lab part of it is going to be we will be analyzing the spectral basically whatever is given.
2.srt	00:13:35.379 --> 00:13:37.120	using the Radix II FFT.
2.srt	00:13:37.639 --> 00:13:45.979	In this case we will be using the DSK6713 board either in simulator mode or in the hardware.
2.srt	00:13:46.339 --> 00:13:51.990	So, the accompanying code what we will be writing is in C basically.
2.srt	00:13:52.719 --> 00:14:05.429	So, the next one is because how to generate different sine waves signals what we will be checking up because we know that IR filter.
2.srt	00:14:05.879 --> 00:14:14.419	when we put it in oscillatory mode, once the input is remote it can oscillate itself.
2.srt	00:14:14.720 --> 00:14:24.659	So, we can use this concept to generate sine waves with specified frequency and amplitude what we can run it.
2.srt	00:14:24.970 --> 00:14:34.230	And the other way of implementing is you can we can use the lookup table by generating sine or cos functions signals can be generated.
2.srt	00:14:35.860 --> 00:14:48.909	So, component to for the lab is will be using the IR filter in the oscillatory mode to generate sine wave using the DSK673, it can be used both in simulator as well as bolt.
2.srt	00:14:49.649 --> 00:14:53.820	So, coming to the next module that is 3 actually.
2.srt	00:14:54.139 --> 00:14:59.190	So, we will be checking little bit of applications what we have specified.
2.srt	00:14:59.820 --> 00:15:03.899	The first one is going to be how to improve signal to noise ratio.
2.srt	00:15:04.419 --> 00:15:08.419	That is basically will be speech or audio signals.
2.srt	00:15:08.850 --> 00:15:13.920	using LMS algorithm first in MATLAB what we are going to use it.
2.srt	00:15:14.660 --> 00:15:22.030	And then later on the lab component will be implementing in real time using DSK6713.
2.srt	00:15:22.540 --> 00:15:39.320	So, we know that FIR and IR filters have fixed coefficients basically, but if there is any noise in the input or in the surroundings they will be not performing whatever we would like.
2.srt	00:15:44.540 --> 00:15:51.710	So, how we can do the adaptive filter we will be seeing it using LMS algorithm.
2.srt	00:15:52.620 --> 00:16:02.950	So, the next outcome is how we will use this some of the design filters to generate synthetic output.
2.srt	00:16:03.240 --> 00:16:10.490	That is basically process this is baseband signals for one what we will be doing equalization.
2.srt	00:16:10.920 --> 00:16:13.210	So, all of us know that the.
2.srt	00:16:17.590 --> 00:16:23.990	How we can make all of you have heard about the karaoke or whatever may be the thing.
2.srt	00:16:23.990 --> 00:16:31.759	So, in your mobiles and other things what will be using it you will be suppressing the voice and then you will be having the instruments basically.
2.srt	00:16:32.490 --> 00:16:42.860	How you can record your own voice along with the instruments by suppressing some of it by doing equalization what will be looking at one of the application.
2.srt	00:16:43.340 --> 00:16:46.580	The other one we know that if we go for.
2.srt	00:16:47.180 --> 00:17:00.570	out station in a hilly region or wherever we speak about it, we know that how echo is going to be generated, can we generate the synthetically that is what we will be looking as in one more application.
2.srt	00:17:00.660 --> 00:17:15.700	Next one is reverberation basically lot of people will be speaking multiple things, how it can be multiple echoes what we can have it what we call it as reverberation, how we can generate it.
2.srt	00:17:18.819 --> 00:17:23.279	And then later on we can see that how this can be eliminated also.
2.srt	00:17:23.779 --> 00:17:43.709	So, the next one is all of us know that speech basically coding that is whatever the speech we are recording or whatever may be the thing there are different ways of storing them, how to do the compression and other things.
2.srt	00:17:43.709 --> 00:17:47.089	So, one of the example we will take it how we can.
2.srt	00:17:48.760 --> 00:17:54.980	implemented or we will be looking at basically in this module.
2.srt	00:17:55.890 --> 00:18:02.140	The other one we will going to have lab component after learning about the theory.
2.srt	00:18:02.540 --> 00:18:19.320	So, how we will use or whatever the filter we have designed earlier that is low pass, high pass and band pass filters in the baseband signal for the equalization, for the echo how we are going to delay the speech and then generate a echo.
2.srt	00:18:19.500 --> 00:18:23.670	and even the reverberation how multiple peoples are speaking what we can generate it.
2.srt	00:18:24.130 --> 00:18:30.360	And in the speech coding also some of the things what we will be looking using TSK board.
2.srt	00:18:31.390 --> 00:18:40.530	So, this is what this course outcome the last one what we will be looking in this module is going to be little flavor on the image processing.
2.srt	00:18:40.980 --> 00:18:46.400	So, in this case only discrete cosine transform what we will be looking at.
2.srt	00:18:46.920 --> 00:18:49.420	So, we will be seeing how fast.
2.srt	00:18:49.780 --> 00:18:54.670	8.1 ddct implementation in using code composer studio we can implement.
2.srt	00:18:55.200 --> 00:19:10.480	And then check that how this can be used in the 2D domain that is using separable transform to check the compression achieved for images in DSK board.
2.srt	00:19:10.480 --> 00:19:14.840	So, these are the course modules what we have it.
2.srt	00:19:14.840 --> 00:19:19.090	So, in the next session what we will be taking.
2.srt	00:19:20.299 --> 00:19:28.500	with the regular course basically basics of signal processing as a module 1 what we will be looking at.
2.srt	00:19:29.019 --> 00:19:41.250	So, what I will say is happy learning and then thank you with introduction of this real time signal processing.
2.srt	00:19:41.250 --> 00:19:41.819	Thank you.
51.srt	00:00:00.340 --> 00:00:25.760	Namaste, welcome back to real time digital signal processing course.
51.srt	00:00:33.019 --> 00:00:34.239	Last class we discussed about discrete cosine transform in 1D how we are going to reconstruct the 2D form.
51.srt	00:00:34.629 --> 00:00:37.729	So, today we will continue discrete cosine transform.
51.srt	00:00:38.299 --> 00:00:48.250	So, as we are continuing in the previous class as I said from 1D DCT we reconstructed for 2D DCT.
51.srt	00:00:48.609 --> 00:00:55.759	So, today we will see how we can do the that is inverse of 2D DCT how we are going to implement it.
51.srt	00:00:56.149 --> 00:00:58.609	So, forward DCT what we had seen the thing.
51.srt	00:01:03.809 --> 00:01:08.579	So, we know that y is given as c into c x transpose into transpose what will be taking it.
51.srt	00:01:08.890 --> 00:01:23.319	So, this is x transpose what we have it here and then the transpose of it will be giving as this way what is it y is equal to c into x into c transpose what we can write it.
51.srt	00:01:23.709 --> 00:01:27.119	Since c is an orthogonal what we had seen in the last class.
51.srt	00:01:27.469 --> 00:01:35.639	So, we can solve for x using the fact that the inverse of it c inverse what it is going to be equal to c into.
51.srt	00:01:36.389 --> 00:01:42.489	transpose basically what we have assumed it we have shown because of the orthogonal property.
51.srt	00:01:43.119 --> 00:02:06.009	So, therefore, what happens to this it will be equivalent to C transpose Y into C. So, how we are going to reconstruct this image in mathematical terms let X is equal to X side J be a matrix of N squared real numbers and Y will be YKL be the 2D DCT of X.
51.srt	00:02:06.409 --> 00:02:17.030	So, x what will be taking it and we know the a naught coefficient is going to be 1 by root 2 and a k is going to be 1 for k greater than 0.
51.srt	00:02:17.729 --> 00:02:35.799	Then what is our p n s comma that is comma t going to be represented as in the 2 d 2 by n is our scaling factor k will be going from 0 to n minus 1 that is the size of our matrix.
51.srt	00:02:36.429 --> 00:02:40.709	And, because it is a 2D so, I will be having a double summation.
51.srt	00:02:41.189 --> 00:03:03.469	So, y k l into a k into a l. So, into cos k 2 s plus 1 into pi divided by 2 n into cos l 2 j plus 1 into n by 2 n. So, this is how our 2D DCT is going to be represented.
51.srt	00:03:03.469 --> 00:03:09.599	And, we say that the satisfied P n l comma j equal to.
51.srt	00:03:10.789 --> 00:03:16.659	x i j for i comma j is varying from 0 to n minus 1.
51.srt	00:03:17.369 --> 00:03:20.560	So, how we are going to do the reconstruction of this?
51.srt	00:03:20.979 --> 00:03:26.279	So, the new matrix and then what we show is the compressed image here.
51.srt	00:03:26.829 --> 00:03:35.489	So, we have these are the values what it is available and then this is the image what it has been compressed to.
51.srt	00:03:37.019 --> 00:03:40.859	So, can you make the difference between the original?
51.srt	00:03:41.329 --> 00:03:43.659	because, I said this is a compressed image.
51.srt	00:03:43.959 --> 00:03:48.029	So, in the next one we will be comparing with original and then compressed image.
51.srt	00:03:48.979 --> 00:03:54.929	So, how much difference you are going to make out between the two what you can look at it.
51.srt	00:03:55.249 --> 00:04:11.009	So, as you can see that here you will be seeing the little bit of difference in the thing here it is white whereas, here what you are seeing is as white and then here you have seen that all of them have.
51.srt	00:04:11.879 --> 00:04:16.019	white in the thing that is after compression what we are looking at it.
51.srt	00:04:17.769 --> 00:04:25.929	So, that was this thing what is it black and white patches what you had seen the difference between the thing.
51.srt	00:04:26.389 --> 00:04:28.819	Now, we will see the image basically.
51.srt	00:04:29.349 --> 00:04:33.789	So, we have the original lena image and this is the compressed image.
51.srt	00:04:34.289 --> 00:04:37.929	So, is it possible for you to find the difference minute difference.
51.srt	00:04:37.929 --> 00:04:42.339	So, if you are too good enough you can find a difference between the two.
51.srt	00:04:43.619 --> 00:04:48.289	So, what is it we have discussed about the linear quantization in previous classes.
51.srt	00:04:48.749 --> 00:04:52.779	So, we will not zero the bottom half of the matrix.
51.srt	00:04:53.319 --> 00:05:01.369	So, that is idea is to assign fewer bits of memory to store information in the lower right corner of the DCT matrix.
51.srt	00:05:01.939 --> 00:05:11.019	Previous quantization what we did was lower that is half diagonal below that what we have made everything as 0.
51.srt	00:05:11.509 --> 00:05:13.919	So, here instead of making it 0.
51.srt	00:05:14.339 --> 00:05:19.619	So, number of bits allocated for this values is going to be made less.
51.srt	00:05:19.829 --> 00:05:26.229	So, that we can have the method of linear quantization included in it.
51.srt	00:05:26.759 --> 00:05:29.189	So, now how we are going to do that?
51.srt	00:05:29.759 --> 00:05:33.389	So, use the quantization matrix basically Q.
51.srt	00:05:34.109 --> 00:05:45.839	So, what is it Q K i is 8 P into K plus L plus 1 for 0 less than or equal to K comma L which is less than or equal to 7.
51.srt	00:05:46.429 --> 00:05:54.039	So, we say that p is called the last parameter and it is going to acts like a knob to control compression.
51.srt	00:05:54.659 --> 00:05:58.009	So, the greater p is the more you compress the image.
51.srt	00:05:58.359 --> 00:06:03.099	So, p can vary from 1 to whatever value you are going to take it.
51.srt	00:06:03.479 --> 00:06:17.249	So, if you look at it the quantization matrix p multiplied with 8 that is 16, 24, 30, 40, 48, 56 and then 64 are the values.
51.srt	00:06:18.689 --> 00:06:26.519	take 8 as the thing in the first row then you will be seeing that 1624 what you will be seeing it.
51.srt	00:06:26.899 --> 00:06:34.639	This is the multiplication of what you will be seeing is 8 what you are going to assume as the Q matrix.
51.srt	00:06:35.079 --> 00:06:42.449	So, that means, to say you will divide your DCT value with respect to this matrix.
51.srt	00:06:42.629 --> 00:06:50.549	So, that whichever is low values you will be seeing that they become very small and then you can represent.
51.srt	00:06:50.729 --> 00:06:52.989	them with the fewer bits.
51.srt	00:06:53.559 --> 00:06:59.999	As you can see that one each entry in the DCT matrix by the quantization matrix.
51.srt	00:07:00.319 --> 00:07:04.599	So, this is our DCT matrix and this is our quantization matrix.
51.srt	00:07:04.949 --> 00:07:12.189	So, what we are going to do is divide each element by each of these values ok.
51.srt	00:07:12.559 --> 00:07:16.339	The first one is our DC which is going to be divided by 8.
51.srt	00:07:16.989 --> 00:07:22.219	So, what happens it will be when p is equal to 1 this becomes minus 38.
51.srt	00:07:23.199 --> 00:07:29.089	So, you can compute and then cross verify whether you are getting it correctly or not ok.
51.srt	00:07:29.399 --> 00:07:33.659	So, the next one is a 210 is going to be divided by 16.
51.srt	00:07:34.129 --> 00:07:36.889	So, you will be seeing that is the 13 value.
51.srt	00:07:37.169 --> 00:07:44.289	So, you will be seeing for the rest of the values automatically lot of them have got 0s.
51.srt	00:07:44.289 --> 00:07:50.369	And you will be seeing that there are few coefficients which are greater than 0 are left on this.
51.srt	00:07:50.999 --> 00:07:54.519	And then here what you will be seeing it is few of them.
51.srt	00:07:55.309 --> 00:08:03.069	in the what we call it as this is the DC coefficient, these are the few AC coefficients on the top corner what is left.
51.srt	00:08:03.069 --> 00:08:06.689	So, when I use p is equal to 4.
51.srt	00:08:07.439 --> 00:08:16.919	So, what happens to that can you guess that when p is equal to 1 what we had the first one was 8 and 16.
51.srt	00:08:17.419 --> 00:08:26.569	So, whereas, when p is equal to that is this is p is equal to 1 when p is equal to 4 what will be the value of it.
51.srt	00:08:26.679 --> 00:08:28.279	So, you can see that.
51.srt	00:08:28.989 --> 00:08:50.569	So, this becomes 32 and so on ok, you can multiply with the thing and then you will be seeing that minus whether you are going to go it is easier to do minus 9 into your 32 whether it belongs to whatever value you want to get is minus 304.
51.srt	00:08:51.069 --> 00:08:59.229	So, are we getting it?
51.srt	00:08:59.469 --> 00:09:09.709	or you can do minus 3 naught 4 divided by 9 that will be the easiest way of representing it what is the p value what I have chosen.
51.srt	00:09:10.229 --> 00:09:20.529	So, approximately as I am putting it is 32 ok.
51.srt	00:09:20.750 --> 00:09:25.569	So, you eliminate the thing only retain the integer values.
51.srt	00:09:25.949 --> 00:09:30.769	So, you can see that compared to this the value has got.
51.srt	00:09:31.439 --> 00:09:32.459	quite reduced.
51.srt	00:09:32.699 --> 00:09:38.379	So, number of bits to represent this is very a fever bits.
51.srt	00:09:38.669 --> 00:09:45.799	So, can you guess how many bits I needed because I can go 0 to 15 with 4 bits fine.
51.srt	00:09:45.799 --> 00:09:55.519	Whereas, minus 38 means I can I have to go to the power of 2 always.
51.srt	00:09:55.519 --> 00:09:58.240	So, 64 is a maximum what I have to represent.
51.srt	00:09:58.579 --> 00:10:02.469	So, which I will be requiring how many bits can you.
51.srt	00:10:02.950 --> 00:10:05.360	compare here in this case.
51.srt	00:10:05.740 --> 00:10:11.600	So, 2 to the power of 6 is 64, I need 6 bit.
51.srt	00:10:12.039 --> 00:10:14.629	So, 6 bits to represent this value.
51.srt	00:10:14.629 --> 00:10:18.059	So, I have reduced by 2 more bits in this case.
51.srt	00:10:18.529 --> 00:10:23.360	So, it depends on how much detail I want to retain.
51.srt	00:10:23.639 --> 00:10:41.000	So, by using p is equal to 4 whether I can do with that is what it says there are 14 terms left in y in the case of p is equal to 1 whereas, in the new p is equal to 4 we are left with only 10 terms.
51.srt	00:10:41.370 --> 00:10:47.240	So, 4 terms have come down in the thing and then the number of bits representation for this is also reduced.
51.srt	00:10:47.570 --> 00:10:52.790	So, can you see now after doing that p is equal to 1 and then p is equal to 4.
51.srt	00:10:53.370 --> 00:11:07.320	So, what are the differences you are making out between the two that is what one has to consider and then see what kind of quantization matrix you want to use it to represent your output.
51.srt	00:11:07.680 --> 00:11:12.570	So, you will be seeing using the linear quantization.
51.srt	00:11:13.040 --> 00:11:16.300	with respect to p is equal to 1 and then p is equal to 4.
51.srt	00:11:16.840 --> 00:11:28.970	So, how you are changing the thing you can see here by grey value it has gone to completely white and then some of them some of it what you can find the difference.
51.srt	00:11:29.350 --> 00:11:37.870	But coming to the image you may you have not noticed p is equal to 1 later on we will see with p is equal to 4 how much difference we are going to get it.
51.srt	00:11:38.230 --> 00:11:41.730	So, in terms of memory storage what we look at it.
51.srt	00:11:42.129 --> 00:11:46.460	So, the original image what we had it 1 byte that is 8 bits per.
51.srt	00:11:46.899 --> 00:11:49.320	pixel what we wanted it to be represented.
51.srt	00:11:49.820 --> 00:12:02.690	So, the amount of memory needed was 8 into 8 that is a block is basically 8 into 8 square what we wanted that is 512 bits what we want.
51.srt	00:12:03.070 --> 00:12:08.710	For this block 8 into 8 into 8 bits per pixel.
51.srt	00:12:08.870 --> 00:12:11.560	So, that is how we will be needing 512 bits.
51.srt	00:12:12.080 --> 00:12:17.620	So, doing the linear quantization P if we do not use any of the value of P.
51.srt	00:12:18.000 --> 00:12:22.899	then we need 512 bits and the number of bits per pixel what we need it is 8.
51.srt	00:12:23.590 --> 00:12:30.649	Whereas, if we use p is equal to 1 then total number of bits what will be having is only 249.
51.srt	00:12:30.649 --> 00:12:37.829	You can go back and then check in one of the cases and then number of bits per 6 pixel what we need is 3.89.
51.srt	00:12:37.939 --> 00:12:47.699	So, like that 2 and then 3 you will be seeing it that is total bits in p is equal to 2 is 191 whereas, in 3 it is 147.
51.srt	00:12:48.950 --> 00:12:59.250	So, you will be seeing that if we use p is equal to 3 if we are not going to lose much of the information then only 2.3 bits per 6 pixel what we needed to represent it.
51.srt	00:12:59.279 --> 00:13:04.560	So, this is how number of bits and then our memory storage is going to come down.
51.srt	00:13:05.899 --> 00:13:07.310	We have seen the JPEG imaging.
51.srt	00:13:07.470 --> 00:13:12.570	So, what it says is fairly easy to extend this to application to color images.
51.srt	00:13:12.629 --> 00:13:17.149	What we have seen was the black and white in the previous case.
51.srt	00:13:18.790 --> 00:13:30.840	So, Now, you will be wondering why the thing this is for the black and white when I use the color as we discussed in the first class of DCT that it has to be represented RGB.
51.srt	00:13:31.040 --> 00:13:35.420	So, we will be multiplying by 3 colors basically.
51.srt	00:13:35.450 --> 00:13:41.399	So, you will be seeing that each pixel is assigned 3 integers for each color intensity.
51.srt	00:13:41.480 --> 00:13:52.300	So, what is it here it is you will be seeing red you can see that R is 1.
51.srt	00:13:52.819 --> 00:13:55.129	G is 0 and B is 0 in this.
51.srt	00:13:55.610 --> 00:14:11.429	As you move across so, you will be seeing that something here dark pink what you have it which will be having both R component, red component and then a blue component and then green is going to be 0 in this.
51.srt	00:14:11.759 --> 00:14:21.490	When you come to white you will be seeing that all of them are 1 RGB is equal to 1 it becomes white and all of them are 0s it becomes black.
51.srt	00:14:22.059 --> 00:14:29.409	Whereas, when you have only green part of it has to be represented you will be seeing that it is going to be 0 1 comma 0 here.
51.srt	00:14:30.100 --> 00:14:41.830	And, the combination now from here to there you will be seeing that red is 0 here and then you will have the green component and then blue component which will be mixing from both the ends.
51.srt	00:14:42.259 --> 00:14:51.190	And you will be seeing on the other side also as it is represented with the cube how different colours are represented with your RGB.
51.srt	00:14:53.159 --> 00:15:00.529	So, how to go with this basically a few ways to approach the image compression.
51.srt	00:15:01.139 --> 00:15:09.500	That is repeat the discussed process independently for each of the three colors and then reconstruct the image.
51.srt	00:15:09.940 --> 00:15:18.769	So, we will be doing the compression in the R plane and then G plane and then the B plane and then we can mix it and then do it.
51.srt	00:15:19.220 --> 00:15:24.970	So, that is what it says baseline JPEG uses a more delicate approach.
51.srt	00:15:25.279 --> 00:15:31.080	How it is done that is usually we will represent with respect to luminance.
51.srt	00:15:31.459 --> 00:15:35.509	what is that coordinate to be y coordinate.
51.srt	00:15:35.990 --> 00:15:38.789	So, what how the value is going to be defined.
51.srt	00:15:38.819 --> 00:15:51.519	So, you will be taking 0.299 of r plus that is you will be seeing 50 percent of the green value what you will be taking it and then the lowest is 0.114 of the blue component.
51.srt	00:15:51.519 --> 00:15:55.639	Because green is more perceptive to our eyes.
51.srt	00:15:55.639 --> 00:16:01.949	So, which is given more weightage and you will be seeing that one fourth of it is given to red and then.
51.srt	00:16:02.899 --> 00:16:06.099	the blue gets the least preference.
51.srt	00:16:06.579 --> 00:16:10.449	And then you will be defining the color differences coordinates.
51.srt	00:16:10.750 --> 00:16:14.089	So, then we call it as YUV representation.
51.srt	00:16:14.469 --> 00:16:19.629	U is going to have b minus y and then v will be having r minus y.
51.srt	00:16:20.199 --> 00:16:28.099	So, with luminance and then u and v component YUV what we can represent are color images also.
51.srt	00:16:28.099 --> 00:16:33.189	So, how it is going to be the transformation what you will be saying.
51.srt	00:16:33.809 --> 00:16:46.669	RGB what you have it that is this is R, R G is here and then B you will be shifting to YUV system which is both the ways possible.
51.srt	00:16:46.759 --> 00:16:55.529	So, you have been shown from here to here from YUV you can get back your RGB also that is what it means that it is reversible.
51.srt	00:16:56.089 --> 00:17:03.819	So, you will be seeing a few of the colours that is from 3 dimensional what you have done is come down to.
51.srt	00:17:04.119 --> 00:17:11.099	only two dimensional what you have is u and v what are the coordinates with the your colours have been mapped in to.
51.srt	00:17:11.619 --> 00:17:25.789	So, it applies that DCT filtering independently to y u and v using the quantization matrix q r what we can use it and then apply it and then get the result.
51.srt	00:17:26.669 --> 00:17:28.589	So, how is the luminance?
51.srt	00:17:28.589 --> 00:17:36.119	So, I think the bulb shows how it is going to glow correct that is what we call it as luminance.
51.srt	00:17:36.549 --> 00:17:38.729	So, you will be seeing the quantization.
51.srt	00:17:38.930 --> 00:17:47.079	Q y here p is given these values to represent the thing.
51.srt	00:17:47.460 --> 00:18:03.779	So, you are earlier we had taken the quantization matrix basically p is equal to 1 means it is a multiple of 8 what we have taken the thing, but here you can see it is with the different p what you are representing the matrix for the quantization.
51.srt	00:18:05.129 --> 00:18:09.169	And then the chrominance what you will be seeing is Q c.
51.srt	00:18:09.710 --> 00:18:12.360	is represented with this.
51.srt	00:18:12.660 --> 00:18:19.650	So, you will be seeing that most of them are 99 is the value what it will be going.
51.srt	00:18:19.970 --> 00:18:27.009	So, you will be representing these colors using the chrominance value of these matrix basically.
51.srt	00:18:27.600 --> 00:18:29.319	So, how we are going to do that?
51.srt	00:18:29.559 --> 00:18:39.230	We know that human eye is more sensible to luminance that is y coordinate and it is less sensible to our color images that is UV coordinates.
51.srt	00:18:39.660 --> 00:18:42.210	So, then compress more on UV.
51.srt	00:18:42.559 --> 00:18:43.710	and less than y.
51.srt	00:18:44.200 --> 00:18:50.029	Consequences color images are more compressible than grayscale ones as you can see it.
51.srt	00:18:50.799 --> 00:18:54.289	So, how we are going to reconstitute the thing?
51.srt	00:18:54.809 --> 00:19:03.599	After compression our YUV are recombined and converted back to RGB to form the compressed color image.
51.srt	00:19:03.899 --> 00:19:13.750	So, blue is represented with U plus Y and our red is going to be with V and then Y and then G is going to be you are seeing that.
51.srt	00:19:14.329 --> 00:19:43.089	Y into 0.299 of R minus point Y that is luminance Y minus 0.299 of red minus 0.114 of blue whole divided by whatever we had represented our green with that is the 0.587 what we had represented in the original for the green we had given the weightage to calculate luminance.
51.srt	00:19:46.030 --> 00:19:47.890	is divided by 0.587.
51.srt	00:19:47.890 --> 00:19:50.400	So, what is it?
51.srt	00:19:50.400 --> 00:19:57.000	In the equation what you will be substituting it basically what I have in the equation is this is my y.
51.srt	00:19:57.000 --> 00:20:04.410	So, you will be doing 0.587 g equal to transform these into the other part of it.
51.srt	00:20:04.410 --> 00:20:15.200	So, that is why you will be getting y minus 0.299 r minus 0.114 b and to get g we have to divide this by its weight that is 0.587.
51.srt	00:20:15.330 --> 00:20:18.820	So, this is how you will be reconstructing your green.
51.srt	00:20:22.070 --> 00:20:25.480	So, coming to comparing the compression.
51.srt	00:20:25.860 --> 00:20:34.820	So, this is lena has been taken this is the original image and then if I give p is equal to 1.
51.srt	00:20:35.230 --> 00:20:50.330	So, the compressed image is shown in this way and you will be seeing the other compression p is equal to 4.8 basically what it is chosen instead of 4 and then you can see your lena how it is represented.
51.srt	00:20:51.870 --> 00:20:57.819	and compression of 8.6 p is equal to 8.6 and you are seeing your lena here.
51.srt	00:20:57.819 --> 00:21:00.680	How much difference you are going to make out?
51.srt	00:21:00.680 --> 00:21:11.809	Only you can subtract from the original image and then represent that value as an image again and then you will see how much you have lost compared to the original.
51.srt	00:21:25.960 --> 00:21:26.090	But still your eyes is unable to unless you have a very sharp eyes where you can pinpoint that this is the difference what I am seeing from the original to the image.
51.srt	00:21:26.120 --> 00:21:31.230	So, this is one of the advantage of our human visual system.
51.srt	00:21:31.350 --> 00:21:36.780	So, you can see compressed image we have done the blown up of it there it was small.
51.srt	00:21:36.780 --> 00:21:41.580	So, you are not deviating from much of the original.
51.srt	00:21:41.730 --> 00:21:50.690	So, that is what one of the compression advantage in image processing.
51.srt	00:21:56.750 --> 00:22:07.840	So, this is what we have looked at by selection of P how we can do the compression and in the next class we will see it is like our fast FFT what we did for Fourier transform.
51.srt	00:22:08.180 --> 00:22:19.720	So, we can do fast DCT using our butterfly structure here it is not exactly butterfly, but flow diagram what we will look at it in the next class.
51.srt	00:22:19.830 --> 00:22:26.840	Thank you for listening to this class we will come back in the next class for D C T.
51.srt	00:22:28.030 --> 00:22:28.360	Thank you.
3.srt	00:00:00.330 --> 00:00:29.030	So, last class we discussed about what are the basics of signal processing, what course is going to discuss about it.
3.srt	00:00:32.000 --> 00:00:36.530	Today, we will discuss about little bit on basics of signal processing.
3.srt	00:00:38.429 --> 00:00:47.149	So, the real time signal processing has three components basically what you will see that some of the signals are represented with.
3.srt	00:00:48.010 --> 00:00:50.820	The first part is the analog signals.
3.srt	00:00:51.109 --> 00:01:00.590	So, what you will be seeing is the continuous signal, you will be seeing that the amplitude is continuous as well as the time is going to be continuous.
3.srt	00:01:01.100 --> 00:01:05.789	So, coming to the discrete signals how it is going to be represented is shown.
3.srt	00:01:06.130 --> 00:01:07.010	this figure.
3.srt	00:01:07.550 --> 00:01:18.620	So, the frequencies as you can see continuous or continuous time what we call it and then the amplitude is going to be discrete in this.
3.srt	00:01:19.260 --> 00:01:24.530	So, when we come to represent the signals in the digital domain that is in the digital form.
3.srt	00:01:24.930 --> 00:01:32.740	So, we will see that the amplitude is discrete as well as it is going to be discrete in time.
3.srt	00:01:32.740 --> 00:01:36.130	So, as it is represented with n. So, these are.
3.srt	00:01:36.540 --> 00:01:38.620	some of the examples of the signals.
3.srt	00:01:38.980 --> 00:01:42.330	When we come to the system how we are going to represent them.
3.srt	00:01:42.980 --> 00:01:56.350	Analog system is represented with along with the signals whatever we are processing input is going to be analog signal basically input and then the even the output after performing the processing.
3.srt	00:01:56.810 --> 00:02:04.140	So, the output is going to be represented in the analog domain itself that we call it as analog signal output.
3.srt	00:02:04.870 --> 00:02:09.560	So, when we come to represent the system digital systems basically.
3.srt	00:02:10.180 --> 00:02:21.570	input is going to be digital signal input and then we will be doing the processing the output again it will be in the digital signal output what we are going to get from the system.
3.srt	00:02:22.320 --> 00:02:29.470	So, coming to some of the advantages of analog systems or digital systems.
3.srt	00:02:29.940 --> 00:02:40.070	So, we will say that analog systems the first one is it is easy to interface with real world systems and then we say from the.
3.srt	00:02:40.430 --> 00:02:42.010	point of view of digital system.
3.srt	00:02:42.480 --> 00:02:51.590	They offer programming flexibility basically and then capable of performing complex task with low power consumption.
3.srt	00:02:52.140 --> 00:03:06.100	So, whereas, in the case of analog systems we do not need any A to D or DTA converters because input is in the analog format and even output what we wanted in the analog domain.
3.srt	00:03:06.100 --> 00:03:13.210	So, we need not have to convert it into signals in from analog to digital or digital to analog.
3.srt	00:03:14.509 --> 00:03:21.349	And, then whatever we are talking about the speed is going to be independent of the clocking cycles.
3.srt	00:03:21.949 --> 00:03:27.639	So, there is no need to sample the signals whereas, in the digital domain.
3.srt	00:03:28.020 --> 00:03:37.199	So, we have to do sampling has to be done and then it depends on sampling frequency and the frequency component present in the input signals.
3.srt	00:03:37.870 --> 00:03:43.629	So, these are one of the advantage in this case is going to be accurate and reliable.
3.srt	00:03:43.849 --> 00:03:46.099	against environmental changes.
3.srt	00:03:46.609 --> 00:03:51.369	So, we know that analog when we do the processing.
3.srt	00:03:51.399 --> 00:03:58.739	So, some of the components may be resistors or capacitors or other hardware what we will be using it for processing.
3.srt	00:03:59.319 --> 00:04:07.310	So, we know that for the weather conditions we as we say that precision basically percentage of the precision.
3.srt	00:04:07.649 --> 00:04:15.729	So, which may vary depending on the temperature and other environmental changes that is going to occur.
3.srt	00:04:16.219 --> 00:04:19.699	We know that in the digital systems they are not going to be.
3.srt	00:04:20.089 --> 00:04:23.029	affected by this environmental changes.
3.srt	00:04:23.499 --> 00:04:28.089	And one more advantage of the digital system is reproduction of signals.
3.srt	00:04:28.469 --> 00:04:34.399	So, that is going to be multiple times what we can do it without degrading the quality of signals.
3.srt	00:04:35.019 --> 00:04:43.909	In this case what we say is if I have to little bit modify or the same signal what I want to get it in different places which is possible.
3.srt	00:04:44.319 --> 00:04:50.299	Whereas, from the analog domain we know that because environment is going to play a havoc.
3.srt	00:04:50.329 --> 00:04:53.869	So, if we are not taken care of these things.
3.srt	00:04:54.399 --> 00:04:59.610	the multiple outputs for the same input data we may get it differently.
3.srt	00:04:59.670 --> 00:05:03.139	So, this is one of the disadvantage of analog systems.
3.srt	00:05:03.139 --> 00:05:10.029	So, coming to when we have talked about so much of advantage of digital systems.
3.srt	00:05:10.029 --> 00:05:17.139	So, we will see what are the basic elements of real time system DSP systems are going to have it.
3.srt	00:05:17.719 --> 00:05:27.849	So, once I the input if it is a analog signal input as we will see that it is both varying in time as well as amplitude.
3.srt	00:05:28.319 --> 00:05:38.469	which has to be which is represented as x of t. So, we have if it is the amplitude very low then we may have to do little bit of amplification.
3.srt	00:05:39.209 --> 00:05:50.139	And then to curtail the frequency component present in the analog signal we have to pass it through the low pass filter.
3.srt	00:05:50.519 --> 00:05:54.609	So, we call in the analog domain as the anti aliasing filter.
3.srt	00:05:54.879 --> 00:05:57.310	So, we will come to the aliasing part of it in a while.
3.srt	00:05:57.939 --> 00:06:09.829	Then once we have converted we call it as x dash of t. So, as you can see that some of the amplitude is going to be discrete and then it may be continuous in time domain.
3.srt	00:06:10.240 --> 00:06:14.409	Then we pass it through the analog to digital converter or.
3.srt	00:06:14.639 --> 00:06:20.870	So, that ADCs are going to convert analog signals sent to digital domain.
3.srt	00:06:21.189 --> 00:06:32.589	So, we call it as X of NT in this case as you will be seeing that the samples what we are going to get from the analog is represented in this figure.
3.srt	00:06:33.399 --> 00:06:46.300	Then once this it is in the digital signals, but is both in amplitude as well as in time they are being discretized will fit it as input or digital signal processor.
3.srt	00:06:46.969 --> 00:06:55.779	So, for the digital signal processor input as we know that it is going to be discretized signal both in amplitude as well as in time what we will be feeding it.
3.srt	00:06:56.219 --> 00:07:05.269	And we will do the processing whatever application we are intended to, then the output is available as digital output.
3.srt	00:07:05.659 --> 00:07:18.289	As we will be seeing it Y of n in this case after the processing of it, then if it has to be converted back to analog domain, then we have to pass it through the digital to analog converter.
3.srt	00:07:18.909 --> 00:07:22.759	So, that we will be getting y dash t as the output.
3.srt	00:07:23.169 --> 00:07:28.099	Then what we have to do is we need analog output in the continuous domain.
3.srt	00:07:28.439 --> 00:07:33.679	So, we have to do little bit of amplification and then we will use the reconstruction filter.
3.srt	00:07:34.349 --> 00:07:37.339	Reconstruction filters are going to be usually sync filters.
3.srt	00:07:37.339 --> 00:07:43.399	So, we will time permits we will take it up and then we will be getting the analog signal output.
3.srt	00:07:43.729 --> 00:07:48.729	So, if we want to store digital signals in the digital form.
3.srt	00:07:49.179 --> 00:07:54.439	So, in the compression or whatever we can store it in that domain itself.
3.srt	00:07:54.839 --> 00:08:03.499	Whenever we want to have the analog output that time we can retrieve the signals and then convert it back into analog domain.
3.srt	00:08:05.739 --> 00:08:13.039	So, coming to the extending the basic elements of the real time DSP systems.
3.srt	00:08:24.539 --> 00:08:28.739	So, we have the x of n as the input and then this is the digital signal input what we are going to provide it to the DSP processor and then we are going to process it and then will storing digital signal output as I have mentioned in the previous slide.
3.srt	00:08:28.739 --> 00:08:35.189	So, we can store it after computation what it has been done in the digital domain itself.
3.srt	00:08:35.870 --> 00:08:44.329	So, now, we will see little bit of what we will be doing how to do analog to digital conversion that is ADC what we say it.
3.srt	00:08:44.769 --> 00:08:53.569	So, we know that first is the analog input as it is shown here basically which is continuous in time as well as in amplitude.
3.srt	00:08:53.919 --> 00:08:57.329	So, the first step in this going to be we have to do the sampling.
3.srt	00:08:57.590 --> 00:09:05.829	what we have to do it sampling frequency has to be fixed which depends on the Nyquist criteria basically.
3.srt	00:09:06.559 --> 00:09:23.449	And then x of n is the input to our quantizer because we know that although we have the discrete amplitude and discrete in time we would not amplitude need not we cannot represent it in the digital domain as we want it.
3.srt	00:09:24.220 --> 00:09:26.909	It depends on number of bits what we are going to use it.
3.srt	00:09:26.909 --> 00:09:31.699	So, we have to quantize our input signal.
3.srt	00:09:33.149 --> 00:09:48.259	And, then after quantization so, we will be storing it as x t of n. So, as the quantization process little bit is shown and then little more we will be showing in the next slides actually.
3.srt	00:09:48.549 --> 00:10:00.620	So, we will be seeing that number of bits this is the digital output which has to be encoded and then we will be storing it as a digital input as it is shown.
3.srt	00:10:00.909 --> 00:10:05.849	So, we will see that analog signal was this when it comes to the digital domain.
3.srt	00:10:06.129 --> 00:10:15.399	So, this is how the representation with respect to amplitude as well as time what we will be seeing it is discretized.
3.srt	00:10:16.049 --> 00:10:21.259	So, as first step in this block diagram in the conversion is the sampling.
3.srt	00:10:21.719 --> 00:10:31.109	So, we will be seeing that what we call it is uniform sampling that is x of n is the output what we want after sampling.
3.srt	00:10:31.299 --> 00:10:34.949	So, for that this is from the analog signal x a.
3.srt	00:10:34.979 --> 00:10:42.309	So, which is going to be sampled for every n and then t is the period what we will be considering.
3.srt	00:10:50.289 --> 00:10:50.879	So, t is our sampling period and then n will be belonging it to our real world.
3.srt	00:10:51.779 --> 00:10:55.979	And then when we come to sampling frequency how we are going to fix the thing.
3.srt	00:10:56.309 --> 00:11:10.059	So, what we say is f s is the sampling frequency it should be greater than 2 times of the f m, where f m is the maximum frequency that is present in our analog input.
3.srt	00:11:10.379 --> 00:11:23.769	So, as we can see this is the analog signal and then what is the duration here what we call it as delta t is the sampling period what we will be taking it here between two samples.
3.srt	00:11:24.259 --> 00:11:31.989	And, then the complete sampling frequency what fs is going to be represented depending on the maximum frequency present in the signal.
3.srt	00:11:32.699 --> 00:11:44.659	So, just as an example here we will consider 2 sine wave frequencies that is we have f1 as a 2 hertz and then the second frequency component is 10 hertz.
3.srt	00:11:45.169 --> 00:11:50.529	And then we are going to sample this with 8 hertz sampling frequency.
3.srt	00:11:51.249 --> 00:11:56.609	So, we know that we said that according to the previous equation.
3.srt	00:11:57.039 --> 00:12:17.389	So, sampling frequency should be greater than twice that of the maximum frequency whereas, in this case it should be according to this maximum frequency is 10 hertz it should have been 20 hertz instead of that what we are doing is sampling at 8 hertz.
3.srt	00:12:17.909 --> 00:12:20.879	So, then what happens to this ok.
3.srt	00:12:21.209 --> 00:12:26.599	So, you will be seeing that this is the first frequency what I have it at 2 hertz.
3.srt	00:12:27.139 --> 00:12:32.749	and then this is the 10 hertz frequency component which is represented.
3.srt	00:12:33.209 --> 00:12:40.989	When I try to reconstruct these two signals back to original after doing processing and everything.
3.srt	00:12:41.449 --> 00:12:52.389	So, you will be seeing that this is going to be 2 hertz basically that is we have f 1 is at 2 hertz and then the sampling frequency is 8 hertz.
3.srt	00:12:52.739 --> 00:12:55.449	So, which has reconstructed properly.
3.srt	00:12:55.979 --> 00:12:59.159	So, what I have in this case.
3.srt	00:12:59.489 --> 00:13:15.939	is how many points I am going to have there are 4 points 2 points what it has in maximum what you are representing the thing in both domain that is in the positive and then the negative what it has it.
3.srt	00:13:15.939 --> 00:13:27.089	And then when I reconstruct this signal 8 hertz signal so what happens to the thing is it is going to have the aliasing effect.
3.srt	00:13:30.669 --> 00:13:34.809	So, because I have not taken care of twice that of the maximum frequency.
3.srt	00:13:35.149 --> 00:13:46.499	So, we will be seeing that 10 minus 8 hertz is the one reflected basically what I will be getting both as a 2 hertz frequency in the domain.
3.srt	00:13:46.799 --> 00:13:50.859	So, some of these examples we will be doing it in the lab.
3.srt	00:13:51.249 --> 00:14:01.669	So, that you will be able to figure it out what will be the reconstruction is going to happen if normal whatever Nyquist criteria frequency is not met.
3.srt	00:14:02.599 --> 00:14:06.119	So, coming to the other part of the sampling.
3.srt	00:14:06.159 --> 00:14:16.739	So, you will be seeing that two different analog signals sampled at different frequencies leading to some digital signal what we are looking at.
3.srt	00:14:17.029 --> 00:14:27.119	So, we have sampled at 40 hertz here and then this one is sampled at 80 hertz what you will be seeing it.
3.srt	00:14:27.119 --> 00:14:34.629	So, when I do the reconstruction, so the 40 hertz if the sampling frequency is.
3.srt	00:14:35.099 --> 00:14:44.119	So, you will be representing both the signals in their domain reconstructed properly.
3.srt	00:14:45.349 --> 00:14:55.999	So, coming to real world application so, we will be seeing a few of the sampling frequencies and then what are the sampling period associated with each one of them.
3.srt	00:14:56.519 --> 00:15:02.449	So, one of the real world thing is our telecommunication.
3.srt	00:15:02.449 --> 00:15:06.859	So, we know that international telecommunication unit.
3.srt	00:15:07.129 --> 00:15:19.589	union that is ITU what it is going to be representing speech coding and decoding standards which is defined by ITU-T what we call it G729 and then 723.1 standards.
3.srt	00:15:19.589 --> 00:15:25.769	There the sampling frequencies what it is used is 8 kilohertz.
3.srt	00:15:25.769 --> 00:15:39.169	So we know that 8 kilohertz when we say the thing what will be the sampling period is T is going to be given by 1 by fs which is going to be 1 by 8000 seconds so which.
3.srt	00:15:40.429 --> 00:15:45.789	constitute 125 microseconds basically what will be representing it.
3.srt	00:15:46.119 --> 00:15:53.019	So, how we are going to represent 1 microsecond is equal to 10 power minus 6 seconds.
3.srt	00:15:53.469 --> 00:16:05.649	The same thing so, if we consider the wideband telecommunication speech coding standards such as ITU-TG 722 and then 722.2 ok.
3.srt	00:16:05.759 --> 00:16:15.379	Here the sampling frequency is 16 kilohertz then we know that sampling period is going to be 1 by 16000 which is nothing but 62.5 microseconds.
3.srt	00:16:17.859 --> 00:16:34.029	Coming to the third real world signal, so what we call it as high fidelity audio compression basically standards such as MPEG-2 that is moving picture basically what we will be looking at it expressed group basically.
3.srt	00:16:34.059 --> 00:16:51.749	And then AEC standards that is advanced audio coding and then MP3 we know that coding technology technique, so which is we call it as MPEG-1 layer 3 what it is going to be considered for the audio.
3.srt	00:16:54.759 --> 00:16:57.869	And, then we know the DOLBY AC3 systems also.
3.srt	00:16:58.509 --> 00:17:04.319	In these applications the sampling frequency that is used is 48 kilohertz.
3.srt	00:17:04.789 --> 00:17:13.279	And then we know that for the sampling rate for MPEG-2 AAC it can be as high as 96 kilohertz.
3.srt	00:17:13.729 --> 00:17:28.879	So, in that case what happens our sample period is if we are consider 48 kilohertz which is 1 by 48000 which is going to be 20.83 microsecond is the sampling period at which we have to sample the MPEG-2.
3.srt	00:17:29.179 --> 00:17:30.750	signals basically.
3.srt	00:17:31.209 --> 00:17:36.769	So, these are some application shows that how we have to do the sampling thing correctly.
3.srt	00:17:37.289 --> 00:17:48.109	So, now, once we have sampled the signals, then the signal is available in the digital domain which we call it as x of n, then we have to go for the quantization.
3.srt	00:17:48.659 --> 00:17:54.480	So, as we the it depends on as I said number of bits.
3.srt	00:17:54.789 --> 00:18:01.969	In this case as an example, we have taken 2 bit quantizer that is whatever the input which is coming.
3.srt	00:18:01.969 --> 00:18:05.750	So, we will be representing with 2 bits, then I know in the.
3.srt	00:18:06.829 --> 00:18:12.409	digital domain how well we representing the 2 bit number system.
3.srt	00:18:12.829 --> 00:18:16.909	So, that is 0 0 and then 0 1 1 0 and 1 1.
3.srt	00:18:17.329 --> 00:18:19.979	So, this is what my input signal.
3.srt	00:18:20.319 --> 00:18:22.159	So, in the continuous domain.
3.srt	00:18:22.159 --> 00:18:25.569	So, or sample signal what I have got it.
3.srt	00:18:25.809 --> 00:18:34.209	So, I have to map them to the nearest numbers basically whatever I will be representing with the number of bits.
3.srt	00:18:34.469 --> 00:18:35.829	So, we call.
3.srt	00:18:36.229 --> 00:18:49.089	So, whatever the difference between the two as we as can see one of the example, this number which is between 1 0 and 1 1 which I will be representing as 1 0.
3.srt	00:18:49.529 --> 00:19:06.199	So, which we call all these errors as quantization errors that is basically the difference between the quantized number and the original values defined as the quantization error which appears as noise in the output of the converter.
3.srt	00:19:07.729 --> 00:19:23.459	How do we define the quantization error which is given by equation like this eq of n which is nothing, but xq of n minus that is quantized value minus the x of n the original value of it.
3.srt	00:19:23.729 --> 00:19:27.339	So, for all n in my real world basically.
3.srt	00:19:28.279 --> 00:19:34.189	So, coming to next one what is the thing is going to happen.
3.srt	00:19:34.189 --> 00:19:38.579	So, we took it as example as 2 bit quantizer and then we saw the thing.
3.srt	00:19:39.109 --> 00:19:49.599	So, for uniform quantization the resolution is going to be determined by dividing the full scale range by the total number of quantization levels.
3.srt	00:19:49.939 --> 00:20:02.799	That is if I am representing with 8 bit number then the resolution for each value is going to be represented as 2 power 8.
3.srt	00:20:03.059 --> 00:20:10.959	So, B can be any number of bits what it is shown here and then I have to specify signal to quantization noise ratio.
3.srt	00:20:12.129 --> 00:20:22.109	For b bit quantizer is approximately what we call it as 6 b, b is the number of bits d b in represented in decibel.
3.srt	00:20:22.669 --> 00:20:36.439	So, as it is shown in the table here number of bits if I use 8, b is equal to 8, then the levels what I can represent is 2 power 8 which is 256 levels what I can represent the values.
3.srt	00:20:36.979 --> 00:20:42.359	And then the resolution is going to be as we have said that full scale range.
3.srt	00:20:42.909 --> 00:20:50.299	If we take it as 5 volts then I will be getting each sample is represented as 19.5 milli volt level.
3.srt	00:20:50.299 --> 00:21:01.989	And, then in that case what I am going to achieve for 6 into 8 is going to be my signal to quantization noise ratio which is going to be 48 dB.
3.srt	00:21:01.989 --> 00:21:10.729	So, if I increase the number of bits to 12 bits what I am going to look at it then I will be representing the number of levels is 4096.
3.srt	00:21:13.139 --> 00:21:19.979	and then which is 2 power 12 and then the resolution as we will be seeing that it will be 1.22 millivolts.
3.srt	00:21:19.979 --> 00:21:34.069	So, compared to this I have a more resolution between the bits and my SQNR that is quantization noise ratio what signal to quantization noise ratio is going to increase to 72 dB.
3.srt	00:21:34.529 --> 00:21:40.599	So, for the 16 bit conversion or quantization.
3.srt	00:21:40.679 --> 00:21:43.609	So, I will be achieving somewhere around 96.
3.srt	00:21:44.979 --> 00:21:50.989	So, all of us know that CD quality although it is extinguished now today.
3.srt	00:21:51.369 --> 00:22:01.499	So, which had a 91 dB resolution what that is signal to quantization noise ratio was the standard being used for it.
3.srt	00:22:01.839 --> 00:22:07.309	So, you will be seeing that somewhere between these two what you are supposed to have number of bits.
3.srt	00:22:07.579 --> 00:22:13.949	But we know that it depends on ADC what we are going to use it.
3.srt	00:22:13.949 --> 00:22:15.749	So, which we will be discussing it in a while.
3.srt	00:22:16.599 --> 00:22:28.259	So, now once we have done quantization then we have to represent this quantization bits according to the number of bits what we have been using it.
3.srt	00:22:28.599 --> 00:22:34.589	So, then we have to do the encoding of the number or the signal.
3.srt	00:22:34.959 --> 00:22:46.349	So, this is 2 bit encoder we have seen it already and then when I talk about 3 bit then I will be representing the values between 0 to 7.
3.srt	00:22:46.539 --> 00:22:48.999	integer what I will be representing it.
3.srt	00:22:49.349 --> 00:23:00.199	So, when I take up the number system we will discuss about the what I will call it as negative and then positive numbers how we can represent it.
3.srt	00:23:00.749 --> 00:23:08.259	So, once we have done the analog to digital conversion then if we want to do digital to analog conversion.
3.srt	00:23:08.259 --> 00:23:16.899	So, we have these are the digital values what I have it y of n is the thing and then I will be seeing that.
3.srt	00:23:18.109 --> 00:23:24.049	presenting it and then we will try to reconstruct the signal in this way.
3.srt	00:23:24.049 --> 00:23:32.569	So, this is our linear interpolation what I can do it and then reconstruct the signal in this fashion.
3.srt	00:23:32.569 --> 00:23:36.409	So, this is how we will be getting the analog signal output.
3.srt	00:23:37.159 --> 00:23:40.309	So, coming to data converters.
3.srt	00:23:40.480 --> 00:23:48.089	So, we need ADC's and DAC's for both the input analog input conversion to digital domain.
3.srt	00:23:48.409 --> 00:23:50.749	and from digital domain to unlock.
3.srt	00:23:51.109 --> 00:24:01.469	So, in this we will be using the DSK6713 board basically as I mentioned in the previous class that most of the colleges have this.
3.srt	00:24:01.469 --> 00:24:17.139	So, I will be taking this as the basic one and then we will be going with the lab laboratory incorporating this board either in the simulator mode initially then we can use the hardware to test the real time signals.
3.srt	00:24:17.529 --> 00:24:23.849	So, in this case what we have call it as AIC chip which is analog interface chip.
3.srt	00:24:24.429 --> 00:24:36.609	In the DSK6713 is going to be AAC23 codec what we call it both coding and then decoding is incorporated in one of the chip itself.
3.srt	00:24:37.399 --> 00:24:43.289	So, the higher versions of DSP processor from TI what I will be taking it.
3.srt	00:24:43.579 --> 00:24:46.759	So, we will see why we have gone with the TI later on.
3.srt	00:24:47.379 --> 00:24:57.529	The thing is going to be 3 2 version AAC32 version what they will be using in the higher versions of the boards basically.
3.srt	00:24:57.959 --> 00:25:05.279	So, now, when we want to do the data conversion either I can have a parallel converters or serial converters.
3.srt	00:25:05.589 --> 00:25:10.449	So, we will see the advantage of a disadvantage of both parallel and serial converters.
3.srt	00:25:10.789 --> 00:25:18.369	So, parallel converters we know that it receives or transmit all b bits in one pass.
3.srt	00:25:18.709 --> 00:25:30.859	So, whatever data I have considered basically then it will be converting or taking all the 8 bits at a time if it is 8 bit converter.
3.srt	00:25:31.500 --> 00:25:34.839	and then it will be outputting all 8 bits output.
3.srt	00:25:35.399 --> 00:25:45.539	So, whereas, in the serial case it receives or transmit this b bits in a serial of bit stream that is 1 bit at a time.
3.srt	00:25:46.079 --> 00:26:00.559	So, what is the consequence of it as we know that whatever I can get if I am talking about 8 bit 8 bits have taken the thing b is equal to 8 I have considered.
3.srt	00:26:03.669 --> 00:26:07.909	So, all the 8 values will be coming into my system at 1 clock cycle.
3.srt	00:26:08.399 --> 00:26:16.839	Whereas, when I am using the serial converter, I know that 8 bits will take 8 clock cycles because I am taking 1 bit at a time.
3.srt	00:26:16.999 --> 00:26:20.759	So, I have to wait for 8 clock cycles to get complete data.
3.srt	00:26:21.479 --> 00:26:26.419	But what are the disadvantage of the parallel converters we will see.
3.srt	00:26:26.829 --> 00:26:36.029	So, these are attached to the digital signal process basically external address and databases directly it will be connected to that.
3.srt	00:26:36.349 --> 00:26:39.769	So, which are also attached to many different types of.
3.srt	00:26:40.619 --> 00:26:42.319	devices in this case.
3.srt	00:26:42.779 --> 00:26:54.579	So, that means, to say that so many bits are required or what I will call it as I O pins to get the input data and any other devices also using it.
3.srt	00:26:54.669 --> 00:26:58.460	So, so many I O pins has to be there.
3.srt	00:26:58.460 --> 00:27:09.859	Whereas, in the case of serial converters, so we will be using built in serial ports of digital signal processors.
3.srt	00:27:10.299 --> 00:27:17.299	And then we know that it requires few signals or pins to connect with our digital signal processor.
3.srt	00:27:17.689 --> 00:27:24.399	So, most of the many practical DSP systems use serial ADCs and then DACs.
3.srt	00:27:27.199 --> 00:27:32.449	And then coming to the thing what are the kinds of data converters available in the market.
3.srt	00:27:32.889 --> 00:27:40.230	So, we know that some of them are successive approximation, dual slope, flash ADCs are there.
3.srt	00:27:40.479 --> 00:27:42.209	and sigma delta converters are there.
3.srt	00:27:42.689 --> 00:27:46.379	So, we will see advantage and disadvantage of them few of them.
3.srt	00:27:46.999 --> 00:27:49.919	The first one is a successive approximation ADC.
3.srt	00:27:50.399 --> 00:28:01.519	So, we know that it is very accurate and then olden days we were using this type of conversion and we know that it is fast at a relatively low cost.
3.srt	00:28:01.949 --> 00:28:03.939	So, very popular in the olden days.
3.srt	00:28:04.209 --> 00:28:13.519	So, this results in slow response to sudden changes in the input signal due to limitation in its internal cross.
3.srt	00:28:13.789 --> 00:28:14.359	clock rate.
3.srt	00:28:14.409 --> 00:28:16.299	So, internal clock rate is slow.
3.srt	00:28:16.299 --> 00:28:18.439	So, any changes in the thing.
3.srt	00:28:18.500 --> 00:28:20.349	So, the response is going to be slow.
3.srt	00:28:20.349 --> 00:28:24.240	This is the disadvantage of our successive approximation ADC.
3.srt	00:28:24.889 --> 00:28:26.809	Coming to dual slope ADC.
3.srt	00:28:27.250 --> 00:28:33.059	So, this is very precise and can produce ADCs with high resolution.
3.srt	00:28:33.849 --> 00:28:35.459	What is the disadvantage?
3.srt	00:28:35.569 --> 00:28:40.929	They are very slow and generally cost more than successive approximation.
3.srt	00:28:41.240 --> 00:28:44.639	So, where the cost is not going to matter then.
3.srt	00:28:45.029 --> 00:28:47.889	So, people were going to use the dual slope ADCs.
3.srt	00:28:48.470 --> 00:28:51.019	The other one type is the flash ADC.
3.srt	00:28:51.399 --> 00:29:04.799	So, we know that it is very high speed conversion and commercially available flash ADC usually have lower bits because of the power consumption and then speed and other things coming into picture.
3.srt	00:29:05.269 --> 00:29:07.690	So, they cannot have higher bits.
3.srt	00:29:08.069 --> 00:29:13.099	So, in a B bit ADC we know that it requires 2 power B minus 1.
3.srt	00:29:13.980 --> 00:29:19.990	So, bits basically so which is going to be expensive comparators and laser.
3.srt	00:29:20.490 --> 00:29:26.369	trim resistors are required to implement this kind of ADC's in the flash mode.
3.srt	00:29:26.889 --> 00:29:34.899	So, the other advantage of using the sigma delta which we will be looking it in a while.
3.srt	00:29:35.279 --> 00:29:41.089	So, what the input signal we have the analog input signal.
3.srt	00:29:41.559 --> 00:29:53.869	So, we will be feeding it to the sigma delta what we first is sigma basically, then you will be seeing the delta part of it is going to come which is a 1 bit ADC will be taking it.
3.srt	00:29:54.419 --> 00:30:02.519	and then I will be getting 1 bit output and then which is going to be we call it as digital decimator.
3.srt	00:30:02.949 --> 00:30:15.549	So, why we need the digital decimator is we will be sampling at a very high frequency here input signal and then the output has to be brought down to whatever the board is going to support.
3.srt	00:30:15.839 --> 00:30:23.199	So, which will be converted get into 8 bit digital output signal in this case.
3.srt	00:30:25.929 --> 00:30:29.749	So, when I want to reconstruct because this is what we call it as sigma delta or delta sigma basically.
3.srt	00:30:30.059 --> 00:30:39.519	So, when converting it from ADC mode we will be having sigma delta, when I want to convert it back to DAC that is my analog output.
3.srt	00:30:39.799 --> 00:30:52.429	So, I will be taking the delta output and then this is a 1 bit DAC I am going to have it which is going to provide it to sigma and then I will be getting the analog output from it.
3.srt	00:30:56.629 --> 00:31:00.939	So, you will be seeing that this is a digital input how 8 representation of the signal digital signal is shown in this figure.
3.srt	00:31:01.659 --> 00:31:06.499	So, the coming to the its usage.
3.srt	00:31:06.839 --> 00:31:17.909	So, what it does is we use the over sampling and quantization noise shaping to treat the quantizer resolution with sampling rate.
3.srt	00:31:18.319 --> 00:31:23.129	So, we are going to sample it to high sampling rate then what happens to this.
3.srt	00:31:23.399 --> 00:31:27.129	Then we use 1 bit quantizer with a very high sampling rate.
3.srt	00:31:27.519 --> 00:31:32.909	Thus the requirements for an anti aliasing filter are significantly relaxed.
3.srt	00:31:33.349 --> 00:31:38.969	So, we know that anti aliasing filter has to be designed in the analog domain.
3.srt	00:31:39.359 --> 00:31:45.449	So, we know the disadvantage of filter construction there in analog domain.
3.srt	00:31:45.449 --> 00:31:53.709	So, that means, to say that we are going to provide a lower roll off rate for the anti aliasing filter.
3.srt	00:31:53.929 --> 00:32:05.479	So, we say that low order anti aliasing filter requires simple low cost analog circuitry compared to complicated one if we want to have a.
3.srt	00:32:05.869 --> 00:32:11.950	fast roll off and is much easier to build and then maintain them for longer period.
3.srt	00:32:12.309 --> 00:32:23.409	So, in the process of quantization what happens the resulting noise power is going to be spread evenly over the entire spectrum because we have sampled it at high speed.
3.srt	00:32:23.629 --> 00:32:27.539	So, the noise is going to be distributed over the whole spectrum.
3.srt	00:32:28.139 --> 00:32:36.950	So, that is what it says the quantization noise beyond the required spectrum range can be attenuated using a digital low pass filter.
3.srt	00:32:37.609 --> 00:32:49.519	So, we are relaxing on the analog low pass filter and then we can use a digital low pass filter to remove the noise from the component that is present in this input signal.
3.srt	00:32:50.059 --> 00:32:59.569	So, as a result the noise proper within the frequency band of interest is going to be lower because it is distributed over the entire spectrum.
3.srt	00:33:00.079 --> 00:33:07.789	So, to match the sampling frequency with the system and increase its resolution, we use the decimator.
3.srt	00:33:08.370 --> 00:33:10.310	to reduce the sampling rate.
3.srt	00:33:10.950 --> 00:33:21.900	So, the advantages of sigma delta ADCs are high resolution and good noise characteristics at a competitive price using digital decimation filters.
3.srt	00:33:22.240 --> 00:33:24.680	So, the thing is happening in the digital domain.
3.srt	00:33:24.980 --> 00:33:29.220	So, the cost of this ADCs are very less.
3.srt	00:33:29.370 --> 00:33:36.420	So, that is how most of the DSP processors use the sigma delta ADCs in their hardware.
3.srt	00:33:37.180 --> 00:33:40.100	Now once we have discussed about the ADC.
3.srt	00:33:40.360 --> 00:33:42.400	So, we look into the DSP hardware.
3.srt	00:33:42.930 --> 00:33:49.420	So, we can have different as you will be seeing that 5 varieties of them are there.
3.srt	00:33:49.990 --> 00:33:59.299	One is the special purpose that is usually we custom build the chips basically such as application specific integrated circuit.
3.srt	00:33:59.720 --> 00:34:02.230	We call that as ASICs basically.
3.srt	00:34:02.230 --> 00:34:10.920	So, one of the advantage is there if you are going for a very huge volume.
3.srt	00:34:11.429 --> 00:34:18.590	The cost of the units is going to be very less, we will be seeing in a while how they will be comparing.
3.srt	00:34:19.380 --> 00:34:36.500	Then it is worthwhile going for the special purpose processor, but once we have built this to change any of the in between components or any circuitry, then we have to redesign it, it is not possible to modify it.
3.srt	00:34:36.500 --> 00:34:40.179	That is one disadvantage of using ASICs.
3.srt	00:34:40.550 --> 00:34:45.090	The other one is field programmable gate arrays, we call it as FPGAs.
3.srt	00:34:45.539 --> 00:34:52.130	there it is before ASIC what we can use them.
3.srt	00:34:52.480 --> 00:34:59.430	So, that is in the field I can reprogram although gates are present in the thing as an arrays.
3.srt	00:34:59.430 --> 00:35:14.480	So, we will be programming them and then I can later on once we I feel that my circuit is capable of working very well and then I want high productivity then I can go for the ASICs.
3.srt	00:35:14.740 --> 00:35:17.000	So, it is easier to try it in this.
3.srt	00:35:17.280 --> 00:35:19.690	So, compared to this we will be seeing that.
3.srt	00:35:19.860 --> 00:35:43.720	But in terms of the design time and other things which will the first one will have the maximum time to build around and then this is little much easier and coming to some of the levels where in classrooms and then some of the research we can use general purpose microprocessors or microcontrollers for specific applications.
3.srt	00:35:44.370 --> 00:35:53.830	And then we can go if the application is I O oriented it is better to go with microcontrollers.
3.srt	00:35:54.260 --> 00:35:59.990	Or if general purpose processor number of applications are much more what we have to test it.
3.srt	00:36:00.510 --> 00:36:07.579	But when it comes to signal processing, so it is better to go for general purpose digital signal processors.
3.srt	00:36:08.010 --> 00:36:11.430	So, we will see the advantage of them later.
3.srt	00:36:11.889 --> 00:36:21.280	The other one is we can have DSP with application specific hardware that is we call it as hardware accelerators.
3.srt	00:36:21.599 --> 00:36:27.940	So, with respect to general purpose process we can have a hardware accelerators.
3.srt	00:36:28.380 --> 00:36:35.089	Particularly, meant for DSP applications also is a possible hardware one can consider.
3.srt	00:36:35.509 --> 00:36:54.210	So, this table gives you what are the advantages and then disadvantages in terms of that is from the flexibility, from the design time, power consumption and then performance and then what will be the development cost and then the production cost.
3.srt	00:36:54.519 --> 00:37:00.119	So, you will be seeing that ASIC is I do not have any flexibility as I mentioned in.
3.srt	00:37:00.409 --> 00:37:07.589	the previous slide that once you have designed it any change you have to incorporate you have to redesign.
3.srt	00:37:07.589 --> 00:37:10.480	So, I would not have any flexibility in change of design.
3.srt	00:37:11.129 --> 00:37:30.909	And then in the case of design time you will be seeing that it is going to take a longer time and power consumption because according to my requirement application I have designed it which is going to consume low power because I will be using only few components what.
3.srt	00:37:31.170 --> 00:37:32.789	it is much required for it.
3.srt	00:37:33.820 --> 00:37:40.880	And coming to the performance which is going to give very high performance because it is application specific what we have designed it.
3.srt	00:37:41.480 --> 00:37:47.269	Coming to the development cost is going to be very high as it time is going to be longer.
3.srt	00:37:47.679 --> 00:37:59.289	So, one who are very good in designing get they have to be paid heavily that is why it is going to cost us very high development cost.
3.srt	00:37:59.559 --> 00:38:05.230	Coming to the production cost because we think of high volume basically you can see your.
3.srt	00:38:05.980 --> 00:38:07.320	mobiles basically.
3.srt	00:38:07.600 --> 00:38:16.480	So, as the customer increases you will be seeing that cost is going to lower as the trend is if it is older version.
3.srt	00:38:16.480 --> 00:38:35.650	So, we will be getting it for a low cost, but whenever it is new you see that there whatever the your design time is going to be much higher, but production cost will be kept as low as possible.
3.srt	00:38:36.190 --> 00:38:40.170	Coming to FPGA field programmable gate arrays.
3.srt	00:38:40.440 --> 00:39:07.890	So, we have limited flexibility in this compared to ASIC we have some of the flexibility and then our design time is medium and then power consumption is going to be low medium in this case and performance is going to be high as equivalent to ASIC and development cost is going to be medium in this and production cost it will be in the low medium case.
3.srt	00:39:08.239 --> 00:39:23.670	Coming to your microprocessor and microcontrollers as we will be seeing that our flexibility in digital signal processor and microprocessor and microcontrollers are very high and then design time in both the cases is short.
3.srt	00:39:24.130 --> 00:39:39.360	Whereas, in the power consumption here it is can be medium to high, but in the digital signal processor we can have low this thing power consumption processors are available or I can have some of the medium processors.
3.srt	00:39:39.730 --> 00:39:42.460	which I can use it for my applications.
3.srt	00:39:42.920 --> 00:39:54.090	So, when comes to performance they will be low to medium what it is going to be, but whereas, in the case of digital signal processor it is from medium to high performance what I will be getting it.
3.srt	00:39:54.090 --> 00:40:04.780	Coming to the development cost both standard low and then production cost is going to be this one is medium to high whereas, digital signal processor low to medium.
3.srt	00:40:05.559 --> 00:40:18.070	Coming to with hardware accelerators, so the flexibility is going to be medium because my accelerator based on my requirement what I have designed it or what I am using it.
3.srt	00:40:18.420 --> 00:40:43.539	So, that way I will not have much flexibility just like our FPGA we may have the medium flexibility whereas, the design time in this going to be short and then I can have the power consumption between low to medium what I can select and then performance is going to be very high and then development cost is going to be low in this and production cost is going to be medium.
3.srt	00:40:53.040 --> 00:40:55.470	So, if I have the hardware and I want to have increase the speed of my computer DSP, I have then it is better to go with accelerators.
3.srt	00:40:55.880 --> 00:41:02.600	So, these are the table what it decides what kind of hardware one has to select for their basic applications.
3.srt	00:41:02.600 --> 00:41:06.130	Coming to the design how we are going to proceed.
3.srt	00:41:06.870 --> 00:41:09.380	So, signal process system design what we call it.
3.srt	00:41:09.380 --> 00:41:14.610	So, that is if you have been given an application.
3.srt	00:41:14.610 --> 00:41:18.240	So, I will be defining my system requirements.
3.srt	00:41:24.800 --> 00:41:34.269	and develop algorithms and then perform simulation first to see that my algorithms are working fine and then my requirements are correct.
3.srt	00:41:34.720 --> 00:41:46.599	Then I can select DSP chips or devices or whether I have to go for the full custom or FPGA based or hardware based accelerator I can decide it here.
3.srt	00:41:47.019 --> 00:41:56.760	Then what I will do is I will be deciding on initially earlier cases was software development was separate and then hardware development was separate.
3.srt	00:41:57.190 --> 00:42:08.509	As you will I was pointing it out in the last class hardware cost was very less software cost is going to be very high because they were designing it independently.
3.srt	00:42:09.049 --> 00:42:25.940	So, hardware lot of functions are built into our chips and then which is going to come out to make them use software has to be developed in such a way that all the units are used which is going to cost us very high.
3.srt	00:42:26.309 --> 00:42:32.179	So, but now the trend is as we will be calling it as hardware software co-design.
3.srt	00:42:32.179 --> 00:42:37.029	So, they have to go in hand in hand that is why it is put in dotted line.
3.srt	00:42:38.349 --> 00:42:47.679	recent trends they have to go in concurrent design of hardware and software components of complex electronics systems basically.
3.srt	00:42:48.000 --> 00:42:58.069	So, that will be in line with whatever hardware is getting added software also will be able to use that hardware.
3.srt	00:42:58.469 --> 00:43:10.219	So, that is what it says it tries to exploit the synergy of hardware and software with the goal to optimize and satisfy design constraints such as cost.
3.srt	00:43:10.549 --> 00:43:13.509	performance and power of the final product.
3.srt	00:43:13.819 --> 00:43:20.329	So, once this is being done so, we will be doing the integration system integration has to happen.
3.srt	00:43:20.829 --> 00:43:26.009	Then we know that testing and debugging is one of the most critical one.
3.srt	00:43:26.329 --> 00:43:46.329	So, how one is going to do testing and debugging it depends on what application we are going to use for and then how much we have to do it whether for real time systems are that is what I am we are talking about real time signal processing it should not fail then we should have taken care of.
3.srt	00:43:46.750 --> 00:43:51.179	testing and debugging for all possible cases one has to do it.
3.srt	00:43:51.650 --> 00:43:58.539	So, in the case of software development, so we will be using mostly general purpose computer.
3.srt	00:43:58.940 --> 00:44:16.849	In that case will be externally we have to provide the analog to digital converted signal into the system which will be doing it storing it in the data files or we can take it from other computers if we have the converted data.
3.srt	00:44:17.230 --> 00:44:31.690	So, we will be storing it as data files and then we can run the thing DSP algorithms either using C or C++ or MATLAB and then those are the softwares what we can use it DSP software.
3.srt	00:44:32.130 --> 00:44:49.579	And then we can generate some of the signals and then if we want we can store it back in the data files and then the output of it applying the algorithm we can store it in the data files and then externally we can use the digital to analog converter to convert it.
3.srt	00:44:50.030 --> 00:44:58.000	and then send it out or if it has to be given to other computers which has to process it we can give it to other computers.
3.srt	00:44:58.520 --> 00:45:01.910	So, this is the end of the second lecture.
3.srt	00:45:02.300 --> 00:45:10.980	So, in the next lecture we would be taking DSP architecture and then number system in the next lecture.
3.srt	00:45:11.540 --> 00:45:14.430	Again I will tell happy learning and then thank you.
45.srt	00:00:01.219 --> 00:00:24.929	Welcome back to real time digital signal processing course.
45.srt	00:00:24.929 --> 00:00:30.420	So last class we discussed about little on speech coding.
45.srt	00:00:31.480 --> 00:00:35.140	Today we will continue on that regarding the O coders.
45.srt	00:00:35.640 --> 00:00:38.840	So, this is the second lecture what we will have it.
45.srt	00:00:39.090 --> 00:00:44.299	So, we saw that although I did not discuss the A law companding.
45.srt	00:00:44.740 --> 00:00:47.060	So, which was in the analog domain.
45.srt	00:00:47.329 --> 00:00:49.439	So, you can go back and then check the thing.
45.srt	00:00:49.439 --> 00:01:02.519	So, we discussed little on mu law and then little on the sub band coding how we can bring down from PCM that is 64 kilobit per second to sub band coding of 31.5 kilobits per second.
45.srt	00:01:03.490 --> 00:01:07.670	So, today we will see about the O coders.
45.srt	00:01:08.179 --> 00:01:21.909	So, we say it is a parametric coders basically and models the vocalization of speech and the speech sampled and broken into frames approximately we break it up into 25 millisecond.
45.srt	00:01:21.909 --> 00:01:34.939	And instead of transmitting digitized speech we are going to build the model of speech and the transmit the parameters of the model and synthesize.
45.srt	00:01:35.199 --> 00:01:36.829	approximation of speech.
45.srt	00:01:36.959 --> 00:01:43.319	So, we say that the first one is the linear predictive coders in this category LPC.
45.srt	00:01:43.829 --> 00:01:47.519	So, the basic coder model what we are going to have it.
45.srt	00:01:48.030 --> 00:01:57.159	So, models the vocal tract as a filter and then filter excitation what it is going to be done.
45.srt	00:01:57.889 --> 00:02:06.729	So, of it is going to be done it is periodic pulse that is voice speech or noise we call it as unvoiced speech.
45.srt	00:02:07.099 --> 00:02:14.340	So, using that we will do the filter excitation and then synthetically generate the speech at the receiving end.
45.srt	00:02:14.800 --> 00:02:23.189	So, the transmitted parameters are gain, voiced or unvoiced decision and the pitch.
45.srt	00:02:23.719 --> 00:02:33.449	So, if it is voiced we have to send the pitch and the rest of it is LPC parameters what we have used in the coding techniques.
45.srt	00:02:33.889 --> 00:02:38.590	So, coming to the second part of our coders.
45.srt	00:02:39.209 --> 00:02:44.560	We as we said it is the linear predictive coders we are going to use it.
45.srt	00:02:45.030 --> 00:02:48.079	So, the first is the excitation stage.
45.srt	00:02:48.449 --> 00:02:57.379	So, what we are going to have is periodic pulse that is voice speech or noise we call it as unvoiced speech.
45.srt	00:02:57.709 --> 00:03:04.829	So, this is how the pulse generator is going to be and we are going to provide a pitch period in this case.
45.srt	00:03:05.159 --> 00:03:08.109	So, we call this is the voiced generation.
45.srt	00:03:09.209 --> 00:03:13.489	And, here it is unvoiced we say it as noise generator.
45.srt	00:03:14.409 --> 00:03:18.299	So, this is our excitation model what we have it.
45.srt	00:03:18.789 --> 00:03:22.649	Then after the excitation model ah.
45.srt	00:03:22.649 --> 00:03:25.139	So, we have to select the excitation.
45.srt	00:03:25.739 --> 00:03:44.079	So, that is going to happen here and we will be having the gain factor G. So, which is multiplied by this one ok. Then these are the transmitted parameters ah which are the ones we are going to what gain we have used it.
45.srt	00:03:44.530 --> 00:03:57.199	So, whether it is voiced or unvoiced decision we will be putting it and then the pitch if it is a voice signal and the other ones are LPC parameters what will be transmitting it.
45.srt	00:03:57.629 --> 00:04:06.649	So, here you will be seeing that this is the excitation model output is mu of t and how we are going to see the LPC basically.
45.srt	00:04:07.129 --> 00:04:09.319	These are the predictor coefficients.
45.srt	00:04:09.409 --> 00:04:11.929	So, we will be putting the linear feedback.
45.srt	00:04:15.609 --> 00:04:26.289	and do the summation of the two of it and we will be sending y of t along with the parameters of LPC these are the parameters.
45.srt	00:04:26.289 --> 00:04:39.739	So, this is our vocal tract model what we are going to generate and then we will be passing the LPC parameters to the through the channel to receiver place.
45.srt	00:04:39.949 --> 00:04:43.519	So, coming back what is it?
45.srt	00:04:46.979 --> 00:04:52.959	Example 10th order linear predictive coder what the example shows here.
45.srt	00:04:53.409 --> 00:05:05.189	So, the samples voice at 8 kilohertz and we are going to have a buffer of 240 samples that is we are taking 30 millisecond of the data.
45.srt	00:05:05.789 --> 00:05:19.859	And here the filter model is M is 10 is the order of the filter and gain considered is G and we know that Z-1 is the unit delay we are going to have it.
45.srt	00:05:20.619 --> 00:05:28.359	and b k are filter coefficients what we will be using it in the system.
45.srt	00:05:28.719 --> 00:05:50.619	So, then what happens to our impulse response H of z is given by g divided by 1 plus sigma k is equal to 1 m is the order of the filter b k into z minus k then our g is going to be 5 bits and then b k is going to be.
45.srt	00:05:50.909 --> 00:06:05.979	are 8 bits each what we can use for the voiced and unvoiced decision we are going to have 1 bit and pitch is represented with 6 bits.
45.srt	00:06:06.419 --> 00:06:13.059	So, this implies that we have 92 bits per 30 millisecond.
45.srt	00:06:21.199 --> 00:06:24.839	So, it gives this thing 3061 that is band bit per second what we are going to get the thing.
45.srt	00:06:25.229 --> 00:06:31.849	So, this is the model of the LPC coding the previous one we discussed about this.
45.srt	00:06:32.369 --> 00:06:35.549	This is the model which is going to be used in the LPC.
45.srt	00:06:36.819 --> 00:06:41.719	This is bits per second what we are going to have what we have to transmit totally.
45.srt	00:06:42.319 --> 00:06:48.979	What we have is can achieve low bit rates that is from 1.2 to 4.8 kilo bit per second.
45.srt	00:06:55.119 --> 00:07:08.189	So, the characteristics of LPC coding is quality is very low and complexity in this case is moderate and bit rate as we have seen that it is low and delay in this case is moderate and robustness is also low.
45.srt	00:07:08.989 --> 00:07:18.289	So, quality of pure LPC vocoder to low for cellular telephony it try to improve quality by using hybrid coders basically.
45.srt	00:07:18.769 --> 00:07:23.459	So, how to improve the quality by refining model of speech.
45.srt	00:07:26.089 --> 00:07:31.489	model and improve accuracy of the model and improve input speech coder.
45.srt	00:07:31.989 --> 00:07:37.129	So, by using this we can modify our LPC vocoders.
45.srt	00:07:38.449 --> 00:07:57.759	So, how is it you can see that we can use the hybrid coders that is combined vocoder and waveform coder concept basically and we will be using the LPC modified one we call it as residual LPC that is rel basically.
45.srt	00:07:58.449 --> 00:08:06.239	And, we can use the code book excited LPC that is we call it as scalp we will see in a while how we are going to use it.
45.srt	00:08:06.719 --> 00:08:13.089	So, you can see that this is again 2 which is a deferred.
45.srt	00:08:13.479 --> 00:08:28.769	So, you will be seeing that this is the voiced portion and this is the unvoiced region and then how the pitch is generated what you can see the thing this is the frame and then this is the pitch period.
45.srt	00:08:29.089 --> 00:08:31.409	what we call it on the y axis.
45.srt	00:08:31.779 --> 00:08:38.829	So, this is how we will be generating the pitch and then transmitting in our LPC.
45.srt	00:08:39.620 --> 00:08:55.689	So, what how does the this thing RELP-OCODER looks like that is Residual Exited LPC to improve the quality of LPC by transmitting error that is we call it as residue along with the LPC parameters.
45.srt	00:09:00.110 --> 00:09:05.669	So, you have the this is the input signal which is going to be buffered or windowed here.
45.srt	00:09:06.519 --> 00:09:16.059	And then you will be checking that it is voiced or unvoiced decision gain and then pitch which are getting transmitted.
45.srt	00:09:16.470 --> 00:09:35.029	So, this is short time LP analysis what we are going to see that do that and then which is going into the LPC synthesis here and these are the this thing LP parameters which generated from here is going to be transmitted.
45.srt	00:09:35.610 --> 00:09:44.220	and from the synthesis you are going to subtract from this original and then we will be checking the residue.
45.srt	00:09:44.840 --> 00:10:01.820	So, what is the error we have got it or the residue which also is going to be encoded along with the parameters and then the rest of the thing whether it is voiced or unvoiced gain and then pitch.
45.srt	00:10:02.039 --> 00:10:07.480	So, these are the three inputs along with in the LPC only these two are going.
45.srt	00:10:07.820 --> 00:10:10.809	Now even the residue is going to be put into the encoder.
45.srt	00:10:11.290 --> 00:10:15.750	and this encoded output is sent to the receiver.
45.srt	00:10:16.620 --> 00:10:22.350	So, the other one is we call it as GSM speech coding basically.
45.srt	00:10:22.870 --> 00:10:35.990	How does it look like basically GSM we know all of us use the thing uses a regular pulse excited linear predictive coder that is RPLPC for speech.
45.srt	00:10:35.990 --> 00:10:39.500	So, basically what does it have combined.
45.srt	00:10:43.370 --> 00:10:48.980	the DPCM we discussed in the last class concept with LPC.
45.srt	00:10:49.570 --> 00:11:10.560	So, information from previous samples used to predict the current sample and LPC coefficients plus an encoded form of the residual that is predicted minus actual sample equal to error what it is going to be transmitted the represent the signal basically which are transmitted.
45.srt	00:11:10.910 --> 00:11:12.620	So, as you can see here.
45.srt	00:11:14.080 --> 00:11:22.720	This is the analog speech so, which is going to be low pass filtered and then you will be converting it into analog to digital form.
45.srt	00:11:23.110 --> 00:11:34.180	So, the sampling rate used is 8 kilohertz and in this case A to D converter has 13 bit bits per sample what it is going to be represented.
45.srt	00:11:34.530 --> 00:11:47.760	So, what you will be getting at the output will be 104 kilo bit per second samples and then here it is going to be RPLTP speech encoder is going to be put in.
45.srt	00:11:48.240 --> 00:11:56.400	and the output what we will be having is 13 kilo bit per second what it is represented in the GSM module.
45.srt	00:11:56.820 --> 00:12:01.910	So, this is going with our to the input to the channel encoder.
45.srt	00:12:02.780 --> 00:12:07.310	So, how the speech coding is going to happen we will see in a while.
45.srt	00:12:07.770 --> 00:12:14.190	So, we said regular pulse excited long term prediction what we can have the thing.
45.srt	00:12:14.640 --> 00:12:18.940	So, that is speech encoder here our LPS the speech coder.
45.srt	00:12:19.450 --> 00:12:24.750	and LPC we know that it is linear prediction coding filter what it is going to be present.
45.srt	00:12:25.280 --> 00:12:39.030	And LTP is the long term prediction which is going to have pitch plus input parameter and RPE we said that residual prediction error which is going to be transmitted.
45.srt	00:12:39.350 --> 00:12:48.630	So, what we have here is input is a 160 samples per 20 millisecond from our A to D converter.
45.srt	00:12:49.050 --> 00:12:50.600	So, which we call it as Z.
45.srt	00:12:50.970 --> 00:12:57.110	2080 bits what it is going to be transmitted and then this is our encoder here.
45.srt	00:12:57.290 --> 00:13:21.810	So, we will be converting it into different pattern as you can see that is 36 LPC bits per 20 millisecond and this is 9 LTP bits per second bits per 5 millisecond and this is 47 RPE bits per 5 millisecond.
45.srt	00:13:22.110 --> 00:13:25.350	which are getting generated from our GSM.
45.srt	00:13:25.790 --> 00:13:34.170	So, total what it is going to be is 260 bits per 20 millisecond what we are going to have to channel encoder.
45.srt	00:13:34.660 --> 00:13:39.360	So, what we are passing it through the system.
45.srt	00:13:40.280 --> 00:13:47.950	So, how the coding is going to look like the first one we have to see the channel encoder also.
45.srt	00:13:48.550 --> 00:13:52.120	So, here it is going to be using class NEE.
45.srt	00:13:52.600 --> 00:14:05.330	So, this is error correction code what it is going to happen that is 3 bit error detection and convolutional coding that is error correction what we will be having it.
45.srt	00:14:05.650 --> 00:14:25.040	So, we call it as CRC basically both detection and then error correction what we will be having it and if it is a class 1B then convolutional coding is going to take place and class 2 no error protection is going to be provided in the thing.
45.srt	00:14:25.040 --> 00:14:26.400	So, these are the three.
45.srt	00:14:26.980 --> 00:14:30.140	GSM this thing channel encoders are there.
45.srt	00:14:30.790 --> 00:14:38.790	And what we have is tail bits to periodically reset this convolutional coder when being used.
45.srt	00:14:39.210 --> 00:14:46.960	So, what we pass is 260 bits per for 20 millisecond which is equivalent 13 kilobit per second.
45.srt	00:14:47.410 --> 00:14:51.850	So, which class you are going to use is depends on the thing.
45.srt	00:14:51.950 --> 00:14:59.520	So, here if it is 1 A then you will be having 1 A bits then 50 class what you are going to have.
45.srt	00:14:59.930 --> 00:15:15.060	And, this is the error correction 3 bit CRC what we have it and then for class 2 you will have 182 class 2 bits and 78 class 2 bits what is going to be generated out of it.
45.srt	00:15:15.600 --> 00:15:23.170	And this one goes as 53 bits because you are adding 3 bit correction codes.
45.srt	00:15:23.240 --> 00:15:25.540	So, 50 plus 3 will be 53 bits.
45.srt	00:15:25.990 --> 00:15:30.920	The other ones are one more whatever you have 182 class.
45.srt	00:15:31.690 --> 00:15:34.350	2 bits are fed to your this thing convolution coder.
45.srt	00:15:34.960 --> 00:15:41.510	So, which is has what you call it as 2 comma 1 comma 5.
45.srt	00:15:42.020 --> 00:15:47.020	So, you are going to have 4 tail bits basically what it is getting added.
45.srt	00:15:47.480 --> 00:16:03.000	So, which comes down to 470 bits when it is coming out of the thing and this is the bit inter lever what you are going to have it which combines these bits and then the 78 class 2 bits which are coming.
45.srt	00:16:03.620 --> 00:16:29.390	combined and you will be getting 456 bits per 20 millisecond as you can see from 260 you have increased to this and then whereas, in the case of kilobit per second it goes to 22.8 kilobit per second is the data rate what it is going from GSM speech coding from the channel encoder.
45.srt	00:16:29.390 --> 00:16:33.730	So, you can have hybrid basically coders.
45.srt	00:16:35.720 --> 00:16:40.440	That is what we call it as code book excited linear predictive coding.
45.srt	00:16:41.240 --> 00:16:52.550	So, that is problem with simple LPCs that is voiced and unvoiced decision and pitch estimation does not model transitional speech well basically and not always accurate.
45.srt	00:16:52.550 --> 00:16:56.860	So, we said that accuracy was low in the LPC.
45.srt	00:16:57.340 --> 00:17:01.940	So, whether we can use the code book excited model.
45.srt	00:17:01.940 --> 00:17:05.560	So, what is that code book approach?
45.srt	00:17:07.470 --> 00:17:18.830	So, that is pass speech through an analyzer to find closest match to a set of possible excitations that is known as our code book.
45.srt	00:17:19.400 --> 00:17:32.080	And transmit the code book pointer plus LPC parameters and you can see that in NA TDMA standard what they call it IS 95 in 3G what they use it.
45.srt	00:17:32.230 --> 00:17:35.860	So, the standard for this is ITUG.729 standard.
45.srt	00:17:41.340 --> 00:17:59.270	So, how is it going to be it is going to have both the things that is here you have the vocoder basically seeing the thing voiced and then unvoiced what it will be going into the code book generation.
45.srt	00:17:59.710 --> 00:18:12.330	So, from there you will be taking the code book generated signals and it passes through the synthesis filter and this is how the output is going to be represented.
45.srt	00:18:14.040 --> 00:18:25.390	So, if it is having a multiple excitation so, which is taken into the thing pass through the synthesis filter and this is our output.
45.srt	00:18:25.890 --> 00:18:35.100	Then if it is a stochastic excitation is used, use the synthesis filter and then you take the output through that.
45.srt	00:18:35.430 --> 00:18:42.860	So, this way you can use the hybrid model to improve upon the standard of LPC.
45.srt	00:18:44.650 --> 00:18:58.640	So, So, this covers are this thing, a coders basically and then in the next class we will be discussing about code excited linear predictive model.
45.srt	00:18:59.280 --> 00:18:59.720	Thank you.
